function Hp(n, t) {
  for (var e = 0; e < t.length; e++) {
    const i = t[e];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const s in i)
        if (s !== "default" && !(s in n)) {
          const r = Object.getOwnPropertyDescriptor(i, s);
          r && Object.defineProperty(n, s, r.get ? r : {
            enumerable: !0,
            get: () => i[s]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
const Up = "¹", tu = "²", eu = "³", ec = "⁻", Qp = "Ω";
var le = /* @__PURE__ */ ((n) => (n[n.unitUnknown = 0] = "unitUnknown", n[n.unitLength = 1] = "unitLength", n[n.unitMass = 2] = "unitMass", n[n.unitTime = 3] = "unitTime", n[n.unitElectricCurrent = 4] = "unitElectricCurrent", n[n.unitThermoTemperature = 5] = "unitThermoTemperature", n[n.unitSubstanceAmount = 6] = "unitSubstanceAmount", n[n.unitLuminosityIntensity = 7] = "unitLuminosityIntensity", n[n.unitPlaneAngle = 8] = "unitPlaneAngle", n[n.unitSolidAngle = 9] = "unitSolidAngle", n[n.unitFrequency = 10] = "unitFrequency", n[n.unitForce = 11] = "unitForce", n[n.unitPressure = 12] = "unitPressure", n[n.unitEnergy = 13] = "unitEnergy", n[n.unitPower = 14] = "unitPower", n[n.unitElectricCharge = 15] = "unitElectricCharge", n[n.unitElectromotiveForce = 16] = "unitElectromotiveForce", n[n.unitCapacitance = 17] = "unitCapacitance", n[n.unitElectricResistance = 18] = "unitElectricResistance", n[n.unitElectricConductance = 19] = "unitElectricConductance", n[n.unitMagneticFlux = 20] = "unitMagneticFlux", n[n.unitMagneticFluxDensity = 21] = "unitMagneticFluxDensity", n[n.unitInductance = 22] = "unitInductance", n[n.unitLuminousFlux = 23] = "unitLuminousFlux", n[n.unitIlluminance = 24] = "unitIlluminance", n[n.unitActivityRadionuclide = 25] = "unitActivityRadionuclide", n[n.unitKerma = 26] = "unitKerma", n[n.unitDoseEquivalent = 27] = "unitDoseEquivalent", n[n.unitCatalyticActivity = 28] = "unitCatalyticActivity", n))(le || {});
function Du(n) {
  return n !== null && typeof n == "object" && "x" in n && typeof n.x == "number" && "y" in n && typeof n.y == "number";
}
function zu(n) {
  return n !== null && typeof n == "object" && "z" in n && typeof n.z == "number" && Du(n);
}
function W0(n) {
  return n !== null && typeof n == "object" && "w" in n && typeof n.w == "number" && zu(n);
}
class d {
  /**
   * Creates a new point object.
   * @param x X value
   * @param y Y value
   * @param z Z value
   */
  constructor(t, e, i) {
    this.x = t, this.y = e, this.z = i;
  }
  /**
   * Sets this point equal to another point.
   * @param point The point to assign.
   * @returns This point object.
   */
  assign(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this;
  }
  /**
   * Sets the values of this point.
   * @param x X value to set.
   * @param y Y value to set.
   * @param z Z value to set.
   * @returns This point object.
   */
  set(t, e, i) {
    return this.x = t, this.y = e, this.z = i, this;
  }
  /**
   * Sets an array from this point.
   * @param arr Array to assign.
   */
  toArray(t = [0, 0, 0]) {
    return t[0] = this.x, t[1] = this.y, t[2] = this.z, t;
  }
  /**
   * Sets this point from an array.
   * @param arr Array to assign from.
   * @returns This point object.
   */
  fromArray(t) {
    return this.x = t[0], this.y = t[1], this.z = t[2], this;
  }
  /**
   * Adds another point to this point.
   * @param point Point to add.
   * @returns This point object.
   */
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this;
  }
  /**
   * Subtracts another point from this point.
   * @param point Point to subtract.
   * @returns This point object.
   */
  subtract(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
  }
  /**
   * Creates a copy of this point.
   * @returns Copy of this point object.
   */
  copy() {
    return new d(this.x, this.y, this.z);
  }
  /**
   * Creates a new [[Point3]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    if (zu(t))
      return new d(t.x, t.y, t.z);
    throw new TypeError("Point3.fromJson: data does not satisfy type IPoint3 constraints");
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {
      x: this.x,
      y: this.y,
      z: this.z
    };
  }
  /**
   * Strictly compares this point with another.
   * @param other Point to compare with.
   * @returns True if the values of this point equal those of the other.
   */
  equals(t) {
    return this.x === t.x && this.y === t.y && this.z === t.z;
  }
  /**
   * Compares this point with another using a tolerance.
   * @param other Point to compare with.
   * @param tolerance Tolerance to be used in the comparison.
   * @returns True if the values of this point equal those of the other.
   */
  equalsWithTolerance(t, e) {
    return Math.abs(this.x - t.x) < e && Math.abs(this.y - t.y) < e && Math.abs(this.z - t.z) < e;
  }
  /**
   * Returns a boolean value indicating if this vector lies on a major axis.
   */
  isAxis() {
    return Math.abs(this.x) === 1 && this.y === 0 && this.z === 0 || this.x === 0 && Math.abs(this.y) === 1 && this.z === 0 || this.x === 0 && this.y === 0 && Math.abs(this.z) === 1;
  }
  /**
   * Returns the length of this vector.
   * @returns Vector length.
   */
  length() {
    return Math.sqrt(this.squaredLength());
  }
  /**
   * Returns the squared length of this vector.
   * @returns Vector squared length.
   */
  squaredLength() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  /**
   * Scale the point by constant value.
   * @param k Constant value to scale by.
   * @returns Point object.
   */
  scale(t) {
    return this.x *= t, this.y *= t, this.z *= t, this;
  }
  /**
   * Normalizes the vector.
   * @returns This object.
   */
  normalize() {
    const t = this.length();
    return t === 0 ? this : this.scale(1 / t);
  }
  /**
   * Negates the point.
   * @returns This object.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  /**
   * Creates a new Point initialized to (0,0,0).
   * @returns New point with all elements set to 0.
   */
  static zero() {
    return new d(0, 0, 0);
  }
  /**
   * Adds two points.
   * @param p1 First point.
   * @param p2 Second point.
   * @returns Sum of p1 and p2.
   */
  static add(t, e) {
    return new d(t.x + e.x, t.y + e.y, t.z + e.z);
  }
  /**
   * Subtract two points.
   * @param p1 First point.
   * @param p2 Second point.
   * @returns Difference of p1 and p2.
   */
  static subtract(t, e) {
    return new d(t.x - e.x, t.y - e.y, t.z - e.z);
  }
  /**
   * Calculate dot product.
   * @param p1 First point.
   * @param p2 Second point.
   * @returns Dot product of p1 and p2.
   */
  static dot(t, e) {
    return t.x * e.x + t.y * e.y + t.z * e.z;
  }
  /**
   * Calculate cross product.
   * @param p1 First point.
   * @param p2 Second point.
   * @returns Cross product of p1 and p2.
   */
  static cross(t, e) {
    return new d(
      t.y * e.z - t.z * e.y,
      t.z * e.x - t.x * e.z,
      t.x * e.y - t.y * e.x
    );
  }
  /**
   * Calculate distance between two points
   * @param p1 First point
   * @param p2 Second point
   * @returns Distance between p1 and p2
   */
  static distance(t, e) {
    return d.subtract(e, t).length();
  }
  /**
   * Scale a point by a constant factor
   * @param p1 Point to scale
   * @param k Constant value to scale byS
   * @returns Copy of p scaled by a constant factor
   */
  static scale(t, e) {
    return t.copy().scale(e);
  }
  /**
   * Creates a point from an array of numbers
   * @param Array to assign from
   * @returns new point set from array elements
   */
  static createFromArray(t) {
    return new d(t[0], t[1], t[2]);
  }
}
class jn {
  constructor(t, e, i, s) {
    this.x = t, this.y = e, this.z = i, this.w = s;
  }
  scale(t) {
    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
  }
  set(t, e, i, s) {
    this.x = t, this.y = e, this.z = i, this.w = s;
  }
  assign(t) {
    this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w;
  }
  static zero() {
    return new jn(0, 0, 0, 0);
  }
  /**
   * Strictly compares this point with another.
   * @param other Point to compare with.
   * @returns True if the values of this point equal those of the other.
   */
  equals(t) {
    return this.x === t.x && this.y === t.y && this.z === t.z;
  }
  /**
   * Compares this point with another using a tolerance.
   * @param other Point to compare with.
   * @param tolerance Tolerance to be used in the comparison.
   * @returns True if the values of this point equal those of the other.
   */
  equalsWithTolerance(t, e) {
    return Math.abs(this.x - t.x) < e && Math.abs(this.y - t.y) < e && Math.abs(this.z - t.z) < e;
  }
}
let Q = class xn {
  /**
   * Creates a new matrix set to the identity matrix.
   */
  constructor() {
    this.loadIdentity();
  }
  /**
   * Sets the matrix to the identity matrix.
   * @returns This matrix object.
   */
  loadIdentity() {
    return this.m = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], this;
  }
  isIdentity() {
    const t = this.m;
    return t[0] === 1 && t[1] === 0 && t[2] === 0 && t[3] === 0 && t[4] === 0 && t[5] === 1 && t[6] === 0 && t[7] === 0 && t[8] === 0 && t[9] === 0 && t[10] === 1 && t[11] === 0 && t[12] === 0 && t[13] === 0 && t[14] === 0 && t[15] === 1;
  }
  /**
   * Strictly compares this matrix with another.
   * @param other Matrix to compare with.
   * @returns True if the values of this matrix equal those of the other.
   */
  equals(t) {
    for (let e = 0; e < 16; ++e) {
      const i = this.m[e], s = t.m[e];
      if (i !== s)
        return !1;
    }
    return !0;
  }
  /**
   * Compares this matrix with another using a tolerance.
   * @param other Matrix to compare with.
   * @param tolerance Tolerance to be used in the comparison.
   * @returns True if the values of this matrix equal those of the other.
   */
  equalsWithTolerance(t, e) {
    e = Math.abs(e);
    for (let i = 0; i < 16; ++i)
      if (Math.abs(this.m[i] - t.m[i]) > e)
        return !1;
    return !0;
  }
  /**
   * Sets the scale components of this matrix.
   * @param x X scale value.
   * @param y Y scale value.
   * @param z Z scale value.
   * @returns This matrix object.
   */
  setScaleComponent(t, e, i) {
    return this.m[0] = t, this.m[5] = e, this.m[10] = i, this;
  }
  /**
   * Sets the translation components of this matrix.
   * @param x X translation value.
   * @param y Y translation value.
   * @param z Z translation value.
   * @returns This matrix object.
   */
  setTranslationComponent(t, e, i) {
    return this.m[12] = t, this.m[13] = e, this.m[14] = i, this;
  }
  /**
   * Creates a copy of this matrix.
   * @returns Copy of this matrix.
   */
  copy() {
    const t = new xn();
    return t.m = this.m.slice(), t;
  }
  /**
   * Sets the value of this matrix to another.
   * @param matrix the matrix whose values will be set.
   * @returns This matrix object.
   */
  assign(t) {
    for (let e = 0; e < t.m.length; e++)
      this.m[e] = t.m[e];
    return this;
  }
  /**
   * Multiply the matrix by given scalar.
   * @param scalar Scalar to multiply the matrix with.
   * @return This matrix object.
   */
  multiplyByScalar(t) {
    for (let e = 0; e < 16; e++)
      this.m[e] *= t;
    return this;
  }
  /**
   * Transforms a point according to this matrix. The source and destination points are allowed to be the same object.
   * @param point The point to be transformed.
   * @param result A Point3 which can hold the result of the transformation.
   * @returns A new point if result is undefined, result otherwise.
   */
  transform(t, e) {
    return e = e ?? d.zero(), e.set(
      t.x * this.m[0] + t.y * this.m[4] + t.z * this.m[8] + this.m[12],
      t.x * this.m[1] + t.y * this.m[5] + t.z * this.m[9] + this.m[13],
      t.x * this.m[2] + t.y * this.m[6] + t.z * this.m[10] + this.m[14]
    ), e;
  }
  /**
   * Transforms a point according to this matrix. The source and destination points are allowed to be the same object.
   * @param point The point to be transformed.
   * @param result A Point3 which can hold the result of the transformation.
   * @returns A new point if result is undefined, result otherwise.
   */
  transform4(t, e) {
    return e = e ?? jn.zero(), e.set(
      t.x * this.m[0] + t.y * this.m[4] + t.z * this.m[8] + this.m[12] * t.w,
      t.x * this.m[1] + t.y * this.m[5] + t.z * this.m[9] + this.m[13] * t.w,
      t.x * this.m[2] + t.y * this.m[6] + t.z * this.m[10] + this.m[14] * t.w,
      t.x * this.m[3] + t.y * this.m[7] + t.z * this.m[11] + this.m[15] * t.w
    ), e;
  }
  /**
   * Transforms an array of points according to this matrix.
   * @param inPoints an array of points to be transformed.
   * @param outPoints an array that will be populated with transformed points. Note that the results will be pushed onto the end of the array.
   */
  transformArray(t, e) {
    for (let i = 0; i < t.length; i++) {
      const s = t[i], r = new d(
        s.x * this.m[0] + s.y * this.m[4] + s.z * this.m[8] + this.m[12],
        s.x * this.m[1] + s.y * this.m[5] + s.z * this.m[9] + this.m[13],
        s.x * this.m[2] + s.y * this.m[6] + s.z * this.m[10] + this.m[14]
      );
      e[i] = r;
    }
  }
  transformBox(t) {
    if (t.isDegenerate())
      return ni.invalid();
    const e = t.getCorners();
    for (const s of e)
      this.transform(s, s);
    const i = new ni(e[0], e[0]);
    for (let s = 1; s < e.length; ++s) {
      const r = e[s];
      i.addPoint(r);
    }
    return i;
  }
  /**
   * Sets this matrix equal to its transpose.
   * @returns This matrix object.
   */
  // prettier-ignore
  transpose() {
    let t;
    return t = this.m[1], this.m[1] = this.m[4], this.m[4] = t, t = this.m[2], this.m[2] = this.m[8], this.m[8] = t, t = this.m[3], this.m[3] = this.m[12], this.m[12] = t, t = this.m[6], this.m[6] = this.m[9], this.m[9] = t, t = this.m[7], this.m[7] = this.m[13], this.m[13] = t, t = this.m[11], this.m[11] = this.m[14], this.m[14] = t, this;
  }
  /**
   * Creates a matrix from an array of numbers.
   * @param arr 16 element array of numbers.
   * @returns New matrix with elements set to the values of the array parameter. Array elements will be in column-major order.
   */
  static createFromArray(t) {
    const e = new xn();
    return e.m = t.slice(), e;
  }
  /**
   * Creates a rotation matrix from an arbitrary axis.
   * @param axis Axis to rotate about.
   * @param degrees Amount of degrees to rotate about the provided axis.
   * @returns Rotation matrix which represents the rotation about the supplied axis.
   */
  static createFromOffAxisRotation(t, e) {
    const i = e * (Math.PI / 180), s = Math.sin(i), r = Math.cos(i), o = new xn(), a = t.copy().normalize(), l = 1 - r, c = l * a.x * a.y, h = l * a.x * a.z, u = l * a.y * a.z;
    return o.m[0] = l * a.x * a.x + r, o.m[1] = s * a.z + c, o.m[2] = h - s * a.y, o.m[3] = 0, o.m[4] = c - s * a.z, o.m[5] = l * a.y * a.y + r, o.m[6] = s * a.x + u, o.m[7] = 0, o.m[8] = s * a.y + h, o.m[9] = u - s * a.x, o.m[10] = l * a.z * a.z + r, o.m[11] = 0, o.m[12] = 0, o.m[13] = 0, o.m[14] = 0, o.m[15] = 1, o;
  }
  /**
   * Creates a matrix from three [[Point3]]s, which will be used as the
   * columns of the matrix.
   *
   * @param xAxis The first column.
   * @param yAxis The second column.
   * @param zAxis The third column.
   */
  static createFromBasis(t, e, i) {
    const s = new xn();
    return s.m[0] = t.x, s.m[1] = t.y, s.m[2] = t.z, s.m[4] = e.x, s.m[5] = e.y, s.m[6] = e.z, s.m[8] = i.x, s.m[9] = i.y, s.m[10] = i.z, s;
  }
  /**
   * Multiplies two matrices.
   *
   * (p' = ABp <=> p' = multiply(B, A).transform(p))
   *
   * @param m1 The first matrix.
   * @param m2 The second matrix.
   * @returns Matrix which is the result of the multiplication.
   */
  static multiply(t, e) {
    const i = new xn();
    return i.m[0] = t.m[0] * e.m[0] + t.m[1] * e.m[4] + t.m[2] * e.m[8] + t.m[3] * e.m[12], i.m[1] = t.m[0] * e.m[1] + t.m[1] * e.m[5] + t.m[2] * e.m[9] + t.m[3] * e.m[13], i.m[2] = t.m[0] * e.m[2] + t.m[1] * e.m[6] + t.m[2] * e.m[10] + t.m[3] * e.m[14], i.m[3] = t.m[0] * e.m[3] + t.m[1] * e.m[7] + t.m[2] * e.m[11] + t.m[3] * e.m[15], i.m[4] = t.m[4] * e.m[0] + t.m[5] * e.m[4] + t.m[6] * e.m[8] + t.m[7] * e.m[12], i.m[5] = t.m[4] * e.m[1] + t.m[5] * e.m[5] + t.m[6] * e.m[9] + t.m[7] * e.m[13], i.m[6] = t.m[4] * e.m[2] + t.m[5] * e.m[6] + t.m[6] * e.m[10] + t.m[7] * e.m[14], i.m[7] = t.m[4] * e.m[3] + t.m[5] * e.m[7] + t.m[6] * e.m[11] + t.m[7] * e.m[15], i.m[8] = t.m[8] * e.m[0] + t.m[9] * e.m[4] + t.m[10] * e.m[8] + t.m[11] * e.m[12], i.m[9] = t.m[8] * e.m[1] + t.m[9] * e.m[5] + t.m[10] * e.m[9] + t.m[11] * e.m[13], i.m[10] = t.m[8] * e.m[2] + t.m[9] * e.m[6] + t.m[10] * e.m[10] + t.m[11] * e.m[14], i.m[11] = t.m[8] * e.m[3] + t.m[9] * e.m[7] + t.m[10] * e.m[11] + t.m[11] * e.m[15], i.m[12] = t.m[12] * e.m[0] + t.m[13] * e.m[4] + t.m[14] * e.m[8] + t.m[15] * e.m[12], i.m[13] = t.m[12] * e.m[1] + t.m[13] * e.m[5] + t.m[14] * e.m[9] + t.m[15] * e.m[13], i.m[14] = t.m[12] * e.m[2] + t.m[13] * e.m[6] + t.m[14] * e.m[10] + t.m[15] * e.m[14], i.m[15] = t.m[12] * e.m[3] + t.m[13] * e.m[7] + t.m[14] * e.m[11] + t.m[15] * e.m[15], i;
  }
  /**
   * Computes the determinant and inverse of a matrix, if possible.
   * @returns An array containing the inverse (or null if not invertible) followed by the determinant
   */
  inverseAndDeterminant() {
    const t = this.m[4] * this.m[9] - this.m[5] * this.m[8], e = this.m[4] * this.m[10] - this.m[6] * this.m[8], i = this.m[4] * this.m[11] - this.m[7] * this.m[8], s = this.m[4] * this.m[13] - this.m[5] * this.m[12], r = this.m[4] * this.m[14] - this.m[6] * this.m[12], o = this.m[4] * this.m[15] - this.m[7] * this.m[12], a = this.m[5] * this.m[10] - this.m[6] * this.m[9], l = this.m[5] * this.m[11] - this.m[7] * this.m[9], c = this.m[5] * this.m[14] - this.m[6] * this.m[13], h = this.m[5] * this.m[15] - this.m[7] * this.m[13], u = this.m[6] * this.m[11] - this.m[7] * this.m[10], p = this.m[6] * this.m[15] - this.m[7] * this.m[14], m = this.m[8] * this.m[13] - this.m[9] * this.m[12], g = this.m[8] * this.m[14] - this.m[10] * this.m[12], _ = this.m[8] * this.m[15] - this.m[11] * this.m[12], y = this.m[9] * this.m[14] - this.m[10] * this.m[13], b = this.m[9] * this.m[15] - this.m[11] * this.m[13], w = this.m[10] * this.m[15] - this.m[11] * this.m[14], v = new xn();
    v.m[0] = this.m[5] * w - this.m[6] * b + this.m[7] * y, v.m[1] = this.m[2] * b - this.m[3] * y - this.m[1] * w, v.m[2] = this.m[1] * p - this.m[2] * h + this.m[3] * c, v.m[3] = this.m[2] * l - this.m[3] * a - this.m[1] * u, v.m[4] = this.m[6] * _ - this.m[7] * g - this.m[4] * w, v.m[5] = this.m[0] * w - this.m[2] * _ + this.m[3] * g, v.m[6] = this.m[2] * o - this.m[3] * r - this.m[0] * p, v.m[7] = this.m[0] * u - this.m[2] * i + this.m[3] * e, v.m[8] = this.m[4] * b - this.m[5] * _ + this.m[7] * m, v.m[9] = this.m[1] * _ - this.m[3] * m - this.m[0] * b, v.m[10] = this.m[0] * h - this.m[1] * o + this.m[3] * s, v.m[11] = this.m[1] * i - this.m[3] * t - this.m[0] * l, v.m[12] = this.m[5] * g - this.m[6] * m - this.m[4] * y, v.m[13] = this.m[0] * y - this.m[1] * g + this.m[2] * m, v.m[14] = this.m[1] * r - this.m[2] * s - this.m[0] * c, v.m[15] = this.m[0] * a - this.m[1] * e + this.m[2] * t;
    const C = v.m[0], k = -v.m[4], Y = v.m[8], P = -v.m[12], L = this.m[0] * C - this.m[1] * k + this.m[2] * Y - this.m[3] * P;
    if (L === 0)
      return [null, 0];
    const N = 1 / L;
    return v.multiplyByScalar(N), [v, L];
  }
  /**
   * Computes the inverse of a matrix if possible.
   * @param matrix Matrix whose inverse will be computed.
   * @returns Matrix set to the inverse of the supplied matrix.
   */
  static inverse(t) {
    return t.inverseAndDeterminant()[0];
  }
  /**
   * Computes the determinant of the upper-left 3x3 subsection of this matrix.
   */
  upperLeft3x3Determinant() {
    return this.m[0] * (this.m[5] * this.m[10] - this.m[9] * this.m[6]) - this.m[4] * (this.m[1] * this.m[10] - this.m[9] * this.m[2]) + this.m[8] * (this.m[1] * this.m[6] - this.m[5] * this.m[2]);
  }
  /**
   * @returns the version of this matrix suitable for applying to normals,
   * i.e. the inverse transpose of the upper-left 3x3 submatrix.
   */
  normalMatrix() {
    const t = this.copy().setTranslationComponent(0, 0, 0).inverseAndDeterminant()[0];
    return t ? t.transpose() : null;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this.m.slice();
  }
  /**
   * Creates a new [[Matrix]] from an object given by [[toJson]].
   * @param An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    return xn.createFromArray(t);
  }
  /** @hidden */
  static toMatrix12(t) {
    return [t[0], t[1], t[2], t[4], t[5], t[6], t[8], t[9], t[10], t[12], t[13], t[14]];
  }
  /**
   * Returns the matrix for a clockwise rotation around the X-axis.
   * @param degrees The degrees of the rotation.
   * @returns The rotation matrix.
   */
  static xAxisRotation(t) {
    const e = new xn(), i = cs(t), s = Math.cos(i), r = Math.sin(i);
    return e.m[5] = s, e.m[6] = -r, e.m[9] = r, e.m[10] = s, e;
  }
  /**
   * Returns the matrix for a clockwise rotation around the Y-axis.
   * @param degrees The degrees of the rotation.
   * @returns The rotation matrix.
   */
  static yAxisRotation(t) {
    const e = new xn(), i = cs(t), s = Math.cos(i), r = Math.sin(i);
    return e.m[0] = s, e.m[2] = r, e.m[8] = -r, e.m[10] = s, e;
  }
  /**
   * Returns the matrix for a clockwise rotation around the Z-axis.
   * @param degrees The degrees of the rotation.
   * @returns The rotation matrix.
   */
  static zAxisRotation(t) {
    const e = new xn(), i = cs(t), s = Math.cos(i), r = Math.sin(i);
    return e.m[0] = s, e.m[1] = -r, e.m[4] = r, e.m[5] = s, e;
  }
}, je = class so {
  constructor() {
    this.normal = d.zero(), this.d = 0;
  }
  setFromPointAndNormal(t, e) {
    return this.normal.assign(e), this.d = -d.dot(e, t), this;
  }
  /**
   * Update the plane to pass through the three points
   */
  setFromPoints(t, e, i) {
    this.normal = d.cross(d.subtract(e, t), d.subtract(i, t)).normalize(), this.d = -d.dot(t, this.normal);
  }
  setFromCoefficients(t, e, i, s) {
    this.normal.set(t, e, i), this.d = s;
  }
  getCoefficients() {
    const t = this.normal;
    return [t.x, t.y, t.z, this.d];
  }
  distanceToPoint(t) {
    return d.dot(this.normal, t) + this.d;
  }
  rayIntersection(t) {
    const e = d.zero();
    return this.intersectsRay(t, e) ? e : null;
  }
  intersectsRay(t, e) {
    const i = this.distanceToPoint(t.origin);
    if (Math.abs(i) <= 1e-6)
      return e && e.assign(t.origin), !0;
    const s = d.dot(this.normal, t.direction);
    if (Math.abs(s) <= 1e-6)
      return !1;
    const r = -i / s;
    if (r < 0)
      return !1;
    if (e) {
      const o = t.direction.copy().scale(r);
      e.set(t.origin.x + o.x, t.origin.y + o.y, t.origin.z + o.z);
    }
    return !0;
  }
  /**
   * Returns true if the point is on the side of the plane that the plane's normal is directed. Returns false otherwise.
   * @param p The point to test.
   */
  determineSide(t) {
    return this.normal.x * t.x + this.normal.y * t.y + this.normal.z * t.z + this.d > 0;
  }
  /**
   * Creates a copy of this plane
   * @returns a copy of this plane object
   */
  copy() {
    const t = new so();
    return t.normal.assign(this.normal), t.d = this.d, t;
  }
  /**
   * Sets this plane equal to another plane
   * @param plane the plane to assign
   */
  assign(t) {
    this.normal.assign(t.normal), this.d = t.d;
  }
  /**
   * Returns true if the normal and d value are the same.
   * @param plane
   */
  equals(t) {
    return this.normal.equals(t.normal) && this.d === t.d;
  }
  static createFromPointAndNormal(t, e) {
    return new so().setFromPointAndNormal(t, e);
  }
  static createFromPoints(t, e, i) {
    const s = new so();
    return s.setFromPoints(t, e, i), s;
  }
  static createFromCoefficients(t, e, i, s) {
    const r = new so();
    return r.setFromCoefficients(t, e, i, s), r;
  }
};
class E {
  /**
   * Creates a new point
   * @param {number} x value to set for x
   * @param {number} y value to set for y
   */
  constructor(t, e) {
    this.x = t, this.y = e;
  }
  /**
   * Sets this point equal to another point
   * @param {Point2} pt the point whose values will be used to set this object
   * @returns {Point2} the point object
   */
  assign(t) {
    return this.x = t.x, this.y = t.y, this;
  }
  /**
   * Adds a point to this one
   * @param {Point2} pt the point whose values will be added
   * @returns {Point2} the point object
   */
  add(t) {
    return this.x += t.x, this.y += t.y, this;
  }
  /**
   * Subtracts a point from this one
   * @param {Point2} pt the point whose values will be subtracted
   * @returns {Point2} the point object
   */
  subtract(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }
  /**
   * Scales the point by a constant value
   * @param {number} k the value to scale by
   * @returns {Point2} the point object
   */
  scale(t) {
    return this.x *= t, this.y *= t, this;
  }
  /**
   * Compares this point with another point
   * @param {Point2} pt the point to compare with
   * @returns {Boolean} True if the values of this point equal the other. False otherwise.
   */
  equals(t) {
    return this.x === t.x && this.y === t.y;
  }
  /**
   * Sets the values of this point
   * @param {number} x value to set for x
   * @param {number} y value to set for y
   * @returns {Point2} the point object
   */
  set(t, e) {
    return this.x = t, this.y = e, this;
  }
  /**
   * Creates a copy of this point
   * @returns {Point} Copy of this point
   */
  copy() {
    return new E(this.x, this.y);
  }
  /**
   * Returns the length of this point
   * @returns {number} the point length
   */
  length() {
    return Math.sqrt(this.squaredLength());
  }
  /**
   * Returns the squared length of this vector.
   * @returns Vector squared length.
   */
  squaredLength() {
    return this.x * this.x + this.y * this.y;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {
      x: this.x,
      y: this.y
    };
  }
  /**
   * Creates a new [[Point2]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    if (Du(t))
      return new E(t.x, t.y);
    throw new TypeError("Point2.fromJson: data does not satisfy type IPoint2 constraints");
  }
  /**
   * Subtracts a point from another
   * @param {Point2} pt1 initial point
   * @param {Point2} pt2 the point to subtract
   * @returns {Point2} new point set to pt1 - pt2
   */
  static subtract(t, e) {
    return new E(t.x - e.x, t.y - e.y);
  }
  /**
   * Adds two points
   * @param {Point2} pt1 initial point
   * @param {Point2} pt2 the point to add
   * @returns {Point2} new point set to pt1 + pt2
   */
  static add(t, e) {
    return new E(t.x + e.x, t.y + e.y);
  }
  /**
   * Scale a point by a constant factor
   * @param {Point2} pt Point to be scaled
   * @param {number} k Amount to scale by
   * @returns {Point2} The scaled point
   */
  static scale(t, e) {
    return new E(t.x * e, t.y * e);
  }
  /**
   * Calculate distance between two points
   * @param {Point2} p1 first point
   * @param {Point2} p2 second point
   * @returns {number} the distance between p1 and p2
   */
  static distance(t, e) {
    return E.subtract(e, t).length();
  }
  /**
   * Creates a point initialized to (0,0)
   * @returns {Point} The new point
   */
  static zero() {
    return new E(0, 0);
  }
  static fromPoint3(t) {
    return new E(t.x, t.y);
  }
}
function qp(n) {
  const t = Math.abs(n.x), e = Math.abs(n.y), i = Math.abs(n.z);
  return t <= e && t <= i ? new d(1, 0, 0) : e <= t && e <= i ? new d(0, 1, 0) : new d(0, 0, 1);
}
function Ju(n, t) {
  const e = qp(n), i = d.cross(e, n);
  return t ? (t.assign(i), t) : i;
}
function Bu(n, t, e, i) {
  const s = e.normal.x * (t.x - n.x) + e.normal.y * (t.y - n.y) + e.normal.z * (t.z - n.z);
  if (Math.abs(s) < 1e-5)
    return !1;
  const r = -(e.d + e.normal.x * n.x + e.normal.y * n.y + e.normal.z * n.z) / s;
  return i.x = n.x + r * (t.x - n.x), i.y = n.y + r * (t.y - n.y), i.z = n.z + r * (t.z - n.z), !(r < 0 || r > 1);
}
function ss(n, t, e, i) {
  const s = d.subtract(e, t), r = s.squaredLength();
  let o = 0;
  r > 0 && (o = ((n.x - t.x) * (e.x - t.x) + (n.y - t.y) * (e.y - t.y) + (n.z - t.z) * (e.z - t.z)) / r), s.set(s.x * o, s.y * o, s.z * o), i.set(t.x + s.x, t.y + s.y, t.z + s.z);
  let a = new d(0, 0, 0);
  return a = d.subtract(n, i), a.length();
}
function $p(n) {
  return Math.abs(n - 25.4 / 72) < 0.01 ? "points" : Math.abs(n - 25.4) < 0.01 ? "inch" : Math.abs(n - 1) < 0.01 ? "mm" : Math.abs(n - 10) < 0.01 ? "cm" : Math.abs(n - 25.4 / 6) < 0.01 ? "picas" : Math.abs(n - 12 * 25.4) < 0.01 ? "ft" : Math.abs(n - 3 * 12 * 25.4) < 0.01 ? "yd" : Math.abs(n - 1e3) < 0.01 ? "m" : Math.abs(n - 1e6) < 0.01 ? "km" : Math.abs(n - 1760 * 3 * 12 * 25.4) < 0.01 ? "mi" : (console.log(`warning: unit multiplier doesn't map to known type: unit=${n}`), "");
}
function Go(n, t) {
  const e = $p(t);
  let i = "";
  for (let s = 2; s < 9 && (i = n.toFixed(s), parseFloat(i) === 0); s++)
    ;
  return parseFloat(i) === 0 && (i = "0"), i + e;
}
function cs(n) {
  return n * (Math.PI / 180);
}
function _l(n) {
  return n * (180 / Math.PI);
}
function ro(n, t, e) {
  const i = n.copy().normalize(), s = cs(t), r = Math.cos(s), o = Math.sin(s), a = 1 - r, l = a * i.x * i.y, c = a * i.x * i.z, h = a * i.y * i.z;
  return e === void 0 && (e = new Q()), e.m[0] = a * i.x * i.x + r, e.m[1] = o * i.z + l, e.m[2] = c - o * i.y, e.m[3] = 0, e.m[4] = l - o * i.z, e.m[5] = a * i.y * i.y + r, e.m[6] = o * i.x + h, e.m[7] = 0, e.m[8] = o * i.y + c, e.m[9] = h - o * i.x, e.m[10] = a * i.z * i.z + r, e.m[11] = 0, e.m[12] = 0, e.m[13] = 0, e.m[14] = 0, e.m[15] = 1, e;
}
function tg(n, t, e, i, s, r) {
  const o = d.cross(n.normal, e.normal), a = Math.abs(o.x), l = Math.abs(o.y), c = Math.abs(o.z);
  if (a + l + c < 1e-7) {
    const g = d.subtract(i, t);
    return d.dot(n.normal, g) === 0 ? 1 : 0;
  }
  let h;
  a > l ? a > c ? h = 1 : h = 3 : l > c ? h = 2 : h = 3;
  const u = d.zero(), p = -d.dot(n.normal, t), m = -d.dot(e.normal, i);
  switch (h) {
    case 1:
      u.x = 0, u.y = (m * n.normal.z - p * e.normal.z) / o.x, u.z = (p * e.normal.y - m * n.normal.y) / o.x;
      break;
    case 2:
      u.x = (p * e.normal.z - m * n.normal.z) / o.y, u.y = 0, u.z = (m * n.normal.x - p * e.normal.x) / o.y;
      break;
    case 3:
      u.x = (m * n.normal.y - p * e.normal.y) / o.z, u.y = (p * e.normal.x - m * n.normal.x) / o.z, u.z = 0;
  }
  return s.assign(u), r.set(u.x + o.x, u.y + o.y, u.z + o.z), 2;
}
function eg(n, t, e) {
  const i = new je();
  return i.normal.x = (t.y - n.y) * (e.z - n.z) - (t.z - n.z) * (e.y - n.y), i.normal.y = (t.z - n.z) * (e.x - n.x) - (t.x - n.x) * (e.z - n.z), i.normal.z = (t.x - n.x) * (e.y - n.y) - (t.y - n.y) * (e.x - n.x), i.normal.normalize(), i.d = -i.normal.x * n.x - i.normal.y * n.y - i.normal.z * n.z, i;
}
function Ts(n, t, e, i, s, r) {
  const o = eg(e, i, s);
  return Bu(n, t, o, r);
}
function Yn(n, t) {
  const e = n.copy().normalize(), i = t.copy().normalize(), r = d.cross(e, i).length(), o = d.dot(e, i), a = Math.atan2(r, o);
  return _l(a);
}
function ig(n, t, e, i, s) {
  const r = 2 * Math.PI / i;
  for (let h = 0; h < i; h++) {
    const p = e * Math.cos(r * h), m = e * Math.sin(r * h);
    n[h] = new d(0, p, m);
  }
  n[i] = n[0].copy();
  const o = Ju(s);
  o.normalize();
  const a = d.cross(o, s);
  a.normalize();
  const l = new Q(), c = l.m;
  c[0] = s.x, c[1] = s.y, c[2] = s.z, c[3] = 0, c[4] = o.x, c[5] = o.y, c[6] = o.z, c[7] = 0, c[8] = a.x, c[9] = a.y, c[10] = a.z, c[11] = 0, c[12] = 0, c[13] = 0, c[14] = 0, c[15] = 1, l.transformArray(n, n);
  for (let h = 0; h <= i; h++)
    n[h].set(
      n[h].x + t.x,
      n[h].y + t.y,
      n[h].z + t.z
    );
}
function ng(n, t, e, i, s, r) {
  const o = n, a = t, l = e, c = i;
  let h = 0, u = 0;
  const p = d.subtract(a, o), m = d.subtract(c, l), g = d.dot(p, o), _ = d.dot(p, m), y = d.dot(p, p), b = d.dot(p, l), w = d.dot(m, m), v = d.dot(m, l), C = d.dot(m, o), k = d.dot(p, c), Y = d.dot(m, a), P = y * w - _ * _;
  if (P === 0) {
    let D, B, V, X;
    y !== 0 ? (D = (b - g) / y, D < 0 ? D = 0 : D > 1 && (D = 1), V = (k - g) / y, V < 0 ? V = 0 : V > 1 && (V = 1)) : (D = 0, V = 0), w !== 0 ? (B = (C - v) / w, B < 0 ? B = 0 : B > 1 && (B = 1), X = (Y - v) / w, X < 0 ? X = 0 : X > 1 && (X = 1)) : (B = 0, X = 0), h = (D + V) / 2, u = (B + X) / 2;
  } else {
    const D = _ * C - _ * v - w * g + w * b, B = y * C - y * v + _ * b - _ * g, V = D / P, X = B / P, Z = (b - g) / y, W = (C - v) / w, st = (k - g) / y, j = (Y - v) / w;
    0 <= V && V <= 1 && 0 <= X && X <= 1 ? (h = V, u = X) : V < 0 && 0 <= X && X <= 1 ? (h = V, u = W) : 1 < V && 0 <= X && X <= 1 ? (h = V, u = j) : 0 <= V && V <= 1 && X < 0 ? (h = Z, u = X) : 0 <= V && V <= 1 && 1 < X ? (h = st, u = X) : V < 0 && X < 0 ? (h = Z, u = W) : V < 0 && 1 < X ? (h = st, u = W) : 1 < V && X < 0 ? (h = Z, u = j) : 1 < V && 1 < X && (h = st, u = j), h < 0 ? h = 0 : h > 1 && (h = 1), u < 0 ? u = 0 : u > 1 && (u = 1);
  }
  return s.x = h * p.x + o.x, s.y = h * p.y + o.y, s.z = h * p.z + o.z, r.x = u * m.x + l.x, r.y = u * m.y + l.y, r.z = u * m.z + l.z, d.subtract(r, s).length();
}
function ju(n, t, e, i) {
  const r = d.zero(), o = d.zero(), a = d.zero(), l = d.zero(), c = d.zero();
  if (a.x = n.x - e.x, a.y = n.y - e.y, a.z = n.z - e.z, l.x = i.x - e.x, l.y = i.y - e.y, l.z = i.z - e.z, Math.abs(l.x) < 1e-12 && Math.abs(l.y) < 1e-12 && Math.abs(l.z) < 1e-12 || (c.x = t.x - n.x, c.y = t.y - n.y, c.z = t.z - n.z, Math.abs(c.x) < 1e-12 && Math.abs(c.y) < 1e-12 && Math.abs(c.z) < 1e-12))
    return null;
  const h = a.x * l.x + a.y * l.y + a.z * l.z, u = l.x * c.x + l.y * c.y + l.z * c.z, p = a.x * c.x + a.y * c.y + a.z * c.z, m = l.x * l.x + l.y * l.y + l.z * l.z, _ = (c.x * c.x + c.y * c.y + c.z * c.z) * m - u * u;
  if (Math.abs(_) < 1e-12)
    return null;
  const b = (h * u - p * m) / _, w = (h + u * b) / m;
  return r.x = n.x + b * c.x, r.y = n.y + b * c.y, r.z = n.z + b * c.z, o.x = e.x + w * l.x, o.y = e.y + w * l.y, o.z = e.z + w * l.z, r;
}
function Hu(n, t, e) {
  const i = d.subtract(t, n), s = d.subtract(e, n), o = d.dot(s, i) / i.squaredLength();
  return Math.max(0, Math.min(1, o));
}
function sg(n, t, e) {
  const i = Hu(n, t, e), s = d.subtract(t, n).scale(i);
  return d.add(n, s);
}
function rg(n, t, e, i) {
  const s = Hu(n, t, e);
  if (s < 0 || s > 1)
    return !1;
  const r = d.subtract(t, n).scale(s), o = d.add(n, r);
  return d.subtract(o, e).squaredLength() <= i * i;
}
function og(n, t, e) {
  const i = E.subtract(e, t), s = i.length();
  let r = (n.x - t.x) * (e.x - t.x) + (n.y - t.y) * (e.y - t.y);
  return r /= s * s, i.scale(r), E.add(t, i);
}
function oo(n, t, e, i) {
  const s = og(n, t, e);
  if (E.distance(n, s) <= i) {
    const o = Math.min(t.x, e.x), a = Math.max(t.x, e.x), l = Math.min(t.y, e.y), c = Math.max(t.y, e.y);
    return !(s.x < o || s.x > a || s.y < l || s.y > c);
  } else
    return !1;
}
function Uu(n, t, e, i = 0) {
  return !(n.x + i < t.x || n.x > t.x + e.x + i || n.y + i < t.y || n.y > t.y + e.y + i);
}
function _c(n, t, e, i, s) {
  const r = [], o = d.zero(), a = new Q(), l = t / s;
  for (let c = 0, h = 0; c <= s; ++c, h += l)
    ro(n, h, a), a.transform(i, o), r.push(d.add(e, o));
  return r;
}
function ag(n) {
  const t = n.sort((s, r) => s.exponent < r.exponent ? 1 : -1);
  let e = "";
  const i = ".";
  for (let s = 0; s < t.length; s++) {
    switch (t[s].basicUnit) {
      case le.unitLength:
        e += fe(t[s].factor, "m");
        break;
      case le.unitMass:
        e += lg(t[s].factor, "g");
        break;
      case le.unitTime:
        e += fe(t[s].factor, "s");
        break;
      case le.unitElectricCurrent:
        e += fe(t[s].factor, "A");
        break;
      case le.unitThermoTemperature:
        e += fe(t[s].factor, "K");
        break;
      case le.unitSubstanceAmount:
        e += fe(t[s].factor, "mol");
        break;
      case le.unitLuminosityIntensity:
        e += fe(t[s].factor, "cd");
        break;
      case le.unitPlaneAngle:
        e += fe(t[s].factor, "rad");
        break;
      case le.unitSolidAngle:
        e += fe(t[s].factor, "sr");
        break;
      case le.unitFrequency:
        e += fe(t[s].factor, "Hz");
        break;
      case le.unitForce:
        e += fe(t[s].factor, "N");
        break;
      case le.unitPressure:
        e += fe(t[s].factor, "Pa");
        break;
      case le.unitEnergy:
        e += fe(t[s].factor, "J");
        break;
      case le.unitPower:
        e += fe(t[s].factor, "W");
        break;
      case le.unitElectricCharge:
        e += fe(t[s].factor, "C");
        break;
      case le.unitElectromotiveForce:
        e += fe(t[s].factor, "V");
        break;
      case le.unitCapacitance:
        e += fe(t[s].factor, "F");
        break;
      case le.unitElectricResistance:
        e += fe(t[s].factor, Qp);
        break;
      case le.unitElectricConductance:
        e += fe(t[s].factor, "S");
        break;
      case le.unitMagneticFlux:
        e += fe(t[s].factor, "Wb");
        break;
      case le.unitMagneticFluxDensity:
        e += fe(t[s].factor, "T");
        break;
      case le.unitInductance:
        e += fe(t[s].factor, "H");
        break;
      case le.unitLuminousFlux:
        e += fe(t[s].factor, "lm");
        break;
      case le.unitIlluminance:
        e += fe(t[s].factor, "lx");
        break;
      case le.unitActivityRadionuclide:
        e += fe(t[s].factor, "Bq");
        break;
      case le.unitKerma:
        e += fe(t[s].factor, "Gy");
        break;
      case le.unitDoseEquivalent:
        e += fe(t[s].factor, "Sv");
        break;
      case le.unitCatalyticActivity:
        e += fe(t[s].factor, "kat");
        break;
    }
    switch (t[s].exponent) {
      case 2:
        e += tu;
        break;
      case 3:
        e += eu;
        break;
      case -1:
        e += ec, e += Up;
        break;
      case -2:
        e += ec, e += tu;
        break;
      case -3:
        e += ec, e += eu;
        break;
    }
    s + 1 < t.length && (e += i);
  }
  return e;
}
function fe(n, t) {
  let e = "";
  switch (n) {
    case 0.3048:
      e = "ft";
      break;
    case 0.0254:
      e = "inch";
      break;
    case 1e-3:
      e = `m${t}`;
      break;
    case 0.01:
      e = `c${t}`;
      break;
    case 0.1:
      e = `d${t}`;
      break;
    case 1:
      e = t;
      break;
    case 10:
      e = `da${t}`;
      break;
    case 100:
      e = `h${t}`;
      break;
    case 1e3:
      e = `k${t}`;
      break;
    case 60:
      e = "min";
      break;
    case 3600:
      e = "h";
      break;
    case 86400:
      e = "d";
      break;
    case 274.15:
      e = "°C";
      break;
    case 255.927778:
      e = "°F";
      break;
    case 0.555556:
      e = "°R";
      break;
  }
  return e;
}
function lg(n, t) {
  let e = "";
  switch (n) {
    case 1e-6:
      e = `m${t}`;
      break;
    case 1e-5:
      e = `d${t}`;
      break;
    case 1e-4:
      e = `c${t}`;
      break;
    case 1e-3:
      e = t;
      break;
    case 0.01:
      e = `da${t}`;
      break;
    case 0.1:
      e = `h${t}`;
      break;
    case 1:
      e = `k${t}`;
      break;
    case 100:
      e = "q";
      break;
    case 1e3:
      e = "t";
      break;
  }
  return e;
}
const Rn = class {
  constructor(n, t, e, i) {
    this.x = n, this.y = t, this.z = e, this.w = i;
  }
  set(n, t, e, i) {
    this.x = n, this.y = t, this.z = e, this.w = i;
  }
  assign(n) {
    this.x = n.x, this.y = n.y, this.z = n.z, this.w = n.w;
  }
  copy() {
    return new Rn(this.x, this.y, this.z, this.w);
  }
  equals(n) {
    return this.x === n.x && this.y === n.y && this.z === n.z && this.w === n.w;
  }
  equalsWithTolerance(n, t) {
    return this.x - n.x < t && this.x - n.x > -t && this.y - n.y < t && this.y - n.y > -t && this.z - n.z < t && this.z - n.z > -t && this.w - n.w < t && this.w - n.w > -t;
  }
  fromArray(n) {
    return this.x = n[0], this.y = n[1], this.z = n[2], this.w = n[3], this;
  }
  toArray(n) {
    return n[0] = this.x, n[1] = this.y, n[2] = this.z, n[3] = this.w, this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  magnitudeSquared() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  normalize() {
    const n = this.magnitude();
    return n === 0 ? this : (this.x = this.x / n, this.y = this.y / n, this.z = this.z / n, this.w = this.w / n, this);
  }
  static add(n, t) {
    return new Rn(n.x + t.x, n.y + t.y, n.z + t.z, n.w + t.w);
  }
  static subtract(n, t) {
    return new Rn(n.x - t.x, n.y - t.y, n.z - t.z, n.w - t.w);
  }
  static identity() {
    return new Rn(0, 0, 0, 1);
  }
  static toMatrix(n) {
    let t = n.x * n.x + n.y * n.y + n.z * n.z + n.w * n.w;
    t = 2 / t;
    const e = n.x * t, i = n.y * t, s = n.z * t, r = n.w * e, o = n.w * i, a = n.w * s, l = n.x * e, c = n.x * i, h = n.x * s, u = n.y * i, p = n.y * s, m = n.z * s, g = new Q();
    return g.m[0] = 1 - (u + m), g.m[1] = c + a, g.m[2] = h - o, g.m[3] = 0, g.m[4] = c - a, g.m[5] = 1 - (l + m), g.m[6] = p + r, g.m[7] = 0, g.m[8] = h + o, g.m[9] = p - r, g.m[10] = 1 - (l + u), g.m[11] = 0, g.m[12] = 0, g.m[13] = 0, g.m[14] = 0, g.m[15] = 1, g;
  }
  static createFromMatrix(n) {
    const r = [], o = n.m[0] + n.m[5] + n.m[10];
    if (o > 0) {
      let a = Math.sqrt(o + 1);
      r[3] = 0.5 * a, a = 0.5 / a, r[0] = a * (n.m[6] - n.m[9]), r[1] = a * (n.m[8] - n.m[2]), r[2] = a * (n.m[1] - n.m[4]);
    } else {
      let a = 0;
      n.m[4 * 1 + 1] > n.m[4 * 0 + 0] && (a = 1), n.m[4 * 2 + 2] > n.m[4 * a + a] && (a = 2);
      const l = [1, 2, 0], c = l[a], h = l[c];
      let u = Math.sqrt(n.m[4 * a + a] - (n.m[4 * c + c] + n.m[4 * h + h]) + 1);
      r[a] = 0.5 * u, u = 0.5 / u, r[3] = u * (n.m[4 * c + h] - n.m[4 * h + c]), r[c] = u * (n.m[4 * a + c] + n.m[4 * c + a]), r[h] = u * (n.m[4 * a + h] + n.m[4 * h + a]);
    }
    return Rn.identity().fromArray(r);
  }
  static interpolate(n, t, e) {
    const a = [], l = [], c = [];
    n.toArray(a), t.toArray(l);
    let h, u;
    const p = a[0] * l[0] + a[1] * l[1] + a[2] * l[2] + a[3] * l[3];
    if (1 + p > Rn._epsilon) {
      if (1 - p > Rn._epsilon) {
        const m = Rn._arccos(p), _ = 1 / Math.sin(m);
        h = _ * Math.sin((1 - e) * m), u = _ * Math.sin(e * m);
      } else
        h = 1 - e, u = e;
      for (let m = 0; m < 4; ++m)
        c[m] = h * a[m] + u * l[m];
    } else {
      c[0] = -a[1], c[1] = a[0], c[2] = -a[3], c[3] = a[2], h = Math.sin(0.5 * Math.PI * (1 - e)), u = Math.sin(0.5 * Math.PI * e);
      for (let m = 0; m < 3; ++m)
        c[m] = h * a[m] + u * c[m];
    }
    return Rn.identity().fromArray(c);
  }
  static _arccos(n) {
    return n < -1 ? Math.PI : n > 1 ? 0 : Math.acos(n);
  }
};
let Ti = Rn;
Ti._epsilon = 1e-5;
class Gn {
  constructor(t, e) {
    this.origin = d.zero(), this.direction = new d(0, 0, 1), t && this.origin.assign(t), e && this.direction.assign(e);
  }
  /**
   * Creates a copy of this ray
   * @returns {Ray} a copy of this ray object
   */
  copy() {
    return new Gn(this.origin, this.direction);
  }
  /**
   * Sets this ray equal to another ray
   * @param {Ray} ray the ray to assign
   */
  assign(t) {
    return this.origin.assign(t.origin), this.direction.assign(t.direction), this;
  }
  /**
   * Flips the ray's direction.
   */
  negate() {
    return this.direction.negate(), this;
  }
}
class ni {
  /**
   * Creates a new box.
   * @param min The minimum extent of the box. Defaults to the origin.
   * @param max The maximum extent of the box. Defaults to the origin.
   */
  constructor(t = d.zero(), e = d.zero()) {
    this.min = t.copy(), this.max = e.copy();
  }
  /**
   * Creates a copy of the box.
   * @returns A copy of this box.
   */
  copy() {
    return new ni(this.min, this.max);
  }
  /**
   * Strictly compares this box with another box.
   * @param box Box to compare with.
   * @returns True if the values of this box equals the other. False otherwise.
   */
  equals(t) {
    return this.min.equals(t.min) && this.max.equals(t.max);
  }
  /**
   * Gets the center point for the box.
   * @returns The center point of this box.
   */
  center() {
    const t = d.add(this.min, this.max);
    return t.scale(0.5), t;
  }
  /**
   * Gets the extents of the box.
   * @returns A point with members set to extent values for each corresponding axis.
   */
  extents() {
    return d.subtract(this.max, this.min);
  }
  /**
   * Expands the extents of the box so that it will contain another box.
   * @param box The box to add.
   */
  addBox(t) {
    t.isDegenerate() || (this.addPoint(t.min), this.addPoint(t.max));
  }
  /**
   * Expands the extents of the box so that it will contain a particular point.
   * @param point The point to add.
   */
  addPoint(t) {
    t.x < this.min.x && (this.min.x = t.x), t.y < this.min.y && (this.min.y = t.y), t.z < this.min.z && (this.min.z = t.z), t.x > this.max.x && (this.max.x = t.x), t.y > this.max.y && (this.max.y = t.y), t.z > this.max.z && (this.max.z = t.z);
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      min: this.min.toJson(),
      max: this.max.toJson()
    };
  }
  /**
   * Creates a new [[Box]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = d.fromJson(e.min), s = d.fromJson(e.max);
    return new ni(i, s);
  }
  /**
   * Gets all eight corner points for the box.
   * @returns The corner points of this box.
   */
  getCorners() {
    const t = [];
    return t[0] = this.min.copy(), t[1] = this.min.copy(), t[2] = this.min.copy(), t[1].x = this.max.x, t[2].y = this.max.y, t[3] = t[2].copy(), t[3].x = this.max.x, t[4] = t[0].copy(), t[5] = t[1].copy(), t[6] = t[2].copy(), t[7] = t[3].copy(), t[4].z = this.max.z, t[5].z = this.max.z, t[6].z = this.max.z, t[7].z = this.max.z, t;
  }
  /**
   * Creates and returns an invalid bounding box.
   * @returns an invalid bounding box.
   */
  static invalid() {
    return new ni(
      new d(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY),
      new d(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY)
    );
  }
  /**
   * Returns whether or not the box is degenerate.
   * @returns whether or not the box is degenerate.
   */
  isDegenerate() {
    return this.min.x > this.max.x || this.min.y > this.max.y || this.min.z > this.max.z;
  }
}
function cg(n) {
  return n !== null && typeof n == "object" && "r" in n && typeof n.r == "number" && "g" in n && typeof n.g == "number" && "b" in n && typeof n.b == "number";
}
class it {
  /**
   * Creates a new color object. Values are specified in the 0-255 range.
   * @param r red color component
   * @param g green color component
   * @param b blue color component
   */
  constructor(t, e, i) {
    this.r = t, this.g = e, this.b = i;
  }
  /**
   * Sets this color equal to another color
   * @param color the point whose values will be used to set this color
   * @returns the color object
   */
  assign(t) {
    return this.set(t.r, t.g, t.b), this;
  }
  /**
   * Creates a copy of this color
   * @returns Copy of this color
   */
  copy() {
    return new it(this.r, this.g, this.b);
  }
  /**
   * Compares this color with another color
   * @param color the color to compare with
   * @returns True if the values of this color equal the other. False otherwise.
   */
  equals(t) {
    return this.r === t.r && this.g === t.g && this.b === t.b;
  }
  /**
   * Sets the color object. Values are specified in the 0-255 range.
   * @param r red color component
   * @param g green color component
   * @param b blue color component
   */
  set(t, e, i) {
    this.r = t, this.g = e, this.b = i;
  }
  /**
   * Sets the color object from floating point values. Values are specified in the 0.0-1.0 range.
   * @param r red color component
   * @param g green color component
   * @param b blue color component
   */
  setFromFloat(t, e, i) {
    this.r = Math.round(255 * t), this.g = Math.round(255 * e), this.b = Math.round(255 * i);
  }
  /**
   * Sets this color from an array of normalized floating point values
   * @param the array to assign from
   */
  fromFloatArray(t) {
    return this.setFromFloat(t[0], t[1], t[2]);
  }
  /**
   * Gets an array of floating point values representing this color. Values are clamped in the 0.0 - 1.0 range.
   * @returns array of floating point values for this color.
   */
  getFloatArray() {
    return [this.r / 255, this.g / 255, this.b / 255];
  }
  /**
   * Populates an array with floating point values for this color. Values are clamped in the 0.0 - 1.0 range.
   * @param arr array whose first three elements will be populated with the r,g, and b values of this color respectively.
   */
  toFloatArray(t = [0, 0, 0]) {
    return t[0] = this.r / 255, t[1] = this.g / 255, t[2] = this.b / 255, t;
  }
  /**
   * Creates a new [[Color]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    if (cg(t))
      return new it(t.r, t.g, t.b);
    throw new TypeError("Color.fromJson: data does not satisfy type IColor constraints");
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {
      r: this.r,
      g: this.g,
      b: this.b
    };
  }
  /**
   * Creates a color object from floating point values. Values are specified in the 0.0-1.0 range.
   * @param r red color component
   * @param g green color component
   * @param b blue color component
   * @returns new color object
   */
  static createFromFloat(t, e, i) {
    const s = it.black();
    return s.setFromFloat(t, e, i), s;
  }
  /**
   * Creates a color object from an array of floating point values.
   * Values are specified in the 0.0-1.0 range.
   */
  static createFromFloatArray(t) {
    const e = it.black();
    return e.fromFloatArray(t), e;
  }
  /**
   * Creates a new color object initialized to red.
   * @returns new color object
   */
  static red() {
    return new it(255, 0, 0);
  }
  /**
   * Creates a new color object initialized to green.
   * @returns new color object
   */
  static green() {
    return new it(0, 255, 0);
  }
  /**
   * Creates a new color object initialized to blue.
   * @returns new color object
   */
  static blue() {
    return new it(0, 0, 255);
  }
  /**
   * Creates a new color object initialized to yellow.
   * @returns new color object
   */
  static yellow() {
    return new it(255, 255, 0);
  }
  /**
   * Creates a new color object initialized to white.
   * @returns new color object
   */
  static white() {
    return new it(255, 255, 255);
  }
  /**
   * Creates a new color object initialized to black.
   * @returns new color object
   */
  static black() {
    return new it(0, 0, 0);
  }
}
var rn = /* @__PURE__ */ ((n) => (n[n.Scalar = 1] = "Scalar", n[n.Vec3 = 3] = "Vec3", n[n.Quat = 4] = "Quat", n))(rn || {});
class ca {
  /**
   * Creates a new buffer for storing keyframe data.
   * @param keyType The type of keyframes that will be stored in the buffer.
   */
  constructor(t) {
    this.keyType = t, this.times = [], this.values = [], this.tangents = [], this._hasTangents = null, this.keyOffset = t;
  }
  _validateKey(t) {
    if (this.keyType !== t)
      throw new Error(
        `Cannot add keyframe of type: ${rn[t]} to buffer of type: ${rn[this.keyType]}`
      );
  }
  _validateTangents(t) {
    if (this._hasTangents === null)
      this._hasTangents = t;
    else if (this._hasTangents !== t)
      throw new Error(
        `Cannot add keyframe with${t ? "" : "out"} tangents to buffer with${t ? "out" : ""} tangents`
      );
  }
  _findIndexFromTime(t) {
    for (let e = 0; e < this.times.length; e++)
      if (this.times[e] >= t)
        return e;
    return this.times.length;
  }
  /** Returns the index of the keyframe at the specified time. */
  getKeyframeIndex(t) {
    return this.times.indexOf(t);
  }
  /** Deletes a keyframe at the specified index. */
  deleteKeyframe(t) {
    this.times.splice(t, 1), this.tangents.splice(t * this.keyOffset * 2, this.keyOffset * 2), this.values.splice(t * this.keyOffset, this.keyOffset);
  }
  /**
   * Inserts a Scalar keyframe with the specified time. The type of this buffer should be [[KeyType.Scalar]]
   * @returns Index at which keyframe was inserted
   */
  insertScalarKeyframe(t, e, i, s) {
    this._validateKey(
      1
      /* Scalar */
    );
    const r = this._findIndexFromTime(t);
    return this.times.splice(r, 0, t), this.values.splice(r, 0, e), i !== void 0 && s !== void 0 ? (this._validateTangents(!0), this.tangents.splice(r * 2, 0, i, s)) : this._validateTangents(!1), r;
  }
  /** Updates a Scalar keyframe at the specified index. The type of this buffer should be [[KeyType.Scalar]] */
  updateScalarKeyframe(t, e, i, s, r) {
    this.values[t] = i, this.times[t] = e, s !== void 0 && r !== void 0 && (this.tangents[t * 2] = s, this.tangents[t * 2 + 1] = r);
  }
  /**
   * Inserts a Vec3 keyframe with the specified time. The type of this buffer should be [[KeyType.Vec3]]
   * @returns Index at which keyframe was inserted
   */
  insertVec3Keyframe(t, e, i, s, r, o, a, l, c, h) {
    this._validateKey(
      3
      /* Vec3 */
    );
    const u = this._findIndexFromTime(t);
    return this.times.splice(u, 0, t), this.values.splice(u * this.keyOffset, 0, e, i, s), r !== void 0 && o !== void 0 && a !== void 0 && l !== void 0 && c !== void 0 && h !== void 0 ? (this._validateTangents(!0), this.tangents.splice(
      u * this.keyOffset * 2,
      0,
      r,
      o,
      a,
      l,
      c,
      h
    )) : this._validateTangents(!1), u;
  }
  /** Updates a Vec3 keyframe at the specified index. The type of this buffer should be [[KeyType.Vec3]] */
  updateVec3Keyframe(t, e, i, s, r, o, a, l, c, h, u) {
    return this.times[t] = e, this.values[t * this.keyOffset] = i, this.values[t * this.keyOffset + 1] = s, this.values[t * this.keyOffset + 2] = r, o !== void 0 && a !== void 0 && l !== void 0 && c !== void 0 && h !== void 0 && u !== void 0 ? (this._validateTangents(!0), this.tangents.splice(
      t * this.keyOffset * 2,
      0,
      o,
      a,
      l,
      c,
      h,
      u
    ), this.tangents[t * this.keyOffset * 2] = o, this.tangents[t * this.keyOffset * 2 + 1] = a, this.tangents[t * this.keyOffset * 2 + 2] = l, this.tangents[t * this.keyOffset * 2 + 3] = c, this.tangents[t * this.keyOffset * 2 + 4] = h, this.tangents[t * this.keyOffset * 2 + 5] = u) : this._validateTangents(!1), t;
  }
  /**
   * Inserts a Quat keyframe with the specified time. The type of this buffer should be [[KeyType.Quat]]
   * @returns Index at which keyframe was inserted
   */
  insertQuatKeyframe(t, e, i, s, r, o, a, l, c, h, u, p, m) {
    this._validateKey(
      4
      /* Quat */
    );
    const g = this._findIndexFromTime(t);
    this.times.splice(g, 0, t), this.values.splice(g * this.keyOffset, 0, e, i, s, r), o !== void 0 && a !== void 0 && l !== void 0 && c !== void 0 && h !== void 0 && u !== void 0 && p !== void 0 && m !== void 0 ? (this._validateTangents(!0), this.tangents.splice(
      g * this.keyOffset * 2,
      0,
      o,
      a,
      l,
      c,
      h,
      u,
      p,
      m
    )) : this._validateTangents(!1);
  }
  /** Updates a Quat keyframe at the specified index. The type of this buffer should be [[KeyType.Quat]] */
  updateQuatKeyframe(t, e, i, s, r, o, a, l, c, h, u, p, m, g) {
    this.times[t] = e, this.values[t * this.keyOffset] = i, this.values[t * this.keyOffset + 1] = s, this.values[t * this.keyOffset + 2] = r, this.values[t * this.keyOffset + 3] = o, a !== void 0 && l !== void 0 && c !== void 0 && h !== void 0 && u !== void 0 && p !== void 0 && m !== void 0 && g !== void 0 ? (this._validateTangents(!0), this.tangents.splice(
      t * this.keyOffset * 2,
      0,
      a,
      l,
      c,
      u,
      p,
      m
    ), this.tangents[t * this.keyOffset * 2] = a, this.tangents[t * this.keyOffset * 2 + 1] = l, this.tangents[t * this.keyOffset * 2 + 2] = c, this.tangents[t * this.keyOffset * 2 + 3] = g, this.tangents[t * this.keyOffset * 2 + 4] = u, this.tangents[t * this.keyOffset * 2 + 5] = p, this.tangents[t * this.keyOffset * 2 + 6] = m, this.tangents[t * this.keyOffset * 2 + 7] = g) : this._validateTangents(!1);
  }
  /** @hidden */
  _export() {
    const t = {};
    return this.tangents.length !== 0 && (t.tangents = this.tangents.slice()), {
      keyType: rn[this.keyType],
      times: this.times.slice(),
      values: this.values.slice(),
      ...t
    };
  }
  /** @hidden */
  static _import(t) {
    const e = new ca(rn[t.keyType]);
    return e.times = t.times.slice(), e.values = t.values.slice(), t.tangents !== void 0 && (e.tangents = t.tangents.slice()), e;
  }
}
var di = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Transform = 1] = "Transform", n[n.Opacity = 2] = "Opacity", n[n.Visibility = 4] = "Visibility", n[n.Color = 8] = "Color", n))(di || {});
class Qu {
  constructor(t) {
    this.nodeId = t, this.translate = d.zero(), this.rotation = Ti.identity(), this.scale = new d(1, 1, 1), this.color = new d(1, 1, 1), this.pivotPoint = null, this.opacity = 1, this.visibility = 1, this.matrix = new Q(), this.flags = 0;
  }
  updateMatrix() {
    this.pivotPoint ? this._updateMatrixWithOrigin() : this._updateMatrix();
  }
  // http://glmatrix.net/docs/mat4.js.html#line1354
  _updateMatrixWithOrigin() {
    const t = this.rotation.x, e = this.rotation.y, i = this.rotation.z, s = this.rotation.w, r = t + t, o = e + e, a = i + i, l = t * r, c = t * o, h = t * a, u = e * o, p = e * a, m = i * a, g = s * r, _ = s * o, y = s * a, b = this.scale.x, w = this.scale.y, v = this.scale.z, C = this.pivotPoint.x, k = this.pivotPoint.y, Y = this.pivotPoint.z, P = (1 - (u + m)) * b, L = (c + y) * b, N = (h - _) * b, D = (c - y) * w, B = (1 - (l + m)) * w, V = (p + g) * w, X = (h + _) * v, Z = (p - g) * v, W = (1 - (l + u)) * v;
    this.matrix.m[0] = P, this.matrix.m[1] = L, this.matrix.m[2] = N, this.matrix.m[3] = 0, this.matrix.m[4] = D, this.matrix.m[5] = B, this.matrix.m[6] = V, this.matrix.m[7] = 0, this.matrix.m[8] = X, this.matrix.m[9] = Z, this.matrix.m[10] = W, this.matrix.m[11] = 0, this.matrix.m[12] = this.translate.x + C - (P * C + D * k + X * Y), this.matrix.m[13] = this.translate.y + k - (L * C + B * k + Z * Y), this.matrix.m[14] = this.translate.z + Y - (N * C + V * k + W * Y), this.matrix.m[15] = 1;
  }
  // http://glmatrix.net/docs/mat4.js.html#line1291
  _updateMatrix() {
    const t = this.rotation.x, e = this.rotation.y, i = this.rotation.z, s = this.rotation.w, r = t + t, o = e + e, a = i + i, l = t * r, c = t * o, h = t * a, u = e * o, p = e * a, m = i * a, g = s * r, _ = s * o, y = s * a, b = this.scale.x, w = this.scale.y, v = this.scale.z;
    this.matrix.m[0] = (1 - (u + m)) * b, this.matrix.m[1] = (c + y) * b, this.matrix.m[2] = (h - _) * b, this.matrix.m[3] = 0, this.matrix.m[4] = (c - y) * w, this.matrix.m[5] = (1 - (l + m)) * w, this.matrix.m[6] = (p + g) * w, this.matrix.m[7] = 0, this.matrix.m[8] = (h + _) * v, this.matrix.m[9] = (p - g) * v, this.matrix.m[10] = (1 - (l + u)) * v, this.matrix.m[11] = 0, this.matrix.m[12] = this.translate.x, this.matrix.m[13] = this.translate.y, this.matrix.m[14] = this.translate.z, this.matrix.m[15] = 1;
  }
}
class qu {
  constructor() {
    this.position = null, this.target = null, this.up = null, this.width = null, this.height = null;
  }
  /** Reset this object to its initial state. */
  clear() {
    this.position = null, this.target = null, this.up = null, this.width = null, this.height = null;
  }
  /**
   * Set the stored values on the supplied [[Camera]].
   * @returns True if the camera was modified.
   */
  apply(t) {
    let e = !1;
    return this.position !== null && (t.setPosition(this.position), e = !0), this.target !== null && (t.setTarget(this.target), e = !0), this.up !== null && (t.setUp(this.up), e = !0), this.width !== null && (t.setWidth(this.width), e = !0), this.height !== null && (t.setHeight(this.height), e = !0), e;
  }
}
class $u {
  constructor() {
    this.opacities = /* @__PURE__ */ new Map(), this.colors = /* @__PURE__ */ new Map(), this.matrixNodeIds = [], this.matrices = [], this.visibilityOn = [], this.visibilityOff = [];
  }
  /** Reset this object to its initial state. */
  clear() {
    this.opacities.clear(), this.colors.clear(), this.matrixNodeIds = [], this.matrices = [], this.visibilityOn = [], this.visibilityOff = [];
  }
  /** Set the stored values on the supplied [[WebViewer]]. */
  apply(t) {
    const e = t.model;
    this.opacities.size > 0 && e.setNodesOpacities(this.opacities), this.colors.size > 0 && e.setNodesColors(this.colors), this.matrixNodeIds.length > 0 && e._setNodesMatrices(this.matrixNodeIds, this.matrices), this.visibilityOn.length > 0 && e.setNodesVisibility(this.visibilityOn, !0), this.visibilityOff.length > 0 && e.setNodesVisibility(this.visibilityOff, !1);
  }
}
class Ua {
  constructor() {
    this.node = new $u(), this.camera = new qu();
  }
  /** Reset this object to its initial state. */
  clear() {
    this.node.clear(), this.camera.clear();
  }
  /** Set the stored values on the supplied [[WebViewer]]. */
  apply(t) {
    this.node.apply(t);
    const e = t.view, i = e.getCamera();
    this.camera.apply(i) && e.setCamera(i);
  }
}
var Qa = /* @__PURE__ */ ((n) => (n[n.Translation = 0] = "Translation", n[n.Rotation = 1] = "Rotation", n[n.Scale = 2] = "Scale", n[n.Opacity = 3] = "Opacity", n[n.Visibility = 4] = "Visibility", n[n.Color = 5] = "Color", n[n.ColorMap = 6] = "ColorMap", n))(Qa || {});
class To {
  constructor(t, e, i, s) {
    switch (this.name = t, this.nodeId = e, this.property = i, this.sampler = s, this.property) {
      case 0:
      case 2:
      case 5:
        if (s.buffer.keyType !== rn.Vec3)
          throw new Error("Key type mismatch. Expected Vec3");
        break;
      case 1:
        if (s.buffer.keyType !== rn.Quat)
          throw new Error("Key type mismatch. Expected Quat");
        break;
      case 3:
      case 4:
      case 6:
        if (s.buffer.keyType !== rn.Scalar)
          throw new Error("Key type mismatch. Expected Scalar");
        break;
    }
  }
  /** @hidden */
  _getValue(t, e) {
    switch (this.property) {
      case 0:
        this.sampler.interpolateVec3(t, e.translate), e.flags |= di.Transform;
        break;
      case 1:
        this.sampler.interpolateQuat(t, e.rotation), e.flags |= di.Transform;
        break;
      case 2:
        this.sampler.interpolateVec3(t, e.scale), e.flags |= di.Transform;
        break;
      case 3:
        e.opacity = this.sampler.interpolateScalar(t), e.flags |= di.Opacity;
        break;
      case 4:
        e.visibility = this.sampler.interpolateScalar(t), e.flags |= di.Visibility;
        break;
      case 5:
        this.sampler.interpolateVec3(t, e.color), e.flags |= di.Color;
        break;
      case 6:
        {
          const i = this.sampler.interpolateScalar(t), s = this._getColorFromMap(i);
          s !== null && (e.color.set(s.r, s.g, s.b), e.flags |= di.Color);
        }
        break;
    }
  }
  _getColorFromMap(t) {
    const e = (s, r, o, a, l) => {
      const c = (s - r) / (o - r);
      return new it(
        (1 - c) * a.r + c * l.r,
        (1 - c) * a.g + c * l.g,
        (1 - c) * a.b + c * l.b
      );
    };
    if (this.colorMap === void 0)
      return null;
    t < 0 && (t = 0), t > 1 && (t = 1);
    let i = 0;
    for (; i < this.colorMap.length - 1; ) {
      const s = this.colorMap[i].position, r = this.colorMap[i].color, o = this.colorMap[i + 1].position, a = this.colorMap[i + 1].color;
      if (t <= s)
        return r;
      if (t <= o)
        return e(t, s, o, r, a);
      if (t >= o && i === this.colorMap.length - 2)
        return a;
      ++i;
    }
    return null;
  }
  /** @hidden */
  _gatherForExport(t) {
    this.colorMap !== void 0 && t.colorMaps.add(this.colorMap), t.samplers.add(this.sampler), this.sampler._gatherForExport(t);
  }
  /** @hidden */
  _export(t) {
    const e = {};
    return this.name !== "" && (e.name = this.name), this.colorMap !== void 0 && (e.colorMap = t.colorMaps.getIndex(this.colorMap)), {
      nodeId: this.nodeId,
      property: Qa[this.property],
      sampler: t.samplers.getIndex(this.sampler),
      ...e
    };
  }
  /** @hidden */
  static _import(t, e) {
    const i = new To(
      e.name || "",
      e.nodeId,
      Qa[e.property],
      t.samplers[e.sampler]
    );
    return e.colorMap !== void 0 && (i.colorMap = t.colorMaps[e.colorMap]), i;
  }
}
var Mn = /* @__PURE__ */ ((n) => (n[n.Position = 0] = "Position", n[n.Target = 1] = "Target", n[n.Up = 2] = "Up", n[n.Width = 3] = "Width", n[n.Height = 4] = "Height", n))(Mn || {});
class Eo {
  /**
   * Do not use directly.  Create via Animation class API.
   * @hidden
   * */
  constructor(t, e, i) {
    switch (this.name = t, this.property = e, this.sampler = i, this.property) {
      case 0:
      case 1:
      case 2:
        if (i.buffer.keyType !== rn.Vec3)
          throw new Error("Key type mismatch. Expected Vec3");
        break;
      case 3:
      case 4:
        if (i.buffer.keyType !== rn.Scalar)
          throw new Error("Key type mismatch. Expected Scalar");
        break;
    }
  }
  /** @hidden */
  _getValue(t, e) {
    switch (this.property) {
      case 0:
        e.position === null && (e.position = new d(0, 0, 0)), this.sampler.interpolateVec3(t, e.position);
        break;
      case 1:
        e.target === null && (e.target = new d(0, 0, -1)), this.sampler.interpolateVec3(t, e.target);
        break;
      case 2:
        e.up === null && (e.up = new d(0, 1, 0)), this.sampler.interpolateVec3(t, e.up);
        break;
      case 3:
        e.width = this.sampler.interpolateScalar(t);
        break;
      case 4:
        e.height = this.sampler.interpolateScalar(t);
    }
  }
  /** @hidden */
  _gatherForExport(t) {
    t.samplers.add(this.sampler), this.sampler._gatherForExport(t);
  }
  /** @hidden */
  _export(t) {
    const e = {};
    return this.name !== "" && (e.name = this.name), {
      property: Mn[this.property],
      sampler: t.samplers.getIndex(this.sampler),
      ...e
    };
  }
  /** @hidden */
  static _import(t, e) {
    return new Eo(
      e.name || "",
      Mn[e.property],
      t.samplers[e.sampler]
    );
  }
}
class yl {
  /**
   * Creates a new, empty Animation
   * @param name friendly name for the animation
   */
  constructor(t) {
    this.name = t, this.nodeChannels = [], this.cameraChannels = [], this.pivotPoints = /* @__PURE__ */ new Map();
  }
  /**
   * Creates a new node animation channel.
   * @param name friendly name for the channel.
   * @param target id of node that will receive interpolated values.
   * @param property the node property that will be animated.
   * @param sampler sampler describing the buffer and interpolation type.
   */
  createNodeChannel(t, e, i, s) {
    const r = new To(t, e, i, s);
    return this._registerNodeChannel(r), r;
  }
  _registerNodeChannel(t) {
    this.nodeChannels.push(t);
  }
  /**
   * Creates a new camera animation channel.
   * @param name friendly name for the channel.
   * @param property the property that will be animated by this channel.
   * @param sampler sampler describing the buffer and interpolation type used.
   */
  createCameraChannel(t, e, i) {
    const s = new Eo(t, e, i);
    return this._registerCameraChannel(s), s;
  }
  _registerCameraChannel(t) {
    this.cameraChannels.push(t);
  }
  /**
   * Removes a channel from this animation.
   *
   * Call [[Player.reload]] on any players that are referencing this animation.
   */
  deleteChannel(t) {
    for (let e = 0; e < this.nodeChannels.length; e++)
      if (this.nodeChannels[e] === t) {
        this.nodeChannels.splice(e, 1);
        return;
      }
    for (let e = 0; e < this.cameraChannels.length; e++)
      if (this.cameraChannels[e] === t) {
        this.cameraChannels.splice(e, 1);
        return;
      }
  }
  /** @hidden */
  _gatherForExport(t) {
    for (const e of this.nodeChannels)
      e._gatherForExport(t);
    for (const e of this.cameraChannels)
      e._gatherForExport(t);
  }
  /** @hidden */
  _export(t) {
    const e = [], i = {};
    this.name !== "" && (i.name = this.name);
    const s = {}, r = (o) => {
      if (this[o].length === 0)
        return;
      const a = [];
      for (const l of this[o])
        a.push(l._export(t));
      s[o] = a;
    };
    return this.pivotPoints.forEach((o, a) => {
      e.push({ node: a, point: o });
    }), e.length !== 0 && (i.pivotPoints = e), r("nodeChannels"), r("cameraChannels"), {
      ...i,
      ...s
    };
  }
  /** @hidden */
  static _import(t, e) {
    const i = new yl(e.name || "");
    if (e.nodeChannels !== void 0)
      for (const s of e.nodeChannels)
        i._registerNodeChannel(To._import(t, s));
    if (e.cameraChannels !== void 0)
      for (const s of e.cameraChannels)
        i._registerCameraChannel(Eo._import(t, s));
    if (e.pivotPoints !== void 0)
      for (const s of e.pivotPoints) {
        const r = d.fromJson(s.point);
        i.pivotPoints.set(s.node, r);
      }
    return i;
  }
}
var qa = /* @__PURE__ */ ((n) => (n[n.Constant = 0] = "Constant", n[n.Linear = 1] = "Linear", n[n.CubicSpline = 2] = "CubicSpline", n))(qa || {});
const wt = class {
  /**
   * Creates a new sampler for a [[KeyframeBuffer]]
   * @param buffer The buffer that will be sampled.
   * @param interpolationType The Type of interpolation that will be used
   */
  constructor(n, t) {
    this.buffer = n, this.interpolationType = t;
  }
  /**
   * Returns the index of the next keyframe for a given frame T.
   * Note that this assumes that all keyframes in the buffer
   * are arranged in ascending order by frame time.
   */
  _getNextKeyframeIndex(n) {
    for (let t = 0; t < this.buffer.times.length; t += 1)
      if (this.buffer.times[t] > n)
        return t;
    return this.buffer.times.length;
  }
  /** Computes an interpolated quaternion for the given frame. */
  interpolateQuat(n, t) {
    const e = this._getNextKeyframeIndex(n);
    if (e === 0) {
      this._setQuatFromKeyframeIndex(0, t);
      return;
    } else if (e === this.buffer.times.length) {
      this._setQuatFromKeyframeIndex(e - 1, t);
      return;
    }
    switch (this.interpolationType) {
      case 0:
        this._setQuatFromKeyframeIndex(e - 1, t);
        break;
      case 1:
        this.interpolateQuatSlerp(e - 1, e, n, t);
        break;
      case 2:
        this.interpolateQuatCubicSpline(e - 1, e, n, t);
        break;
    }
  }
  /** Computes an interpolated Vector 3 value for the given frame. */
  interpolateVec3(n, t) {
    const e = this._getNextKeyframeIndex(n);
    if (e === 0) {
      this._setVecFromKeyframeIndex(0, t);
      return;
    } else if (e === this.buffer.times.length) {
      this._setVecFromKeyframeIndex(e - 1, t);
      return;
    }
    switch (this.interpolationType) {
      case 0:
        this._setVecFromKeyframeIndex(e - 1, t);
        break;
      case 1:
        this.interpolateVec3Linear(e - 1, e, n, t);
        break;
      case 2:
        this.interpolateVec3CubicSpline(e - 1, e, n, t);
        break;
    }
  }
  /** Computes an interpolated scalar value for the given frame. */
  interpolateScalar(n) {
    const t = this._getNextKeyframeIndex(n);
    if (t === 0)
      return this.buffer.values[0];
    if (t === this.buffer.times.length)
      return this.buffer.values[t - 1];
    switch (this.interpolationType) {
      case 0:
        return this.buffer.values[t - 1];
      case 1:
        return this.interpolateScalarLinear(t - 1, t, n);
      case 2:
        return this.interpolateScalarCubicSpline(t - 1, t, n);
    }
  }
  /** Performs linear interpolation of two scalar values beginning at indices k0 and k1. */
  interpolateScalarLinear(n, t, e) {
    const i = this.buffer.times[t] - this.buffer.times[n], s = (e - this.buffer.times[n]) / i, r = this.buffer.values[n], o = this.buffer.values[t];
    return r + (o - r) * s;
  }
  /** Performs spherical linear interpolation on the quaternion values beginning at indices k0 and k1. */
  interpolateQuatSlerp(n, t, e, i) {
    const s = this.buffer.times[t] - this.buffer.times[n], r = (e - this.buffer.times[n]) / s;
    this._setQuatFromKeyframeIndex(n, wt.q0), this._setQuatFromKeyframeIndex(t, wt.q1), i.assign(Ti.interpolate(wt.q0, wt.q1, r));
  }
  static _interpVec3(n, t, e, i) {
    t.subtract(n), t.scale(e), t.add(n), i.assign(t);
  }
  /** Performs linear interpolation on the Vector3 values at keyframes beginning at indices k0 and k1 */
  interpolateVec3Linear(n, t, e, i) {
    const s = this.buffer.times[t] - this.buffer.times[n], r = (e - this.buffer.times[n]) / s;
    this._setVecFromKeyframeIndex(n, wt.v0), this._setVecFromKeyframeIndex(t, wt.v1), wt._interpVec3(wt.v0, wt.v1, r, i);
  }
  _interpCubicSpline(n, t, e, i, s) {
    const r = n ** 2, o = n ** 3;
    return (2 * o - 3 * r + 1) * t + (o - 2 * r + n) * i + (-2 * o + 3 * r) * e + (o - r) * s;
  }
  /** Performs Cubic Spline Interpolation on two scalar values beginning at indices k0 and k1 */
  interpolateScalarCubicSpline(n, t, e) {
    const i = this.buffer.times[t] - this.buffer.times[n], s = (e - this.buffer.times[n]) / i, r = this.buffer.values[n], o = this.buffer.values[t];
    let a = 0, l = 0;
    return this.buffer.tangents.length !== 0 && (a = this.buffer.tangents[n] * i, l = this.buffer.tangents[t] * i), this._interpCubicSpline(s, r, o, a, l);
  }
  /** Performs Cubic Spline Interpolation on the Vector3 values at keyframes beginning at indices k0 and k1 */
  interpolateVec3CubicSpline(n, t, e, i) {
    const s = this.buffer.times[t] - this.buffer.times[n], r = (e - this.buffer.times[n]) / s;
    this._setVecFromKeyframeIndex(n, wt.v0), this._setVecFromKeyframeIndex(t, wt.v1), this._setVecTanFromKeyframeIndex(n, wt.v2), this._setVecTanFromKeyframeIndex(t, wt.v3), wt.v2.scale(s), wt.v3.scale(s), i.set(
      this._interpCubicSpline(r, wt.v0.x, wt.v1.x, wt.v2.x, wt.v3.x),
      this._interpCubicSpline(r, wt.v0.y, wt.v1.y, wt.v2.y, wt.v3.y),
      this._interpCubicSpline(r, wt.v0.z, wt.v1.z, wt.v2.z, wt.v3.z)
    );
  }
  /** Performs Cubic Spline Interpolation on the Quaternion values beginning at indices k0 and k1 */
  interpolateQuatCubicSpline(n, t, e, i) {
    const s = this.buffer.times[t] - this.buffer.times[n], r = (e - this.buffer.times[n]) / s;
    this._setQuatFromKeyframeIndex(n, wt.q0), this._setQuatFromKeyframeIndex(t, wt.q1), this._setQuatTanFromKeyframeIndex(n, wt.q2), this._setQuatTanFromKeyframeIndex(t, wt.q3), wt.q4.set(
      wt.q2.x * s,
      wt.q2.y * s,
      wt.q2.z * s,
      wt.q2.w * s
    ), wt.q5.set(
      wt.q3.x * s,
      wt.q3.y * s,
      wt.q3.z * s,
      wt.q3.w * s
    ), i.set(
      this._interpCubicSpline(r, wt.q0.x, wt.q1.x, wt.q4.x, wt.q5.x),
      this._interpCubicSpline(r, wt.q0.y, wt.q1.y, wt.q4.y, wt.q5.y),
      this._interpCubicSpline(r, wt.q0.z, wt.q1.z, wt.q4.z, wt.q5.z),
      this._interpCubicSpline(r, wt.q0.w, wt.q1.w, wt.q4.w, wt.q5.w)
    ), i.normalize();
  }
  _setVecFromKeyframeIndex(n, t) {
    const e = n * 3;
    t.set(
      this.buffer.values[e],
      this.buffer.values[e + 1],
      this.buffer.values[e + 2]
    );
  }
  _setVecTanFromKeyframeIndex(n, t) {
    if (this.buffer.tangents.length === 0)
      t.set(0, 0, 0);
    else {
      const e = n * 3;
      t.set(
        this.buffer.tangents[e],
        this.buffer.tangents[e + 1],
        this.buffer.tangents[e + 2]
      );
    }
  }
  _setQuatFromKeyframeIndex(n, t) {
    const e = n * 4;
    t.set(
      this.buffer.values[e],
      this.buffer.values[e + 1],
      this.buffer.values[e + 2],
      this.buffer.values[e + 3]
    );
  }
  _setQuatTanFromKeyframeIndex(n, t) {
    if (this.buffer.tangents.length === 0)
      t.set(0, 0, 0, 1);
    else {
      const e = n * 4;
      t.set(
        this.buffer.tangents[e],
        this.buffer.tangents[e + 1],
        this.buffer.tangents[e + 2],
        this.buffer.tangents[e + 3]
      );
    }
  }
  /** @hidden */
  _gatherForExport(n) {
    n.buffers.add(this.buffer);
  }
  /** @hidden */
  _export(n) {
    return {
      buffer: n.buffers.getIndex(this.buffer),
      interpolationType: qa[this.interpolationType]
    };
  }
  /** @hidden */
  static _import(n, t) {
    return new wt(n.buffers[t.buffer], qa[t.interpolationType]);
  }
};
let ln = wt;
ln.q0 = Ti.identity();
ln.q1 = Ti.identity();
ln.q2 = Ti.identity();
ln.q3 = Ti.identity();
ln.q4 = Ti.identity();
ln.q5 = Ti.identity();
ln.v0 = d.zero();
ln.v1 = d.zero();
ln.v2 = d.zero();
ln.v3 = d.zero();
var oh = /* @__PURE__ */ ((n) => (n[n.Unknown = 0] = "Unknown", n[n.Catia = 2] = "Catia", n[n.CatiaV5 = 3] = "CatiaV5", n[n.Cadds = 4] = "Cadds", n[n.Unigraphics = 5] = "Unigraphics", n[n.Parasolid = 6] = "Parasolid", n[n.Euclid = 7] = "Euclid", n[n.Iges = 9] = "Iges", n[n.Unisurf = 10] = "Unisurf", n[n.Vda = 11] = "Vda", n[n.Stl = 12] = "Stl", n[n.Wrl = 13] = "Wrl", n[n.Dxf = 14] = "Dxf", n[n.Acis = 15] = "Acis", n[n.ProE = 16] = "ProE", n[n.Step = 18] = "Step", n[n.Ideas = 19] = "Ideas", n[n.Jt = 20] = "Jt", n[n.Slw = 22] = "Slw", n[n.Cgr = 23] = "Cgr", n[n.Prc = 24] = "Prc", n[n.Xvl = 25] = "Xvl", n[n.Hpgl = 26] = "Hpgl", n[n.TopSolid = 27] = "TopSolid", n[n.OneSpaceDesigner = 28] = "OneSpaceDesigner", n[n._3dxml = 29] = "_3dxml", n[n.Inventor = 30] = "Inventor", n[n.PostScript = 31] = "PostScript", n[n.Pdp = 32] = "Pdp", n[n.U3d = 33] = "U3d", n[n.Ifc = 34] = "Ifc", n[n.Dwg = 35] = "Dwg", n[n.Dwf = 36] = "Dwf", n[n.Se = 37] = "Se", n[n.Obj = 38] = "Obj", n[n.Kmz = 39] = "Kmz", n[n.Dae = 40] = "Dae", n[n._3ds = 41] = "_3ds", n[n.Rhino = 43] = "Rhino", n[n.Xml = 44] = "Xml", n[n._3mf = 45] = "_3mf", n[n.Scs = 46] = "Scs", n[n._3dHtml = 47] = "_3dHtml", n[n.Hsf = 48] = "Hsf", n[n.Gltf = 49] = "Gltf", n[n.Revit = 50] = "Revit", n[n.Fbx = 51] = "Fbx", n))(oh || {}), he = /* @__PURE__ */ ((n) => (n[n.IsLoaded = -2147483648] = "IsLoaded", n[n.InitiallyShown = 1073741824] = "InitiallyShown", n[n.InitiallyRemoved = 536870912] = "InitiallyRemoved", n[n.OutOfHierarchy = 268435456] = "OutOfHierarchy", n[n.IsAnnotationView = 134217728] = "IsAnnotationView", n[n.IsCameraSet = 67108864] = "IsCameraSet", n[n.IsPmiFilteringSet = 33554432] = "IsPmiFilteringSet", n[n.IsGeomFilteringSet = 16777216] = "IsGeomFilteringSet", n[n.IsCrossSectionSet = 8388608] = "IsCrossSectionSet", n[n.IsExplosionSet = 4194304] = "IsExplosionSet", n[n.IsCombineState = 2097152] = "IsCombineState", n[n.IsPerspective = 1048576] = "IsPerspective", n[n.IsShownSpecified = 524288] = "IsShownSpecified", n[n.IsShown = 262144] = "IsShown", n[n.BranchVisibilityHidden = 131072] = "BranchVisibilityHidden", n[n.BranchVisibilityShown = 65536] = "BranchVisibilityShown", n[n.BranchVisibilityDirty = 32768] = "BranchVisibilityDirty", n[n.PreventFromResetting = 16384] = "PreventFromResetting", n[n.HasDynamicFrame = 8192] = "HasDynamicFrame", n[n.IsMissing = 4096] = "IsMissing", n[n.IsExternalModelRoot = 2048] = "IsExternalModelRoot", n[n.Requested = 1024] = "Requested", n[n.ImplicitBody = 512] = "ImplicitBody", n[n.IsDefaultView = 256] = "IsDefaultView", n[n.Unused2 = 128] = "Unused2", n[n.Unused1 = 64] = "Unused1", n[n.NodeTypeDrawingSheet = 32] = "NodeTypeDrawingSheet", n[n.IsADefaultNodeType = 16] = "IsADefaultNodeType", n[n.NodeTypeDrawingView = 8] = "NodeTypeDrawingView", n[n.NodeTypeGroup = 4] = "NodeTypeGroup", n[n.NodeTypeProduct = 2] = "NodeTypeProduct", n[n.IsAConfigurationNode = 1] = "IsAConfigurationNode", n))(he || {}), zn = /* @__PURE__ */ ((n) => (n[
  n.OutOfHierarchy = 268435456
  /* OutOfHierarchy */
] = "OutOfHierarchy", n[
  n.PreventFromResetting = 16384
  /* PreventFromResetting */
] = "PreventFromResetting", n[
  n.Requested = 1024
  /* Requested */
] = "Requested", n[
  n.ImplicitBody = 512
  /* ImplicitBody */
] = "ImplicitBody", n))(zn || {}), bt = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.BodyInstance = 1] = "BodyInstance", n[n.PmiBody = 2] = "PmiBody", n[n.ViewFrame = 4] = "ViewFrame", n[n.All = 7] = "All", n))(bt || {}), li = /* @__PURE__ */ ((n) => (n[n.ProductOccurrence = 0] = "ProductOccurrence", n[n.AnyBody = 1] = "AnyBody", n[n.BodyInstance = 2] = "BodyInstance", n[n.CadView = 3] = "CadView", n))(li || {}), We = ((n) => (n[n.InitiallyShown = he.InitiallyShown] = "InitiallyShown", n[n.InitiallyRemoved = he.InitiallyRemoved] = "InitiallyRemoved", n[n.IsShownSpecified = he.IsShownSpecified] = "IsShownSpecified", n[n.IsShown = he.IsShown] = "IsShown", n[n.IsLoaded = he.IsLoaded] = "IsLoaded", n))(We || {}), yc = ((n) => (n[n.IsMissing = he.IsMissing] = "IsMissing", n))(yc || {}), Ie = ((n) => (n[n.IsAnnotationView = he.IsAnnotationView] = "IsAnnotationView", n[n.IsCameraSet = he.IsCameraSet] = "IsCameraSet", n[n.IsPmiFilteringSet = he.IsPmiFilteringSet] = "IsPmiFilteringSet", n[n.IsGeomFilteringSet = he.IsGeomFilteringSet] = "IsGeomFilteringSet", n[n.IsCrossSectionSet = he.IsCrossSectionSet] = "IsCrossSectionSet", n[n.IsExplosionSet = he.IsExplosionSet] = "IsExplosionSet", n[n.IsCombineState = he.IsCombineState] = "IsCombineState", n[n.IsPerspective = he.IsPerspective] = "IsPerspective", n[n.HasDynamicFrame = he.HasDynamicFrame] = "HasDynamicFrame", n[n.IsDefaultView = he.IsDefaultView] = "IsDefaultView", n))(Ie || {}), xs = /* @__PURE__ */ ((n) => (n[n.Rgba32 = 0] = "Rgba32", n[n.Rgb24 = 1] = "Rgb24", n[n.Gray8 = 2] = "Gray8", n[n.GrayAlpha16 = 3] = "GrayAlpha16", n[n.Jpeg = 4] = "Jpeg", n[n.Png = 5] = "Png", n))(xs || {}), ah = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(ah || {}), Hn = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n[n.Local = 0] = "Local", n))(Hn || {}), kr = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(kr || {}), bl = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(bl || {}), td = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(td || {}), ed = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(ed || {}), ve = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n[n.Local = 0] = "Local", n))(ve || {}), lh = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(lh || {}), id = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(id || {}), nd = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(nd || {}), vo = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(vo || {}), Bi = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n[n.Empty = 4294967294] = "Empty", n[n.Local = 0] = "Local", n))(Bi || {}), sd = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(sd || {}), rd = /* @__PURE__ */ ((n) => (n[n.World = 0] = "World", n[n.Camera = 1] = "Camera", n))(rd || {}), od = /* @__PURE__ */ ((n) => (n[n.Directional = 0] = "Directional", n))(od || {}), ar = /* @__PURE__ */ ((n) => (n[n.OfInitialEmptyModel = 0] = "OfInitialEmptyModel", n))(ar || {}), ch = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.SMAA = 1] = "SMAA", n))(ch || {}), xo = /* @__PURE__ */ ((n) => (n[n.Floor = 0] = "Floor", n[n.Wall = 1] = "Wall", n[n.Door = 2] = "Door", n))(xo || {}), So = /* @__PURE__ */ ((n) => (n[n.Pixels = 0] = "Pixels", n[n.ProportionOfWidth = 1] = "ProportionOfWidth", n[n.ProportionOfHeight = 2] = "ProportionOfHeight", n))(So || {}), ad = /* @__PURE__ */ ((n) => (n[n.Object = 0] = "Object", n[n.World = 1] = "World", n))(ad || {}), Dn = /* @__PURE__ */ ((n) => (n[n.Default = 0] = "Default", n[n.Highlight = 1] = "Highlight", n[n.HiddenLine = 2] = "HiddenLine", n[n.XRay = 3] = "XRay", n[n.Gooch = 4] = "Gooch", n[n.Toon = 5] = "Toon", n))(Dn || {}), ld = /* @__PURE__ */ ((n) => (n[n.FixedFramerate = 0] = "FixedFramerate", n[n.OcclusionCulling = 1] = "OcclusionCulling", n))(ld || {}), Je = /* @__PURE__ */ ((n) => (n[n.Faces = 0] = "Faces", n[n.Lines = 1] = "Lines", n[n.Points = 2] = "Points", n))(Je || {}), cd = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Faces = 1] = "Faces", n[n.Lines = 2] = "Lines", n[n.Points = 4] = "Points", n[n.All = 7] = "All", n))(cd || {}), Ss = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Modulate = 1] = "Modulate", n[n.Desaturate = 2] = "Desaturate", n[n.Colorize = 3] = "Colorize", n))(Ss || {}), hh = /* @__PURE__ */ ((n) => (n[n.Visible = 0] = "Visible", n[n.VisibleWithFullOutline = 1] = "VisibleWithFullOutline", n))(hh || {}), hd = /* @__PURE__ */ ((n) => (n[n.Object = 0] = "Object", n[n.World = 1] = "World", n[n.ProportionOfScreenWidth = 2] = "ProportionOfScreenWidth", n[n.ProportionOfScreenHeight = 3] = "ProportionOfScreenHeight", n))(hd || {}), ud = /* @__PURE__ */ ((n) => (n[n.Square = 0] = "Square", n[n.Disk = 1] = "Disk", n[n.Sphere = 2] = "Sphere", n))(ud || {}), dd = /* @__PURE__ */ ((n) => (n[n.ScreenPixels = 0] = "ScreenPixels", n[n.CSSPixels = 1] = "CSSPixels", n[n.World = 2] = "World", n[n.ProportionOfScreenWidth = 3] = "ProportionOfScreenWidth", n[n.ProportionOfScreenHeight = 4] = "ProportionOfScreenHeight", n[n.ProportionOfBoundingDiagonal = 5] = "ProportionOfBoundingDiagonal", n))(dd || {}), No = /* @__PURE__ */ ((n) => (n[n.Perspective = 0] = "Perspective", n[n.Orthographic = 1] = "Orthographic", n[n.Stretched = 2] = "Stretched", n))(No || {}), Ke = /* @__PURE__ */ ((n) => (n[n.Uninitialized = 0] = "Uninitialized", n[n.Network = 1] = "Network", n[n.Scs = 2] = "Scs", n))(Ke || {}), hs = /* @__PURE__ */ ((n) => (n[n.Hide = 0] = "Hide", n[n.Show = 1] = "Show", n[n.Initial = 2] = "Initial", n))(hs || {}), uh = /* @__PURE__ */ ((n) => (n[n.World = 0] = "World", n[n.ProportionOfBoundingHeight = 1] = "ProportionOfBoundingHeight", n))(uh || {}), md = /* @__PURE__ */ ((n) => (n[n.Low = 0] = "Low", n[n.Medium = 1] = "Medium", n[n.High = 2] = "High", n[n.Ultra = 3] = "Ultra", n))(md || {}), dh = /* @__PURE__ */ ((n) => (n[n.SessionNotStarted = 0] = "SessionNotStarted", n[n.Cancelled = 1] = "Cancelled", n[n.CorruptRpcMessage = 2] = "CorruptRpcMessage", n))(dh || {}), $a = /* @__PURE__ */ ((n) => (n[n.On = 0] = "On", n[n.Off = 1] = "Off", n))($a || {}), tl = /* @__PURE__ */ ((n) => (n[n.On = 0] = "On", n[n.Off = 1] = "Off", n))(tl || {}), Zo = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Decal = 1] = "Decal", n))(Zo || {}), el = /* @__PURE__ */ ((n) => (n[n.UV = 0] = "UV", n))(el || {}), il = /* @__PURE__ */ ((n) => (n[n.Repeat = 0] = "Repeat", n[n.Clamp = 1] = "Clamp", n[n.Trim = 2] = "Trim", n))(il || {}), pd = /* @__PURE__ */ ((n) => (n[n.Unsorted = 0] = "Unsorted", n[n.SingleLayer = 1] = "SingleLayer", n))(pd || {}), nl = /* @__PURE__ */ ((n) => (n[n.Selected = 0] = "Selected", n[n.Unselected = 1] = "Unselected", n))(nl || {}), ei = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Floor = 1] = "Floor", n[n.Wall = 2] = "Wall", n[n.Door = 4] = "Door", n))(ei || {}), kn = /* @__PURE__ */ ((n) => (n[n.UpperLeftCorner = 0] = "UpperLeftCorner", n[n.LowerLeftCorner = 1] = "LowerLeftCorner", n[n.LowerRightCorner = 2] = "LowerRightCorner", n[n.UpperRightCorner = 3] = "UpperRightCorner", n[n.TopCenter = 4] = "TopCenter", n[n.LeftCenter = 5] = "LeftCenter", n[n.RightCenter = 6] = "RightCenter", n[n.BottomCenter = 7] = "BottomCenter", n[n.Center = 8] = "Center", n))(kn || {}), Co = /* @__PURE__ */ ((n) => (n[n.Pixels = 0] = "Pixels", n[n.ProportionOfScreen = 1] = "ProportionOfScreen", n[n.ProportionOfOtherDimension = 2] = "ProportionOfOtherDimension", n))(Co || {});
const nn = 0;
function qs(n) {
  return n !== null && typeof n == "object" && "scFunction" in n && typeof n.scFunction == "string";
}
function gd(n) {
  const t = n.data;
  return t !== null && typeof t == "object" && "scStateFailure" in t ? t.scStateFailure : null;
}
var $s = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Il(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var fd = { exports: {} };
/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */
(function(n) {
  (function(t, e, i) {
    n.exports ? n.exports = i() : t[e] = i();
  })($s, "bowser", function() {
    var t = !0;
    function e(c) {
      function h(U) {
        var ht = c.match(U);
        return ht && ht.length > 1 && ht[1] || "";
      }
      function u(U) {
        var ht = c.match(U);
        return ht && ht.length > 1 && ht[2] || "";
      }
      var p = h(/(ipod|iphone|ipad)/i).toLowerCase(), m = /like android/i.test(c), g = !m && /android/i.test(c), _ = /nexus\s*[0-6]\s*/i.test(c), y = !_ && /nexus\s*[0-9]+/i.test(c), b = /CrOS/.test(c), w = /silk/i.test(c), v = /sailfish/i.test(c), C = /tizen/i.test(c), k = /(web|hpw)(o|0)s/i.test(c), Y = /windows phone/i.test(c), P = !Y && /windows/i.test(c), L = !p && !w && /macintosh/i.test(c), N = !g && !v && !C && !k && /linux/i.test(c), D = u(/edg([ea]|ios)\/(\d+(\.\d+)?)/i), B = h(/version\/(\d+(\.\d+)?)/i), V = /tablet/i.test(c) && !/tablet pc/i.test(c), X = !V && /[^-]mobi/i.test(c), Z = /xbox/i.test(c), W;
      /opera/i.test(c) ? W = {
        name: "Opera",
        opera: t,
        version: B || h(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
      } : /opr\/|opios/i.test(c) ? W = {
        name: "Opera",
        opera: t,
        version: h(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || B
      } : /SamsungBrowser/i.test(c) ? W = {
        name: "Samsung Internet for Android",
        samsungBrowser: t,
        version: B || h(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
      } : /Whale/i.test(c) ? W = {
        name: "NAVER Whale browser",
        whale: t,
        version: h(/(?:whale)[\s\/](\d+(?:\.\d+)+)/i)
      } : /MZBrowser/i.test(c) ? W = {
        name: "MZ Browser",
        mzbrowser: t,
        version: h(/(?:MZBrowser)[\s\/](\d+(?:\.\d+)+)/i)
      } : /coast/i.test(c) ? W = {
        name: "Opera Coast",
        coast: t,
        version: B || h(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
      } : /focus/i.test(c) ? W = {
        name: "Focus",
        focus: t,
        version: h(/(?:focus)[\s\/](\d+(?:\.\d+)+)/i)
      } : /yabrowser/i.test(c) ? W = {
        name: "Yandex Browser",
        yandexbrowser: t,
        version: B || h(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
      } : /ucbrowser/i.test(c) ? W = {
        name: "UC Browser",
        ucbrowser: t,
        version: h(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
      } : /mxios/i.test(c) ? W = {
        name: "Maxthon",
        maxthon: t,
        version: h(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
      } : /epiphany/i.test(c) ? W = {
        name: "Epiphany",
        epiphany: t,
        version: h(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
      } : /puffin/i.test(c) ? W = {
        name: "Puffin",
        puffin: t,
        version: h(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
      } : /sleipnir/i.test(c) ? W = {
        name: "Sleipnir",
        sleipnir: t,
        version: h(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
      } : /k-meleon/i.test(c) ? W = {
        name: "K-Meleon",
        kMeleon: t,
        version: h(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
      } : Y ? (W = {
        name: "Windows Phone",
        osname: "Windows Phone",
        windowsphone: t
      }, D ? (W.msedge = t, W.version = D) : (W.msie = t, W.version = h(/iemobile\/(\d+(\.\d+)?)/i))) : /msie|trident/i.test(c) ? W = {
        name: "Internet Explorer",
        msie: t,
        version: h(/(?:msie |rv:)(\d+(\.\d+)?)/i)
      } : b ? W = {
        name: "Chrome",
        osname: "Chrome OS",
        chromeos: t,
        chromeBook: t,
        chrome: t,
        version: h(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      } : /edg([ea]|ios)/i.test(c) ? W = {
        name: "Microsoft Edge",
        msedge: t,
        version: D
      } : /vivaldi/i.test(c) ? W = {
        name: "Vivaldi",
        vivaldi: t,
        version: h(/vivaldi\/(\d+(\.\d+)?)/i) || B
      } : v ? W = {
        name: "Sailfish",
        osname: "Sailfish OS",
        sailfish: t,
        version: h(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
      } : /seamonkey\//i.test(c) ? W = {
        name: "SeaMonkey",
        seamonkey: t,
        version: h(/seamonkey\/(\d+(\.\d+)?)/i)
      } : /firefox|iceweasel|fxios/i.test(c) ? (W = {
        name: "Firefox",
        firefox: t,
        version: h(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
      }, /\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(c) && (W.firefoxos = t, W.osname = "Firefox OS")) : w ? W = {
        name: "Amazon Silk",
        silk: t,
        version: h(/silk\/(\d+(\.\d+)?)/i)
      } : /phantom/i.test(c) ? W = {
        name: "PhantomJS",
        phantom: t,
        version: h(/phantomjs\/(\d+(\.\d+)?)/i)
      } : /slimerjs/i.test(c) ? W = {
        name: "SlimerJS",
        slimer: t,
        version: h(/slimerjs\/(\d+(\.\d+)?)/i)
      } : /blackberry|\bbb\d+/i.test(c) || /rim\stablet/i.test(c) ? W = {
        name: "BlackBerry",
        osname: "BlackBerry OS",
        blackberry: t,
        version: B || h(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
      } : k ? (W = {
        name: "WebOS",
        osname: "WebOS",
        webos: t,
        version: B || h(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
      }, /touchpad\//i.test(c) && (W.touchpad = t)) : /bada/i.test(c) ? W = {
        name: "Bada",
        osname: "Bada",
        bada: t,
        version: h(/dolfin\/(\d+(\.\d+)?)/i)
      } : C ? W = {
        name: "Tizen",
        osname: "Tizen",
        tizen: t,
        version: h(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || B
      } : /qupzilla/i.test(c) ? W = {
        name: "QupZilla",
        qupzilla: t,
        version: h(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || B
      } : /chromium/i.test(c) ? W = {
        name: "Chromium",
        chromium: t,
        version: h(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || B
      } : /chrome|crios|crmo/i.test(c) ? W = {
        name: "Chrome",
        chrome: t,
        version: h(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      } : g ? W = {
        name: "Android",
        version: B
      } : /safari|applewebkit/i.test(c) ? (W = {
        name: "Safari",
        safari: t
      }, B && (W.version = B)) : p ? (W = {
        name: p == "iphone" ? "iPhone" : p == "ipad" ? "iPad" : "iPod"
      }, B && (W.version = B)) : /googlebot/i.test(c) ? W = {
        name: "Googlebot",
        googlebot: t,
        version: h(/googlebot\/(\d+(\.\d+))/i) || B
      } : W = {
        name: h(/^(.*)\/(.*) /),
        version: u(/^(.*)\/(.*) /)
      }, !W.msedge && /(apple)?webkit/i.test(c) ? (/(apple)?webkit\/537\.36/i.test(c) ? (W.name = W.name || "Blink", W.blink = t) : (W.name = W.name || "Webkit", W.webkit = t), !W.version && B && (W.version = B)) : !W.opera && /gecko\//i.test(c) && (W.name = W.name || "Gecko", W.gecko = t, W.version = W.version || h(/gecko\/(\d+(\.\d+)?)/i)), !W.windowsphone && (g || W.silk) ? (W.android = t, W.osname = "Android") : !W.windowsphone && p ? (W[p] = t, W.ios = t, W.osname = "iOS") : L ? (W.mac = t, W.osname = "macOS") : Z ? (W.xbox = t, W.osname = "Xbox") : P ? (W.windows = t, W.osname = "Windows") : N && (W.linux = t, W.osname = "Linux");
      function st(U) {
        switch (U) {
          case "NT":
            return "NT";
          case "XP":
            return "XP";
          case "NT 5.0":
            return "2000";
          case "NT 5.1":
            return "XP";
          case "NT 5.2":
            return "2003";
          case "NT 6.0":
            return "Vista";
          case "NT 6.1":
            return "7";
          case "NT 6.2":
            return "8";
          case "NT 6.3":
            return "8.1";
          case "NT 10.0":
            return "10";
          default:
            return;
        }
      }
      var j = "";
      W.windows ? j = st(h(/Windows ((NT|XP)( \d\d?.\d)?)/i)) : W.windowsphone ? j = h(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i) : W.mac ? (j = h(/Mac OS X (\d+([_\.\s]\d+)*)/i), j = j.replace(/[_\s]/g, ".")) : p ? (j = h(/os (\d+([_\s]\d+)*) like mac os x/i), j = j.replace(/[_\s]/g, ".")) : g ? j = h(/android[ \/-](\d+(\.\d+)*)/i) : W.webos ? j = h(/(?:web|hpw)os\/(\d+(\.\d+)*)/i) : W.blackberry ? j = h(/rim\stablet\sos\s(\d+(\.\d+)*)/i) : W.bada ? j = h(/bada\/(\d+(\.\d+)*)/i) : W.tizen && (j = h(/tizen[\/\s](\d+(\.\d+)*)/i)), j && (W.osversion = j);
      var gt = !W.windows && j.split(".")[0];
      return V || y || p == "ipad" || g && (gt == 3 || gt >= 4 && !X) || W.silk ? W.tablet = t : (X || p == "iphone" || p == "ipod" || g || _ || W.blackberry || W.webos || W.bada) && (W.mobile = t), W.msedge || W.msie && W.version >= 10 || W.yandexbrowser && W.version >= 15 || W.vivaldi && W.version >= 1 || W.chrome && W.version >= 20 || W.samsungBrowser && W.version >= 4 || W.whale && o([W.version, "1.0"]) === 1 || W.mzbrowser && o([W.version, "6.0"]) === 1 || W.focus && o([W.version, "1.0"]) === 1 || W.firefox && W.version >= 20 || W.safari && W.version >= 6 || W.opera && W.version >= 10 || W.ios && W.osversion && W.osversion.split(".")[0] >= 6 || W.blackberry && W.version >= 10.1 || W.chromium && W.version >= 20 ? W.a = t : W.msie && W.version < 10 || W.chrome && W.version < 20 || W.firefox && W.version < 20 || W.safari && W.version < 6 || W.opera && W.version < 10 || W.ios && W.osversion && W.osversion.split(".")[0] < 6 || W.chromium && W.version < 20 ? W.c = t : W.x = t, W;
    }
    var i = e(typeof navigator < "u" && navigator.userAgent || "");
    i.test = function(c) {
      for (var h = 0; h < c.length; ++h) {
        var u = c[h];
        if (typeof u == "string" && u in i)
          return !0;
      }
      return !1;
    };
    function s(c) {
      return c.split(".").length;
    }
    function r(c, h) {
      var u = [], p;
      if (Array.prototype.map)
        return Array.prototype.map.call(c, h);
      for (p = 0; p < c.length; p++)
        u.push(h(c[p]));
      return u;
    }
    function o(c) {
      for (var h = Math.max(s(c[0]), s(c[1])), u = r(c, function(p) {
        var m = h - s(p);
        return p = p + new Array(m + 1).join(".0"), r(p.split("."), function(g) {
          return new Array(20 - g.length).join("0") + g;
        }).reverse();
      }); --h >= 0; ) {
        if (u[0][h] > u[1][h])
          return 1;
        if (u[0][h] === u[1][h]) {
          if (h === 0)
            return 0;
        } else
          return -1;
      }
    }
    function a(c, h, u) {
      var p = i;
      typeof h == "string" && (u = h, h = void 0), h === void 0 && (h = !1), u && (p = e(u));
      var m = "" + p.version;
      for (var g in c)
        if (c.hasOwnProperty(g) && p[g]) {
          if (typeof c[g] != "string")
            throw new Error("Browser version in the minVersion map should be a string: " + g + ": " + String(c));
          return o([m, c[g]]) < 0;
        }
      return h;
    }
    function l(c, h, u) {
      return !a(c, h, u);
    }
    return i.isUnsupportedBrowser = a, i.compareVersions = o, i.check = l, i._detect = e, i.detect = e, i;
  });
})(fd);
var _d = fd.exports;
const hg = /* @__PURE__ */ Il(_d), ug = /* @__PURE__ */ Hp({
  __proto__: null,
  default: hg
}, [_d]), dg = "data:application/javascript;base64,CnZhciBTY0VuZ2luZU1vZHVsZSA9ICgoKSA9PiB7CiAgdmFyIF9zY3JpcHREaXIgPSBpbXBvcnQubWV0YS51cmw7CiAgCiAgcmV0dXJuICgKZnVuY3Rpb24oU2NFbmdpbmVNb2R1bGUpIHsKICBTY0VuZ2luZU1vZHVsZSA9IFNjRW5naW5lTW9kdWxlIHx8IHt9OwoKCnZhciBnO2d8fChnPXR5cGVvZiBTY0VuZ2luZU1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBTY0VuZ2luZU1vZHVsZSA6IHt9KTt2YXIgYWEsZWE7Zy5yZWFkeT1uZXcgUHJvbWlzZShmdW5jdGlvbihhLGIpe2FhPWE7ZWE9Yn0pO2cuJCRzZXRSZWFkeT1mdW5jdGlvbigpe2cuZ2soKTtnLiQkb25SZWFkeS5hcHBseSh3aW5kb3csYXJndW1lbnRzKTtnLiQkb25SZWFkeT12b2lkIDA7Zy5vbkFib3J0PXZvaWQgMH07CmcuZ2s9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKEUpe2lmKCFFKXJldHVybiAwO3ZhciBBPWcuJCRlcy5hbGxvY2F0ZVVpbnQ4QnVmZmVyKDgqRS5sZW5ndGgpO2lmKEEpaGEuc2V0KEUsQT4+Myk7ZWxzZSB0aHJvdyBFcnJvcigiT3V0IG9mIG1lbW9yeS4iKTtyZXR1cm4gQX1mdW5jdGlvbiBiKEUpe2lmKCFFKXJldHVybiAwO3ZhciBBPWcuJCRlcy5hbGxvY2F0ZVVpbnQ4QnVmZmVyKDQqRS5sZW5ndGgpO2lmKEEpaC5zZXQoRSxBPj4yKTtlbHNlIHRocm93IEVycm9yKCJPdXQgb2YgbWVtb3J5LiIpO3JldHVybiBBfWZ1bmN0aW9uIGMoRSl7aWYoIUUpcmV0dXJuIDA7dmFyIEE9Zy4kJGVzLmFsbG9jYXRlVWludDhCdWZmZXIoRS5sZW5ndGgpO2lmKEEpdC5zZXQoRSxBKTtlbHNlIHRocm93IEVycm9yKCJPdXQgb2YgbWVtb3J5LiIpO3JldHVybiBBfWZ1bmN0aW9uIGQoRSl7Zy4kJGVzLmRlYWxsb2NhdGVVaW50OEJ1ZmZlcihFKX1mdW5jdGlvbiBlKEUpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBuKEUsCmFyZ3VtZW50cyl9fWZ1bmN0aW9uIGYoRSxBLFUpe2Z1bmN0aW9uIEsoeGEpe3JldHVybiBmdW5jdGlvbigpe0coKTtSJiZ5LmNhbGxSZWNvcmQucHVzaCh4YSsiICIrdyhhcmd1bWVudHMpKTtyZXR1cm4gbCh0aGlzLGdbRV1beGFdLGFyZ3VtZW50cyl9fWZ1bmN0aW9uIGphKCl7RygpO3RoaXMuJCRtZW1vcnk9bmV3IFVpbnQ4QXJyYXkoZ1tFXVsic2l6ZW9mXyIrQV0oKSk7bCh0aGlzLGdbRV1bVysiY3JlYXRlIl0sYXJndW1lbnRzKX12YXIgVz1BKyJfIjtqYS5wcm90b3R5cGU9eyQkc3RhY2tpZnk6ITB9O2phLmNvcHk9ZnVuY3Rpb24oeGEpe0coKTt2YXIgQmE9T2JqZWN0LmNyZWF0ZShqYS5wcm90b3R5cGUpO0JhLiQkbWVtb3J5PW5ldyBVaW50OEFycmF5KHQuc3ViYXJyYXkoeGEseGErZ1tFXVsic2l6ZW9mXyIrQV0oKSkpO3JldHVybiBCYX07amEuY2xvbmU9ZnVuY3Rpb24oeGEpe3ZhciBCYT1PYmplY3QuY3JlYXRlKGphLnByb3RvdHlwZSk7QmEuJCRtZW1vcnk9bmV3IFVpbnQ4QXJyYXkoeGEuJCRtZW1vcnkpOwpyZXR1cm4gQmF9O2phLmFzc2lnbj1mdW5jdGlvbih4YSxCYSl7eGEuJCRtZW1vcnkuc2V0KEJhLiQkbWVtb3J5KX07Zm9yKHZhciB0YT0wO3RhPFUubGVuZ3RoO3RhKyspamEucHJvdG90eXBlW1VbdGFdXT1LKFcrVVt0YV0pO3JldHVybiB5W0FdPWphfWZ1bmN0aW9uIGwoRSxBLFUpe1U9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoVSk7VS51bnNoaWZ0KEUpO3JldHVybiBuKEEsVSl9ZnVuY3Rpb24gbihFLEEpe2Zvcih2YXIgVT0hMSxLPTA7SzxBLmxlbmd0aDsrK0spaWYoQVtLXS4kJHN0YWNraWZ5KXtVPSEwO2JyZWFrfWlmKCFVKXJldHVybiBFLmFwcGx5KGcsQSk7VT1tYSgpO3RyeXt2YXIgamE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoQSk7Zm9yKEs9MDtLPEEubGVuZ3RoO0srKylpZihBW0tdLiQkc3RhY2tpZnkpe3ZhciBXPW5hKEFbS10uJCRtZW1vcnkubGVuZ3RoKTt0LnNldChBW0tdLiQkbWVtb3J5LFcpO2phW0tdPVd9dmFyIHRhPUUuYXBwbHkoZyxqYSk7Zm9yKEs9CjA7SzxBLmxlbmd0aDtLKyspQVtLXS4kJHN0YWNraWZ5JiZBW0tdLiQkbWVtb3J5LnNldCh0LnN1YmFycmF5KGphW0tdLGphW0tdK0FbS10uJCRtZW1vcnkubGVuZ3RoKSl9ZmluYWxseXtzYShVKX1yZXR1cm4gdGF9ZnVuY3Rpb24gcShFKXt0aGlzLnZhbHVlPUV9ZnVuY3Rpb24gdigpe3kuc3VzcGVuZERyYXdpbmcoKTtnLmdpKCJ3ZWJnbF9jb250ZXh0X2xvc3QiKX1mdW5jdGlvbiB3KCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3VtZW50cyxDKX1mdW5jdGlvbiBDKEUsQSl7cmV0dXJuIG51bGwhPT1BJiYib2JqZWN0Ij09PXR5cGVvZiBBJiZBLiQkbWVtb3J5PyJzdGFja2lmaWVkIjpBfWZ1bmN0aW9uIEcoKXtpZih5IT09Zy4kJGZhY2FkZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoIm1lbWJlciBjYWxsZWQgYWZ0ZXIgc2h1dGRvd24iKTt9dmFyIHA9IiQkY3MiO2cuJCRlcy5pbml0aWFsaXplTGlicmFyeSgpO3ZhciB5PWcuJCRmYWNhZGUsRj1nLktqP25ldyBnLktqOnZvaWQgMDsKZy5vaj1GO3kuaXNWYWxpZD1mdW5jdGlvbigpe3JldHVybiB5PT09Zy4kJGZhY2FkZX07dmFyIFI9ITE7eS5jYWxsUmVjb3JkPVtdO3kuc3RhcnRSZWNvcmRpbmc9ZnVuY3Rpb24oKXtSPSEwfTt5LnN0b3BSZWNvcmRpbmc9ZnVuY3Rpb24oKXtSPSExfTt5LmxvZ0NhbGxSZWNvcmQ9ZnVuY3Rpb24oKXtmb3IodmFyIEU9eS5jYWxsUmVjb3JkLEE9MDtBPEUubGVuZ3RoOysrQSljb25zb2xlLmxvZyhFW0FdKX07eS5zaHV0RG93bj1mdW5jdGlvbigpe0coKTtSJiZ5LmNhbGxSZWNvcmQucHVzaCgic2h1dERvd24iKTsiJCRjcyI9PT1wJiZnLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCJ3ZWJnbGNvbnRleHRsb3N0Iix2KTtnLiQkZXMuc2h1dERvd25MaWJyYXJ5KCk7RiYmRi5UaygpO3kuY29udGFpbmVyLmlubmVySFRNTD0iIjtnLiQkZmFjYWRlPXZvaWQgMDtnLm9qPXZvaWQgMDtnLiQkYXZhaWxhYmxlPSEwO2cuJCR3cmFwcGVyLmlubmVySFRNTD0iIn07eS5CeU1lc2hJbnN0YW5jZT0KbmV3IHEoMCk7eS5CeUdyb3VwPW5ldyBxKDEpO3kuQnlFeHBhbmRlZEdyb3VwPW5ldyBxKDIpOyhmdW5jdGlvbigpe2Z1bmN0aW9uIEUobSxyKXtLKFtILlNjc10pO2lmKCFtKXRocm93IG5ldyBXKCJJbnZhbGlkQ29uZmlnIiwiSW52YWxpZCBsb2FkIGNvbmZpZ3VyYXRpb24iKTt2YXIgdSx4LHo9bmV3IFByb21pc2UoZnVuY3Rpb24oWCxjYSl7dT1YO3g9Y2F9KTt1YT1ILlNjczt2YXIgTD1uZXcgWE1MSHR0cFJlcXVlc3Q7TC5vcGVuKCJHRVQiLHIpO0wucmVzcG9uc2VUeXBlPSJhcnJheWJ1ZmZlciI7TC5vbmxvYWQ9ZnVuY3Rpb24oKXt0cnl7QShtLG5ldyBVaW50OEFycmF5KHRoaXMucmVzcG9uc2UpKS50aGVuKGZ1bmN0aW9uKFgpe3UoWCl9LGZ1bmN0aW9uKFgpe3goWCl9KX1jYXRjaChYKXt9fTsiZnVuY3Rpb24iPT09dHlwZW9mIG0uWEhSb25wcm9ncmVzcyYmKEwub25wcm9ncmVzcz1tLlhIUm9ucHJvZ3Jlc3MpOyJmdW5jdGlvbiI9PT10eXBlb2YgbS5YSFJvbmVycm9yJiYoTC5vbmVycm9yPQptLlhIUm9uZXJyb3IpO2lmKCJmdW5jdGlvbiI9PT10eXBlb2YgbS5YSFJvbmxvYWRlbmQpe3ZhciBmYT1tLlhIUm9ubG9hZGVuZDtMLm9ubG9hZGVuZD1mdW5jdGlvbihYKXtmYShYLEwuc3RhdHVzLHIpfX1MLnNlbmQoKTtyZXR1cm4gen1mdW5jdGlvbiBBKG0scil7SyhbSC5TY3NdKTtpZighbSl0aHJvdyBuZXcgVygiSW52YWxpZENvbmZpZyIsIkludmFsaWQgbG9hZCBjb25maWd1cmF0aW9uIik7aWYoci5jb25zdHJ1Y3RvciE9PVVpbnQ4QXJyYXkpdGhyb3cgbmV3IFcoIkludmFsaWRDb25maWciLCInYnVmZmVyJyBtdXN0IGJlIGEgVWludDhBcnJheSIpO2lmKDA+PXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgVygiRW1wdHlCdWZmZXIiLCInYnVmZmVyJyBoYXMgYSBsZW5ndGggb2YgMCIpO3ZhciB1PWcuJCRlcy5hbGxvY2F0ZVVpbnQ4QnVmZmVyKHIuYnl0ZUxlbmd0aCk7dC5zZXQocix1KTt0cnl7cmV0dXJuIFUobSx1LHIuYnl0ZUxlbmd0aCl9Y2F0Y2goeCl7dGhyb3cgZy4kJGVzLmRlYWxsb2NhdGVVaW50OEJ1ZmZlcih1KSwKeDt9fWZ1bmN0aW9uIFUobSxyLHUpe0soW0guU2NzXSk7dmFyIHg9bS5hdHRhY2hTY29wZSx6PW0uYXR0YWNoTWVhc3VyZW1lbnRVbml0LEw9bS5hdHRhY2hJbnZpc2libHksZmE9bS5yZXNvbHZlT25GdWxseUxvYWRlZCxYPW0uaW5jbHVzaW9uTWF0cml4O209MDtpZihYKXtpZihYLmNvbnN0cnVjdG9yIT09QXJyYXkmJlguY29uc3RydWN0b3IhPT1GbG9hdDY0QXJyYXkpdGhyb3cgbmV3IFR5cGVFcnJvcigiJ2luY2x1c2lvbk1hdHJpeCcgaXMgbm90IGFuIEFycmF5IG9yIEZsb2F0NjRBcnJheS4iKTtpZigxMiE9PVgubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoIidpbmNsdXNpb25NYXRyaXgnIG5lZWRzIHRvIGhhdmUgZXhhY3RseSAxMiBlbGVtZW50cy4iKTttPWEoWCk7aWYoIW0pdGhyb3cgRXJyb3IoIkludGVybmFsIGxvZ2ljIGVycm9yLiIpO311YT1ILlNjczt2YXIgY2EsemE7WD1uZXcgUHJvbWlzZShmdW5jdGlvbihxYSx5YSl7Y2E9cWE7emE9ZnVuY3Rpb24oSGEpe3RyeXtqYShIYSksCnlhKG51bGwpfWNhdGNoKElhKXt5YShJYSl9fX0pO3RyeXtnLiQkZXMuYXR0YWNoU2NzQnVmZmVyKHgscix1LG0seixMLGZhLGNhLHphKX1jYXRjaChxYSl7emEocWEpfWZpbmFsbHl7ZChtKX1yZXR1cm4gWH1mdW5jdGlvbiBLKG0pe2lmKHVhIT09SC5VbmluaXRpYWxpemVkKXtpZih2b2lkIDAhPT1tKWZvcih2YXIgcj0wO3I8bS5sZW5ndGg7KytyKWlmKHVhPT09bVtyXSlyZXR1cm47dGhyb3cgbmV3IFcoIkFscmVhZHlDYWxsZWQiLCJsb2FkKCkgYWxyZWFkeSBjYWxsZWQgd2l0aCBhbiBpbmNvbXBhdGlibGUgc2Vzc2lvbiB0eXBlIik7fX1mdW5jdGlvbiBqYShtKXtzd2l0Y2gobSl7Y2FzZSBnLkxvYWRSZXN1bHQuV2ViR0xNaXNzaW5nOnRocm93IG5ldyBXKCJXZWJHTEVycm9yIiwiV2ViR0wgaW5pdGlhbGl6YXRpb24gZmFpbGVkIik7Y2FzZSBnLkxvYWRSZXN1bHQuU2Vzc2lvbkFscmVhZHlTdGFydGVkOnRocm93IG5ldyBXKCJBbHJlYWR5Q2FsbGVkIiwibG9hZCgpIGFscmVhZHkgY2FsbGVkIik7Cn19ZnVuY3Rpb24gVyhtLHIpe3RoaXMuY29kZT1tO3RoaXMubWVzc2FnZT1yO3RoaXMuc3RhY2s9RXJyb3IoKS5zdGFja31mdW5jdGlvbiB0YShtKXt2YXIgcj1KU09OLnBhcnNlKHZhKG0sMCkpO2lmKCJycGMiaW4gcil7aWYobT1yLnJwYyxyPW0ubGVuZ3RoLzIscj09PU1hdGguZmxvb3Iocikpe2Zvcih2YXIgdT1uZXcgVWludDhBcnJheShyKSx4PTA7eDxyOysreCl1W3hdPXBhcnNlSW50KG0uc3Vic3RyKHgreCwyKSwxNik7bT11O3I9KG5ldyBEYXRhVmlldyhtLmJ1ZmZlcikpLmdldFVpbnQzMigwLCEwKTt1PW1bNF07bT1tLnN1YmFycmF5KDUpO3g9YyhtKTtnW3BdLm5vdGlmeVJwY0NsaWVudFJlc3VsdChyLHUseCxtLmxlbmd0aCl9fWVsc2UgaWYoImV2ZW50ImluIHIpc3dpdGNoKG09ci5ldmVudCxyPXIuZGF0YSxtKXtjYXNlICJjYW1lcmFfc2V0IjpOYj1BYihyKTtnLmdpKG0pO2JyZWFrO2RlZmF1bHQ6QXJyYXkuaXNBcnJheShyKT8oci51bnNoaWZ0KG0pLGcuZ2kuYXBwbHkoZywKcikpOmcuZ2kobSxyKX19ZnVuY3Rpb24geGEobSl7dmFyIHI9YyhtKTtnLiQkZXMucGFyc2VNZXRhRGF0YShPYixyLG0ubGVuZ3RoKX1mdW5jdGlvbiBCYShtKXttPXZhKG0sMCk7Zy5naSgicG9zdF9kcmF3X2pzb24iLG0pfWZ1bmN0aW9uIEFiKG0pe3ZhciByPW5ldyBDYTtyLnJlc2V0LmFwcGx5KHIsbSk7cmV0dXJuIHJ9ZnVuY3Rpb24gUGIobSl7ZnVuY3Rpb24gcihrYSxYYSxQLGRhKXtpZigwPmRhfHxkYT49WGEuZWxlbWVudENvdW50KXRocm93IG5ldyBSYW5nZUVycm9yKCJpbnZhbGlkIGVsZW1lbnQgaW5kZXgiKTt2YXIgcGE9e3ZlcnRleENvdW50OmZhW2thXVszKmRhKzFdLGJpdHM6ZmFba2FdWzMqZGErMl0saXRlcmF0ZTpmdW5jdGlvbihKYSl7cmV0dXJuIHgoa2EsWGEsUCxkYSx0aGlzLEphKX19OyJ1bmRlZmluZWQiIT09dHlwZW9mIFN5bWJvbCYmInVuZGVmaW5lZCIhPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yJiYocGFbU3ltYm9sLml0ZXJhdG9yXT11KTtyZXR1cm4gcGF9CmZ1bmN0aW9uIHUoKXtyZXR1cm4gdGhpcy5pdGVyYXRlKCEwKX1mdW5jdGlvbiB4KGthLFhhLFAsZGEscGEsSmEpe2Z1bmN0aW9uIHFiKCl7dmFyIHJhPXtwb3NpdGlvbjp2b2lkIDAsbm9ybWFsOnZvaWQgMCxVVjp2b2lkIDAsUkdCQTp2b2lkIDB9OysrWWE7Zm9yKHZhciBsYT0wO2xhPGhiLmxlbmd0aDsrK2xhKWhiW2xhXShyYSk7cmV0dXJuIHJhfWlmKCJudW1iZXIiPT09dHlwZW9mIGRhKXZhciBLYz1QK2ZhW2thXVszKmRhXSxMYz1wYS52ZXJ0ZXhDb3VudDtlbHNlIEtjPVAsTGM9WGEudmVydGV4Q291bnQ7dmFyIHdkPUtjK0xjLFlhPUtjLGhiPVtdO2NhP2hiLnB1c2goZnVuY3Rpb24ocmEpe3ZhciBsYT1beltLYV0seltLYSsxXSx6W0thKzJdXTtyYS5wb3NpdGlvbj1bY2FbMF0qbGFbMF0rY2FbNF0qbGFbMV0rY2FbOF0qbGFbMl0rY2FbMTJdLGNhWzFdKmxhWzBdK2NhWzVdKmxhWzFdK2NhWzldKmxhWzJdK2NhWzEzXSxjYVsyXSpsYVswXStjYVs2XSpsYVsxXStjYVsxMF0qbGFbMl0rCmNhWzE0XV19KTpoYi5wdXNoKGZ1bmN0aW9uKHJhKXtyYS5wb3NpdGlvbj1beltLYV0seltLYSsxXSx6W0thKzJdXX0pO1hhLmhhc05vcm1hbHMmJmhiLnB1c2goZnVuY3Rpb24ocmEpe3ZhciBsYT1LYSt6YTtyYS5ub3JtYWw9W3pbbGFdLHpbbGErMV0seltsYSsyXV19KTtYYS5oYXNVVnMmJmhiLnB1c2goZnVuY3Rpb24ocmEpe3ZhciBsYT1LYStxYTtyYS5VVj1beltsYV0seltsYSsxXV19KTtpZihYYS5oYXNSR0JBcyl7dmFyIE1jPW5ldyBVaW50OEFycmF5KHouYnVmZmVyKTtoYi5wdXNoKGZ1bmN0aW9uKHJhKXt2YXIgbGE9S2EreWE8PDI7cmEuUkdCQT1bTWNbbGFdLE1jW2xhKzFdLE1jW2xhKzJdLE1jW2xhKzNdXX0pfWlmKEwpe3ZhciBLYT1MW1lhXSpYO2hiLnB1c2goZnVuY3Rpb24oKXtLYT1MW1lhXSpYfSl9ZWxzZSBLYT1ZYSpYLGhiLnB1c2goZnVuY3Rpb24oKXtLYSs9WH0pO3JldHVybntkb25lOmZ1bmN0aW9uKCl7cmV0dXJuIFlhPj13ZH0sbmV4dDpKYT9mdW5jdGlvbigpe3JldHVybiBZYTwKd2Q/e3ZhbHVlOnFiKCksZG9uZTohMX06e2RvbmU6ITB9fTpmdW5jdGlvbigpe2lmKFlhPHdkKXJldHVybiBxYigpfSxnb1RvOmZ1bmN0aW9uKHJhKXswPnJhP3JhPTA6cmE+PUxjJiYocmE9TGMpO1lhPUtjK3JhO0thPUw/TFtZYV0qWDpZYSpYfX19dmFyIHo9bS52ZXJ0aWNlcyxMPW0uaW5kaWNlcyxmYT1tLmVsZW1lbnRzLFg9bS5zdHJpZGUsY2E9bS5kdXBsaWNhdGVNYXRyaXgsemE9bS5ub3JtYWxPZmZzZXQscWE9bS5VVk9mZnNldCx5YT1tLlJHQkEzMk9mZnNldCxIYT1tLmZhY2VWZXJ0ZXhDb3VudCxJYT1IYSttLmxpbmVWZXJ0ZXhDb3VudCxaYT17ZmFjZXM6e3ZlcnRleENvdW50Om0uZmFjZVZlcnRleENvdW50LGhhc05vcm1hbHM6bS5mYWNlTm9ybWFscz8hMDohMSxoYXNVVnM6bS5mYWNlVVZzPyEwOiExLGhhc1JHQkFzOm0uZmFjZVJHQkEzMnM/ITA6ITEsZWxlbWVudENvdW50OmZhWzBdP2ZhWzBdLmxlbmd0aC8zOjAsaXRlcmF0ZTpmdW5jdGlvbihrYSl7cmV0dXJuIHgoMCwKdGhpcywwLHZvaWQgMCx2b2lkIDAsa2EpfSxlbGVtZW50OmZ1bmN0aW9uKGthKXtyZXR1cm4gcigwLHRoaXMsMCxrYSl9fSxsaW5lczp7dmVydGV4Q291bnQ6bS5saW5lVmVydGV4Q291bnQsaGFzTm9ybWFsczptLmxpbmVOb3JtYWxzPyEwOiExLGhhc1VWczptLmxpbmVVVnM/ITA6ITEsaGFzUkdCQXM6bS5saW5lUkdCQTMycz8hMDohMSxlbGVtZW50Q291bnQ6ZmFbMV0/ZmFbMV0ubGVuZ3RoLzM6MCxpdGVyYXRlOmZ1bmN0aW9uKGthKXtyZXR1cm4geCgxLHRoaXMsSGEsdm9pZCAwLHZvaWQgMCxrYSl9LGVsZW1lbnQ6ZnVuY3Rpb24oa2Epe3JldHVybiByKDEsdGhpcyxIYSxrYSl9fSxwb2ludHM6e3ZlcnRleENvdW50Om0ucG9pbnRWZXJ0ZXhDb3VudCxoYXNOb3JtYWxzOm0ucG9pbnROb3JtYWxzPyEwOiExLGhhc1VWczptLnBvaW50VVZzPyEwOiExLGhhc1JHQkFzOm0ucG9pbnRSR0JBMzJzPyEwOiExLGVsZW1lbnRDb3VudDpmYVsyXT9mYVsyXS5sZW5ndGgvMzowLGl0ZXJhdGU6ZnVuY3Rpb24oa2Epe3JldHVybiB4KDIsCnRoaXMsSWEsdm9pZCAwLHZvaWQgMCxrYSl9LGVsZW1lbnQ6ZnVuY3Rpb24oa2Epe3JldHVybiByKDIsdGhpcyxJYSxrYSl9fX07InVuZGVmaW5lZCIhPT10eXBlb2YgU3ltYm9sJiYidW5kZWZpbmVkIiE9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3ImJihaYS5mYWNlc1tTeW1ib2wuaXRlcmF0b3JdPXUsWmEubGluZXNbU3ltYm9sLml0ZXJhdG9yXT11LFphLnBvaW50c1tTeW1ib2wuaXRlcmF0b3JdPXUpO209bS5mb3J3YXJkO2ZvcihsZXQga2EgaW4gbSltLmhhc093blByb3BlcnR5KGthKSYmKFphW2thXT1tW2thXSk7cmV0dXJuIFphfWZ1bmN0aW9uIE9iKG0scix1KXt2YXIgeD0kYVttXTt4fHwoeD0kYVttXT17fSk7eFtyXT11O2cuZ2koIm1ldGFfZGF0YSIsbSxyLHUpfWZ1bmN0aW9uIG9hKG0scil7aWYoIiQkY3MiPT09cClyZXR1cm4gWi5nZXRNZXRhRGF0YShtKTthYihtKTtmb3IodmFyIHU9W10seD0wO3g8bS5sZW5ndGg7eCs9Mil7dmFyIHo9bVt4XSxMPW1beCsxXSxmYT0kYVt6XTsKdm9pZCAwPT09KGZhP2ZhW0xdOnZvaWQgMCkmJnUucHVzaCh6LEwpfWlmKDA9PT11Lmxlbmd0aCl7cj1bXTtmb3IoeD0wO3g8bS5sZW5ndGg7eCs9Mil6PW1beF0sTD1tW3grMV0sci5wdXNoKCRhW3pdW0xdKTtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHIpfXJldHVybiByPyh4PW5ldyBTKCJnZXRNZXRhRGF0YSIsdSksUHJvbWlzZS5yZWplY3QoeCkpOloucmVxdWVzdE1ldGFEYXRhKHUpLnRoZW4oZnVuY3Rpb24oKXtHKCk7cmV0dXJuIG9hKG0sITApfSl9ZnVuY3Rpb24gU2EoKXsiJCRjcyI9PT1wJiZnLiQkZXMuZGlzY29ubmVjdE5ldHdvcmsoKX1mdW5jdGlvbiBrKG0scix1KXtpZigiZnVuY3Rpb24iPT09dHlwZW9mIHUpaWIobSxyLHUpO2Vsc2V7dT11fHwwO3ZhciB4PSJzdHJpbmciPT09dHlwZW9mIG0/bSsiXyIrcjpyLHo7Zy4kJGVzW3hdP3o9Zy4kJGVzW3hdOno9ZnVuY3Rpb24oKXtyZXR1cm4gZ1twXVt4XS5hcHBseShnLGFyZ3VtZW50cyl9O3ZhciBMPXo7dSYxJiYoTD1mdW5jdGlvbihQKXtyZXR1cm4gMD09ClA/Zy4kJGNzW3hdLmFwcGx5KGcsYXJndW1lbnRzKTp6LmFwcGx5KGcsYXJndW1lbnRzKX0pO3ZhciBmYT1MO3UmMiYmKGZhPWZ1bmN0aW9uKFApeyJudW1iZXIiPT09dHlwZW9mIFAmJihQPVtQXSk7dmFyIGRhPWIoUCk7aWYoIWRhKXRocm93IG5ldyBUeXBlRXJyb3IoImBrZXlzJyBpcyBub3QgYW4gQXJyYXkgb3IgVWludDMyQXJyYXkiKTt2YXIgcGE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO3BhLnVuc2hpZnQoZGEsUC5sZW5ndGgpO3JldHVybiBMLmFwcGx5KGcscGEpfSk7dmFyIFg9ZmE7dSY0JiYoWD1mdW5jdGlvbihQKXthYihQKTt2YXIgZGE9YihQKTtpZighZGEpdGhyb3cgbmV3IFR5cGVFcnJvcigiYGlkcycgaXMgbm90IGFuIEFycmF5IG9yIFVpbnQzMkFycmF5LiIpO3ZhciBwYT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7cGEudW5zaGlmdChkYSxQLmxlbmd0aD4+MSk7cmV0dXJuIGZhLmFwcGx5KGcscGEpfSk7dmFyIGNhPQpYO3UmOCYmKGNhPWZ1bmN0aW9uKFApezQ9PT1QLmxlbmd0aCYmIm51bWJlciI9PT10eXBlb2YgUFswXSYmKFA9W1BdKTt2YXIgZGE9UCxwYT1nLiQkZXMuYWxsb2NhdGVVaW50OEJ1ZmZlcigzMipkYS5sZW5ndGgpO2lmKHBhKWZvcih2YXIgSmE9MDtKYTxkYS5sZW5ndGg7KytKYSl7dmFyIHFiPWRhW0phXTtpZig0IT09cWIubGVuZ3RoKXRocm93IEVycm9yKCJQbGFuZXMgYXJlIGV4cGVjdGVkIGJlIGV4YWN0bHkgNCBudW1iZXJzLiIpO2hhLnNldChxYiwocGE+PjMpKzQqSmEpfWRhPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtkYS51bnNoaWZ0KHBhLFAubGVuZ3RoKTtyZXR1cm4gWC5hcHBseShnLGRhKX0pO3ZhciB6YT1jYTt1JjE2JiYoemE9ZnVuY3Rpb24oUCl7Mz09PVAubGVuZ3RoJiYibnVtYmVyIj09PXR5cGVvZiBQWzBdJiYoUD1bUF0pO3ZhciBkYT1QLHBhPWcuJCRlcy5hbGxvY2F0ZVVpbnQ4QnVmZmVyKDI0KmRhLmxlbmd0aCk7aWYocGEpZm9yKHZhciBKYT0KMDtKYTxkYS5sZW5ndGg7KytKYSl7dmFyIHFiPWRhW0phXTtpZigzIT09cWIubGVuZ3RoKXRocm93IEVycm9yKCJQb2ludHMgYXJlIGV4cGVjdGVkIGJlIGV4YWN0bHkgMyBjb21wb25lbnRzLiIpO2hhLnNldChxYiwocGE+PjMpKzMqSmEpfWRhPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtkYS51bnNoaWZ0KHBhLFAubGVuZ3RoKTtyZXR1cm4gY2EuYXBwbHkoZyxkYSl9KTt2YXIgcWE9emE7dSYzMiYmKHFhPWUoY2EpKTt2YXIgeWE9cWE7dSY2NCYmKHlhPWZ1bmN0aW9uKCl7Y29uc29sZS5sb2coIldBUk5JTkc6IFVzaW5nIGRlcHJlY2F0ZWQgZnVuY3Rpb24gYCIrKCJzdHJpbmciPT09dHlwZW9mIG0/bSsiLiIrcjpyKSsiJyIpO3JldHVybiBxYS5hcHBseShnLGFyZ3VtZW50cyl9KTt2YXIgSGE9eWE7dSYxMjgmJihIYT1mdW5jdGlvbigpe3ZhciBQPWFyZ3VtZW50cyxkYT1QW1AubGVuZ3RoLTFdO2RhLmNvbnN0cnVjdG9yPT09cT9QW1AubGVuZ3RoLTFdPQpkYS52YWx1ZTooUD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChQKSxQLnB1c2goMCkpO3JldHVybiB5YS5hcHBseShnLFApfSk7dmFyIElhPUhhO3UmMjU2JiYoSWE9ZnVuY3Rpb24oKXt2YXIgUD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihkYSxwYSl7UC5wdXNoKGRhKTtQLnB1c2goWSh4LHBhKSk7SGEuYXBwbHkoZyxQKX0pfSk7dmFyIFphPUlhO3UmNTEyJiYoWmE9dSYyNTY/ZnVuY3Rpb24oKXtyZXR1cm4gSWEuYXBwbHkoZyxhcmd1bWVudHMpLnRoZW4oZnVuY3Rpb24oUCl7RygpO3JldHVybiBDYS5jb3B5KFApfSl9OmZ1bmN0aW9uKCl7cmV0dXJuIENhLmNvcHkoSWEuYXBwbHkoZyxhcmd1bWVudHMpKX0pO3ZhciBrYT1aYTt1JjEwMjQmJihrYT11JjI1Nj9mdW5jdGlvbigpe3JldHVybiBaYS5hcHBseShnLGFyZ3VtZW50cykudGhlbihCYil9OmZ1bmN0aW9uKCl7cmV0dXJuIEJiKFphLmFwcGx5KGcsCmFyZ3VtZW50cykpfSk7dmFyIFhhPWthO3UmMjA0OCYmKFhhPXUmMjU2P2Z1bmN0aW9uKCl7cmV0dXJuIGthLmFwcGx5KGcsYXJndW1lbnRzKS50aGVuKENiKX06ZnVuY3Rpb24oKXtyZXR1cm4gQ2Ioa2EuYXBwbHkoZyxhcmd1bWVudHMpKX0pO2liKG0scixmdW5jdGlvbigpe0coKTtSJiZ5LmNhbGxSZWNvcmQucHVzaChyKyIgIit3KGFyZ3VtZW50cykpO3JldHVybiBYYS5hcHBseShnLGFyZ3VtZW50cyl9KX19ZnVuY3Rpb24gaWIobSxyLHUpe3ZhciB4PSJmdW5jdGlvbiI9PT10eXBlb2YgdT9mdW5jdGlvbigpe0coKTtSJiZ5LmNhbGxSZWNvcmQucHVzaChyKyIgIit3KGFyZ3VtZW50cykpO3JldHVybiB1LmFwcGx5KGcsYXJndW1lbnRzKX06dTtudWxsPT09bT95W3JdPXg6InN0cmluZyI9PT10eXBlb2YgbT95W21dW3JdPXg6bVtyXT14fWZ1bmN0aW9uIENiKG0pe2Zvcih2YXIgcj0wO3I8bS5sZW5ndGg7KytyKTA+bVtyXVswXSYmKG1bcl09bnVsbCk7cmV0dXJuIG19ZnVuY3Rpb24gQmIobSl7Zm9yKHZhciByPQowO3I8bS5sZW5ndGg7KytyKTA+bVtyXSYmKG1bcl09bnVsbCk7cmV0dXJuIG19ZnVuY3Rpb24gWShtLHIpe3JldHVybiBmdW5jdGlvbih1KXt1PW5ldyBTKG0sdSk7cih1KX19ZnVuY3Rpb24gUyhtLHIpe3RoaXMuc2NGdW5jdGlvbj1tO3RoaXMuZGF0YT1yfWZ1bmN0aW9uIGFiKG0pe2lmKDAhPT0obS5sZW5ndGgmMSkpdGhyb3cgbmV3IFR5cGVFcnJvcigiYGlkcy5sZW5ndGgnIG11c3QgYmUgZGl2aXNpYmxlIGJ5IHR3by4gKEFuIElkIGlzIGEgcGFpciBvZiBrZXlzLikiKTt9eS5DcmVhdGVJbWFnZUVycm9yPWcuQ3JlYXRlSW1hZ2VFcnJvcjt5LkNyZWF0ZU1lc2hJbnN0YW5jZUVycm9yVHlwZT1nLkNyZWF0ZU1lc2hJbnN0YW5jZUVycm9yVHlwZTt5LkN1dHRpbmdTZWN0aW9uRXJyb3I9Zy5DdXR0aW5nU2VjdGlvbkVycm9yO3kuTWVzaERhdGFHZXREYXRhRXJyb3I9Zy5NZXNoRGF0YUdldERhdGFFcnJvcjt5Lk1lc2hEYXRhUmVwbGFjZUVycm9yPWcuTWVzaERhdGFSZXBsYWNlRXJyb3I7CnkuU2V0TWF0cml4RXJyb3JUeXBlPWcuU2V0TWF0cml4RXJyb3JUeXBlO3kuU2V0VGV4dHVyZUVycm9yVHlwZT1nLlNldFRleHR1cmVFcnJvclR5cGU7dmFyIENhPWYoIiQkZXMiLCJDYW1lcmEiLCJyZXNldCB2aWV3TWF0cml4IHByb2plY3Rpb25NYXRyaXggZnVsbE1hdHJpeCBwcm9qZWN0aW9uIHNldFByb2plY3Rpb24gdXBWZWN0b3Igc2V0VXBWZWN0b3IgcG9zaXRpb24gc2V0UG9zaXRpb24gdGFyZ2V0IHNldFRhcmdldCBuZWFyTGltaXQgc2V0TmVhckxpbWl0IGZpZWxkV2lkdGggZmllbGRIZWlnaHQgc2V0RmllbGQgc2V0RmllbGQgc2V0RmllbGRCeUFuZ2xlcyBzZXRGaWVsZEJ5QW5nbGVzIGRvbGx5IHBhbiByb2xsIHpvb20gb3JiaXQgYXhpc09yYml0IHJlbGF0aXZlT3JiaXQgdW5wcm9qZWN0Ii5zcGxpdCgiICIpKTtTLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNjRnVuY3Rpb24rIjogIit0aGlzLmRhdGF9O3ZhciBaPXt9LCRhPXt9LE5jPQpuZXcgVWludDhBcnJheSgwKSxOYj1uZXcgQ2E7ayhudWxsLCJhZGRDdXR0aW5nU2VjdGlvbiIsMjY0KTtrKG51bGwsImFkZExpZ2h0IiwyNTYpO2sobnVsbCwiYWR2YW5jZVZvbHVtZVNlbGVjdGlvbiIsMjU2KTtrKG51bGwsImF0dGFjaE1vZGVscyIsZnVuY3Rpb24obSxyLHUseCl7Zm9yKHZhciB6PVtdLEw9W10sZmE9MDtmYTxyLmxlbmd0aDsrK2ZhKXt2YXIgWD1yW2ZhXTtpZigyIT09WC5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcigiRXhwZWN0aW5nIFtuYW1lLCBtYXRyaXhdIHBhaXIuIik7dmFyIGNhPVhbMF07aWYoInN0cmluZyIhPT10eXBlb2YgY2EpdGhyb3cgbmV3IFR5cGVFcnJvcigiTmFtZSBpcyBub3QgYSBzdHJpbmcuIik7WD1YWzFdO2lmKFguY29uc3RydWN0b3IhPT1BcnJheSYmWC5jb25zdHJ1Y3RvciE9PUZsb2F0NjRBcnJheSl0aHJvdyBuZXcgVHlwZUVycm9yKCJNYXRyaXggaXMgbm90IGFuIEFycmF5IG9yIEZsb2F0NjRBcnJheS4iKTtpZigxMiE9PVgubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoIkluY2x1c2lvbiBtYXRyaXggbmVlZHMgdG8gaGF2ZSBleGFjdGx5IDEyIGVsZW1lbnRzLiIpOwpjYT11bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoY2EpKTtmb3IodmFyIHphPTA7emE8Y2EubGVuZ3RoOysremEpei5wdXNoKGNhLmNoYXJDb2RlQXQoemEpKTt6LnB1c2goMCk7QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoTCxYKX12YXIgcWE9MCx5YT0wO3FhPWMoeik7aWYoIXFhKXRocm93IGQocWEpLGQoeWEpLEVycm9yKCJJbnRlcm5hbCBsb2dpYyBlcnJvci4iKTt5YT1hKEwpO2lmKCF5YSl0aHJvdyBkKHFhKSxkKHlhKSxFcnJvcigiSW50ZXJuYWwgbG9naWMgZXJyb3IuIik7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKEhhLElhKXtnW3BdLmF0dGFjaE1vZGVscyhxYSx6Lmxlbmd0aCx5YSxMLmxlbmd0aCxtLHUseCxIYSxZKCJhdHRhY2hNb2RlbHMiLElhKSl9KX0pO2sobnVsbCwiYXR0YWNoU2NzTW9kZWxCeUtleSIsZnVuY3Rpb24obSxyLHUseCx6KXt2YXIgTD1bXTtpZihyLmNvbnN0cnVjdG9yIT09QXJyYXkmJnIuY29uc3RydWN0b3IhPT1GbG9hdDY0QXJyYXkpdGhyb3cgbmV3IFR5cGVFcnJvcigiTWF0cml4IGlzIG5vdCBhbiBBcnJheSBvciBGbG9hdDY0QXJyYXkuIik7CmlmKDEyIT09ci5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW5jbHVzaW9uIG1hdHJpeCBuZWVkcyB0byBoYXZlIGV4YWN0bHkgMTIgZWxlbWVudHMuIik7QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoTCxyKTtyPWEoTCk7aWYoIXIpdGhyb3cgZChyKSxFcnJvcigiSW50ZXJuYWwgbG9naWMgZXJyb3IuIik7cmV0dXJuIGcuJCRlcy5hdHRhY2hTY3NNb2RlbEJ5S2V5KHIsTC5sZW5ndGgsbSx1LHgseil9KTtrKG51bGwsImJlZ2luQ29udmV4UG9seWhlZHJvblNlbGVjdGlvbiIsMjY0KTtrKG51bGwsImJlZ2luUmF5RHJpbGxTZWxlY3Rpb24iLDI1Nik7ayhudWxsLCJiZWdpblNjcmVlbkFyZWFTZWxlY3Rpb24iLDI1Nik7ayhudWxsLCJiZWdpblNwaGVyZVNlbGVjdGlvbiIsMjU2KTtrKG51bGwsImNsZWFyTGlnaHRzIik7ayhudWxsLCJjcmVhdGVGbG9vcnBsYW5NZXNoIiwzODgpO2sobnVsbCwiY3V0dGluZ1NlY3Rpb25MaW1pdHMiKTtrKG51bGwsImRlbWFuZE1lc2hJbnN0YW5jZXMiLAoxMzIpO2sobnVsbCwiZGV0YWNoSW5jbHVzaW9ucyIsMjU4KTtrKG51bGwsImRpc2FibGVDYXBwaW5nIik7ayhudWxsLCJkaXNjb25uZWN0TmV0d29yayIsU2EpO2sobnVsbCwiZW5hYmxlQ2FwcGluZyIpO2sobnVsbCwiZW5kQ29tcGFyaXNvbiIpO2sobnVsbCwiZW5kVm9sdW1lU2VsZWN0aW9uIik7ayhudWxsLCJleHBsb2RlIik7ayhudWxsLCJleHBvcnRUb1N2ZyIsMjU2KTtrKG51bGwsImJlZ2luRXhwb3J0VG9TdmciLDI1Nik7ayhudWxsLCJhZHZhbmNlRXhwb3J0VG9TdmciLDI1Nik7ayhudWxsLCJmbHVzaE1ldGFEYXRhQ2FjaGUiLGZ1bmN0aW9uKCl7IiQkc3MiPT09cCYmKCRhPXt9KX0pO2sobnVsbCwiZ2V0QW1iaWVudE9jY2x1c2lvbkVuYWJsZWQiLDI1Nik7ayhudWxsLCJnZXRBbWJpZW50T2NjbHVzaW9uUmFkaXVzIiwyNTYpO2sobnVsbCwiZ2V0QmFja0ZhY2VzVmlzaWJsZSIsMjU2KTtrKG51bGwsImdldEJhY2tncm91bmRHcmFkaWVudCIsMjU2KTtrKG51bGwsImdldENhbWVyYSIsCmZ1bmN0aW9uKCl7cmV0dXJuIiQkc3MiPT09cD9DYS5jbG9uZShOYik6Wi5nZXRDYW1lcmEoKX0pO2sobnVsbCwiZ2V0Q2FtZXJhUHJvbWlzZSIsNzY4KTtrKG51bGwsImdldENhcHBlZEluc3RhbmNlcyIsMjU2KTtrKG51bGwsImdldEN1dHRpbmdTZWN0aW9ucyIsMjU4KTtrKG51bGwsImdldERlZmF1bHREZXB0aFJhbmdlIiwyNTYpO2sobnVsbCwiZ2V0RWxlbWVudENvdW50IiwyNTYpO2sobnVsbCwiZ2V0RXllRG9tZUxpZ2h0aW5nQmx1ckVkZ2VEaXN0YW5jZSIsMjU2KTtrKG51bGwsImdldEV5ZURvbWVMaWdodGluZ0JsdXJJbnRlcnZhbCIsMjU2KTtrKG51bGwsImdldEV5ZURvbWVMaWdodGluZ0JsdXJTYW1wbGVzIiwyNTYpO2sobnVsbCwiZ2V0RXllRG9tZUxpZ2h0aW5nRW5hYmxlZCIsMjU2KTtrKG51bGwsImdldEV5ZURvbWVMaWdodGluZ09wYWNpdHkiLDI1Nik7ayhudWxsLCJnZXRFeWVEb21lTGlnaHRpbmdTaGFkaW5nRWRnZURpc3RhbmNlIiwyNTYpO2sobnVsbCwiZ2V0RmFjZXNWaXNpYmxlIiwKMjU2KTtrKG51bGwsImdldEZhY2VXaW5kaW5nRmxpcHBlZCIsMjU2KTtrKG51bGwsImdldEZyb250RmFjZXNWaXNpYmxlIiwyNTYpO2sobnVsbCwiZ2V0SW50ZXJhY3RpdmVEcmF3TGltaXRJbmNyZWFzZUVuYWJsZWQiLDI1Nik7ayhudWxsLCJnZXRMaWdodEtleXMiLDI1Nik7ayhudWxsLCJnZXRMaWdodCIsMjU2KTtrKG51bGwsImdldExpbmVzVmlzaWJsZSIsMjU2KTtrKG51bGwsImdldExvb3NlQm91bmRpbmciLDI1Nik7ayhudWxsLCJnZXRNZXRhRGF0YSIsb2EpO2sobnVsbCwiZ2V0TWluRnJhbWVSYXRlIiwyNTYpO2sobnVsbCwiZ2V0TmV0d29ya1ZlcnNpb24iKTtrKG51bGwsImdldFBvaW50U2hhcGUiLDI1Nik7ayhudWxsLCJnZXRQb2ludFNpemUiLDI1Nik7ayhudWxsLCJnZXRQb2ludFNpemVVbml0IiwyNTYpO2sobnVsbCwiZ2V0UG9pbnRzVmlzaWJsZSIsMjU2KTtrKG51bGwsImdldFN0YXRpc3RpY3MiLDI1Nik7ayhudWxsLCJnZXRTdHJlYW1lZEJvdW5kaW5nIiwyNTYpOwprKG51bGwsImdldFN0cmVhbVZlcnNpb24iKTtrKG51bGwsImdldFRyaWFuZ2xlQ291bnQiLDI1Nik7ayhudWxsLCJtYXJrQWxsTWVzaEluc3RhbmNlc0ludGVyZXN0aW5nIik7ayhudWxsLCJtYXJrQ2FtZXJhQXNFbXB0eSIpO2sobnVsbCwibWVzaEluc3RhbmNlS2V5SW5mbyIsMjU3KTtrKG51bGwsIm1ldGFEYXRhS2V5SW5mbyIsMjU3KTtrKG51bGwsIm1vZGVsS2V5c0Zyb21JbmNsdXNpb25LZXlzIiwyNTgpO2sobnVsbCwib25SZXNpemUiLGZ1bmN0aW9uKCl7dmFyIG09eS5hbGxvd0hpZ2hEcGk/d2luZG93LmRldmljZVBpeGVsUmF0aW98fDE6MSxyPXkuY29udGFpbmVyLHU9ci5jbGllbnRXaWR0aCx4PXIuY2xpZW50SGVpZ2h0O3I9dSptO20qPXg7aWYoIiQkc3MiPT09cClGLkxrKHIsbSx1LHgpO2Vsc2V7dmFyIHo9Zy4kJGVzLm1heEZyYW1lQnVmZmVyU2l6ZSgpO2lmKDA+PXopcj11LG09eDtlbHNle2lmKHI+enx8bT56KXI9dSxtPXg7aWYocj56fHxtPnopcj5tPyhtPW0vcioKeixyPXopOihyPXIvbSp6LG09eil9fWcuJCRjcy5zZXRTY3JlZW5EaW1lbnNpb25zKHIsbSx1LHgpOyIkJGNzIj09PXAmJih1PWcuY2FudmFzLHUud2lkdGg9cix1LmhlaWdodD1tLHkucXVldWVSZWRyYXcoKSl9KTtrKG51bGwsInBhdXNlQ2FwcGluZyIpO2sobnVsbCwicHJpbWFyeU1vZGVsS2V5IiwyNTYpO2sobnVsbCwicXVldWVSZWRyYXciKTtrKG51bGwsInJlZ2lzdGVyQmltSW5zdGFuY2VzIiw0KTtrKG51bGwsInJlbW92ZUFsbEN1dHRpbmdTZWN0aW9ucyIpO2sobnVsbCwicmVtb3ZlQ3V0dGluZ1NlY3Rpb25zIiwyNTgpO2sobnVsbCwicmVtb3ZlTGlnaHQiKTtrKG51bGwsInJlcGxhY2VDdXR0aW5nU2VjdGlvbiIsMjY0KTtrKG51bGwsInJlcXVlc3RHcm91cHMiLDI2MCk7ayhudWxsLCJyZXF1ZXN0SW1hZ2VzIiwyNjApO2sobnVsbCwicmVxdWVzdE1lc2hJbnN0YW5jZXMiLDI2MCk7ayhudWxsLCJyZXF1ZXN0TWVzaEluc3RhbmNlc0J5R3JvdXAiLDI2MCk7ayhudWxsLCJyZXNldEV4cGxvZGUiKTsKayhudWxsLCJyZXNldFRvRW1wdHkiLGZ1bmN0aW9uKG0scil7dmFyIHU9YihyKTtpZighdSl0aHJvdyBuZXcgVHlwZUVycm9yKCJgbWVzaEtleXMnIGlzIG5vdCBhbiBBcnJheSBvciBVaW50MzJBcnJheSIpO3JldHVybiBaLnJlc2V0VG9FbXB0eShtLHUsci5sZW5ndGgpfSk7ayhudWxsLCJyZXN1bWVDYXBwaW5nIik7ayhudWxsLCJyZXN1bWVEcmF3aW5nIik7ayhudWxsLCJzY3JlZW5TZWxlY3RCeVJheSIsMjU2KTtrKG51bGwsInNlcnZlclNpZGVSZW5kZXJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIiQkc3MiPT09cH0pO2sobnVsbCwic2V0QW1iaWVudExpZ2h0Q29sb3IiKTtrKG51bGwsInNldEFtYmllbnRPY2NsdXNpb25CaWFzIik7ayhudWxsLCJzZXRBbWJpZW50T2NjbHVzaW9uQmx1ckludGVydmFsIik7ayhudWxsLCJzZXRBbWJpZW50T2NjbHVzaW9uQmx1clNhbXBsZXMiKTtrKG51bGwsInNldEFtYmllbnRPY2NsdXNpb25Db250cmFzdCIpO2sobnVsbCwic2V0QW1iaWVudE9jY2x1c2lvbkVkZ2VEaXN0YW5jZSIpOwprKG51bGwsInNldEFtYmllbnRPY2NsdXNpb25FbmFibGVkIik7ayhudWxsLCJzZXRBbWJpZW50T2NjbHVzaW9uSW50ZW5zaXR5Iik7ayhudWxsLCJzZXRBbWJpZW50T2NjbHVzaW9uTm9pc2VTaXplIik7ayhudWxsLCJzZXRBbWJpZW50T2NjbHVzaW9uT3BhY2l0eSIpO2sobnVsbCwic2V0QW1iaWVudE9jY2x1c2lvblJhZGl1cyIpO2sobnVsbCwic2V0QW1iaWVudE9jY2x1c2lvblNhbXBsZXMiKTtrKG51bGwsInNldEFudGlBbGlhc2luZ01vZGUiKTtrKG51bGwsInNldEJhY2tGYWNlc1Zpc2libGUiKTtrKG51bGwsInNldEJhY2tncm91bmRDb2xvciIpO2sobnVsbCwic2V0QmFja2dyb3VuZEdyYWRpZW50Iik7ayhudWxsLCJzZXRCbG9vbUJsdXJJbnRlcnZhbCIpO2sobnVsbCwic2V0Qmxvb21CbHVyU2FtcGxlcyIpO2sobnVsbCwic2V0Qmxvb21FbmFibGVkIik7ayhudWxsLCJzZXRCbG9vbUludGVuc2l0eSIpO2sobnVsbCwic2V0Qmxvb21JbnRlbnNpdHlTY2FsZSIpO2sobnVsbCwKInNldEJsb29tTGF5ZXJDb3VudCIpO2sobnVsbCwic2V0Qmxvb21UaHJlc2hvbGQiKTtrKG51bGwsInNldEJsb29tVGhyZXNob2xkUmFtcFdpZHRoIik7ayhudWxsLCJzZXRCb3VuZGluZ1ByZXZpZXdVbmRlcmRyYXdDb2xvciIpO2sobnVsbCwic2V0Qm91bmRpbmdQcmV2aWV3VGVzdGVkQ29sb3IiKTtrKG51bGwsInNldEJvdW5kaW5nUHJldmlld0VqZWN0ZWRDb2xvciIpO2sobnVsbCwic2V0Qm91bmRpbmdQcmV2aWV3Q29sb3IiKTtrKG51bGwsInNldEJvdW5kaW5nUHJldmlld1VuZGVyZHJhdyIsMTYpO2sobnVsbCwic2V0Qm91bmRpbmdQcmV2aWV3VGVzdGVkIiwxNik7ayhudWxsLCJzZXRCb3VuZGluZ1ByZXZpZXdFamVjdGVkIiwxNik7ayhudWxsLCJzZXRCb3VuZGluZ0RlYnVnTGV2ZWwiKTtrKG51bGwsInNldENhbWVyYSIsZnVuY3Rpb24obSl7Q2EuYXNzaWduKE5iLG0pO1ouc2V0Q2FtZXJhKG0pfSk7ayhudWxsLCJzZXRDYXBwaW5nSWRsZUhvb2tFbmFibGVkIiwyNTYpO2sobnVsbCwKInNldENsdW1waW5nRW5hYmxlZCIpO2sobnVsbCwic2V0Q29tcGFyaXNvbkNvbG9ycyIpO2sobnVsbCwic2V0Q3VycmVudFZpZXciKTtrKG51bGwsInNldERlZmF1bHREZXB0aFJhbmdlIik7ayhudWxsLCJzZXREZWZhdWx0R2xvc3MiKTtrKG51bGwsInNldERlZmF1bHRNaXJyb3IiKTtrKG51bGwsInNldERlZmF1bHRTcGVjdWxhck1peCIpO2sobnVsbCwic2V0RGVmYXVsdFNwaGVyZU1hcCIpO2sobnVsbCwic2V0RGlzcGxheUluY29tcGxldGVGcmFtZXMiKTtrKG51bGwsInNldERyYXdJZGxlRGVsYXkiKTtrKG51bGwsInNldERyYXdNb2RlIik7ayhudWxsLCJzZXREcmF3U3RyYXRlZ3kiKTtrKG51bGwsInNldEV5ZURvbWVMaWdodGluZ0JsdXJFZGdlRGlzdGFuY2UiKTtrKG51bGwsInNldEV5ZURvbWVMaWdodGluZ0JsdXJJbnRlcnZhbCIpO2sobnVsbCwic2V0RXllRG9tZUxpZ2h0aW5nQmx1clNhbXBsZXMiKTtrKG51bGwsInNldEV5ZURvbWVMaWdodGluZ0VuYWJsZWQiKTtrKG51bGwsCiJzZXRFeWVEb21lTGlnaHRpbmdPcGFjaXR5Iik7ayhudWxsLCJzZXRFeWVEb21lTGlnaHRpbmdTaGFkaW5nRWRnZURpc3RhbmNlIik7ayhudWxsLCJzZXRGYWNlc1Zpc2libGUiKTtrKG51bGwsInNldEZhY2VXaW5kaW5nRmxpcHBlZCIpO2sobnVsbCwic2V0Rml4ZWREcmF3TGltaXQiKTtrKG51bGwsInNldEZyb250RmFjZXNWaXNpYmxlIik7ayhudWxsLCJzZXRHb29jaEJhc2VDb2xvclByb21pbmVuY2UiKTtrKG51bGwsInNldEdvb2NoQmx1ZSIpO2sobnVsbCwic2V0R29vY2hMdW1pbmFuY2VTaGlmdFN0cmVuZ3RoIik7ayhudWxsLCJzZXRHb29jaFllbGxvdyIpO2sobnVsbCwic2V0R3JvdW5kUGxhbmUiKTtrKG51bGwsInNldEdyb3VuZFBsYW5lV2l0aFBvc2l0aW9uIik7ayhudWxsLCJzZXRIYXJkRWRnZUNvbG9yIik7ayhudWxsLCJzZXRIYXJkRWRnZU9wYWNpdHkiKTtrKG51bGwsInNldEhhcmRFZGdlc0VuYWJsZWQiKTtrKG51bGwsInNldEhhcmRFZGdlVGhyZXNob2xkIik7ayhudWxsLAoic2V0SGFyZEVkZ2VUaHJlc2hvbGRSYW1wV2lkdGgiKTtrKG51bGwsInNldEhpZGRlbkxpbmVIaWRkZW5MaW5lQ29sb3IiKTtrKG51bGwsInNldEhpZGRlbkxpbmVIaWdobGlnaHRlZEVsZW1lbnRGaWxsQ29sb3IiKTtrKG51bGwsInNldEhpZGRlbkxpbmVIaWdobGlnaHRlZEVsZW1lbnRPdXRsaW5lQ29sb3IiKTtrKG51bGwsInNldEhpZGRlbkxpbmVIaWdobGlnaHRlZEluc3RhbmNlRmlsbENvbG9yIik7ayhudWxsLCJzZXRIaWRkZW5MaW5lSGlnaGxpZ2h0ZWRJbnN0YW5jZU91dGxpbmVDb2xvciIpO2sobnVsbCwic2V0SGlkZGVuTGluZVZpc2libGVMaW5lQ29sb3IiKTtrKG51bGwsInNldEhpZ2hsaWdodENvbG9yaXplQ29tcHJlc3Npb24iKTtrKG51bGwsInNldEhpZ2hsaWdodGVkRWxlbWVudENvbG9yIik7ayhudWxsLCJzZXRIaWdobGlnaHRlZEVsZW1lbnRGaWx0ZXIiKTtrKG51bGwsInNldEhpZ2hsaWdodGVkRWxlbWVudE91dGxpbmVDb2xvciIpO2sobnVsbCwic2V0SGlnaGxpZ2h0ZWRJbnN0YW5jZUNvbG9yIik7CmsobnVsbCwic2V0SGlnaGxpZ2h0ZWRJbnN0YW5jZUZpbHRlciIpO2sobnVsbCwic2V0SGlnaGxpZ2h0ZWRJbnN0YW5jZU91dGxpbmVDb2xvciIpO2sobnVsbCwic2V0SGlnaGxpZ2h0TW9kZSIpO2sobnVsbCwic2V0SW1hZ2VCYXNlZExpZ2h0aW5nRW5hYmxlZCIpO2sobnVsbCwic2V0SW1hZ2VCYXNlZExpZ2h0aW5nRW52aXJvbm1lbnQiLGZ1bmN0aW9uKG0pe3ZhciByPWMobSk7aWYoIXIpdGhyb3cgbmV3IFR5cGVFcnJvcigiYGRhdGEnIGlzIG5vdCBhbiBBcnJheSBvciBVaW50OEFycmF5Iik7cmV0dXJuIGdbcF0uc2V0SW1hZ2VCYXNlZExpZ2h0aW5nRW52aXJvbm1lbnQocixtLmxlbmd0aCl9KTtrKG51bGwsInNldEltYWdlQmFzZWRMaWdodGluZ0Vudmlyb25tZW50VG9EZWZhdWx0Iik7ayhudWxsLCJzZXRJbWFnZUJhc2VkTGlnaHRpbmdJbnRlbnNpdHkiKTtrKG51bGwsInNldEltYWdlQmFzZWRMaWdodGluZ01hdHJpeCIpO2sobnVsbCwic2V0SW5zdGFuY2luZ0VuYWJsZWQiKTsKayhudWxsLCJzZXRJbnRlcmFjdGl2ZURyYXdMaW1pdEluY3JlYXNlRW5hYmxlZCIpO2sobnVsbCwic2V0SW50ZXJhY3RpdmVEcmF3TGltaXRJbmNyZWFzZUludGVydmFsIik7ayhudWxsLCJzZXRMaWdodGluZ0VuYWJsZWQiKTtrKG51bGwsInNldExpbmVKaXR0ZXJFbmFibGVkIik7ayhudWxsLCJzZXRMaW5lSml0dGVyRnJlcXVlbmN5Iik7ayhudWxsLCJzZXRMaW5lSml0dGVySW5zdGFuY2VDb3VudCIpO2sobnVsbCwic2V0TGluZUppdHRlclJhZGl1cyIpO2sobnVsbCwic2V0TGluZXNWaXNpYmxlIik7ayhudWxsLCJzZXRNZXNoTGV2ZWwiKTtrKG51bGwsInNldE1ldGFsbGljUm91Z2huZXNzTWF0ZXJpYWxPdmVycmlkZSIpO2sobnVsbCwic2V0TWluRHJhd0xpbWl0Iik7ayhudWxsLCJzZXRNaW5GcmFtZVJhdGUiKTtrKG51bGwsInNldE1pbkluY3JlbWVudGFsRnJhbWVSYXRlIik7ayhudWxsLCJzZXRNaW5JbnRlcmFjdGl2ZUZyYW1lUmF0ZSIpO2sobnVsbCwic2V0UG9pbnRTaGFwZSIpOwprKG51bGwsInNldFBvaW50U2l6ZSIpO2sobnVsbCwic2V0UG9pbnRzVmlzaWJsZSIpO2sobnVsbCwic2V0UG9pbnRWaXNpYmlsaXR5VGVzdCIsMTYpO2sobnVsbCwic2V0UG9zdElucHV0RGVsYXkiKTtrKG51bGwsInNldFNpbGhvdWV0dGVDb2xvciIpO2sobnVsbCwic2V0U2lsaG91ZXR0ZUVuYWJsZWQiKTtrKG51bGwsInNldFNpbGhvdWV0dGVPcGFjaXR5Iik7ayhudWxsLCJzZXRTaWxob3VldHRlVGhyZXNob2xkIik7ayhudWxsLCJzZXRTaWxob3VldHRlVGhyZXNob2xkUmFtcFdpZHRoIik7ayhudWxsLCJzZXRTaW1wbGVSZWZsZWN0aW9uQXR0ZW51YXRpb24iKTtrKG51bGwsInNldFNpbXBsZVJlZmxlY3Rpb25CbHVySW50ZXJ2YWwiKTtrKG51bGwsInNldFNpbXBsZVJlZmxlY3Rpb25CbHVyU2FtcGxlcyIpO2sobnVsbCwic2V0U2ltcGxlUmVmbGVjdGlvbkVuYWJsZWQiKTtrKG51bGwsInNldFNpbXBsZVJlZmxlY3Rpb25GYWRlQW5nbGUiKTtrKG51bGwsInNldFNpbXBsZVJlZmxlY3Rpb25PcGFjaXR5Iik7CmsobnVsbCwic2V0U2ltcGxlU2hhZG93Qmx1ckludGVydmFsIik7ayhudWxsLCJzZXRTaW1wbGVTaGFkb3dCbHVyU2FtcGxlcyIpO2sobnVsbCwic2V0U2ltcGxlU2hhZG93Q29sb3IiKTtrKG51bGwsInNldFNpbXBsZVNoYWRvd0VuYWJsZWQiKTtrKG51bGwsInNldFNpbXBsZVNoYWRvd0ludGVyYWN0aXZlVXBkYXRlRW5hYmxlZCIpO2sobnVsbCwic2V0U2ltcGxlU2hhZG93T3BhY2l0eSIpO2sobnVsbCwic2V0U2ltcGxlU2hhZG93UmVzb2x1dGlvbiIpO2sobnVsbCwic2V0U21hYVF1YWxpdHkiKTtrKG51bGwsInNldFNzclF1YWxpdHkiLGZ1bmN0aW9uKG0pe0YuUmsobSl9KTtrKG51bGwsInNldFN0cmVhbUN1dG9mZlNjYWxlIik7ayhudWxsLCJzZXRTdHJlYW1JZGxlTWFya2VyIiwyNTYpO2sobnVsbCwic2V0VG9vbkJhbmRDb3VudCIpO2sobnVsbCwic2V0VG9vblNwZWN1bGFyRmFjdG9yIik7ayhudWxsLCJzZXRUcmFuc3BhcmVuY3lNb2RlIik7ayhudWxsLCJzZXRVbmhpZ2hsaWdodGVkQ29sb3IiKTsKayhudWxsLCJzZXRVbmhpZ2hsaWdodGVkRmlsdGVyIik7ayhudWxsLCJzZXRWaXNpYmlsaXR5QnlBdHRhY2htZW50Iik7ayhudWxsLCJzZXRYUmF5TWF0ZXJpYWwiKTtrKG51bGwsInNldFhSYXlPcGFjaXR5Iik7ayhudWxsLCJzZXRYUmF5VHJhbnNwYXJlbmN5TW9kZSIpO2sobnVsbCwic3RhcnRDb21wYXJpc29uIixmdW5jdGlvbihtLHIpe2FiKG0pO2FiKHIpO3ZhciB1PWIobSk7aWYoIXUpdGhyb3cgbmV3IFR5cGVFcnJvcigiYGluc3RhbmNlU2V0MScgaXMgbm90IGFuIEFycmF5IG9yIFVpbnQzMkFycmF5LiIpO3ZhciB4PWIocik7aWYoIXgpdGhyb3cgbmV3IFR5cGVFcnJvcigiYGluc3RhbmNlU2V0MicgaXMgbm90IGFuIEFycmF5IG9yIFVpbnQzMkFycmF5LiIpO3JldHVybiBnW3BdLnN0YXJ0Q29tcGFyaXNvbih1LG0ubGVuZ3RoPj4xLHgsci5sZW5ndGg+PjEpfSk7ayhudWxsLCJzdGFydEV4cGxvZGUiLDQpO2sobnVsbCwic3VzcGVuZERyYXdpbmciKTtrKG51bGwsInRlc3RQb2ludFZpc2liaWxpdHkiLAoyNzIpO2sobnVsbCwidGhyb3R0bGVMb2FkIik7ayhudWxsLCJ0cmlhbmd1bGF0ZVBvbHlnb24iLGZ1bmN0aW9uKG0scil7aWYoMz5tLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKCIncG9seWdvblBvaW50cycgZG9lcyBub3QgZGVzY3JpYmUgYSBwb2x5Z29uLiIpO3ZhciB1O2lmKG0paWYodT1nLiQkZXMuYWxsb2NhdGVVaW50OEJ1ZmZlcig0Km0ubGVuZ3RoKSlCLnNldChtLHU+PjIpO2Vsc2UgdGhyb3cgRXJyb3IoIk91dCBvZiBtZW1vcnkuIik7ZWxzZSB1PTA7aWYoIXUpdGhyb3cgRXJyb3IoIkludGVybmFsIGxvZ2ljIGVycm9yLiIpO3JldHVybiBnLiQkZXMudHJpYW5ndWxhdGVQb2x5Z29uKHUsbS5sZW5ndGgscil9KTtrKG51bGwsInRydW5jYXRlTWV0YURhdGEiLGZ1bmN0aW9uKG0pe2lmKCIkJGNzIj09PXApcmV0dXJuIFoudHJ1bmNhdGVNZXRhRGF0YShtKTtmb3IodmFyIHI9MDtyPG0ubGVuZ3RoO3IrPTIpe3ZhciB1PW1bcisxXSx4PSRhW21bcl1dO3gmJih4W3VdPU5jKX19KTsKayhudWxsLCJ1bnNldEFsbENvbG9ycyIpO2sobnVsbCwidW5zZXRBbGxIaWdobGlnaHRlZCIpO2sobnVsbCwidW5zZXRBbGxPcGFjaXR5Iik7ayhudWxsLCJ1bnNldEFsbFhSYXkiKTtrKG51bGwsInVuc2V0Q3VycmVudFZpZXciKTtrKG51bGwsInVuc2V0WFJheU1hdGVyaWFsIik7ayhudWxsLCJ1cGRhdGVMaWdodCIpO2sobnVsbCwid2FpdEZvckltYWdlRGVjb2RpbmciLDI1Nik7ayhudWxsLCJ3b3JsZFNlbGVjdEJ5UmF5IiwyNTYpO2sobnVsbCwiX2xvc2VXZWJHbENvbnRleHQiLGZ1bmN0aW9uKCl7dmFyIG09Zy5SaS5nZXRFeHRlbnNpb24oIldFQkdMX2xvc2VfY29udGV4dCIpO3JldHVybiBudWxsIT09bT8obS5sb3NlQ29udGV4dCgpLCEwKTohMX0pO2soWiwiZ2V0Q2FtZXJhIiw1MTIpO2soWiwiZ2V0TWV0YURhdGEiLDI2MCk7ayhaLCJNZXNoRGF0YV9nZXREYXRhIiwyNTYpO2soWiwiTWVzaEluc3RhbmNlX3NldExpbmVQYXR0ZXJuIiwxMzIpO2soWiwicmVxdWVzdE1ldGFEYXRhIiwKMjYwKTtrKFosInJlc2V0VG9FbXB0eSIsMjU4KTtrKFosInNldENhbWVyYSIsMzIpO2soWiwidHJ1bmNhdGVNZXRhRGF0YSIsMjYwKTtrKG51bGwsIkRlYnVnX2xvZyIsZnVuY3Rpb24obSl7bT11bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQobSkpO2Zvcih2YXIgcj1bXSx1PTA7dTxtLmxlbmd0aDsrK3Upci5wdXNoKG0uY2hhckNvZGVBdCh1KSk7ci5wdXNoKDApO3ZhciB4PWMocik7aWYoIXgpdGhyb3cgRXJyb3IoIkludGVybmFsIGxvZ2ljIGVycm9yLiIpO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbih6LEwpe2dbcF0uZGVidWdfbG9nKHgsci5sZW5ndGgseixMKX0pfSk7ayhudWxsLCJEZWJ1Z19zdGF0ZUZhaWx1cmUiLDI1Nik7ayhudWxsLCJEZWJ1Z19zeW5jIiwyNTYpO3kuSW1hZ2U9e307aygiSW1hZ2UiLCJjcmVhdGUiLGZ1bmN0aW9uKG0scix1LHgseixMLGZhLFgsY2EsemEpe3ZhciBxYT1jKHIpO2lmKCFxYSl0aHJvdyBFcnJvcigiSW50ZXJuYWwgbG9naWMgZXJyb3IuIik7CnZhciB5YT1jKGZhKTtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oSGEsSWEpe2dbcF0uSW1hZ2VfY3JlYXRlKHFhLHIubGVuZ3RoLHlhLGZhP2ZhLmxlbmd0aDowLG0sdSx4P3g6MCx6P3o6MCxMP0w6MCxYfHwhMSxjYT9jYTowLHphP3phOjAsSGEsWSgiSW1hZ2VfY3JlYXRlIixJYSkpfSl9KTtrKCJJbWFnZSIsImRlc3Ryb3kiLDI2MCk7eS5NYXRyaXg9e307aygiTWF0cml4IiwiY3JlYXRlIiwyNTYpO2soIk1hdHJpeCIsImRlc3Ryb3kiLDI2MCk7aygiTWF0cml4IiwiZ2V0RWxlbWVudHMiLDI2MCk7aygiTWF0cml4Iiwic2V0RWxlbWVudHMiLDI2MCk7eS5NZXNoRGF0YT17fTtrKCJNZXNoRGF0YSIsImNyZWF0ZSIsZnVuY3Rpb24obSl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHIsdSl7dmFyIHg9bS5fbWFyc2hhbCgpO2dbcF0uTWVzaERhdGFfY3JlYXRlKHguYml0cyx4LnRvdGFsRmFjZVZlcnRpY2VzLHgudG90YWxMaW5lVmVydGljZXMseC50b3RhbFBvaW50VmVydGljZXMsCnguZmxvYXREYXRhUHRyLHguZmxvYXREYXRhUHRyTGVuLHguZmFjZUVsZW1lbnRJbmZvc1B0cixiYSptLl9mYWNlRWxlbWVudHMubGVuZ3RoLHgubGluZUVsZW1lbnRJbmZvc1B0cixiYSptLl9saW5lRWxlbWVudHMubGVuZ3RoLHgucG9pbnRFbGVtZW50SW5mb3NQdHIsYmEqbS5fcG9pbnRFbGVtZW50cy5sZW5ndGgscixZKCJNZXNoRGF0YV9jcmVhdGUiLHUpKX0pfSk7aygiTWVzaERhdGEiLCJkZXN0cm95IiwyNjApO2soIk1lc2hEYXRhIiwiZ2V0RGF0YSIsZnVuY3Rpb24obSl7cmV0dXJuIFouTWVzaERhdGFfZ2V0RGF0YShtKS50aGVuKFBiKX0pO2soIk1lc2hEYXRhIiwibGluZUVsZW1lbnRTZWdtZW50cyIsMjU2KTtrKCJNZXNoRGF0YSIsImxpbmVzVG9JbmNpZGVudEZhY2VzIiwyNTgpO2soIk1lc2hEYXRhIiwicmVwbGFjZSIsZnVuY3Rpb24obSxyKXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24odSx4KXt2YXIgej1yLl9tYXJzaGFsKCk7Z1twXS5NZXNoRGF0YV9yZXBsYWNlKG1bMF0sCm1bMV0sei5iaXRzLHoudG90YWxGYWNlVmVydGljZXMsei50b3RhbExpbmVWZXJ0aWNlcyx6LnRvdGFsUG9pbnRWZXJ0aWNlcyx6LmZsb2F0RGF0YVB0cix6LmZsb2F0RGF0YVB0ckxlbix6LmZhY2VFbGVtZW50SW5mb3NQdHIsYmEqci5fZmFjZUVsZW1lbnRzLmxlbmd0aCx6LmxpbmVFbGVtZW50SW5mb3NQdHIsYmEqci5fbGluZUVsZW1lbnRzLmxlbmd0aCx6LnBvaW50RWxlbWVudEluZm9zUHRyLGJhKnIuX3BvaW50RWxlbWVudHMubGVuZ3RoLHUsWSgiTWVzaERhdGFfcmVwbGFjZSIseCkpfSl9KTt5Lk1lc2hJbnN0YW5jZT17fTtrKCJNZXNoSW5zdGFuY2UiLCJjbGVhckFsbEVsZW1lbnRIaWdobGlnaHQiLDEzMik7aygiTWVzaEluc3RhbmNlIiwiY2xlYXJBbGxFbGVtZW50VmlzaWJsZSIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJjbGVhckFsbEVsZW1lbnRYUmF5IiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsImNsZWFyRWxlbWVudENvbG9ycyIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLAoiY2xlYXJFbGVtZW50SGlnaGxpZ2h0IiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsImNsZWFyRWxlbWVudFZpc2libGUiLDEzMik7aygiTWVzaEluc3RhbmNlIiwiY2xlYXJFbGVtZW50WFJheSIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJjb21wdXRlTWluaW1hbEJvZHlCb2R5RGlzdGFuY2UiLDI1Nik7aygiTWVzaEluc3RhbmNlIiwiY29tcHV0ZU1pbmltYWxGYWNlRmFjZURpc3RhbmNlIiwyNTYpO2soIk1lc2hJbnN0YW5jZSIsImNvbXB1dGVNaW5pbWFsRmFjZUxpbmVEaXN0YW5jZSIsMjU2KTtrKCJNZXNoSW5zdGFuY2UiLCJjb21wdXRlTWluaW1hbEZhY2VSYXlEaXN0YW5jZSIsMjU2KTtrKCJNZXNoSW5zdGFuY2UiLCJjcmVhdGUiLDI1Nik7aygiTWVzaEluc3RhbmNlIiwiZGVzdHJveSIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJkaXNjYXJkQW5vbnltb3VzTWF0cml4IiwzODgpO2soIk1lc2hJbnN0YW5jZSIsImdldEFsd2F5c0RyYXciLDM4OCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0Q2FwcGluZ01lc2hEYXRhIiwKMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXRDb2xvciIsMjQzNik7aygiTWVzaEluc3RhbmNlIiwiZ2V0Q3VsbGluZ1ZlY3RvciIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXREb05vdEN1dCIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXREb05vdEV4cGxvZGUiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0RG9Ob3RMaWdodCIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXREb05vdE91dGxpbmVIaWdobGlnaHQiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0RG9Ob3RTZWxlY3QiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0RG9Ob3RVc2VWZXJ0ZXhDb2xvcnMiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0RHJhd25Xb3JsZFNwYWNlQm91bmRpbmciLDI2MCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0RWZmZWN0aXZlQ29sb3IiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0RWZmZWN0aXZlRWxlbWVudENvbG9yIiwzODgpO2soIk1lc2hJbnN0YW5jZSIsImdldEVmZmVjdGl2ZU9wYWNpdHkiLAozODgpO2soIk1lc2hJbnN0YW5jZSIsImdldEVsZW1lbnRDb2xvciIsMjQzNik7aygiTWVzaEluc3RhbmNlIiwiZ2V0RWxlbWVudEhpZ2hsaWdodGVkIiwzODgpO2soIk1lc2hJbnN0YW5jZSIsImdldEVsZW1lbnRWaXNpYmxlIiwzODgpO2soIk1lc2hJbnN0YW5jZSIsImdldEVsZW1lbnRYUmF5IiwzODgpO2soIk1lc2hJbnN0YW5jZSIsImdldEV4Y2x1ZGVCb3VuZGluZyIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXRGYWNlRWxlbWVudEJvdW5kaW5nIiwyNTgpO2soIk1lc2hJbnN0YW5jZSIsImdldEZhY2VzVmlzaWJsZSIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXRIaWdobGlnaHRlZCIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXRMYXllckNvdW50Iik7aygiTWVzaEluc3RhbmNlIiwiZ2V0TGluZUVsZW1lbnRCb3VuZGluZyIsMjU4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXRMaW5lc1Zpc2libGUiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0TWF0cml4IiwzODgpO2soIk1lc2hJbnN0YW5jZSIsCiJnZXRNZXNoRGF0YSIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXRNZXRhbGxpY1JvdWdobmVzcyIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXRPYmplY3RTcGFjZUJvdW5kaW5nIiwzODgpO2soIk1lc2hJbnN0YW5jZSIsImdldE9wYWNpdHkiLDE0MTIpO2soIk1lc2hJbnN0YW5jZSIsImdldE92ZXJyaWRlU2NlbmVWaXNpYmlsaXR5IiwzODgpO2soIk1lc2hJbnN0YW5jZSIsImdldFBvaW50RWxlbWVudEJvdW5kaW5nIiwyNTgpO2soIk1lc2hJbnN0YW5jZSIsImdldFBvaW50c1Zpc2libGUiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0U2NyZWVuT3JpZW50ZWQiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0U3VwcHJlc3NDYW1lcmFTY2FsZSIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXRXb3JsZFNwYWNlQm91bmRpbmciLDI2MCk7aygiTWVzaEluc3RhbmNlIiwiaGFzRGVwdGhSYW5nZSIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJoYXNUcmFuc3BhcmVuY3kiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwKImxpbmVzVG9JbmNpZGVudEZhY2VzIiwyNTgpO2soIk1lc2hJbnN0YW5jZSIsIm1hdHJpeFByZU11bHRpcGx5IiwzODgpO2soIk1lc2hJbnN0YW5jZSIsInJlaWZ5QW5vbnltb3VzTWF0cml4IiwzODgpO2soIk1lc2hJbnN0YW5jZSIsInNldEFsd2F5c0RyYXciLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0QW1iaWVudENvbG9yIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldEFtYmllbnRNaXgiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0QW5vbnltb3VzTWF0cml4IiwzODgpO2soIk1lc2hJbnN0YW5jZSIsInNldEFub255bW91c01hdHJpY2VzIixmdW5jdGlvbihtLHIpe3ZhciB1PTAseD0wO2lmKG0uY29uc3RydWN0b3IhPT1BcnJheSYmbS5jb25zdHJ1Y3RvciE9PVVpbnQzMkFycmF5KXRocm93IG5ldyBUeXBlRXJyb3IoIkluY3MgQnVmZmVyIGlzIG5vdCBhbiBBcnJheSBvciBVaW50MzJBcnJheS4iKTtpZihyLmNvbnN0cnVjdG9yIT09QXJyYXkmJnIuY29uc3RydWN0b3IhPT0KRmxvYXQ2NEFycmF5KXRocm93IG5ldyBUeXBlRXJyb3IoIk1hdHJpY2VzIEJ1ZmZlciBpcyBub3QgYW4gQXJyYXkgb3IgRmxvYXQ2NEFycmF5LiIpO3U9YihtKTtpZighdSl0aHJvdyBkKHUpLGQoeCksRXJyb3IoIkludGVybmFsIGxvZ2ljIGVycm9yLiIpO3g9YShyKTtpZigheCl0aHJvdyBkKHUpLGQoeCksRXJyb3IoIkludGVybmFsIGxvZ2ljIGVycm9yLiIpO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbih6LEwpe2dbcF0uTWVzaEluc3RhbmNlX3NldEFub255bW91c01hdHJpY2VzKHUsbS5sZW5ndGg+PjEseCxyLmxlbmd0aCx6LFkoIk1lc2hJbnN0YW5jZV9zZXRBbm9ueW1vdXNNYXRyaWNlcyIsTCksMCl9KX0pO2soIk1lc2hJbnN0YW5jZSIsInNldENvbG9yIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldEN1bGxpbmdWZWN0b3IiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0RGVwdGhSYW5nZSIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXREb05vdEN1dCIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLAoic2V0RG9Ob3RFeHBsb2RlIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldERvTm90TGlnaHQiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0RG9Ob3RPdXRsaW5lSGlnaGxpZ2h0IiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldERvTm90U2VsZWN0IiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldERvTm90UmVzZXQiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0RG9Ob3RVc2VWZXJ0ZXhDb2xvcnMiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0RG9Ob3RYUmF5IiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldEVsZW1lbnRDb2xvciIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRFbGVtZW50SGlnaGxpZ2h0ZWQiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0RWxlbWVudFZpc2libGUiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0RWxlbWVudFhSYXkiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0RXhjbHVkZUJvdW5kaW5nIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldEZhY2VzVmlzaWJsZSIsCjEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0SGlnaGxpZ2h0ZWQiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0TGluZVBhdHRlcm4iLGZ1bmN0aW9uKG0scix1LHgpe3ZhciB6PWMocik7aWYoIXopdGhyb3cgbmV3IFR5cGVFcnJvcigiYHBhdHRlcm4nIGlzIG5vdCBhbiBBcnJheSBvciBVaW50OEFycmF5Iik7cmV0dXJuIFouTWVzaEluc3RhbmNlX3NldExpbmVQYXR0ZXJuKG0seixyLmxlbmd0aCx1LHgpfSk7aygiTWVzaEluc3RhbmNlIiwic2V0TGluZXNWaXNpYmxlIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldE1hdHJpeCIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRNZXNoTGV2ZWwiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0TWV0YWxsaWNSb3VnaG5lc3MiLDEzMik7aygiTWVzaEluc3RhbmNlIiwidW5zZXRNZXRhbGxpY1JvdWdobmVzcyIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRPcGFjaXR5IiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldE92ZXJsYXlJbmRleCIsCjEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0T3ZlcnJpZGVTY2VuZVZpc2liaWxpdHkiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0UG9pbnRzVmlzaWJsZSIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRTY3JlZW5PcmllbnRlZCIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRTY3JlZW5TcGFjZSIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRTY3JlZW5TcGFjZVN0cmV0Y2hlZCIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRTdHJlYW1DdXRvZmZTY2FsZSIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRTdXBwcmVzc0NhbWVyYVNjYWxlIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldFRleHR1cmUiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwic2V0VmlzaWJsZSIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRYUmF5IiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInN5bmNocm9uaXplVmlzaWJpbGl0aWVzIiw0KTtrKCJNZXNoSW5zdGFuY2UiLCJ1bnNldENvbG9yIiwxMzIpOwprKCJNZXNoSW5zdGFuY2UiLCJ1bnNldEN1bGxpbmdWZWN0b3IiLDEzMik7aygiTWVzaEluc3RhbmNlIiwidW5zZXREZXB0aFJhbmdlIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInVuc2V0RWxlbWVudENvbG9yIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInVuc2V0TGluZVBhdHRlcm4iLDEzMik7aygiTWVzaEluc3RhbmNlIiwidW5zZXRNYXRyaXgiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwidW5zZXRPcGFjaXR5IiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInVuc2V0VGV4dHVyZSIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRFbWlzc2l2ZUNvbG9yIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInVuc2V0RW1pc3NpdmVDb2xvciIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRTcGVjdWxhckNvbG9yIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInVuc2V0U3BlY3VsYXJDb2xvciIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRTcGVjdWxhckludGVuc2l0eSIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLAoidW5zZXRTcGVjdWxhckludGVuc2l0eSIsMTMyKTt5Lk92ZXJsYXk9e307aygiT3ZlcmxheSIsImRlc3Ryb3kiKTtrKCJPdmVybGF5IiwibWF4SW5kZXgiKTtrKCJPdmVybGF5Iiwic2V0Q2FtZXJhIiwzMik7aygiT3ZlcmxheSIsInNldFZpZXdwb3J0Iik7aygiT3ZlcmxheSIsInNldFZpc2libGUiKTt2YXIgZWM9e29wZW5fbW9kZWxfZmFpbGVkOlNhLHNlc3Npb25fc3RhcnRlZDpmdW5jdGlvbigpeyIkJGNzIj09PXAmJihnLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCJ3ZWJnbGNvbnRleHRsb3N0Iix2LCExKSx5Lm9uUmVzaXplKCkpfSxwb3N0X2RyYXdfanNvbjpmdW5jdGlvbihtLHIpe3RyeXt2YXIgdT1KU09OLnBhcnNlKHIpfWNhdGNoKHgpe2NvbnNvbGUuYXNzZXJ0KCExLCJtYWxmb3JtZWQgSlNPTiBmcm9tIHBvc3RfZHJhdyIseCk7cmV0dXJufWcuZ2koInBvc3RfZHJhdyIsdS5zdGF0cyxBYih1LmNhbWVyYSksdS52aXNpYmxlUG9pbnRzKTsiaGlnaCI9PT11LnF1YWxpdHkmJgooZy5naSgiZHJhd19jb21wbGV0ZSIpLGcuZ2koImRyYXdfaWRsZSIpKX19LGlhPXtzZXNzaW9uX3N0YXJ0ZWQ6ZnVuY3Rpb24oKXsiJCRzcyI9PT1wJiYoeS5yZXN1bWVEcmF3aW5nKCksZ1twXS5EZWJ1Z19ub3RpZnlMb2dnZWRScGNFeGVjdXRpb25Jc0FsbG93ZWQoKSl9fSxRPXt9O2cuZ2k9ZnVuY3Rpb24obSl7aWYobSBpbiBlYyl7dmFyIHI9ZWNbbV07ci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIHU9UVttXTt0cnl7aWYodm9pZCAwIT09dSlmb3IodmFyIHg9MDt4PHUubGVuZ3RoO3grKylyPXVbeF0sImZ1bmN0aW9uIj09PXR5cGVvZiByJiZyLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jYXRjaCh6KXtjb25zb2xlLmxvZygiVW5oYW5kbGVkIGV4Y2VwdGlvbiBpbiAiK20rIiBldmVudCBoYW5kbGVyOiIpLGNvbnNvbGUubG9nKHopfW0gaW4gaWEmJihyPWlhW21dLHIuYXBwbHkodGhpcyxhcmd1bWVudHMpKX07eS5zZXRFdmVudEhhbmRsZXI9ZnVuY3Rpb24obSxyKXtRLmhhc093blByb3BlcnR5KG0pfHwKKFFbbV09W10pO1FbbV0ucHVzaChyKX07eS51bnNldEV2ZW50SGFuZGxlcj1mdW5jdGlvbihtLHIpe209UVttXTtpZih2b2lkIDAhPT1tKWZvcih2YXIgdT0wO3U8bS5sZW5ndGg7KW1bdV09PT1yP20uc3BsaWNlKHUsMSk6Kyt1fTtXLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7Vy5wcm90b3R5cGUuY29uc3RydWN0b3I9Vzt2YXIgSD17VW5pbml0aWFsaXplZDowLE5ldHdvcms6MSxTY3M6Mn07eS5TZXNzaW9uVHlwZT1IO3ZhciB1YT1ILlVuaW5pdGlhbGl6ZWQ7eS5sb2FkPWZ1bmN0aW9uKG0pe0coKTtSJiZ5LmNhbGxSZWNvcmQucHVzaCgibG9hZCAiK3cobSkpO2lmKCFtKXRocm93IG5ldyBXKCJJbnZhbGlkQ29uZmlnIiwiSW52YWxpZCBsb2FkIGNvbmZpZ3VyYXRpb24iKTt2YXIgcj1tLnVyaTtpZigxIT09ISFyKyEhbS5idWZmZXIrISFtLmVtcHR5KXRocm93IG5ldyBXKCJJbnZhbGlkQ29uZmlnIiwiTXVzdCBzcGVjaWZ5IGV4YWN0bHkgb25lIG9mICd1cmknLCAnYnVmZmVyJywgb3IgJ2VtcHR5Jy4iKTsKaWYocil7e2lmKCJzdHJpbmciIT09dHlwZW9mIHIpdGhyb3cgbmV3IFcoIkludmFsaWRDb25maWciLCIndXJpJyBtdXN0IGJlIGEgc3RyaW5nIik7Y29uc3QgW2ZhLFgsY2FdPXIuc3BsaXQoIjovLyIpO2lmKFgpe2lmKGNhKXRocm93IG5ldyBXKCJJbnZhbGlkQ29uZmlnIiwiSW52YWxpZCBVUkkiKTt2YXIgdT1mYX1lbHNlIHU9Imh0dHAifWlmKCJ3cyI9PT11fHwid3NzIj09PXUpe0soKTtpZighbSl0aHJvdyBuZXcgVygiSW52YWxpZENvbmZpZyIsIkludmFsaWQgbG9hZCBjb25maWd1cmF0aW9uIik7bS5tb2RlbCYmInN0cmluZyI9PT10eXBlb2YgbS5tb2RlbHx8KG0ubW9kZWw9IiIpO3U9bS5zZXNzaW9uVG9rZW47dm9pZCAwPT09dSYmKHU9IiIpO2lmKCJzdHJpbmciIT09dHlwZW9mIHUpdGhyb3cgbmV3IFcoIkludmFsaWRDb25maWciLCInc2Vzc2lvblRva2VuJyBtdXN0IGJlIGEgc3RyaW5nIik7dmFyIHg9bS5saW1pdE1pQjt2b2lkIDA9PT14JiYoeD0wKTtpZigibnVtYmVyIiE9PQp0eXBlb2YgeCl0aHJvdyBuZXcgVygiSW52YWxpZENvbmZpZyIsIidsaW1pdE1pQicgbXVzdCBiZSBhIG51bWJlciIpO3ZhciB6PW0ubWVzaExldmVsO3ZvaWQgMD09PXomJih6PTApO2lmKCJudW1iZXIiIT09dHlwZW9mIHopdGhyb3cgbmV3IFcoIkludmFsaWRDb25maWciLCInbWVzaExldmVsJyBtdXN0IGJlIGEgbnVtYmVyIik7dmFyIEw9bS5zdHJlYW1DdXRvZmZTY2FsZTt2b2lkIDA9PT1MJiYoTD0tMSk7aWYoIm51bWJlciIhPT10eXBlb2YgTCl0aHJvdyBuZXcgVygiSW52YWxpZENvbmZpZyIsIidzdHJlYW1DdXRvZmZTY2FsZScgbXVzdCBiZSBhIG51bWJlciIpO2lmKHVhIT09SC5VbmluaXRpYWxpemVkKXRocm93IG5ldyBXKCJBbHJlYWR5Q2FsbGVkIiwibG9hZCgpIGFscmVhZHkgY2FsbGVkIGZvciBhIG5vbi1zdHJlYW1pbmcgc2Vzc2lvbiIpO3VhPUguTmV0d29yazttLnNlcnZlclNpZGVSZW5kZXJpbmc/KGcuY2FudmFzLnN0eWxlLmRpc3BsYXk9Im5vbmUiLHA9IiQkc3MiLApGLnZqKGcuJCR3cmFwcGVyKSx5Lm9uUmVzaXplKCksRi5Qayh0YSksRi5Rayh4YSksRi5PayhCYSksRi5OayhnLmdpKSxGLmNvbm5lY3QobSkpOihwPSIkJGNzIixqYShnLiQkZXMubG9hZE5ldHdvcmsocix1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQobS5tb2RlbCkpLHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh1KSksISFtLnN0cmVhbUN1bGxlZCwhIW0uc3RyZWFtTWV0YURhdGFPbklkbGUsISFtLnN0cmVhbU5vTGltaXQsISFtLnN0cmVhbUluc3RhbmNlc09uRGVtYW5kLCEhbS5zdHJlYW1BZ2dyZXNzaXZlQ29tcHJlc3Npb24sISFtLnN0cmVhbU1vZGVsQm91bmRpbmdQcmV2aWV3cywhIW0uc3RyZWFtSW5zdGFuY2VCb3VuZGluZ1ByZXZpZXdzLCEhbS5zdHJlYW1Pbmx5SW50ZXJlc3RpbmdCb3VuZGluZ1ByZXZpZXdzLCEhbS5zdHJlYW1FamVjdGVkQm91bmRpbmdQcmV2aWV3cyx4LHosTCkpKX1lbHNlImh0dHAiIT09dSYmImh0dHBzIiE9PXV8fEUobSxyKX1lbHNlIG0uYnVmZmVyPwpBKG0sbS5idWZmZXIpOihtPSEhbS5zdHJlYW1JbnN0YW5jZXNPbkRlbWFuZCxLKFtILlNjc10pLHVhPUguU2NzLG09Zy4kJGVzLmxvYWRFbXB0eVNjcyhtKSxqYShtKSk7cmV0dXJuIHVhfTt5LmF0dGFjaFNjc0J1ZmZlcj1mdW5jdGlvbihtLHIsdSx4LHosTCl7bT17YXR0YWNoU2NvcGU6bSxpbmNsdXNpb25NYXRyaXg6dSxhdHRhY2hNZWFzdXJlbWVudFVuaXQ6eCxhdHRhY2hJbnZpc2libHk6eixyZXNvbHZlT25GdWxseUxvYWRlZDpMfTtyZXR1cm4gbnVsbD09PXJ8fDA9PT1yLmxlbmd0aD9VKG0sMCwwKTpBKG0scil9O3kuZmVlZFNjc0J1ZmZlcj1mdW5jdGlvbihtLHIpe0soW0guU2NzXSk7aWYoMD09PW0pdGhyb3cgbmV3IFcoIkludmFsaWRDb25maWciLCInYXR0YWNoU2NvcGUnIHNob3VsZCBub3QgYmUgMCIpO3ZhciB1PTAseD0wO2lmKG51bGwhPT1yKXtpZihyLmNvbnN0cnVjdG9yIT09VWludDhBcnJheSl0aHJvdyBuZXcgVygiSW52YWxpZENvbmZpZyIsIididWZmZXInIG11c3QgYmUgYSBVaW50OEFycmF5Iik7CmlmKDA+PXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgVygiRW1wdHlCdWZmZXIiLCInYnVmZmVyJyBoYXMgYSBsZW5ndGggb2YgMCIpO3U9ci5ieXRlTGVuZ3RoO3g9Zy4kJGVzLmFsbG9jYXRlVWludDhCdWZmZXIoci5ieXRlTGVuZ3RoKTt0LnNldChyLHgpfWcuJCRlcy5mZWVkU2NzQnVmZmVyKG0seCx1KX19KSgpO3ZhciBiYT0zLE09NCpiYTt5Lk1lc2hEYXRhQnVpbGRlcj1mdW5jdGlvbigpe3RoaXMuX2ZhY2VFbGVtZW50cz1bXTt0aGlzLl9saW5lRWxlbWVudHM9W107dGhpcy5fcG9pbnRFbGVtZW50cz1bXTt0aGlzLmZvcm1hdEJpdHM9MH07eS5NZXNoRGF0YUJ1aWxkZXIuRm9ybWF0Qml0cz17Q2xvY2t3aXNlV2luZGluZzoxLENvdW50ZXJDbG9ja3dpc2VXaW5kaW5nOjIsVHdvU2lkZWQ6NCxNYW5pZm9sZDo2NTUzNn07eS5NZXNoRGF0YUJ1aWxkZXIucHJvdG90eXBlPXtjb25zdHJ1Y3Rvcjp5Lk1lc2hEYXRhQnVpbGRlcixfZ2V0T3B0aW9uYWw6ZnVuY3Rpb24oRSxBKXtyZXR1cm4gdm9pZCAwPT09CkU/bnVsbDpFW0FdP0VbQV06bnVsbH0sX29wdGlvbmFsR3VhcmQ6ZnVuY3Rpb24oRSxBLFUpe2lmKFUpe2lmKChVPXRoaXNbVV1bMF0pJiYhVVtFXSl0aHJvdyBFcnJvcigiQ2Fubm90IGRlZmluZSAiK0ErIiBmb3Igc29tZSBidXQgbm90IGFsbCB2ZXJ0aWNlcy4iKTt9ZWxzZSB0aGlzLl9vcHRpb25hbEd1YXJkKEUsQSwiX2ZhY2VFbGVtZW50cyIpLHRoaXMuX29wdGlvbmFsR3VhcmQoRSxBLCJfbGluZUVsZW1lbnRzIiksdGhpcy5fb3B0aW9uYWxHdWFyZChFLEEsIl9wb2ludEVsZW1lbnRzIil9LGFkZEZhY2U6ZnVuY3Rpb24oRSxBKXt2YXIgVT10aGlzLl9mYWNlRWxlbWVudHMsSz10aGlzLl9nZXRPcHRpb25hbChBLCJub3JtYWxzIiksamE9dGhpcy5fZ2V0T3B0aW9uYWwoQSwidXZzIiksVz10aGlzLl9nZXRPcHRpb25hbChBLCJyZ2JhMzJzIik7QT10aGlzLl9nZXRPcHRpb25hbChBLCJiaXRzIil8fDA7aWYoMCE9PUUubGVuZ3RoJTkpdGhyb3cgRXJyb3IoIklsbGVnYWwgdHJpYW5nbGVzOiAndmVydGV4RGF0YS5sZW5ndGgnIG11c3QgYmUgZGl2aXNpYmxlIGJ5IDkgKGkuZS4gMyBudW1iZXJzIHBlciB2ZXJ0ZXggYW5kIDMgdmVydGljZXMgcGVyIHRyaWFuZ2xlKS4iKTsKaWYoSyl7aWYoSy5sZW5ndGghPT1FLmxlbmd0aCl0aHJvdyBFcnJvcigiQ2Fubm90IGRlZmluZSBub3JtYWxzIGZvciBzb21lIGJ1dCBub3QgYWxsIHZlcnRpY2VzLiIpO3RoaXMuX29wdGlvbmFsR3VhcmQoIm5vcm1hbHMiLCJub3JtYWxzIiwiX2ZhY2VFbGVtZW50cyIpfWlmKGphKXtpZigzKmphLmxlbmd0aCE9PTIqRS5sZW5ndGgpdGhyb3cgRXJyb3IoIkNhbm5vdCBkZWZpbmUgVVYgcGFyYW1ldGVycyBmb3Igc29tZSBidXQgbm90IGFsbCB2ZXJ0aWNlcy4iKTt0aGlzLl9vcHRpb25hbEd1YXJkKCJ1dnMiLCJVViBwYXJhbWV0ZXJzIiwiX2ZhY2VFbGVtZW50cyIpfWlmKFcpe2lmKDMqVy5sZW5ndGghPT00KkUubGVuZ3RoKXRocm93IEVycm9yKCJDYW5ub3QgZGVmaW5lIFJHQkEzMnMgZm9yIHNvbWUgYnV0IG5vdCBhbGwgdmVydGljZXMuIik7dGhpcy5fb3B0aW9uYWxHdWFyZCgicmdiYTMycyIsIlJHQkEzMnMiKTtpZigwPT0odGhpcy5mb3JtYXRCaXRzJjMyNzY4KSlmb3IodmFyIHRhPQozO3RhPFcubGVuZ3RoO3RhKz00KWlmKDI1NSE9V1t0YV0pe3RoaXMuZm9ybWF0Qml0c3w9MzI3Njg7YnJlYWt9fVUucHVzaCh7dmVydGV4RGF0YTpFLG5vcm1hbHM6Syx1dnM6amEscmdiYTMyczpXLGJpdHM6QX0pfSxhZGRQb2x5bGluZTpmdW5jdGlvbihFLEEpe3ZhciBVPXRoaXMuX2xpbmVFbGVtZW50cyxLPXRoaXMuX2dldE9wdGlvbmFsKEEsInJnYmEzMnMiKTtBPXRoaXMuX2dldE9wdGlvbmFsKEEsImJpdHMiKXx8MDtpZigwIT09RS5sZW5ndGglMyl0aHJvdyBFcnJvcigidmVydGV4RGF0YSBhcnJheSBtdXN0IGJlIGRpdmlzaWJsZSBieSAzIChpLmUuIDMgbnVtYmVycyBwZXIgdmVydGV4KS4iKTtpZig2PkUubGVuZ3RoJiYwPEUubGVuZ3RoKXRocm93IEVycm9yKCJJbGxlZ2FsIHBvbHlsaW5lOiAnMCA8IHZlcnRleERhdGEubGVuZ3RoIDwgNicuIik7aWYoSyl7aWYoMypLLmxlbmd0aCE9PTQqRS5sZW5ndGgpdGhyb3cgRXJyb3IoIkNhbm5vdCBkZWZpbmUgUkdCQTMycyBmb3Igc29tZSBidXQgbm90IGFsbCB2ZXJ0aWNlcy4iKTsKdGhpcy5fb3B0aW9uYWxHdWFyZCgicmdiYTMycyIsIlJHQkEzMnMiKX1VLnB1c2goe3ZlcnRleERhdGE6RSxyZ2JhMzJzOkssYml0czpBfSl9LGFkZFBvaW50czpmdW5jdGlvbihFLEEpe3ZhciBVPXRoaXMuX3BvaW50RWxlbWVudHMsSz10aGlzLl9nZXRPcHRpb25hbChBLCJyZ2JhMzJzIik7QT10aGlzLl9nZXRPcHRpb25hbChBLCJiaXRzIil8fDA7aWYoMCE9PUUubGVuZ3RoJTMpdGhyb3cgRXJyb3IoInZlcnRleERhdGEgYXJyYXkgbXVzdCBiZSBkaXZpc2libGUgYnkgMyAoaS5lLiAzIG51bWJlcnMgcGVyIHZlcnRleCkuIik7aWYoSyl7aWYoMypLLmxlbmd0aCE9PTQqRS5sZW5ndGgpdGhyb3cgRXJyb3IoIkNhbm5vdCBkZWZpbmUgUkdCQTMycyBmb3Igc29tZSBidXQgbm90IGFsbCB2ZXJ0aWNlcy4iKTt0aGlzLl9vcHRpb25hbEd1YXJkKCJyZ2JhMzJzIiwiUkdCQTMycyIpfVUucHVzaCh7dmVydGV4RGF0YTpFLHJnYmEzMnM6SyxiaXRzOkF9KX0sX21hcnNoYWw6ZnVuY3Rpb24oKXt2YXIgRT0KdGhpcy5fZmFjZUVsZW1lbnRzLEE9dGhpcy5fbGluZUVsZW1lbnRzLFU9dGhpcy5fcG9pbnRFbGVtZW50cyxLPSExLGphPSExLFc9ITEsdGE9ITEseGE9ITEsQmE9ITEsQWI9ITEsUGI9ITEsT2I9ITEsb2E9RVswXSxTYT1BWzBdLGs9VVswXTtvYSYmKEs9ISFvYS5ub3JtYWxzLGphPSEhb2EudXZzLFc9ISFvYS5yZ2JhMzJzKTtTYSYmKHRhPSEhU2Eubm9ybWFscyx4YT0hIVNhLnV2cyxCYT0hIVNhLnJnYmEzMnMpO2smJihBYj0hIWsubm9ybWFscyxQYj0hIWsudXZzLE9iPSEhay5yZ2JhMzJzKTt2YXIgaWI9MztvYT10aGlzLmZvcm1hdEJpdHM7aWYoU2E9S3x8dGF8fEFiKWliKz0zLG9hfD00MDk2LEsmJihvYXw9OCksdGEmJihvYXw9NjQpLEFiJiYob2F8PTUxMik7aWYoaz1qYXx8eGF8fFBiKWliKz0yLG9hfD04MTkyLGphJiYob2F8PTE2KSx4YSYmKG9hfD0xMjgpLFBiJiYob2F8PTEwMjQpO3ZhciBDYj1XfHxCYXx8T2I7Q2ImJihpYis9MSxvYXw9MTYzODQsVyYmKG9hfD0zMiksCkJhJiYob2F8PTI1NiksT2ImJihvYXw9MjA0OCkpO2Zvcih2YXIgQmI9MCxZPTA7WTxFLmxlbmd0aDsrK1kpe3ZhciBTPUVbWV07QmIrPVMudmVydGV4RGF0YS5sZW5ndGh9QmIvPTM7dmFyIGFiPTAsQ2E9MDtmb3IoWT0wO1k8QS5sZW5ndGg7KytZKXtTPUFbWV07dmFyIFo9Uy52ZXJ0ZXhEYXRhO1oubGVuZ3RoJiYoYWIrPVoubGVuZ3RoLCsrQ2EpfWFiPTIqKGFiLzMtQ2EpO2ZvcihZPUNhPTA7WTxVLmxlbmd0aDsrK1kpUz1VW1ldLENhKz1TLnZlcnRleERhdGEubGVuZ3RoO0NhLz0zO2liKj1CYithYitDYTtZPWcuJCRlcy5hbGxvY2F0ZVVpbnQ4QnVmZmVyO3ZhciAkYT1ZKDQqaWIpLE5jPUUubGVuZ3RoP1koTSpFLmxlbmd0aCk6MCxOYj1BLmxlbmd0aD9ZKE0qQS5sZW5ndGgpOjAsZWM9VS5sZW5ndGg/WShNKlUubGVuZ3RoKTowLGlhPXQuc3ViYXJyYXkoJGEpLFE9Qi5zdWJhcnJheSgkYT4+MiksSD0wLHVhPTA7Zm9yKFk9MDtZPEUubGVuZ3RoOysrWSl7Uz1FW1ldO1o9Uy52ZXJ0ZXhEYXRhOwp2YXIgbT1TLm5vcm1hbHMscj1TLnV2cyx1PVMucmdiYTMycyx4PVoubGVuZ3RoLzMsej1oLnN1YmFycmF5KChOYz4+MikrYmEqWSk7elswXT11YTt6WzFdPXg7elsyXT1TLmJpdHM7dWErPXg7dmFyIEw9MDtmb3IoeD1TPTA7eDxaLmxlbmd0aDt4Kz0zKVFbSF09Wlt4XSxRW0grMV09Wlt4KzFdLFFbSCsyXT1aW3grMl0sSCs9MyxTYSYmKEs/KFFbSF09bVt4XSxRW0grMV09bVt4KzFdLFFbSCsyXT1tW3grMl0pOihRW0hdPTAsUVtIKzFdPTAsUVtIKzJdPTApLEgrPTMpLGsmJihqYT8oUVtIXT1yW0xdLFFbSCsxXT1yW0wrMV0sTCs9Mik6KFFbSF09MCxRW0grMV09MCksSCs9MiksQ2ImJih6PUg8PDIsVz8oaWFbeisrXT11W1MrK10saWFbeisrXT11W1MrK10saWFbeisrXT11W1MrK10saWFbeisrXT11W1MrK10pOihpYVt6KytdPTAsaWFbeisrXT0wLGlhW3orK109MCxpYVt6KytdPTApLCsrSCl9Zm9yKFk9dWE9MDtZPEEubGVuZ3RoOysrWSlmb3IoUz1BW1ldLFo9Uy52ZXJ0ZXhEYXRhLAptPVMubm9ybWFscyxyPVMudXZzLHU9Uy5yZ2JhMzJzLHg9Wi5sZW5ndGgvMywwPHgmJih4PTIqeC0yKSx6PWguc3ViYXJyYXkoKE5iPj4yKStiYSpZKSx6WzBdPXVhLHpbMV09eCx6WzJdPVMuYml0cyx1YSs9eCxTPTQseD0zO3g8Wi5sZW5ndGg7eCs9Mylmb3IoUy09NCxFPS0zOzA+PUU7RSs9MylLPXgrRSxRW0hdPVpbS10sUVtIKzFdPVpbSysxXSxRW0grMl09WltLKzJdLEgrPTMsU2EmJih0YT8oUVtIXT1tW0tdLFFbSCsxXT1tW0srMV0sUVtIKzJdPW1bSysyXSk6KFFbSF09MCxRW0grMV09MCxRW0grMl09MCksSCs9MyksayYmKHhhPyhLPUsvMyoyLFFbSF09cltLXSxRW0grMV09cltLKzFdKTooUVtIXT0wLFFbSCsxXT0wKSxIKz0yKSxDYiYmKHo9SDw8MixCYT8oaWFbeisrXT11W1MrK10saWFbeisrXT11W1MrK10saWFbeisrXT11W1MrK10saWFbeisrXT11W1MrK10pOihpYVt6KytdPTAsaWFbeisrXT0wLGlhW3orK109MCxpYVt6KytdPTApLCsrSCk7Zm9yKFk9dWE9MDtZPFUubGVuZ3RoOysrWSlmb3IoUz0KVVtZXSxaPVMudmVydGV4RGF0YSxtPVMubm9ybWFscyxyPVMudXZzLHU9Uy5yZ2JhMzJzLHg9Wi5sZW5ndGgvMyx6PWguc3ViYXJyYXkoKGVjPj4yKStiYSpZKSx6WzBdPXVhLHpbMV09eCx6WzJdPVMuYml0cyx1YSs9eCx4PVM9TD0wO3g8Wi5sZW5ndGg7eCs9MylRW0hdPVpbeF0sUVtIKzFdPVpbeCsxXSxRW0grMl09Wlt4KzJdLEgrPTMsU2EmJihBYj8oUVtIXT1tW3hdLFFbSCsxXT1tW3grMV0sUVtIKzJdPW1beCsyXSk6KFFbSF09MCxRW0grMV09MCxRW0grMl09MCksSCs9MyksayYmKFBiPyhRW0hdPXJbTF0sUVtIKzFdPXJbTCsxXSxMKz0yKTooUVtIXT0wLFFbSCsxXT0wKSxIKz0yKSxDYiYmKHo9SDw8MixPYj8oaWFbeisrXT11W1MrK10saWFbeisrXT11W1MrK10saWFbeisrXT11W1MrK10saWFbeisrXT11W1MrK10pOihpYVt6KytdPTAsaWFbeisrXT0wLGlhW3orK109MCxpYVt6KytdPTApLCsrSCk7cmV0dXJue3RvdGFsRmFjZVZlcnRpY2VzOkJiLHRvdGFsTGluZVZlcnRpY2VzOmFiLAp0b3RhbFBvaW50VmVydGljZXM6Q2EsZmFjZUVsZW1lbnRJbmZvc1B0cjpOYyxsaW5lRWxlbWVudEluZm9zUHRyOk5iLHBvaW50RWxlbWVudEluZm9zUHRyOmVjLGZsb2F0RGF0YVB0cjokYSxmbG9hdERhdGFQdHJMZW46aWIsYml0czpvYX19fX07CmcuS2o9ZnVuY3Rpb24oKXt2YXIgYT17UGo6bnVsbCxYaTpudWxsLGNvbm5lY3Rpb246bnVsbCxlajpudWxsLGhqOm51bGwsYmo6bnVsbCxhajpudWxsLCRpOjEyODAsWmk6ODAwLGdqOjEyODAsZmo6ODAwLFFpOjEsZGs6e2NvbW1hbmQ6IlNFUlZFUl9TRVRUSU5HUyJ9LHZqOmZ1bmN0aW9uKGMpe3RoaXMuUGo9YztiLnZqKCl9LFRrOmZ1bmN0aW9uKCl7dGhpcy5Yaj0hMDtkZWxldGUgdGhpcy5lajtkZWxldGUgdGhpcy5oajtkZWxldGUgdGhpcy5iajtkZWxldGUgdGhpcy5hajt0aGlzLmNvbm5lY3Rpb24mJnRoaXMuY29ubmVjdGlvbi5jbG9zZSgpfSxrazpmdW5jdGlvbihjKXthLlhpIT09YyYmKGEuWGkmJihhLlhpLnN0eWxlLmRpc3BsYXk9Im5vbmUiKSxhLlhpPWMsYS5YaS5zdHlsZS5kaXNwbGF5PSIiKX0sY29ubmVjdGVkOmZ1bmN0aW9uKCl7cmV0dXJuIGEuY29ubmVjdGlvbiYmYS5jb25uZWN0aW9uLnJlYWR5U3RhdGU9PT1XZWJTb2NrZXQuT1BFTn0sRWo6ZnVuY3Rpb24oKXthLmNvbm5lY3RlZCgpJiYKYS5jb25uZWN0aW9uLnNlbmQoSlNPTi5zdHJpbmdpZnkoe2NvbW1hbmQ6IlNFUlZFUl9TSURFX0NMSUVOVF9JTkZPIix3aWR0aDphLiRpKmEuUWksaGVpZ2h0OmEuWmkqYS5RaSxsYXlvdXRXaWR0aDphLmdqLGxheW91dEhlaWdodDphLmZqLGVuY29kaW5nOiJqcGVnIn0pKX0sTGs6ZnVuY3Rpb24oYyxkLGUsZil7MD49Y3x8MD49ZHx8MD49ZXx8MD49Znx8YS4kaT09PWMmJmEuWmk9PT1kJiZhLmdqPT09ZSYmYS5maj09PWZ8fChhLiRpPWMsYS5aaT1kLGEuZ2o9ZSxhLmZqPWYsYS5jb25uZWN0ZWQoKSYmKHZvaWQgMCE9PWEuRGomJndpbmRvdy5jbGVhclRpbWVvdXQoYS5EaiksYS5Eaj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5Yanx8KGEuRGo9dm9pZCAwLGEuRWooKSl9LDUwMCkpKX0sS2s6ZnVuY3Rpb24oYyl7YS5jb25uZWN0ZWQoKSYmYS5jb25uZWN0aW9uLnNlbmQoYyl9LFBrOmZ1bmN0aW9uKGMpe2EuZWo9Y30sUWs6ZnVuY3Rpb24oYyl7YS5oaj1jfSxPazpmdW5jdGlvbihjKXthLmJqPQpjfSxOazpmdW5jdGlvbihjKXthLmFqPWN9LEZrOmZ1bmN0aW9uKGMpe2EuYmomJmEuYmooYyl9LFJrOmZ1bmN0aW9uKGMpe3ZhciBkPXtjb21tYW5kOiJTRVJWRVJfU0VUVElOR1MifSxlO2ZvcihlIGluIGMpaWYoYy5oYXNPd25Qcm9wZXJ0eShlKSl7aWYoInNjYWxlSGlnaCI9PT1lKXt2YXIgZj1jW2VdO2lmKCJudW1iZXIiIT09dHlwZW9mIGYpY29udGludWU7Zj1NYXRoLm1pbigxLGYpOzA+PWYmJihmPTEpO2EuUWkhPT1mJiYoYS5RaT1mLGEuRWooKSl9ImpwZWdRdWFsaXR5SGlnaCIhPT1lJiYianBlZ1F1YWxpdHlMb3ciIT09ZSYmImpwZWdDaHJvbWFTYW1wbGVzSGlnaCIhPT1lJiYianBlZ0Nocm9tYVNhbXBsZXNMb3ciIT09ZSYmInNjYWxlTG93IiE9PWV8fCJudW1iZXIiIT09dHlwZW9mIGNbZV18fChkW2VdPWEuZGtbZV09Y1tlXSl9YS5jb25uZWN0ZWQoKSYmYS5jb25uZWN0aW9uLnNlbmQoSlNPTi5zdHJpbmdpZnkoZCkpfSxjb25uZWN0OmZ1bmN0aW9uKGMpe3ZhciBkPWcuJCRlcy5nZXROZXR3b3JrVmVyc2lvbigpOwphLmNvbm5lY3Rpb249bmV3IFdlYlNvY2tldChjLnVyaSxbImJpbmFyeSJdKTthLmNvbm5lY3Rpb24uYmluYXJ5VHlwZT0iYXJyYXlidWZmZXIiO3ZhciBlPSExO2EuY29ubmVjdGlvbi5vbmNsb3NlPWZ1bmN0aW9uKCl7Zy5naSgid2Vic29ja2V0X2Nvbm5lY3Rpb25fY2xvc2VkIil9O2EuY29ubmVjdGlvbi5vbm9wZW49ZnVuY3Rpb24oKXtlPSEwO2EuY29ubmVjdGlvbi5zZW5kKEpTT04uc3RyaW5naWZ5KHtjb21tYW5kOiJTRVJWRVJfU0lERV9SRU5ERVIiLHdpZHRoOmEuJGkqYS5RaSxoZWlnaHQ6YS5aaSphLlFpLGxheW91dFdpZHRoOmEuZ2osbGF5b3V0SGVpZ2h0OmEuZmosbW9kZWw6Yy5tb2RlbCxuZXR3b3JrVmVyc2lvbjpkLHN0cmVhbUN1bGxlZDohIWMuc3RyZWFtQ3VsbGVkLHN0cmVhbUtleWVkRGF0YU9uSWRsZTohIWMuc3RyZWFtTWV0YURhdGFPbklkbGUsc3RyZWFtTm9MaW1pdDohIWMuc3RyZWFtTm9MaW1pdCxzdHJlYW1JbnN0YW5jZXNPbkRlbWFuZDohIWMuc3RyZWFtSW5zdGFuY2VzT25EZW1hbmQsCnN0cmVhbUJvdW5kaW5nUHJldmlld3M6ISFjLnN0cmVhbUJvdW5kaW5nUHJldmlld3Msc3RyZWFtTW9kZWxCb3VuZGluZ1ByZXZpZXdzOiEhYy5zdHJlYW1Nb2RlbEJvdW5kaW5nUHJldmlld3Msc3RyZWFtSW5zdGFuY2VCb3VuZGluZ1ByZXZpZXdzOiEhYy5zdHJlYW1JbnN0YW5jZUJvdW5kaW5nUHJldmlld3Msc3RyZWFtT25seUludGVyZXN0aW5nQm91bmRpbmdQcmV2aWV3czohIWMuc3RyZWFtT25seUludGVyZXN0aW5nQm91bmRpbmdQcmV2aWV3cyxzdHJlYW1FamVjdGVkQm91bmRpbmdQcmV2aWV3czohIWMuc3RyZWFtRWplY3RlZEJvdW5kaW5nUHJldmlld3MsbGltaXRNaUI6Yy5saW1pdE1pQixtZXNoTGV2ZWw6Yy5tZXNoTGV2ZWwsc3RyZWFtQ3V0b2ZmU2NhbGU6Yy5zdHJlYW1DdXRvZmZTY2FsZSxzZXNzaW9uVG9rZW46Yy5zZXNzaW9uVG9rZW59KSk7YS5FaigpO2EuY29ubmVjdGlvbi5zZW5kKEpTT04uc3RyaW5naWZ5KGEuZGspKX07YS5jb25uZWN0aW9uLm9uZXJyb3I9ZnVuY3Rpb24oKXthLmFqJiYKYS5haihlPyJzb2NrZXRfZXJyb3IiOiJzb2NrZXRfb3Blbl9mYWlsZWQiKX07YS5jb25uZWN0aW9uLm9ubWVzc2FnZT1mdW5jdGlvbihmKXtpZighYS5YaiYmZi5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe3ZhciBsPW5ldyBVaW50OEFycmF5KGYuZGF0YSk7Zj1sWzBdO2lmKDEyMz09PWYpYS5laiYmYS5laihsKTtlbHNlIGlmKDY4PT09ZilhLmhqJiZhLmhqKGwuc3ViYXJyYXkoMSkpO2Vsc2V7YS5jb25uZWN0aW9uLnNlbmQoJ3siY29tbWFuZCI6IkFDSyJ9Jyk7dmFyIG49W2xbMV0sbFsyXV0scT1sWzRdPDwyNHxsWzVdPDwxNnxsWzZdPDw4fGxbN10sdj1uZXcgVWludDhBcnJheShsLnN1YmFycmF5KDgsOCtxKSk7bD1sLnN1YmFycmF5KDgrcSk7MD09PWYmJmIudmsobCxuLHYpfX19fX0sYj17Y2FudmFzOm51bGwsTmo6bnVsbCx2ajpmdW5jdGlvbigpe30sY3JlYXRlRWxlbWVudDpmdW5jdGlvbigpe3RoaXMuY2FudmFzfHwodGhpcy5jYW52YXM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIiksCnRoaXMuY2FudmFzLnNldEF0dHJpYnV0ZSgic3R5bGUiLCJkaXNwbGF5OiBub25lOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsiKSx0aGlzLk5qPXRoaXMuY2FudmFzLmdldENvbnRleHQoIjJkIiksYS5Qai5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcykpfSxkcmF3SW1hZ2U6ZnVuY3Rpb24oYyxkKXt2YXIgZT1jLndpZHRoLWRbMF07ZD1jLmhlaWdodC1kWzFdO3RoaXMuY2FudmFzLndpZHRoIT09ZSYmKHRoaXMuY2FudmFzLndpZHRoPWUpO3RoaXMuY2FudmFzLmhlaWdodCE9PWQmJih0aGlzLmNhbnZhcy5oZWlnaHQ9ZCk7dGhpcy5Oai5kcmF3SW1hZ2UoYywwLDApfSxuazpmdW5jdGlvbihjLGQsZSl7dmFyIGY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIik7dGhpcy5Eaz1mO2Yub25sb2FkPWZ1bmN0aW9uKCl7Zj09PWIuRGsmJihiLmRyYXdJbWFnZShmLGQpLGEua2soYi5jYW52YXMpLGEuRmsoZSkpO1VSTC5yZXZva2VPYmplY3RVUkwoYyl9OwpmLm9uZXJyb3I9ZnVuY3Rpb24oKXtVUkwucmV2b2tlT2JqZWN0VVJMKGMpfTtmLnNyYz1jO3JldHVybiBmfSx2azpmdW5jdGlvbihjLGQsZSl7MTI+PWMuYnl0ZUxlbmd0aHx8KHRoaXMuY3JlYXRlRWxlbWVudCgpLHRoaXMubmsoVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbY10se3R5cGU6ImltYWdlL2pwZWcifSkpLGQsZSkpfX07cmV0dXJuIGF9O3ZhciB3YT1PYmplY3QuYXNzaWduKHt9LGcpLEFhPSIuL3RoaXMucHJvZ3JhbSIsRGE9KGEsYik9Pnt0aHJvdyBiO30sRWE9Im9iamVjdCI9PXR5cGVvZiB3aW5kb3csRmE9ImZ1bmN0aW9uIj09dHlwZW9mIGltcG9ydFNjcmlwdHMsR2E9Im9iamVjdCI9PXR5cGVvZiBwcm9jZXNzJiYib2JqZWN0Ij09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMmJiJzdHJpbmciPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLExhPSIiLE1hLE5hLE9hOwppZihHYSl7TGE9RmE/cmVxdWlyZSgicGF0aCIpLmRpcm5hbWUoTGEpKyIvIjpfX2Rpcm5hbWUrIi8iO3ZhciBmcyxQYTsiZnVuY3Rpb24iPT09dHlwZW9mIHJlcXVpcmUmJihmcz1yZXF1aXJlKCJmcyIpLFBhPXJlcXVpcmUoInBhdGgiKSk7TWE9KGEsYik9PnthPVBhLm5vcm1hbGl6ZShhKTtyZXR1cm4gZnMucmVhZEZpbGVTeW5jKGEsYj92b2lkIDA6InV0ZjgiKX07T2E9YT0+e2E9TWEoYSwhMCk7YS5idWZmZXJ8fChhPW5ldyBVaW50OEFycmF5KGEpKTtyZXR1cm4gYX07TmE9KGEsYixjKT0+e2E9UGEubm9ybWFsaXplKGEpO2ZzLnJlYWRGaWxlKGEsZnVuY3Rpb24oZCxlKXtkP2MoZCk6YihlLmJ1ZmZlcil9KX07MTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYoQWE9cHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcL2csIi8iKSk7cHJvY2Vzcy5hcmd2LnNsaWNlKDIpO3Byb2Nlc3Mub24oInVuY2F1Z2h0RXhjZXB0aW9uIixmdW5jdGlvbihhKXtpZighKGEgaW5zdGFuY2VvZiBRYSkpdGhyb3cgYTsKfSk7cHJvY2Vzcy5vbigidW5oYW5kbGVkUmVqZWN0aW9uIixmdW5jdGlvbihhKXt0aHJvdyBhO30pO0RhPShhLGIpPT57aWYobm9FeGl0UnVudGltZSl0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPWEsYjtiIGluc3RhbmNlb2YgUWF8fFJhKCJleGl0aW5nIGR1ZSB0byBleGNlcHRpb246ICIrYik7cHJvY2Vzcy5leGl0KGEpfTtnLmluc3BlY3Q9ZnVuY3Rpb24oKXtyZXR1cm4iW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF0ifX1lbHNlIGlmKEVhfHxGYSlGYT9MYT1zZWxmLmxvY2F0aW9uLmhyZWY6InVuZGVmaW5lZCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKExhPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxfc2NyaXB0RGlyJiYoTGE9X3NjcmlwdERpciksMCE9PUxhLmluZGV4T2YoImJsb2I6Iik/TGE9TGEuc3Vic3RyKDAsTGEucmVwbGFjZSgvWz8jXS4qLywiIikubGFzdEluZGV4T2YoIi8iKSsxKTpMYT0iIixNYT1hPT57dmFyIGI9bmV3IFhNTEh0dHBSZXF1ZXN0OwpiLm9wZW4oIkdFVCIsYSwhMSk7Yi5zZW5kKG51bGwpO3JldHVybiBiLnJlc3BvbnNlVGV4dH0sRmEmJihPYT1hPT57dmFyIGI9bmV3IFhNTEh0dHBSZXF1ZXN0O2Iub3BlbigiR0VUIixhLCExKTtiLnJlc3BvbnNlVHlwZT0iYXJyYXlidWZmZXIiO2Iuc2VuZChudWxsKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYi5yZXNwb25zZSl9KSxOYT0oYSxiLGMpPT57dmFyIGQ9bmV3IFhNTEh0dHBSZXF1ZXN0O2Qub3BlbigiR0VUIixhLCEwKTtkLnJlc3BvbnNlVHlwZT0iYXJyYXlidWZmZXIiO2Qub25sb2FkPSgpPT57MjAwPT1kLnN0YXR1c3x8MD09ZC5zdGF0dXMmJmQucmVzcG9uc2U/YihkLnJlc3BvbnNlKTpjKCl9O2Qub25lcnJvcj1jO2Quc2VuZChudWxsKX07dmFyIFRhPWcucHJpbnR8fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksUmE9Zy5wcmludEVycnx8Y29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7T2JqZWN0LmFzc2lnbihnLHdhKTt3YT1udWxsOwpnLnRoaXNQcm9ncmFtJiYoQWE9Zy50aGlzUHJvZ3JhbSk7Zy5xdWl0JiYoRGE9Zy5xdWl0KTt2YXIgVWE7Zy53YXNtQmluYXJ5JiYoVWE9Zy53YXNtQmluYXJ5KTt2YXIgbm9FeGl0UnVudGltZT1nLm5vRXhpdFJ1bnRpbWV8fCEwOyJvYmplY3QiIT10eXBlb2YgV2ViQXNzZW1ibHkmJlZhKCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkIik7dmFyIFdhLGJiPSExLGNiPSJ1bmRlZmluZWQiIT10eXBlb2YgVGV4dERlY29kZXI/bmV3IFRleHREZWNvZGVyKCJ1dGY4Iik6dm9pZCAwOwpmdW5jdGlvbiB2YShhLGIsYyl7dmFyIGQ9YitjO2ZvcihjPWI7YVtjXSYmIShjPj1kKTspKytjO2lmKDE2PGMtYiYmYS5idWZmZXImJmNiKXJldHVybiBjYi5kZWNvZGUoYS5zdWJhcnJheShiLGMpKTtmb3IoZD0iIjtiPGM7KXt2YXIgZT1hW2IrK107aWYoZSYxMjgpe3ZhciBmPWFbYisrXSY2MztpZigxOTI9PShlJjIyNCkpZCs9U3RyaW5nLmZyb21DaGFyQ29kZSgoZSYzMSk8PDZ8Zik7ZWxzZXt2YXIgbD1hW2IrK10mNjM7ZT0yMjQ9PShlJjI0MCk/KGUmMTUpPDwxMnxmPDw2fGw6KGUmNyk8PDE4fGY8PDEyfGw8PDZ8YVtiKytdJjYzOzY1NTM2PmU/ZCs9U3RyaW5nLmZyb21DaGFyQ29kZShlKTooZS09NjU1MzYsZCs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxlPj4xMCw1NjMyMHxlJjEwMjMpKX19ZWxzZSBkKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGUpfXJldHVybiBkfWZ1bmN0aW9uIGRiKGEsYil7cmV0dXJuIGE/dmEodCxhLGIpOiIifQpmdW5jdGlvbiBlYihhLGIsYyxkKXtpZighKDA8ZCkpcmV0dXJuIDA7dmFyIGU9YztkPWMrZC0xO2Zvcih2YXIgZj0wO2Y8YS5sZW5ndGg7KytmKXt2YXIgbD1hLmNoYXJDb2RlQXQoZik7aWYoNTUyOTY8PWwmJjU3MzQzPj1sKXt2YXIgbj1hLmNoYXJDb2RlQXQoKytmKTtsPTY1NTM2KygobCYxMDIzKTw8MTApfG4mMTAyM31pZigxMjc+PWwpe2lmKGM+PWQpYnJlYWs7YltjKytdPWx9ZWxzZXtpZigyMDQ3Pj1sKXtpZihjKzE+PWQpYnJlYWs7YltjKytdPTE5MnxsPj42fWVsc2V7aWYoNjU1MzU+PWwpe2lmKGMrMj49ZClicmVhaztiW2MrK109MjI0fGw+PjEyfWVsc2V7aWYoYyszPj1kKWJyZWFrO2JbYysrXT0yNDB8bD4+MTg7YltjKytdPTEyOHxsPj4xMiY2M31iW2MrK109MTI4fGw+PjYmNjN9YltjKytdPTEyOHxsJjYzfX1iW2NdPTA7cmV0dXJuIGMtZX0KZnVuY3Rpb24gZmIoYSl7Zm9yKHZhciBiPTAsYz0wO2M8YS5sZW5ndGg7KytjKXt2YXIgZD1hLmNoYXJDb2RlQXQoYyk7MTI3Pj1kP2IrKzoyMDQ3Pj1kP2IrPTI6NTUyOTY8PWQmJjU3MzQzPj1kPyhiKz00LCsrYyk6Yis9M31yZXR1cm4gYn12YXIgZ2IsamIsdCxrYixsYixELGgsQixoYTtmdW5jdGlvbiBtYigpe3ZhciBhPVdhLmJ1ZmZlcjtnYj1hO2cuSEVBUDg9amI9bmV3IEludDhBcnJheShhKTtnLkhFQVAxNj1rYj1uZXcgSW50MTZBcnJheShhKTtnLkhFQVAzMj1EPW5ldyBJbnQzMkFycmF5KGEpO2cuSEVBUFU4PXQ9bmV3IFVpbnQ4QXJyYXkoYSk7Zy5IRUFQVTE2PWxiPW5ldyBVaW50MTZBcnJheShhKTtnLkhFQVBVMzI9aD1uZXcgVWludDMyQXJyYXkoYSk7Zy5IRUFQRjMyPUI9bmV3IEZsb2F0MzJBcnJheShhKTtnLkhFQVBGNjQ9aGE9bmV3IEZsb2F0NjRBcnJheShhKX12YXIgbmIsb2I9W10scGI9W10scmI9W10sc2I9W107CmZ1bmN0aW9uIHRiKCl7dmFyIGE9Zy5wcmVSdW4uc2hpZnQoKTtvYi51bnNoaWZ0KGEpfXZhciB1Yj0wLHZiPW51bGwsd2I9bnVsbDtmdW5jdGlvbiB4Yigpe3ViKys7Zy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZnLm1vbml0b3JSdW5EZXBlbmRlbmNpZXModWIpfWZ1bmN0aW9uIHliKCl7dWItLTtnLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmcubW9uaXRvclJ1bkRlcGVuZGVuY2llcyh1Yik7aWYoMD09dWImJihudWxsIT09dmImJihjbGVhckludGVydmFsKHZiKSx2Yj1udWxsKSx3Yikpe3ZhciBhPXdiO3diPW51bGw7YSgpfX1mdW5jdGlvbiBWYShhKXtpZihnLm9uQWJvcnQpZy5vbkFib3J0KGEpO2E9IkFib3J0ZWQoIithKyIpIjtSYShhKTtiYj0hMDthPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoYSsiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLiIpO2VhKGEpO3Rocm93IGE7fQpmdW5jdGlvbiB6Yigpe3JldHVybiBEYi5zdGFydHNXaXRoKCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsIil9dmFyIERiO2lmKGcubG9jYXRlRmlsZSl7aWYoRGI9ImVuZ2luZS5lc20ud2FzbSIsIXpiKCkpe3ZhciBFYj1EYjtEYj1nLmxvY2F0ZUZpbGU/Zy5sb2NhdGVGaWxlKEViLExhKTpMYStFYn19ZWxzZSBEYj0obmV3IFVSTCgiZW5naW5lLmVzbS53YXNtIixpbXBvcnQubWV0YS51cmwpKS50b1N0cmluZygpO2Z1bmN0aW9uIEZiKCl7dmFyIGE9RGI7dHJ5e2lmKGE9PURiJiZVYSlyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoVWEpO2lmKE9hKXJldHVybiBPYShhKTt0aHJvdyJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZCI7fWNhdGNoKGIpe1ZhKGIpfX0KZnVuY3Rpb24gR2IoKXtpZighVWEmJihFYXx8RmEpKXtpZigiZnVuY3Rpb24iPT10eXBlb2YgZmV0Y2gmJiFEYi5zdGFydHNXaXRoKCJmaWxlOi8vIikpcmV0dXJuIGZldGNoKERiLHtjcmVkZW50aWFsczoic2FtZS1vcmlnaW4ifSkudGhlbihmdW5jdGlvbihhKXtpZighYS5vayl0aHJvdyJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICciK0RiKyInIjtyZXR1cm4gYS5hcnJheUJ1ZmZlcigpfSkuY2F0Y2goZnVuY3Rpb24oKXtyZXR1cm4gRmIoKX0pO2lmKE5hKXJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihhLGIpe05hKERiLGZ1bmN0aW9uKGMpe2EobmV3IFVpbnQ4QXJyYXkoYykpfSxiKX0pfXJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIEZiKCl9KX0KdmFyIEhiLEliLEpiPXs3MjYzMzY6KCk9Pntjb25zb2xlLmxvZygiUlBDIHBhcnNpbmcgZmFpbGVkIil9LDcyNjM3NTooYSxiKT0+e2cuJCRmYWNhZGUmJihoYVthPj4zXT1nLiQkZmFjYWRlLmNvbnRhaW5lci5jbGllbnRXaWR0aCxoYVtiPj4zXT1nLiQkZmFjYWRlLmNvbnRhaW5lci5jbGllbnRIZWlnaHQpfSw3MjY1MzY6KCk9Pnt0cnl7dmFyIGE9d2luZG93LmJvd3NlcjtyZXR1cm4gYSYmYS53aW5kb3dzJiYoYS53ZWJraXR8fGEuYmxpbmt8fGEuZ2Vja28pPzE6MH1jYXRjaChiKXtyZXR1cm4gMX19LDcyNjcwOTooKT0+e3RyeXt2YXIgYT13aW5kb3cuYm93c2VyO2lmKCEoYSYmYS53aW5kb3dzJiYoYS5jaHJvbWUmJjA8PWEuY29tcGFyZVZlcnNpb25zKFthLnZlcnNpb24sIjU1Il0pJiYwPmEuY29tcGFyZVZlcnNpb25zKFthLnZlcnNpb24sIjU3Il0pfHxhLmZpcmVmb3gmJjA8PWEuY29tcGFyZVZlcnNpb25zKFthLnZlcnNpb24sIjUxIl0pJiYwPmEuY29tcGFyZVZlcnNpb25zKFthLnZlcnNpb24sCiI1OCJdKSkpKXJldHVybiAwfWNhdGNoKGUpe3JldHVybiAwfXRyeXt2YXIgYj1nLlJpLGM9Yi5nZXRFeHRlbnNpb24oIldFQkdMX2RlYnVnX3JlbmRlcmVyX2luZm8iKTtpZihjKXt2YXIgZD1iLmdldFBhcmFtZXRlcihjLlVOTUFTS0VEX1JFTkRFUkVSX1dFQkdMKTtpZighKGQmJjA8PWQuaW5kZXhPZigiQU5HTEUiKSYmKDA8PWQuaW5kZXhPZigiQU1EIil8fDA8PWQuaW5kZXhPZigiUmFkZW9uIikpJiYwPD1kLmluZGV4T2YoIkRpcmVjdDNEMTEiKSkpcmV0dXJuIDB9fWNhdGNoKGUpe31yZXR1cm4gMX19O2Z1bmN0aW9uIFFhKGEpe3RoaXMubmFtZT0iRXhpdFN0YXR1cyI7dGhpcy5tZXNzYWdlPSJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCIrYSsiKSI7dGhpcy5zdGF0dXM9YX1mdW5jdGlvbiBLYihhKXtmb3IoOzA8YS5sZW5ndGg7KWEuc2hpZnQoKShnKX0KdmFyIExiPVtdLE1iPVtdLFFiPShhLGIpPT57Zm9yKHZhciBjPTAsZD1hLmxlbmd0aC0xOzA8PWQ7ZC0tKXt2YXIgZT1hW2RdOyIuIj09PWU/YS5zcGxpY2UoZCwxKToiLi4iPT09ZT8oYS5zcGxpY2UoZCwxKSxjKyspOmMmJihhLnNwbGljZShkLDEpLGMtLSl9aWYoYilmb3IoO2M7Yy0tKWEudW5zaGlmdCgiLi4iKTtyZXR1cm4gYX0sUmI9YT0+e3ZhciBiPSIvIj09PWEuY2hhckF0KDApLGM9Ii8iPT09YS5zdWJzdHIoLTEpOyhhPVFiKGEuc3BsaXQoIi8iKS5maWx0ZXIoZD0+ISFkKSwhYikuam9pbigiLyIpKXx8Ynx8KGE9Ii4iKTthJiZjJiYoYSs9Ii8iKTtyZXR1cm4oYj8iLyI6IiIpK2F9LFNiPWE9Pnt2YXIgYj0vXihcLz98KShbXHNcU10qPykoKD86XC57MSwyfXxbXlwvXSs/fCkoXC5bXi5cL10qfCkpKD86W1wvXSopJC8uZXhlYyhhKS5zbGljZSgxKTthPWJbMF07Yj1iWzFdO2lmKCFhJiYhYilyZXR1cm4iLiI7YiYmKGI9Yi5zdWJzdHIoMCxiLmxlbmd0aC0xKSk7cmV0dXJuIGErCmJ9LFRiPWE9PntpZigiLyI9PT1hKXJldHVybiIvIjthPVJiKGEpO2E9YS5yZXBsYWNlKC9cLyQvLCIiKTt2YXIgYj1hLmxhc3RJbmRleE9mKCIvIik7cmV0dXJuLTE9PT1iP2E6YS5zdWJzdHIoYisxKX07ZnVuY3Rpb24gVWIoKXtpZigib2JqZWN0Ij09dHlwZW9mIGNyeXB0byYmImZ1bmN0aW9uIj09dHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpe3ZhciBhPW5ldyBVaW50OEFycmF5KDEpO3JldHVybigpPT57Y3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhKTtyZXR1cm4gYVswXX19aWYoR2EpdHJ5e3ZhciBiPXJlcXVpcmUoImNyeXB0byIpO3JldHVybigpPT5iLnJhbmRvbUJ5dGVzKDEpWzBdfWNhdGNoKGMpe31yZXR1cm4oKT0+VmEoInJhbmRvbURldmljZSIpfQpmdW5jdGlvbiBWYigpe2Zvcih2YXIgYT0iIixiPSExLGM9YXJndW1lbnRzLmxlbmd0aC0xOy0xPD1jJiYhYjtjLS0pe2I9MDw9Yz9hcmd1bWVudHNbY106Ii8iO2lmKCJzdHJpbmciIT10eXBlb2YgYil0aHJvdyBuZXcgVHlwZUVycm9yKCJBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncyIpO2lmKCFiKXJldHVybiIiO2E9YisiLyIrYTtiPSIvIj09PWIuY2hhckF0KDApfWE9UWIoYS5zcGxpdCgiLyIpLmZpbHRlcihkPT4hIWQpLCFiKS5qb2luKCIvIik7cmV0dXJuKGI/Ii8iOiIiKSthfHwiLiJ9ZnVuY3Rpb24gV2IoYSxiKXt2YXIgYz1BcnJheShmYihhKSsxKTthPWViKGEsYywwLGMubGVuZ3RoKTtiJiYoYy5sZW5ndGg9YSk7cmV0dXJuIGN9dmFyIFhiPVtdO2Z1bmN0aW9uIFliKGEsYil7WGJbYV09e2lucHV0OltdLG91dHB1dDpbXSxQaTpifTtaYihhLCRiKX0KdmFyICRiPXtvcGVuOmZ1bmN0aW9uKGEpe3ZhciBiPVhiW2Eubm9kZS5yZGV2XTtpZighYil0aHJvdyBuZXcgSSg0Myk7YS50dHk9YjthLnNlZWthYmxlPSExfSxjbG9zZTpmdW5jdGlvbihhKXthLnR0eS5QaS5mc3luYyhhLnR0eSl9LGZzeW5jOmZ1bmN0aW9uKGEpe2EudHR5LlBpLmZzeW5jKGEudHR5KX0scmVhZDpmdW5jdGlvbihhLGIsYyxkKXtpZighYS50dHl8fCFhLnR0eS5QaS5Xail0aHJvdyBuZXcgSSg2MCk7Zm9yKHZhciBlPTAsZj0wO2Y8ZDtmKyspe3RyeXt2YXIgbD1hLnR0eS5QaS5XaihhLnR0eSl9Y2F0Y2gobil7dGhyb3cgbmV3IEkoMjkpO31pZih2b2lkIDA9PT1sJiYwPT09ZSl0aHJvdyBuZXcgSSg2KTtpZihudWxsPT09bHx8dm9pZCAwPT09bClicmVhaztlKys7YltjK2ZdPWx9ZSYmKGEubm9kZS50aW1lc3RhbXA9RGF0ZS5ub3coKSk7cmV0dXJuIGV9LHdyaXRlOmZ1bmN0aW9uKGEsYixjLGQpe2lmKCFhLnR0eXx8IWEudHR5LlBpLkFqKXRocm93IG5ldyBJKDYwKTsKdHJ5e2Zvcih2YXIgZT0wO2U8ZDtlKyspYS50dHkuUGkuQWooYS50dHksYltjK2VdKX1jYXRjaChmKXt0aHJvdyBuZXcgSSgyOSk7fWQmJihhLm5vZGUudGltZXN0YW1wPURhdGUubm93KCkpO3JldHVybiBlfX0sYWM9e1dqOmZ1bmN0aW9uKGEpe2lmKCFhLmlucHV0Lmxlbmd0aCl7dmFyIGI9bnVsbDtpZihHYSl7dmFyIGM9QnVmZmVyLmFsbG9jKDI1NiksZD0wO3RyeXtkPWZzLnJlYWRTeW5jKHByb2Nlc3Muc3RkaW4uZmQsYywwLDI1NiwtMSl9Y2F0Y2goZSl7aWYoZS50b1N0cmluZygpLmluY2x1ZGVzKCJFT0YiKSlkPTA7ZWxzZSB0aHJvdyBlO30wPGQ/Yj1jLnNsaWNlKDAsZCkudG9TdHJpbmcoInV0Zi04Iik6Yj1udWxsfWVsc2UidW5kZWZpbmVkIiE9dHlwZW9mIHdpbmRvdyYmImZ1bmN0aW9uIj09dHlwZW9mIHdpbmRvdy5wcm9tcHQ/KGI9d2luZG93LnByb21wdCgiSW5wdXQ6ICIpLG51bGwhPT1iJiYoYis9IlxuIikpOiJmdW5jdGlvbiI9PXR5cGVvZiByZWFkbGluZSYmKGI9CnJlYWRsaW5lKCksbnVsbCE9PWImJihiKz0iXG4iKSk7aWYoIWIpcmV0dXJuIG51bGw7YS5pbnB1dD1XYihiLCEwKX1yZXR1cm4gYS5pbnB1dC5zaGlmdCgpfSxBajpmdW5jdGlvbihhLGIpe251bGw9PT1ifHwxMD09PWI/KFRhKHZhKGEub3V0cHV0LDApKSxhLm91dHB1dD1bXSk6MCE9YiYmYS5vdXRwdXQucHVzaChiKX0sZnN5bmM6ZnVuY3Rpb24oYSl7YS5vdXRwdXQmJjA8YS5vdXRwdXQubGVuZ3RoJiYoVGEodmEoYS5vdXRwdXQsMCkpLGEub3V0cHV0PVtdKX19LGJjPXtBajpmdW5jdGlvbihhLGIpe251bGw9PT1ifHwxMD09PWI/KFJhKHZhKGEub3V0cHV0LDApKSxhLm91dHB1dD1bXSk6MCE9YiYmYS5vdXRwdXQucHVzaChiKX0sZnN5bmM6ZnVuY3Rpb24oYSl7YS5vdXRwdXQmJjA8YS5vdXRwdXQubGVuZ3RoJiYoUmEodmEoYS5vdXRwdXQsMCkpLGEub3V0cHV0PVtdKX19LEo9e3ZpOm51bGwsQWk6ZnVuY3Rpb24oKXtyZXR1cm4gSi5jcmVhdGVOb2RlKG51bGwsIi8iLDE2ODk1LAowKX0sY3JlYXRlTm9kZTpmdW5jdGlvbihhLGIsYyxkKXtpZigyNDU3Nj09PShjJjYxNDQwKXx8NDA5Nj09PShjJjYxNDQwKSl0aHJvdyBuZXcgSSg2Myk7Si52aXx8KEoudmk9e2Rpcjp7bm9kZTp7RWk6Si5laS5FaSxyaTpKLmVpLnJpLGxvb2t1cDpKLmVpLmxvb2t1cCxpajpKLmVpLmlqLHJlbmFtZTpKLmVpLnJlbmFtZSx1bmxpbms6Si5laS51bmxpbmsscm1kaXI6Si5laS5ybWRpcixyZWFkZGlyOkouZWkucmVhZGRpcixzeW1saW5rOkouZWkuc3ltbGlua30sc3RyZWFtOntHaTpKLmZpLkdpfX0sZmlsZTp7bm9kZTp7RWk6Si5laS5FaSxyaTpKLmVpLnJpfSxzdHJlYW06e0dpOkouZmkuR2kscmVhZDpKLmZpLnJlYWQsd3JpdGU6Si5maS53cml0ZSxMajpKLmZpLkxqLHpqOkouZmkuemosYWs6Si5maS5ha319LGxpbms6e25vZGU6e0VpOkouZWkuRWkscmk6Si5laS5yaSxyZWFkbGluazpKLmVpLnJlYWRsaW5rfSxzdHJlYW06e319LE9qOntub2RlOntFaTpKLmVpLkVpLHJpOkouZWkucml9LApzdHJlYW06Y2N9fSk7Yz1kYyhhLGIsYyxkKTsxNjM4ND09PShjLm1vZGUmNjE0NDApPyhjLmVpPUoudmkuZGlyLm5vZGUsYy5maT1KLnZpLmRpci5zdHJlYW0sYy5kaT17fSk6MzI3Njg9PT0oYy5tb2RlJjYxNDQwKT8oYy5laT1KLnZpLmZpbGUubm9kZSxjLmZpPUoudmkuZmlsZS5zdHJlYW0sYy5paT0wLGMuZGk9bnVsbCk6NDA5NjA9PT0oYy5tb2RlJjYxNDQwKT8oYy5laT1KLnZpLmxpbmsubm9kZSxjLmZpPUoudmkubGluay5zdHJlYW0pOjgxOTI9PT0oYy5tb2RlJjYxNDQwKSYmKGMuZWk9Si52aS5Pai5ub2RlLGMuZmk9Si52aS5Pai5zdHJlYW0pO2MudGltZXN0YW1wPURhdGUubm93KCk7YSYmKGEuZGlbYl09YyxhLnRpbWVzdGFtcD1jLnRpbWVzdGFtcCk7cmV0dXJuIGN9LGhsOmZ1bmN0aW9uKGEpe3JldHVybiBhLmRpP2EuZGkuc3ViYXJyYXk/YS5kaS5zdWJhcnJheSgwLGEuaWkpOm5ldyBVaW50OEFycmF5KGEuZGkpOm5ldyBVaW50OEFycmF5KDApfSxUajpmdW5jdGlvbihhLApiKXt2YXIgYz1hLmRpP2EuZGkubGVuZ3RoOjA7Yz49Ynx8KGI9TWF0aC5tYXgoYixjKigxMDQ4NTc2PmM/MjoxLjEyNSk+Pj4wKSwwIT1jJiYoYj1NYXRoLm1heChiLDI1NikpLGM9YS5kaSxhLmRpPW5ldyBVaW50OEFycmF5KGIpLDA8YS5paSYmYS5kaS5zZXQoYy5zdWJhcnJheSgwLGEuaWkpLDApKX0sSms6ZnVuY3Rpb24oYSxiKXtpZihhLmlpIT1iKWlmKDA9PWIpYS5kaT1udWxsLGEuaWk9MDtlbHNle3ZhciBjPWEuZGk7YS5kaT1uZXcgVWludDhBcnJheShiKTtjJiZhLmRpLnNldChjLnN1YmFycmF5KDAsTWF0aC5taW4oYixhLmlpKSkpO2EuaWk9Yn19LGVpOntFaTpmdW5jdGlvbihhKXt2YXIgYj17fTtiLmRldj04MTkyPT09KGEubW9kZSY2MTQ0MCk/YS5pZDoxO2IuaW5vPWEuaWQ7Yi5tb2RlPWEubW9kZTtiLm5saW5rPTE7Yi51aWQ9MDtiLmdpZD0wO2IucmRldj1hLnJkZXY7MTYzODQ9PT0oYS5tb2RlJjYxNDQwKT9iLnNpemU9NDA5NjozMjc2OD09PShhLm1vZGUmNjE0NDApPwpiLnNpemU9YS5paTo0MDk2MD09PShhLm1vZGUmNjE0NDApP2Iuc2l6ZT1hLmxpbmsubGVuZ3RoOmIuc2l6ZT0wO2IuYXRpbWU9bmV3IERhdGUoYS50aW1lc3RhbXApO2IubXRpbWU9bmV3IERhdGUoYS50aW1lc3RhbXApO2IuY3RpbWU9bmV3IERhdGUoYS50aW1lc3RhbXApO2IubGs9NDA5NjtiLmJsb2Nrcz1NYXRoLmNlaWwoYi5zaXplL2IubGspO3JldHVybiBifSxyaTpmdW5jdGlvbihhLGIpe3ZvaWQgMCE9PWIubW9kZSYmKGEubW9kZT1iLm1vZGUpO3ZvaWQgMCE9PWIudGltZXN0YW1wJiYoYS50aW1lc3RhbXA9Yi50aW1lc3RhbXApO3ZvaWQgMCE9PWIuc2l6ZSYmSi5KayhhLGIuc2l6ZSl9LGxvb2t1cDpmdW5jdGlvbigpe3Rocm93IGZjWzQ0XTt9LGlqOmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBKLmNyZWF0ZU5vZGUoYSxiLGMsZCl9LHJlbmFtZTpmdW5jdGlvbihhLGIsYyl7aWYoMTYzODQ9PT0oYS5tb2RlJjYxNDQwKSl7dHJ5e3ZhciBkPWdjKGIsYyl9Y2F0Y2goZil7fWlmKGQpZm9yKHZhciBlIGluIGQuZGkpdGhyb3cgbmV3IEkoNTUpOwp9ZGVsZXRlIGEucGFyZW50LmRpW2EubmFtZV07YS5wYXJlbnQudGltZXN0YW1wPURhdGUubm93KCk7YS5uYW1lPWM7Yi5kaVtjXT1hO2IudGltZXN0YW1wPWEucGFyZW50LnRpbWVzdGFtcDthLnBhcmVudD1ifSx1bmxpbms6ZnVuY3Rpb24oYSxiKXtkZWxldGUgYS5kaVtiXTthLnRpbWVzdGFtcD1EYXRlLm5vdygpfSxybWRpcjpmdW5jdGlvbihhLGIpe3ZhciBjPWdjKGEsYiksZDtmb3IoZCBpbiBjLmRpKXRocm93IG5ldyBJKDU1KTtkZWxldGUgYS5kaVtiXTthLnRpbWVzdGFtcD1EYXRlLm5vdygpfSxyZWFkZGlyOmZ1bmN0aW9uKGEpe3ZhciBiPVsiLiIsIi4uIl0sYztmb3IoYyBpbiBhLmRpKWEuZGkuaGFzT3duUHJvcGVydHkoYykmJmIucHVzaChjKTtyZXR1cm4gYn0sc3ltbGluazpmdW5jdGlvbihhLGIsYyl7YT1KLmNyZWF0ZU5vZGUoYSxiLDQxNDcxLDApO2EubGluaz1jO3JldHVybiBhfSxyZWFkbGluazpmdW5jdGlvbihhKXtpZig0MDk2MCE9PShhLm1vZGUmNjE0NDApKXRocm93IG5ldyBJKDI4KTsKcmV0dXJuIGEubGlua319LGZpOntyZWFkOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9YS5ub2RlLmRpO2lmKGU+PWEubm9kZS5paSlyZXR1cm4gMDthPU1hdGgubWluKGEubm9kZS5paS1lLGQpO2lmKDg8YSYmZi5zdWJhcnJheSliLnNldChmLnN1YmFycmF5KGUsZSthKSxjKTtlbHNlIGZvcihkPTA7ZDxhO2QrKyliW2MrZF09ZltlK2RdO3JldHVybiBhfSx3cml0ZTpmdW5jdGlvbihhLGIsYyxkLGUsZil7Yi5idWZmZXI9PT1qYi5idWZmZXImJihmPSExKTtpZighZClyZXR1cm4gMDthPWEubm9kZTthLnRpbWVzdGFtcD1EYXRlLm5vdygpO2lmKGIuc3ViYXJyYXkmJighYS5kaXx8YS5kaS5zdWJhcnJheSkpe2lmKGYpcmV0dXJuIGEuZGk9Yi5zdWJhcnJheShjLGMrZCksYS5paT1kO2lmKDA9PT1hLmlpJiYwPT09ZSlyZXR1cm4gYS5kaT1iLnNsaWNlKGMsYytkKSxhLmlpPWQ7aWYoZStkPD1hLmlpKXJldHVybiBhLmRpLnNldChiLnN1YmFycmF5KGMsYytkKSxlKSxkfUouVGooYSxlKwpkKTtpZihhLmRpLnN1YmFycmF5JiZiLnN1YmFycmF5KWEuZGkuc2V0KGIuc3ViYXJyYXkoYyxjK2QpLGUpO2Vsc2UgZm9yKGY9MDtmPGQ7ZisrKWEuZGlbZStmXT1iW2MrZl07YS5paT1NYXRoLm1heChhLmlpLGUrZCk7cmV0dXJuIGR9LEdpOmZ1bmN0aW9uKGEsYixjKXsxPT09Yz9iKz1hLnBvc2l0aW9uOjI9PT1jJiYzMjc2OD09PShhLm5vZGUubW9kZSY2MTQ0MCkmJihiKz1hLm5vZGUuaWkpO2lmKDA+Yil0aHJvdyBuZXcgSSgyOCk7cmV0dXJuIGJ9LExqOmZ1bmN0aW9uKGEsYixjKXtKLlRqKGEubm9kZSxiK2MpO2Eubm9kZS5paT1NYXRoLm1heChhLm5vZGUuaWksYitjKX0semo6ZnVuY3Rpb24oYSxiLGMsZCxlKXtpZigzMjc2OCE9PShhLm5vZGUubW9kZSY2MTQ0MCkpdGhyb3cgbmV3IEkoNDMpO2E9YS5ub2RlLmRpO2lmKGUmMnx8YS5idWZmZXIhPT1nYil7aWYoMDxjfHxjK2I8YS5sZW5ndGgpYS5zdWJhcnJheT9hPWEuc3ViYXJyYXkoYyxjK2IpOmE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYSwKYyxjK2IpO2M9ITA7VmEoKTtiPXZvaWQgMDtpZighYil0aHJvdyBuZXcgSSg0OCk7amIuc2V0KGEsYil9ZWxzZSBjPSExLGI9YS5ieXRlT2Zmc2V0O3JldHVybntoaTpiLCRrOmN9fSxhazpmdW5jdGlvbihhLGIsYyxkKXtKLmZpLndyaXRlKGEsYiwwLGQsYywhMSk7cmV0dXJuIDB9fX07ZnVuY3Rpb24gaGMoYSxiLGMpe3ZhciBkPSJhbCAiK2E7TmEoYSxlPT57ZXx8VmEoJ0xvYWRpbmcgZGF0YSBmaWxlICInK2ErJyIgZmFpbGVkIChubyBhcnJheUJ1ZmZlcikuJyk7YihuZXcgVWludDhBcnJheShlKSk7ZCYmeWIoZCl9LCgpPT57aWYoYyljKCk7ZWxzZSB0aHJvdydMb2FkaW5nIGRhdGEgZmlsZSAiJythKyciIGZhaWxlZC4nO30pO2QmJnhiKGQpfQp2YXIgaWM9bnVsbCxqYz17fSxrYz1bXSxsYz0xLG1jPW51bGwsbmM9ITAsST1udWxsLGZjPXt9LHBjPShhLGI9e30pPT57YT1WYigiLyIsYSk7aWYoIWEpcmV0dXJue3BhdGg6IiIsbm9kZTpudWxsfTtiPU9iamVjdC5hc3NpZ24oe1ZqOiEwLEJqOjB9LGIpO2lmKDg8Yi5Cail0aHJvdyBuZXcgSSgzMik7YT1RYihhLnNwbGl0KCIvIikuZmlsdGVyKGw9PiEhbCksITEpO2Zvcih2YXIgYz1pYyxkPSIvIixlPTA7ZTxhLmxlbmd0aDtlKyspe3ZhciBmPWU9PT1hLmxlbmd0aC0xO2lmKGYmJmIucGFyZW50KWJyZWFrO2M9Z2MoYyxhW2VdKTtkPVJiKGQrIi8iK2FbZV0pO2MuVGkmJighZnx8ZiYmYi5WaikmJihjPWMuVGkucm9vdCk7aWYoIWZ8fGIucmopZm9yKGY9MDs0MDk2MD09PShjLm1vZGUmNjE0NDApOylpZihjPW9jKGQpLGQ9VmIoU2IoZCksYyksYz1wYyhkLHtCajpiLkJqKzF9KS5ub2RlLDQwPGYrKyl0aHJvdyBuZXcgSSgzMik7fXJldHVybntwYXRoOmQsbm9kZTpjfX0scWM9YT0+Cntmb3IodmFyIGI7Oyl7aWYoYT09PWEucGFyZW50KXJldHVybiBhPWEuQWkuJGosYj8iLyIhPT1hW2EubGVuZ3RoLTFdP2ErIi8iK2I6YStiOmE7Yj1iP2EubmFtZSsiLyIrYjphLm5hbWU7YT1hLnBhcmVudH19LHJjPShhLGIpPT57Zm9yKHZhciBjPTAsZD0wO2Q8Yi5sZW5ndGg7ZCsrKWM9KGM8PDUpLWMrYi5jaGFyQ29kZUF0KGQpfDA7cmV0dXJuKGErYz4+PjApJW1jLmxlbmd0aH0sZ2M9KGEsYik9Pnt2YXIgYztpZihjPShjPXNjKGEsIngiKSk/YzphLmVpLmxvb2t1cD8wOjIpdGhyb3cgbmV3IEkoYyxhKTtmb3IoYz1tY1tyYyhhLmlkLGIpXTtjO2M9Yy5PaSl7dmFyIGQ9Yy5uYW1lO2lmKGMucGFyZW50LmlkPT09YS5pZCYmZD09PWIpcmV0dXJuIGN9cmV0dXJuIGEuZWkubG9va3VwKGEsYil9LGRjPShhLGIsYyxkKT0+e2E9bmV3IHRjKGEsYixjLGQpO2I9cmMoYS5wYXJlbnQuaWQsYS5uYW1lKTthLk9pPW1jW2JdO3JldHVybiBtY1tiXT1hfSx1Yz17cjowLCJyKyI6Mix3OjU3NywKIncrIjo1NzgsYToxMDg5LCJhKyI6MTA5MH0sdmM9YT0+e3ZhciBiPVsiciIsInciLCJydyJdW2EmM107YSY1MTImJihiKz0idyIpO3JldHVybiBifSxzYz0oYSxiKT0+e2lmKG5jKXJldHVybiAwO2lmKCFiLmluY2x1ZGVzKCJyIil8fGEubW9kZSYyOTIpe2lmKGIuaW5jbHVkZXMoInciKSYmIShhLm1vZGUmMTQ2KXx8Yi5pbmNsdWRlcygieCIpJiYhKGEubW9kZSY3MykpcmV0dXJuIDJ9ZWxzZSByZXR1cm4gMjtyZXR1cm4gMH0sd2M9KGEsYik9Pnt0cnl7cmV0dXJuIGdjKGEsYiksMjB9Y2F0Y2goYyl7fXJldHVybiBzYyhhLCJ3eCIpfSx4Yz0oYT0wKT0+e2Zvcig7NDA5Nj49YTthKyspaWYoIWtjW2FdKXJldHVybiBhO3Rocm93IG5ldyBJKDMzKTt9LHpjPShhLGIpPT57eWN8fCh5Yz1mdW5jdGlvbigpe3RoaXMubGk9e319LHljLnByb3RvdHlwZT17fSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyh5Yy5wcm90b3R5cGUse29iamVjdDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZX0sCnNldDpmdW5jdGlvbihjKXt0aGlzLm5vZGU9Y319LGZsYWdzOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saS5mbGFnc30sc2V0OmZ1bmN0aW9uKGMpe3RoaXMubGkuZmxhZ3M9Y319LHBvc2l0aW9uOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saS5wb3NpdGlvbn0sc2V0OmZ1bmN0aW9uKGMpe3RoaXMubGkucG9zaXRpb249Y319fSkpO2E9T2JqZWN0LmFzc2lnbihuZXcgeWMsYSk7Yj14YyhiKTthLmZkPWI7cmV0dXJuIGtjW2JdPWF9LGNjPXtvcGVuOmE9PnthLmZpPWpjW2Eubm9kZS5yZGV2XS5maTthLmZpLm9wZW4mJmEuZmkub3BlbihhKX0sR2k6KCk9Pnt0aHJvdyBuZXcgSSg3MCk7fX0sWmI9KGEsYik9PntqY1thXT17Zmk6Yn19LEFjPShhLGIpPT57dmFyIGM9Ii8iPT09YixkPSFiO2lmKGMmJmljKXRocm93IG5ldyBJKDEwKTtpZighYyYmIWQpe3ZhciBlPXBjKGIse1ZqOiExfSk7Yj1lLnBhdGg7ZT1lLm5vZGU7aWYoZS5UaSl0aHJvdyBuZXcgSSgxMCk7aWYoMTYzODQhPT0KKGUubW9kZSY2MTQ0MCkpdGhyb3cgbmV3IEkoNTQpO31iPXt0eXBlOmEsbmw6e30sJGo6YixFazpbXX07YT1hLkFpKGIpO2EuQWk9YjtiLnJvb3Q9YTtjP2ljPWE6ZSYmKGUuVGk9YixlLkFpJiZlLkFpLkVrLnB1c2goYikpfSxCYz0oYSxiLGMpPT57dmFyIGQ9cGMoYSx7cGFyZW50OiEwfSkubm9kZTthPVRiKGEpO2lmKCFhfHwiLiI9PT1hfHwiLi4iPT09YSl0aHJvdyBuZXcgSSgyOCk7dmFyIGU9d2MoZCxhKTtpZihlKXRocm93IG5ldyBJKGUpO2lmKCFkLmVpLmlqKXRocm93IG5ldyBJKDYzKTtyZXR1cm4gZC5laS5paihkLGEsYixjKX0sQ2M9KGEsYixjKT0+eyJ1bmRlZmluZWQiPT10eXBlb2YgYyYmKGM9YixiPTQzOCk7cmV0dXJuIEJjKGEsYnw4MTkyLGMpfSxEYz0oYSxiKT0+e2lmKCFWYihhKSl0aHJvdyBuZXcgSSg0NCk7dmFyIGM9cGMoYix7cGFyZW50OiEwfSkubm9kZTtpZighYyl0aHJvdyBuZXcgSSg0NCk7Yj1UYihiKTt2YXIgZD13YyhjLGIpO2lmKGQpdGhyb3cgbmV3IEkoZCk7CmlmKCFjLmVpLnN5bWxpbmspdGhyb3cgbmV3IEkoNjMpO2MuZWkuc3ltbGluayhjLGIsYSl9LEVjPWE9Pnt2YXIgYj1wYyhhLHtwYXJlbnQ6ITB9KS5ub2RlO2lmKCFiKXRocm93IG5ldyBJKDQ0KTt2YXIgYz1UYihhKTthPWdjKGIsYyk7YTp7dHJ5e3ZhciBkPWdjKGIsYyl9Y2F0Y2goZil7ZD1mLkRpO2JyZWFrIGF9dmFyIGU9c2MoYiwid3giKTtkPWU/ZToxNjM4ND09PShkLm1vZGUmNjE0NDApPzMxOjB9aWYoZCl0aHJvdyBuZXcgSShkKTtpZighYi5laS51bmxpbmspdGhyb3cgbmV3IEkoNjMpO2lmKGEuVGkpdGhyb3cgbmV3IEkoMTApO2IuZWkudW5saW5rKGIsYyk7Yj1yYyhhLnBhcmVudC5pZCxhLm5hbWUpO2lmKG1jW2JdPT09YSltY1tiXT1hLk9pO2Vsc2UgZm9yKGI9bWNbYl07Yjspe2lmKGIuT2k9PT1hKXtiLk9pPWEuT2k7YnJlYWt9Yj1iLk9pfX0sb2M9YT0+e2E9cGMoYSkubm9kZTtpZighYSl0aHJvdyBuZXcgSSg0NCk7aWYoIWEuZWkucmVhZGxpbmspdGhyb3cgbmV3IEkoMjgpOwpyZXR1cm4gVmIocWMoYS5wYXJlbnQpLGEuZWkucmVhZGxpbmsoYSkpfSxGYz0oYSxiKT0+e2E9InN0cmluZyI9PXR5cGVvZiBhP3BjKGEse3JqOiEwfSkubm9kZTphO2lmKCFhLmVpLnJpKXRocm93IG5ldyBJKDYzKTthLmVpLnJpKGEse21vZGU6YiY0MDk1fGEubW9kZSYtNDA5Nix0aW1lc3RhbXA6RGF0ZS5ub3coKX0pfSxIYz0oYSxiLGMpPT57aWYoIiI9PT1hKXRocm93IG5ldyBJKDQ0KTtpZigic3RyaW5nIj09dHlwZW9mIGIpe3ZhciBkPXVjW2JdO2lmKCJ1bmRlZmluZWQiPT10eXBlb2YgZCl0aHJvdyBFcnJvcigiVW5rbm93biBmaWxlIG9wZW4gbW9kZTogIitiKTtiPWR9Yz1iJjY0PygidW5kZWZpbmVkIj09dHlwZW9mIGM/NDM4OmMpJjQwOTV8MzI3Njg6MDtpZigib2JqZWN0Ij09dHlwZW9mIGEpdmFyIGU9YTtlbHNle2E9UmIoYSk7dHJ5e2U9cGMoYSx7cmo6IShiJjEzMTA3Mil9KS5ub2RlfWNhdGNoKGYpe319ZD0hMTtpZihiJjY0KWlmKGUpe2lmKGImMTI4KXRocm93IG5ldyBJKDIwKTsKfWVsc2UgZT1CYyhhLGMsMCksZD0hMDtpZighZSl0aHJvdyBuZXcgSSg0NCk7ODE5Mj09PShlLm1vZGUmNjE0NDApJiYoYiY9LTUxMyk7aWYoYiY2NTUzNiYmMTYzODQhPT0oZS5tb2RlJjYxNDQwKSl0aHJvdyBuZXcgSSg1NCk7aWYoIWQmJihjPWU/NDA5NjA9PT0oZS5tb2RlJjYxNDQwKT8zMjoxNjM4ND09PShlLm1vZGUmNjE0NDApJiYoInIiIT09dmMoYil8fGImNTEyKT8zMTpzYyhlLHZjKGIpKTo0NCkpdGhyb3cgbmV3IEkoYyk7aWYoYiY1MTImJiFkKXtjPWU7Yz0ic3RyaW5nIj09dHlwZW9mIGM/cGMoYyx7cmo6ITB9KS5ub2RlOmM7aWYoIWMuZWkucmkpdGhyb3cgbmV3IEkoNjMpO2lmKDE2Mzg0PT09KGMubW9kZSY2MTQ0MCkpdGhyb3cgbmV3IEkoMzEpO2lmKDMyNzY4IT09KGMubW9kZSY2MTQ0MCkpdGhyb3cgbmV3IEkoMjgpO2lmKGQ9c2MoYywidyIpKXRocm93IG5ldyBJKGQpO2MuZWkucmkoYyx7c2l6ZTowLHRpbWVzdGFtcDpEYXRlLm5vdygpfSl9YiY9LTEzMTcxMztlPQp6Yyh7bm9kZTplLHBhdGg6cWMoZSksZmxhZ3M6YixzZWVrYWJsZTohMCxwb3NpdGlvbjowLGZpOmUuZmksWWs6W10sZXJyb3I6ITF9KTtlLmZpLm9wZW4mJmUuZmkub3BlbihlKTshZy5sb2dSZWFkRmlsZXN8fGImMXx8KEdjfHwoR2M9e30pLGEgaW4gR2N8fChHY1thXT0xKSk7cmV0dXJuIGV9LEljPWE9PntpZihudWxsPT09YS5mZCl0aHJvdyBuZXcgSSg4KTthLnNqJiYoYS5zaj1udWxsKTt0cnl7YS5maS5jbG9zZSYmYS5maS5jbG9zZShhKX1jYXRjaChiKXt0aHJvdyBiO31maW5hbGx5e2tjW2EuZmRdPW51bGx9YS5mZD1udWxsfSxKYz0oYSxiLGMpPT57aWYobnVsbD09PWEuZmQpdGhyb3cgbmV3IEkoOCk7aWYoIWEuc2Vla2FibGV8fCFhLmZpLkdpKXRocm93IG5ldyBJKDcwKTtpZigwIT1jJiYxIT1jJiYyIT1jKXRocm93IG5ldyBJKDI4KTthLnBvc2l0aW9uPWEuZmkuR2koYSxiLGMpO2EuWWs9W119LE9jPShhLGIsYyxkLGUsZik9PntpZigwPmR8fDA+ZSl0aHJvdyBuZXcgSSgyOCk7CmlmKG51bGw9PT1hLmZkKXRocm93IG5ldyBJKDgpO2lmKDA9PT0oYS5mbGFncyYyMDk3MTU1KSl0aHJvdyBuZXcgSSg4KTtpZigxNjM4ND09PShhLm5vZGUubW9kZSY2MTQ0MCkpdGhyb3cgbmV3IEkoMzEpO2lmKCFhLmZpLndyaXRlKXRocm93IG5ldyBJKDI4KTthLnNlZWthYmxlJiZhLmZsYWdzJjEwMjQmJkpjKGEsMCwyKTt2YXIgbD0idW5kZWZpbmVkIiE9dHlwZW9mIGU7aWYoIWwpZT1hLnBvc2l0aW9uO2Vsc2UgaWYoIWEuc2Vla2FibGUpdGhyb3cgbmV3IEkoNzApO2I9YS5maS53cml0ZShhLGIsYyxkLGUsZik7bHx8KGEucG9zaXRpb24rPWIpO3JldHVybiBifSxQYz0oKT0+e0l8fChJPWZ1bmN0aW9uKGEsYil7dGhpcy5ub2RlPWI7dGhpcy5Naz1mdW5jdGlvbihjKXt0aGlzLkRpPWN9O3RoaXMuTWsoYSk7dGhpcy5tZXNzYWdlPSJGUyBlcnJvciJ9LEkucHJvdG90eXBlPUVycm9yKCksSS5wcm90b3R5cGUuY29uc3RydWN0b3I9SSxbNDRdLmZvckVhY2goYT0+e2ZjW2FdPW5ldyBJKGEpOwpmY1thXS5zdGFjaz0iPGdlbmVyaWMgZXJyb3IsIG5vIHN0YWNrPiJ9KSl9LFFjLFJjPShhLGIpPT57dmFyIGM9MDthJiYoY3w9MzY1KTtiJiYoY3w9MTQ2KTtyZXR1cm4gY30sU2M9KGEsYik9PnthPSJzdHJpbmciPT10eXBlb2YgYT9hOnFjKGEpO2ZvcihiPWIuc3BsaXQoIi8iKS5yZXZlcnNlKCk7Yi5sZW5ndGg7KXt2YXIgYz1iLnBvcCgpO2lmKGMpe3ZhciBkPVJiKGErIi8iK2MpO3RyeXtCYyhkLDE2ODk1LDApfWNhdGNoKGUpe31hPWR9fXJldHVybiBkfSxUYz0oYSxiLGMsZCk9PnthPVJiKCgic3RyaW5nIj09dHlwZW9mIGE/YTpxYyhhKSkrIi8iK2IpO2M9UmMoYyxkKTtyZXR1cm4gQmMoYSwodm9pZCAwIT09Yz9jOjQzOCkmNDA5NXwzMjc2OCwwKX0sVWM9KGEsYixjLGQsZSxmKT0+e3ZhciBsPWI7YSYmKGE9InN0cmluZyI9PXR5cGVvZiBhP2E6cWMoYSksbD1iP1JiKGErIi8iK2IpOmEpO2E9UmMoZCxlKTtsPUJjKGwsKHZvaWQgMCE9PWE/YTo0MzgpJjQwOTV8MzI3NjgsMCk7CmlmKGMpe2lmKCJzdHJpbmciPT10eXBlb2YgYyl7Yj1BcnJheShjLmxlbmd0aCk7ZD0wO2ZvcihlPWMubGVuZ3RoO2Q8ZTsrK2QpYltkXT1jLmNoYXJDb2RlQXQoZCk7Yz1ifUZjKGwsYXwxNDYpO2I9SGMobCw1NzcpO09jKGIsYywwLGMubGVuZ3RoLDAsZik7SWMoYik7RmMobCxhKX1yZXR1cm4gbH0sVmM9KGEsYixjLGQpPT57YT1SYigoInN0cmluZyI9PXR5cGVvZiBhP2E6cWMoYSkpKyIvIitiKTtiPVJjKCEhYywhIWQpO1ZjLlpqfHwoVmMuWmo9NjQpO3ZhciBlPVZjLlpqKys8PDh8MDtaYihlLHtvcGVuOmY9PntmLnNlZWthYmxlPSExfSxjbG9zZTooKT0+e2QmJmQuYnVmZmVyJiZkLmJ1ZmZlci5sZW5ndGgmJmQoMTApfSxyZWFkOihmLGwsbixxKT0+e2Zvcih2YXIgdj0wLHc9MDt3PHE7dysrKXt0cnl7dmFyIEM9YygpfWNhdGNoKEcpe3Rocm93IG5ldyBJKDI5KTt9aWYodm9pZCAwPT09QyYmMD09PXYpdGhyb3cgbmV3IEkoNik7aWYobnVsbD09PUN8fHZvaWQgMD09PUMpYnJlYWs7CnYrKztsW24rd109Q312JiYoZi5ub2RlLnRpbWVzdGFtcD1EYXRlLm5vdygpKTtyZXR1cm4gdn0sd3JpdGU6KGYsbCxuLHEpPT57Zm9yKHZhciB2PTA7djxxO3YrKyl0cnl7ZChsW24rdl0pfWNhdGNoKHcpe3Rocm93IG5ldyBJKDI5KTt9cSYmKGYubm9kZS50aW1lc3RhbXA9RGF0ZS5ub3coKSk7cmV0dXJuIHZ9fSk7cmV0dXJuIENjKGEsYixlKX0sV2M9YT0+e2lmKCEoYS5Ba3x8YS5Ca3x8YS5saW5rfHxhLmRpKSl7aWYoInVuZGVmaW5lZCIhPXR5cGVvZiBYTUxIdHRwUmVxdWVzdCl0aHJvdyBFcnJvcigiTGF6eSBsb2FkaW5nIHNob3VsZCBoYXZlIGJlZW4gcGVyZm9ybWVkIChjb250ZW50cyBzZXQpIGluIGNyZWF0ZUxhenlGaWxlLCBidXQgaXQgd2FzIG5vdC4gTGF6eSBsb2FkaW5nIG9ubHkgd29ya3MgaW4gd2ViIHdvcmtlcnMuIFVzZSAtLWVtYmVkLWZpbGUgb3IgLS1wcmVsb2FkLWZpbGUgaW4gZW1jYyBvbiB0aGUgbWFpbiB0aHJlYWQuIik7aWYoTWEpdHJ5e2EuZGk9V2IoTWEoYS51cmwpLAohMCksYS5paT1hLmRpLmxlbmd0aH1jYXRjaChiKXt0aHJvdyBuZXcgSSgyOSk7fWVsc2UgdGhyb3cgRXJyb3IoIkNhbm5vdCBsb2FkIHdpdGhvdXQgcmVhZCgpIG9yIFhNTEh0dHBSZXF1ZXN0LiIpO319LFhjPShhLGIsYyxkLGUpPT57ZnVuY3Rpb24gZigpe3RoaXMueGo9ITE7dGhpcy5saT1bXX1mLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odyl7aWYoISh3PnRoaXMubGVuZ3RoLTF8fDA+dykpe3ZhciBDPXcldGhpcy5jaHVua1NpemU7cmV0dXJuIHRoaXMuTmkody90aGlzLmNodW5rU2l6ZXwwKVtDXX19O2YucHJvdG90eXBlLnBrPWZ1bmN0aW9uKHcpe3RoaXMuTmk9d307Zi5wcm90b3R5cGUuTWo9ZnVuY3Rpb24oKXt2YXIgdz1uZXcgWE1MSHR0cFJlcXVlc3Q7dy5vcGVuKCJIRUFEIixjLCExKTt3LnNlbmQobnVsbCk7aWYoISgyMDA8PXcuc3RhdHVzJiYzMDA+dy5zdGF0dXN8fDMwND09PXcuc3RhdHVzKSl0aHJvdyBFcnJvcigiQ291bGRuJ3QgbG9hZCAiK2MrIi4gU3RhdHVzOiAiKwp3LnN0YXR1cyk7dmFyIEM9TnVtYmVyKHcuZ2V0UmVzcG9uc2VIZWFkZXIoIkNvbnRlbnQtbGVuZ3RoIikpLEcscD0oRz13LmdldFJlc3BvbnNlSGVhZGVyKCJBY2NlcHQtUmFuZ2VzIikpJiYiYnl0ZXMiPT09Rzt3PShHPXcuZ2V0UmVzcG9uc2VIZWFkZXIoIkNvbnRlbnQtRW5jb2RpbmciKSkmJiJnemlwIj09PUc7dmFyIHk9MTA0ODU3NjtwfHwoeT1DKTt2YXIgRj10aGlzO0YucGsoUj0+e3ZhciBiYT1SKnksTT0oUisxKSp5LTE7TT1NYXRoLm1pbihNLEMtMSk7aWYoInVuZGVmaW5lZCI9PXR5cGVvZiBGLmxpW1JdKXt2YXIgRT1GLmxpO2lmKGJhPk0pdGhyb3cgRXJyb3IoImludmFsaWQgcmFuZ2UgKCIrYmErIiwgIitNKyIpIG9yIG5vIGJ5dGVzIHJlcXVlc3RlZCEiKTtpZihNPkMtMSl0aHJvdyBFcnJvcigib25seSAiK0MrIiBieXRlcyBhdmFpbGFibGUhIHByb2dyYW1tZXIgZXJyb3IhIik7dmFyIEE9bmV3IFhNTEh0dHBSZXF1ZXN0O0Eub3BlbigiR0VUIixjLCExKTtDIT09eSYmCkEuc2V0UmVxdWVzdEhlYWRlcigiUmFuZ2UiLCJieXRlcz0iK2JhKyItIitNKTtBLnJlc3BvbnNlVHlwZT0iYXJyYXlidWZmZXIiO0Eub3ZlcnJpZGVNaW1lVHlwZSYmQS5vdmVycmlkZU1pbWVUeXBlKCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkIik7QS5zZW5kKG51bGwpO2lmKCEoMjAwPD1BLnN0YXR1cyYmMzAwPkEuc3RhdHVzfHwzMDQ9PT1BLnN0YXR1cykpdGhyb3cgRXJyb3IoIkNvdWxkbid0IGxvYWQgIitjKyIuIFN0YXR1czogIitBLnN0YXR1cyk7YmE9dm9pZCAwIT09QS5yZXNwb25zZT9uZXcgVWludDhBcnJheShBLnJlc3BvbnNlfHxbXSk6V2IoQS5yZXNwb25zZVRleHR8fCIiLCEwKTtFW1JdPWJhfWlmKCJ1bmRlZmluZWQiPT10eXBlb2YgRi5saVtSXSl0aHJvdyBFcnJvcigiZG9YSFIgZmFpbGVkISIpO3JldHVybiBGLmxpW1JdfSk7aWYod3x8IUMpeT1DPTEseT1DPXRoaXMuTmkoMCkubGVuZ3RoLFRhKCJMYXp5RmlsZXMgb24gZ3ppcCBmb3JjZXMgZG93bmxvYWQgb2YgdGhlIHdob2xlIGZpbGUgd2hlbiBsZW5ndGggaXMgYWNjZXNzZWQiKTsKdGhpcy5qaz1DO3RoaXMuaWs9eTt0aGlzLnhqPSEwfTtpZigidW5kZWZpbmVkIiE9dHlwZW9mIFhNTEh0dHBSZXF1ZXN0KXtpZighRmEpdGhyb3ciQ2Fubm90IGRvIHN5bmNocm9ub3VzIGJpbmFyeSBYSFJzIG91dHNpZGUgd2Vid29ya2VycyBpbiBtb2Rlcm4gYnJvd3NlcnMuIFVzZSAtLWVtYmVkLWZpbGUgb3IgLS1wcmVsb2FkLWZpbGUgaW4gZW1jYyI7dmFyIGw9bmV3IGY7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMobCx7bGVuZ3RoOntnZXQ6ZnVuY3Rpb24oKXt0aGlzLnhqfHx0aGlzLk1qKCk7cmV0dXJuIHRoaXMuamt9fSxjaHVua1NpemU6e2dldDpmdW5jdGlvbigpe3RoaXMueGp8fHRoaXMuTWooKTtyZXR1cm4gdGhpcy5pa319fSk7dmFyIG49dm9pZCAwfWVsc2Ugbj1jLGw9dm9pZCAwO3ZhciBxPVRjKGEsYixkLGUpO2w/cS5kaT1sOm4mJihxLmRpPW51bGwscS51cmw9bik7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocSx7aWk6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpLmxlbmd0aH19fSk7CnZhciB2PXt9O09iamVjdC5rZXlzKHEuZmkpLmZvckVhY2godz0+e3ZhciBDPXEuZmlbd107dlt3XT1mdW5jdGlvbigpe1djKHEpO3JldHVybiBDLmFwcGx5KG51bGwsYXJndW1lbnRzKX19KTt2LnJlYWQ9KHcsQyxHLHAseSk9PntXYyhxKTt3PXcubm9kZS5kaTtpZih5Pj13Lmxlbmd0aClDPTA7ZWxzZXtwPU1hdGgubWluKHcubGVuZ3RoLXkscCk7aWYody5zbGljZSlmb3IodmFyIEY9MDtGPHA7RisrKUNbRytGXT13W3krRl07ZWxzZSBmb3IoRj0wO0Y8cDtGKyspQ1tHK0ZdPXcuZ2V0KHkrRik7Qz1wfXJldHVybiBDfTt2LnpqPSgpPT57V2MocSk7VmEoKTt0aHJvdyBuZXcgSSg0OCk7fTtxLmZpPXY7cmV0dXJuIHF9LFpjPShhLGIsYyxkLGUsZixsLG4scSx2KT0+e2Z1bmN0aW9uIHcocCl7ZnVuY3Rpb24geShGKXt2JiZ2KCk7bnx8VWMoYSxiLEYsZCxlLHEpO2YmJmYoKTt5YihHKX1ZYyhwLEMseSwoKT0+e2wmJmwoKTt5YihHKX0pfHx5KHApfXZhciBDPWI/VmIoUmIoYSsiLyIrYikpOgphLEc9ImNwICIrQzt4YihHKTsic3RyaW5nIj09dHlwZW9mIGM/aGMoYyxwPT53KHApLGwpOncoYyl9LCRjPXt9LHljLEdjLGFkPXZvaWQgMDtmdW5jdGlvbiBiZCgpe2FkKz00O3JldHVybiBEW2FkLTQ+PjJdfWZ1bmN0aW9uIGNkKGEpe2E9a2NbYV07aWYoIWEpdGhyb3cgbmV3IEkoOCk7cmV0dXJuIGF9dmFyIGRkPXt9O2Z1bmN0aW9uIGVkKGEpe2Zvcig7YS5sZW5ndGg7KXt2YXIgYj1hLnBvcCgpO2EucG9wKCkoYil9fWZ1bmN0aW9uIGZkKGEpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShEW2E+PjJdKX12YXIgZ2Q9e30saGQ9e30samQ9e307ZnVuY3Rpb24ga2QoYSl7aWYodm9pZCAwPT09YSlyZXR1cm4iX3Vua25vd24iO2E9YS5yZXBsYWNlKC9bXmEtekEtWjAtOV9dL2csIiQiKTt2YXIgYj1hLmNoYXJDb2RlQXQoMCk7cmV0dXJuIDQ4PD1iJiY1Nz49Yj8iXyIrYTphfQpmdW5jdGlvbiBsZChhLGIpe2E9a2QoYSk7cmV0dXJuKG5ldyBGdW5jdGlvbigiYm9keSIsInJldHVybiBmdW5jdGlvbiAiK2ErJygpIHtcbiAgICAidXNlIHN0cmljdCI7ICAgIHJldHVybiBib2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuJykpKGIpfWZ1bmN0aW9uIG1kKGEpe3ZhciBiPUVycm9yLGM9bGQoYSxmdW5jdGlvbihkKXt0aGlzLm5hbWU9YTt0aGlzLm1lc3NhZ2U9ZDtkPUVycm9yKGQpLnN0YWNrO3ZvaWQgMCE9PWQmJih0aGlzLnN0YWNrPXRoaXMudG9TdHJpbmcoKSsiXG4iK2QucmVwbGFjZSgvXkVycm9yKDpbXlxuXSopP1xuLywiIikpfSk7Yy5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShiLnByb3RvdHlwZSk7Yy5wcm90b3R5cGUuY29uc3RydWN0b3I9YztjLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB2b2lkIDA9PT10aGlzLm1lc3NhZ2U/dGhpcy5uYW1lOnRoaXMubmFtZSsiOiAiK3RoaXMubWVzc2FnZX07cmV0dXJuIGN9CnZhciBuZD12b2lkIDA7ZnVuY3Rpb24gb2QoYSl7dGhyb3cgbmV3IG5kKGEpO31mdW5jdGlvbiBwZChhLGIsYyl7ZnVuY3Rpb24gZChuKXtuPWMobik7bi5sZW5ndGghPT1hLmxlbmd0aCYmb2QoIk1pc21hdGNoZWQgdHlwZSBjb252ZXJ0ZXIgY291bnQiKTtmb3IodmFyIHE9MDtxPGEubGVuZ3RoOysrcSlxZChhW3FdLG5bcV0pfWEuZm9yRWFjaChmdW5jdGlvbihuKXtqZFtuXT1ifSk7dmFyIGU9QXJyYXkoYi5sZW5ndGgpLGY9W10sbD0wO2IuZm9yRWFjaCgobixxKT0+e2hkLmhhc093blByb3BlcnR5KG4pP2VbcV09aGRbbl06KGYucHVzaChuKSxnZC5oYXNPd25Qcm9wZXJ0eShuKXx8KGdkW25dPVtdKSxnZFtuXS5wdXNoKCgpPT57ZVtxXT1oZFtuXTsrK2w7bD09PWYubGVuZ3RoJiZkKGUpfSkpfSk7MD09PWYubGVuZ3RoJiZkKGUpfXZhciByZD17fTsKZnVuY3Rpb24gc2QoYSl7c3dpdGNoKGEpe2Nhc2UgMTpyZXR1cm4gMDtjYXNlIDI6cmV0dXJuIDE7Y2FzZSA0OnJldHVybiAyO2Nhc2UgODpyZXR1cm4gMztkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gdHlwZSBzaXplOiAiK2EpO319dmFyIHRkPXZvaWQgMDtmdW5jdGlvbiB1ZChhKXtmb3IodmFyIGI9IiI7dFthXTspYis9dGRbdFthKytdXTtyZXR1cm4gYn12YXIgdmQ9dm9pZCAwO2Z1bmN0aW9uIHhkKGEpe3Rocm93IG5ldyB2ZChhKTt9CmZ1bmN0aW9uIHFkKGEsYixjPXt9KXtpZighKCJhcmdQYWNrQWR2YW5jZSJpbiBiKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJyZWdpc3RlclR5cGUgcmVnaXN0ZXJlZEluc3RhbmNlIHJlcXVpcmVzIGFyZ1BhY2tBZHZhbmNlIik7dmFyIGQ9Yi5uYW1lO2F8fHhkKCd0eXBlICInK2QrJyIgbXVzdCBoYXZlIGEgcG9zaXRpdmUgaW50ZWdlciB0eXBlaWQgcG9pbnRlcicpO2lmKGhkLmhhc093blByb3BlcnR5KGEpKXtpZihjLnhrKXJldHVybjt4ZCgiQ2Fubm90IHJlZ2lzdGVyIHR5cGUgJyIrZCsiJyB0d2ljZSIpfWhkW2FdPWI7ZGVsZXRlIGpkW2FdO2dkLmhhc093blByb3BlcnR5KGEpJiYoYj1nZFthXSxkZWxldGUgZ2RbYV0sYi5mb3JFYWNoKGU9PmUoKSkpfWZ1bmN0aW9uIHlkKGEpe3hkKGEuY2kua2kuamkubmFtZSsiIGluc3RhbmNlIGFscmVhZHkgZGVsZXRlZCIpfXZhciB6ZD0hMTtmdW5jdGlvbiBBZCgpe30KZnVuY3Rpb24gQmQoYSl7LS1hLmNvdW50LnZhbHVlOzA9PT1hLmNvdW50LnZhbHVlJiYoYS5vaT9hLnRpLnNpKGEub2kpOmEua2kuamkuc2koYS5oaSkpfWZ1bmN0aW9uIENkKGEsYixjKXtpZihiPT09YylyZXR1cm4gYTtpZih2b2lkIDA9PT1jLnVpKXJldHVybiBudWxsO2E9Q2QoYSxiLGMudWkpO3JldHVybiBudWxsPT09YT9udWxsOmMucWsoYSl9dmFyIERkPXt9LEVkPVtdO2Z1bmN0aW9uIEZkKCl7Zm9yKDtFZC5sZW5ndGg7KXt2YXIgYT1FZC5wb3AoKTthLmNpLk1pPSExO2FbImRlbGV0ZSJdKCl9fXZhciBHZD12b2lkIDAsSGQ9e307ZnVuY3Rpb24gSWQoYSxiKXtmb3Iodm9pZCAwPT09YiYmeGQoInB0ciBzaG91bGQgbm90IGJlIHVuZGVmaW5lZCIpO2EudWk7KWI9YS5XaShiKSxhPWEudWk7cmV0dXJuIEhkW2JdfQpmdW5jdGlvbiBKZChhLGIpe2Iua2kmJmIuaGl8fG9kKCJtYWtlQ2xhc3NIYW5kbGUgcmVxdWlyZXMgcHRyIGFuZCBwdHJUeXBlIik7ISFiLnRpIT09ISFiLm9pJiZvZCgiQm90aCBzbWFydFB0clR5cGUgYW5kIHNtYXJ0UHRyIG11c3QgYmUgc3BlY2lmaWVkIik7Yi5jb3VudD17dmFsdWU6MX07cmV0dXJuIEtkKE9iamVjdC5jcmVhdGUoYSx7Y2k6e3ZhbHVlOmJ9fSkpfWZ1bmN0aW9uIEtkKGEpe2lmKCJ1bmRlZmluZWQiPT09dHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5KXJldHVybiBLZD1iPT5iLGE7emQ9bmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KGI9PntCZChiLmNpKX0pO0tkPWI9Pnt2YXIgYz1iLmNpO2Mub2kmJnpkLnJlZ2lzdGVyKGIse2NpOmN9LGIpO3JldHVybiBifTtBZD1iPT57emQudW5yZWdpc3RlcihiKX07cmV0dXJuIEtkKGEpfWZ1bmN0aW9uIExkKCl7fQpmdW5jdGlvbiBNZChhLGIsYyl7aWYodm9pZCAwPT09YVtiXS5CaSl7dmFyIGQ9YVtiXTthW2JdPWZ1bmN0aW9uKCl7YVtiXS5CaS5oYXNPd25Qcm9wZXJ0eShhcmd1bWVudHMubGVuZ3RoKXx8eGQoIkZ1bmN0aW9uICciK2MrIicgY2FsbGVkIHdpdGggYW4gaW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzICgiK2FyZ3VtZW50cy5sZW5ndGgrIikgLSBleHBlY3RzIG9uZSBvZiAoIithW2JdLkJpKyIpISIpO3JldHVybiBhW2JdLkJpW2FyZ3VtZW50cy5sZW5ndGhdLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07YVtiXS5CaT1bXTthW2JdLkJpW2QucGpdPWR9fQpmdW5jdGlvbiBOZChhLGIpe2cuaGFzT3duUHJvcGVydHkoYSk/KHhkKCJDYW5ub3QgcmVnaXN0ZXIgcHVibGljIG5hbWUgJyIrYSsiJyB0d2ljZSIpLE1kKGcsYSxhKSxnLmhhc093blByb3BlcnR5KHZvaWQgMCkmJnhkKCJDYW5ub3QgcmVnaXN0ZXIgbXVsdGlwbGUgb3ZlcmxvYWRzIG9mIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzICh1bmRlZmluZWQpISIpLGdbYV0uQmlbdm9pZCAwXT1iKTpnW2FdPWJ9ZnVuY3Rpb24gT2QoYSxiLGMsZCxlLGYsbCxuKXt0aGlzLm5hbWU9YTt0aGlzLmNvbnN0cnVjdG9yPWI7dGhpcy5TaT1jO3RoaXMuc2k9ZDt0aGlzLnVpPWU7dGhpcy50az1mO3RoaXMuV2k9bDt0aGlzLnFrPW59CmZ1bmN0aW9uIFBkKGEsYixjKXtmb3IoO2IhPT1jOyliLldpfHx4ZCgiRXhwZWN0ZWQgbnVsbCBvciBpbnN0YW5jZSBvZiAiK2MubmFtZSsiLCBnb3QgYW4gaW5zdGFuY2Ugb2YgIitiLm5hbWUpLGE9Yi5XaShhKSxiPWIudWk7cmV0dXJuIGF9ZnVuY3Rpb24gUWQoYSxiKXtpZihudWxsPT09YilyZXR1cm4gdGhpcy53aiYmeGQoIm51bGwgaXMgbm90IGEgdmFsaWQgIit0aGlzLm5hbWUpLDA7Yi5jaXx8eGQoJ0Nhbm5vdCBwYXNzICInK1JkKGIpKyciIGFzIGEgJyt0aGlzLm5hbWUpO2IuY2kuaGl8fHhkKCJDYW5ub3QgcGFzcyBkZWxldGVkIG9iamVjdCBhcyBhIHBvaW50ZXIgb2YgdHlwZSAiK3RoaXMubmFtZSk7cmV0dXJuIFBkKGIuY2kuaGksYi5jaS5raS5qaSx0aGlzLmppKX0KZnVuY3Rpb24gU2QoYSxiKXtpZihudWxsPT09Yil7dGhpcy53aiYmeGQoIm51bGwgaXMgbm90IGEgdmFsaWQgIit0aGlzLm5hbWUpO2lmKHRoaXMuZGope3ZhciBjPXRoaXMuVmkoKTtudWxsIT09YSYmYS5wdXNoKHRoaXMuc2ksYyk7cmV0dXJuIGN9cmV0dXJuIDB9Yi5jaXx8eGQoJ0Nhbm5vdCBwYXNzICInK1JkKGIpKyciIGFzIGEgJyt0aGlzLm5hbWUpO2IuY2kuaGl8fHhkKCJDYW5ub3QgcGFzcyBkZWxldGVkIG9iamVjdCBhcyBhIHBvaW50ZXIgb2YgdHlwZSAiK3RoaXMubmFtZSk7IXRoaXMuY2omJmIuY2kua2kuY2omJnhkKCJDYW5ub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlICIrKGIuY2kudGk/Yi5jaS50aS5uYW1lOmIuY2kua2kubmFtZSkrIiB0byBwYXJhbWV0ZXIgdHlwZSAiK3RoaXMubmFtZSk7Yz1QZChiLmNpLmhpLGIuY2kua2kuamksdGhpcy5qaSk7aWYodGhpcy5kailzd2l0Y2godm9pZCAwPT09Yi5jaS5vaSYmeGQoIlBhc3NpbmcgcmF3IHBvaW50ZXIgdG8gc21hcnQgcG9pbnRlciBpcyBpbGxlZ2FsIiksCnRoaXMuU2spe2Nhc2UgMDpiLmNpLnRpPT09dGhpcz9jPWIuY2kub2k6eGQoIkNhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgIisoYi5jaS50aT9iLmNpLnRpLm5hbWU6Yi5jaS5raS5uYW1lKSsiIHRvIHBhcmFtZXRlciB0eXBlICIrdGhpcy5uYW1lKTticmVhaztjYXNlIDE6Yz1iLmNpLm9pO2JyZWFrO2Nhc2UgMjppZihiLmNpLnRpPT09dGhpcyljPWIuY2kub2k7ZWxzZXt2YXIgZD1iLmNsb25lKCk7Yz10aGlzLklrKGMsVGQoZnVuY3Rpb24oKXtkWyJkZWxldGUiXSgpfSkpO251bGwhPT1hJiZhLnB1c2godGhpcy5zaSxjKX1icmVhaztkZWZhdWx0OnhkKCJVbnN1cHBvcnRpbmcgc2hhcmluZyBwb2xpY3kiKX1yZXR1cm4gY30KZnVuY3Rpb24gVWQoYSxiKXtpZihudWxsPT09YilyZXR1cm4gdGhpcy53aiYmeGQoIm51bGwgaXMgbm90IGEgdmFsaWQgIit0aGlzLm5hbWUpLDA7Yi5jaXx8eGQoJ0Nhbm5vdCBwYXNzICInK1JkKGIpKyciIGFzIGEgJyt0aGlzLm5hbWUpO2IuY2kuaGl8fHhkKCJDYW5ub3QgcGFzcyBkZWxldGVkIG9iamVjdCBhcyBhIHBvaW50ZXIgb2YgdHlwZSAiK3RoaXMubmFtZSk7Yi5jaS5raS5jaiYmeGQoIkNhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgIitiLmNpLmtpLm5hbWUrIiB0byBwYXJhbWV0ZXIgdHlwZSAiK3RoaXMubmFtZSk7cmV0dXJuIFBkKGIuY2kuaGksYi5jaS5raS5qaSx0aGlzLmppKX0KZnVuY3Rpb24gVmQoYSxiLGMsZCl7dGhpcy5uYW1lPWE7dGhpcy5qaT1iO3RoaXMud2o9Yzt0aGlzLmNqPWQ7dGhpcy5kaj0hMTt0aGlzLnNpPXRoaXMuSWs9dGhpcy5WaT10aGlzLmNrPXRoaXMuU2s9dGhpcy5Haz12b2lkIDA7dm9pZCAwIT09Yi51aT90aGlzLnRvV2lyZVR5cGU9U2Q6KHRoaXMudG9XaXJlVHlwZT1kP1FkOlVkLHRoaXMucGk9bnVsbCl9ZnVuY3Rpb24gV2QoYSxiKXtnLmhhc093blByb3BlcnR5KGEpfHxvZCgiUmVwbGFjaW5nIG5vbmV4aXN0YW50IHB1YmxpYyBzeW1ib2wiKTtnW2FdPWI7Z1thXS5waj12b2lkIDB9CmZ1bmN0aW9uIFhkKGEsYil7dmFyIGM9W107cmV0dXJuIGZ1bmN0aW9uKCl7Yy5sZW5ndGg9MDtPYmplY3QuYXNzaWduKGMsYXJndW1lbnRzKTtpZihhLmluY2x1ZGVzKCJqIikpe3ZhciBkPWdbImR5bkNhbGxfIithXTtkPWMmJmMubGVuZ3RoP2QuYXBwbHkobnVsbCxbYl0uY29uY2F0KGMpKTpkLmNhbGwobnVsbCxiKX1lbHNlIGQ9bmIuZ2V0KGIpLmFwcGx5KG51bGwsYyk7cmV0dXJuIGR9fWZ1bmN0aW9uIFlkKGEsYil7YT11ZChhKTt2YXIgYz1hLmluY2x1ZGVzKCJqIik/WGQoYSxiKTpuYi5nZXQoYik7ImZ1bmN0aW9uIiE9dHlwZW9mIGMmJnhkKCJ1bmtub3duIGZ1bmN0aW9uIHBvaW50ZXIgd2l0aCBzaWduYXR1cmUgIithKyI6ICIrYik7cmV0dXJuIGN9dmFyIFpkPXZvaWQgMDtmdW5jdGlvbiAkZChhKXthPWFlKGEpO3ZhciBiPXVkKGEpO2JlKGEpO3JldHVybiBifQpmdW5jdGlvbiBjZShhLGIpe2Z1bmN0aW9uIGMoZil7ZVtmXXx8aGRbZl18fChqZFtmXT9qZFtmXS5mb3JFYWNoKGMpOihkLnB1c2goZiksZVtmXT0hMCkpfXZhciBkPVtdLGU9e307Yi5mb3JFYWNoKGMpO3Rocm93IG5ldyBaZChhKyI6ICIrZC5tYXAoJGQpLmpvaW4oWyIsICJdKSk7fWZ1bmN0aW9uIGRlKGEpe3ZhciBiPUZ1bmN0aW9uO2lmKCEoYiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJuZXdfIGNhbGxlZCB3aXRoIGNvbnN0cnVjdG9yIHR5cGUgIit0eXBlb2YgYisiIHdoaWNoIGlzIG5vdCBhIGZ1bmN0aW9uIik7dmFyIGM9bGQoYi5uYW1lfHwidW5rbm93bkZ1bmN0aW9uTmFtZSIsZnVuY3Rpb24oKXt9KTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZTtjPW5ldyBjO2E9Yi5hcHBseShjLGEpO3JldHVybiBhIGluc3RhbmNlb2YgT2JqZWN0P2E6Y30KZnVuY3Rpb24gZWUoYSxiKXtmb3IodmFyIGM9W10sZD0wO2Q8YTtkKyspYy5wdXNoKGhbYis0KmQ+PjJdKTtyZXR1cm4gY312YXIgZmU9W10sZ2U9W3t9LHt2YWx1ZTp2b2lkIDB9LHt2YWx1ZTpudWxsfSx7dmFsdWU6ITB9LHt2YWx1ZTohMX1dO2Z1bmN0aW9uIGhlKGEpezQ8YSYmMD09PS0tZ2VbYV0uQ2omJihnZVthXT12b2lkIDAsZmUucHVzaChhKSl9dmFyIGllPWE9PnthfHx4ZCgiQ2Fubm90IHVzZSBkZWxldGVkIHZhbC4gaGFuZGxlID0gIithKTtyZXR1cm4gZ2VbYV0udmFsdWV9LFRkPWE9Pntzd2l0Y2goYSl7Y2FzZSB2b2lkIDA6cmV0dXJuIDE7Y2FzZSBudWxsOnJldHVybiAyO2Nhc2UgITA6cmV0dXJuIDM7Y2FzZSAhMTpyZXR1cm4gNDtkZWZhdWx0OnZhciBiPWZlLmxlbmd0aD9mZS5wb3AoKTpnZS5sZW5ndGg7Z2VbYl09e0NqOjEsdmFsdWU6YX07cmV0dXJuIGJ9fTsKZnVuY3Rpb24gamUoYSxiLGMpe3N3aXRjaChiKXtjYXNlIDA6cmV0dXJuIGZ1bmN0aW9uKGQpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZSgoYz9qYjp0KVtkXSl9O2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24oZCl7cmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKChjP2tiOmxiKVtkPj4xXSl9O2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24oZCl7cmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKChjP0Q6aClbZD4+Ml0pfTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gaW50ZWdlciB0eXBlOiAiK2EpO319ZnVuY3Rpb24ga2UoYSxiKXt2YXIgYz1oZFthXTt2b2lkIDA9PT1jJiZ4ZChiKyIgaGFzIHVua25vd24gdHlwZSAiKyRkKGEpKTtyZXR1cm4gY31mdW5jdGlvbiBSZChhKXtpZihudWxsPT09YSlyZXR1cm4ibnVsbCI7dmFyIGI9dHlwZW9mIGE7cmV0dXJuIm9iamVjdCI9PT1ifHwiYXJyYXkiPT09Ynx8ImZ1bmN0aW9uIj09PWI/YS50b1N0cmluZygpOiIiK2F9CmZ1bmN0aW9uIGxlKGEsYil7c3dpdGNoKGIpe2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24oYyl7cmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKEJbYz4+Ml0pfTtjYXNlIDM6cmV0dXJuIGZ1bmN0aW9uKGMpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShoYVtjPj4zXSl9O2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBmbG9hdCB0eXBlOiAiK2EpO319CmZ1bmN0aW9uIG1lKGEsYixjKXtzd2l0Y2goYil7Y2FzZSAwOnJldHVybiBjP2Z1bmN0aW9uKGQpe3JldHVybiBqYltkXX06ZnVuY3Rpb24oZCl7cmV0dXJuIHRbZF19O2Nhc2UgMTpyZXR1cm4gYz9mdW5jdGlvbihkKXtyZXR1cm4ga2JbZD4+MV19OmZ1bmN0aW9uKGQpe3JldHVybiBsYltkPj4xXX07Y2FzZSAyOnJldHVybiBjP2Z1bmN0aW9uKGQpe3JldHVybiBEW2Q+PjJdfTpmdW5jdGlvbihkKXtyZXR1cm4gaFtkPj4yXX07ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGludGVnZXIgdHlwZTogIithKTt9fXZhciBuZT0idW5kZWZpbmVkIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcigidXRmLTE2bGUiKTp2b2lkIDA7CmZ1bmN0aW9uIG9lKGEsYil7dmFyIGM9YT4+MTtmb3IodmFyIGQ9YytiLzI7IShjPj1kKSYmbGJbY107KSsrYztjPDw9MTtpZigzMjxjLWEmJm5lKXJldHVybiBuZS5kZWNvZGUodC5zdWJhcnJheShhLGMpKTtjPSIiO2ZvcihkPTA7IShkPj1iLzIpOysrZCl7dmFyIGU9a2JbYSsyKmQ+PjFdO2lmKDA9PWUpYnJlYWs7Yys9U3RyaW5nLmZyb21DaGFyQ29kZShlKX1yZXR1cm4gY31mdW5jdGlvbiBwZShhLGIsYyl7dm9pZCAwPT09YyYmKGM9MjE0NzQ4MzY0Nyk7aWYoMj5jKXJldHVybiAwO2MtPTI7dmFyIGQ9YjtjPWM8MiphLmxlbmd0aD9jLzI6YS5sZW5ndGg7Zm9yKHZhciBlPTA7ZTxjOysrZSlrYltiPj4xXT1hLmNoYXJDb2RlQXQoZSksYis9MjtrYltiPj4xXT0wO3JldHVybiBiLWR9ZnVuY3Rpb24gcWUoYSl7cmV0dXJuIDIqYS5sZW5ndGh9CmZ1bmN0aW9uIHJlKGEsYil7Zm9yKHZhciBjPTAsZD0iIjshKGM+PWIvNCk7KXt2YXIgZT1EW2ErNCpjPj4yXTtpZigwPT1lKWJyZWFrOysrYzs2NTUzNjw9ZT8oZS09NjU1MzYsZCs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxlPj4xMCw1NjMyMHxlJjEwMjMpKTpkKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGUpfXJldHVybiBkfWZ1bmN0aW9uIHNlKGEsYixjKXt2b2lkIDA9PT1jJiYoYz0yMTQ3NDgzNjQ3KTtpZig0PmMpcmV0dXJuIDA7dmFyIGQ9YjtjPWQrYy00O2Zvcih2YXIgZT0wO2U8YS5sZW5ndGg7KytlKXt2YXIgZj1hLmNoYXJDb2RlQXQoZSk7aWYoNTUyOTY8PWYmJjU3MzQzPj1mKXt2YXIgbD1hLmNoYXJDb2RlQXQoKytlKTtmPTY1NTM2KygoZiYxMDIzKTw8MTApfGwmMTAyM31EW2I+PjJdPWY7Yis9NDtpZihiKzQ+YylicmVha31EW2I+PjJdPTA7cmV0dXJuIGItZH0KZnVuY3Rpb24gdGUoYSl7Zm9yKHZhciBiPTAsYz0wO2M8YS5sZW5ndGg7KytjKXt2YXIgZD1hLmNoYXJDb2RlQXQoYyk7NTUyOTY8PWQmJjU3MzQzPj1kJiYrK2M7Yis9NH1yZXR1cm4gYn1mdW5jdGlvbiB1ZShhLGIpe2Zvcih2YXIgYz1BcnJheShhKSxkPTA7ZDxhOysrZCljW2RdPWtlKGhbYis0KmQ+PjJdLCJwYXJhbWV0ZXIgIitkKTtyZXR1cm4gY312YXIgdmU9e307ZnVuY3Rpb24gd2UoYSl7dmFyIGI9dmVbYV07cmV0dXJuIHZvaWQgMD09PWI/dWQoYSk6Yn12YXIgeGU9W107ZnVuY3Rpb24geWUoKXtyZXR1cm4ib2JqZWN0Ij09dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczpGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpfWZ1bmN0aW9uIHplKGEpe3ZhciBiPXhlLmxlbmd0aDt4ZS5wdXNoKGEpO3JldHVybiBifXZhciBBZT1bXTsKZnVuY3Rpb24gQmUoYSl7Zm9yKHZhciBiPSIiLGM9MDtjPGE7KytjKWIrPSgwIT09Yz8iLCAiOiIiKSsiYXJnIitjO3ZhciBkPSJyZXR1cm4gZnVuY3Rpb24gZW12YWxfYWxsb2NhdG9yXyIrYSsiKGNvbnN0cnVjdG9yLCBhcmdUeXBlcywgYXJncykge1xuICB2YXIgSEVBUFUzMiA9IGdldE1lbW9yeSgpO1xuIjtmb3IoYz0wO2M8YTsrK2MpZCs9InZhciBhcmdUeXBlIitjKyIgPSByZXF1aXJlUmVnaXN0ZXJlZFR5cGUoSEVBUFUzMlsoKGFyZ1R5cGVzKT4+MildLCAncGFyYW1ldGVyICIrYysiJyk7XG52YXIgYXJnIitjKyIgPSBhcmdUeXBlIitjKyIucmVhZFZhbHVlRnJvbVBvaW50ZXIoYXJncyk7XG5hcmdzICs9IGFyZ1R5cGUiK2MrIlsnYXJnUGFja0FkdmFuY2UnXTtcbmFyZ1R5cGVzICs9IDQ7XG4iO3JldHVybihuZXcgRnVuY3Rpb24oInJlcXVpcmVSZWdpc3RlcmVkVHlwZSIsIk1vZHVsZSIsInZhbHVlVG9IYW5kbGUiLCJnZXRNZW1vcnkiLGQrKCJ2YXIgb2JqID0gbmV3IGNvbnN0cnVjdG9yKCIrCmIrIik7XG5yZXR1cm4gdmFsdWVUb0hhbmRsZShvYmopO1xufVxuIikpKShrZSxnLFRkLCgpPT5oKX12YXIgQ2U9e30sRGU9W107CmZ1bmN0aW9uIEVlKGEsYil7RmU9YTtHZT1iO2lmKEhlKWlmKEllfHwoSWU9ITApLDA9PWEpSmU9ZnVuY3Rpb24oKXt2YXIgZD1NYXRoLm1heCgwLEtlK2ItTGUoKSl8MDtzZXRUaW1lb3V0KE1lLGQpfTtlbHNlIGlmKDE9PWEpSmU9ZnVuY3Rpb24oKXtOZShNZSl9O2Vsc2UgaWYoMj09YSl7aWYoInVuZGVmaW5lZCI9PXR5cGVvZiBzZXRJbW1lZGlhdGUpe3ZhciBjPVtdO2FkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLGQ9PntpZigic2V0aW1tZWRpYXRlIj09PWQuZGF0YXx8InNldGltbWVkaWF0ZSI9PT1kLmRhdGEudGFyZ2V0KWQuc3RvcFByb3BhZ2F0aW9uKCksYy5zaGlmdCgpKCl9LCEwKTtzZXRJbW1lZGlhdGU9ZnVuY3Rpb24oZCl7Yy5wdXNoKGQpO0ZhPyh2b2lkIDA9PT1nLnNldEltbWVkaWF0ZXMmJihnLnNldEltbWVkaWF0ZXM9W10pLGcuc2V0SW1tZWRpYXRlcy5wdXNoKGQpLHBvc3RNZXNzYWdlKHt0YXJnZXQ6InNldGltbWVkaWF0ZSJ9KSk6cG9zdE1lc3NhZ2UoInNldGltbWVkaWF0ZSIsCiIqIil9fUplPWZ1bmN0aW9uKCl7c2V0SW1tZWRpYXRlKE1lKX19fXZhciBMZTtMZT1HYT8oKT0+e3ZhciBhPXByb2Nlc3MuaHJ0aW1lKCk7cmV0dXJuIDFFMyphWzBdK2FbMV0vMUU2fTooKT0+cGVyZm9ybWFuY2Uubm93KCk7ZnVuY3Rpb24gT2UoYSl7aWYoIW5vRXhpdFJ1bnRpbWUpe2lmKGcub25FeGl0KWcub25FeGl0KGEpO2JiPSEwfURhKGEsbmV3IFFhKGEpKX1mdW5jdGlvbiBQZShhKXthIGluc3RhbmNlb2YgUWF8fCJ1bndpbmQiPT1hfHxEYSgxLGEpfQpmdW5jdGlvbiBRZShhKXshSGV8fFZhKCJlbXNjcmlwdGVuX3NldF9tYWluX2xvb3A6IHRoZXJlIGNhbiBvbmx5IGJlIG9uZSBtYWluIGxvb3AgZnVuY3Rpb24gYXQgb25jZTogY2FsbCBlbXNjcmlwdGVuX2NhbmNlbF9tYWluX2xvb3AgdG8gY2FuY2VsIHRoZSBwcmV2aW91cyBvbmUgYmVmb3JlIHNldHRpbmcgYSBuZXcgb25lIHdpdGggZGlmZmVyZW50IHBhcmFtZXRlcnMuIik7SGU9YTt2YXIgYj1SZTtJZT0hMTtNZT1mdW5jdGlvbigpe2lmKCFiYilpZigwPFNlLmxlbmd0aCl7dmFyIGM9RGF0ZS5ub3coKSxkPVNlLnNoaWZ0KCk7ZC5nbChkLmFsKTtpZihUZSl7dmFyIGU9VGUsZj0wPT1lJTE/ZS0xOk1hdGguZmxvb3IoZSk7VGU9ZC5ibD9mOig4KmUrKGYrLjUpKS85fVRhKCdtYWluIGxvb3AgYmxvY2tlciAiJytkLm5hbWUrJyIgdG9vayAnKyhEYXRlLm5vdygpLWMpKyIgbXMiKTtnLnNldFN0YXR1cyYmKGM9Zy5zdGF0dXNNZXNzYWdlfHwiUGxlYXNlIHdhaXQuLi4iLGQ9VGUsZT0KVWUuZmwsZD9kPGU/Zy5zZXRTdGF0dXMoYysiICgiKyhlLWQpKyIvIitlKyIpIik6Zy5zZXRTdGF0dXMoYyk6Zy5zZXRTdGF0dXMoIiIpKTtiPFJlfHxzZXRUaW1lb3V0KE1lLDApfWVsc2UgYjxSZXx8KFZlPVZlKzF8MCwxPT1GZSYmMTxHZSYmMCE9VmUlR2U/SmUoKTooMD09RmUmJihLZT1MZSgpKSxiYnx8Zy5wcmVNYWluTG9vcCYmITE9PT1nLnByZU1haW5Mb29wKCl8fChXZShhKSxnLnBvc3RNYWluTG9vcCYmZy5wb3N0TWFpbkxvb3AoKSksYjxSZXx8KCJvYmplY3QiPT10eXBlb2YgU0RMJiZTREwuYXVkaW8mJlNETC5hdWRpby5IayYmU0RMLmF1ZGlvLkhrKCksSmUoKSkpKX19ZnVuY3Rpb24gV2UoYSl7aWYoIWJiKXRyeXthKCl9Y2F0Y2goYil7UGUoYil9fWZ1bmN0aW9uIFhlKGEsYil7c2V0VGltZW91dChmdW5jdGlvbigpe1dlKGEpfSxiKX1mdW5jdGlvbiBZZShhKXtaZXx8KFplPXt9KTtaZVthXXx8KFplW2FdPTEsR2EmJihhPSJ3YXJuaW5nOiAiK2EpLFJhKGEpKX0KdmFyIFplLEllPSExLEplPW51bGwsUmU9MCxIZT1udWxsLEZlPTAsR2U9MCxWZT0wLFNlPVtdLFVlPXt9LEtlLE1lLFRlLCRlPSExLGFmPSExLGJmPVtdOwpmdW5jdGlvbiBjZigpe2Z1bmN0aW9uIGEoKXthZj1kb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQ9PT1nLmNhbnZhc3x8ZG9jdW1lbnQubW96UG9pbnRlckxvY2tFbGVtZW50PT09Zy5jYW52YXN8fGRvY3VtZW50LndlYmtpdFBvaW50ZXJMb2NrRWxlbWVudD09PWcuY2FudmFzfHxkb2N1bWVudC5tc1BvaW50ZXJMb2NrRWxlbWVudD09PWcuY2FudmFzfWcucHJlbG9hZFBsdWdpbnN8fChnLnByZWxvYWRQbHVnaW5zPVtdKTtpZighZGYpe2RmPSEwO3RyeXtlZj0hMH1jYXRjaChjKXtlZj0hMSxSYSgid2FybmluZzogbm8gYmxvYiBjb25zdHJ1Y3RvciwgY2Fubm90IGNyZWF0ZSBibG9icyB3aXRoIG1pbWV0eXBlcyIpfWZmPSJ1bmRlZmluZWQiIT10eXBlb2YgTW96QmxvYkJ1aWxkZXI/TW96QmxvYkJ1aWxkZXI6InVuZGVmaW5lZCIhPXR5cGVvZiBXZWJLaXRCbG9iQnVpbGRlcj9XZWJLaXRCbG9iQnVpbGRlcjplZj9udWxsOlJhKCJ3YXJuaW5nOiBubyBCbG9iQnVpbGRlciIpO2dmPSJ1bmRlZmluZWQiIT0KdHlwZW9mIHdpbmRvdz93aW5kb3cuVVJMP3dpbmRvdy5VUkw6d2luZG93LndlYmtpdFVSTDp2b2lkIDA7Zy5ia3x8InVuZGVmaW5lZCIhPXR5cGVvZiBnZnx8KFJhKCJ3YXJuaW5nOiBCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgY3JlYXRpbmcgb2JqZWN0IFVSTHMuIEJ1aWx0LWluIGJyb3dzZXIgaW1hZ2UgZGVjb2Rpbmcgd2lsbCBub3QgYmUgYXZhaWxhYmxlLiIpLGcuYms9ITApO2cucHJlbG9hZFBsdWdpbnMucHVzaCh7Y2FuSGFuZGxlOmZ1bmN0aW9uKGMpe3JldHVybiFnLmJrJiYvXC4oanBnfGpwZWd8cG5nfGJtcCkkL2kudGVzdChjKX0saGFuZGxlOmZ1bmN0aW9uKGMsZCxlLGYpe3ZhciBsPW51bGw7aWYoZWYpdHJ5e2w9bmV3IEJsb2IoW2NdLHt0eXBlOmhmKGQpfSksbC5zaXplIT09Yy5sZW5ndGgmJihsPW5ldyBCbG9iKFsobmV3IFVpbnQ4QXJyYXkoYykpLmJ1ZmZlcl0se3R5cGU6aGYoZCl9KSl9Y2F0Y2godil7WWUoIkJsb2IgY29uc3RydWN0b3IgcHJlc2VudCBidXQgZmFpbHM6ICIrCnYrIjsgZmFsbGluZyBiYWNrIHRvIGJsb2IgYnVpbGRlciIpfWx8fChsPW5ldyBmZixsLmFwcGVuZCgobmV3IFVpbnQ4QXJyYXkoYykpLmJ1ZmZlciksbD1sLmdldEJsb2IoKSk7dmFyIG49Z2YuY3JlYXRlT2JqZWN0VVJMKGwpLHE9bmV3IEltYWdlO3Eub25sb2FkPSgpPT57cS5jb21wbGV0ZXx8VmEoIkltYWdlICIrZCsiIGNvdWxkIG5vdCBiZSBkZWNvZGVkIik7dmFyIHY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIik7di53aWR0aD1xLndpZHRoO3YuaGVpZ2h0PXEuaGVpZ2h0O3YuZ2V0Q29udGV4dCgiMmQiKS5kcmF3SW1hZ2UocSwwLDApO2dmLnJldm9rZU9iamVjdFVSTChuKTtlJiZlKGMpfTtxLm9uZXJyb3I9KCk9PntUYSgiSW1hZ2UgIituKyIgY291bGQgbm90IGJlIGRlY29kZWQiKTtmJiZmKCl9O3Euc3JjPW59fSk7Zy5wcmVsb2FkUGx1Z2lucy5wdXNoKHtjYW5IYW5kbGU6ZnVuY3Rpb24oYyl7cmV0dXJuIWcubWwmJmMuc3Vic3RyKC00KWlueyIub2dnIjoxLAoiLndhdiI6MSwiLm1wMyI6MX19LGhhbmRsZTpmdW5jdGlvbihjLGQsZSxmKXtmdW5jdGlvbiBsKCl7cXx8KHE9ITAsZSYmZShjKSl9ZnVuY3Rpb24gbigpe3F8fChxPSEwLG5ldyBBdWRpbyxmJiZmKCkpfXZhciBxPSExO2lmKGVmKXt0cnl7dmFyIHY9bmV3IEJsb2IoW2NdLHt0eXBlOmhmKGQpfSl9Y2F0Y2goQyl7cmV0dXJuIG4oKX12PWdmLmNyZWF0ZU9iamVjdFVSTCh2KTt2YXIgdz1uZXcgQXVkaW87dy5hZGRFdmVudExpc3RlbmVyKCJjYW5wbGF5dGhyb3VnaCIsKCk9PmwodyksITEpO3cub25lcnJvcj1mdW5jdGlvbigpe2lmKCFxKXtSYSgid2FybmluZzogYnJvd3NlciBjb3VsZCBub3QgZnVsbHkgZGVjb2RlIGF1ZGlvICIrZCsiLCB0cnlpbmcgc2xvd2VyIGJhc2U2NCBhcHByb2FjaCIpO2Zvcih2YXIgQz0iIixHPTAscD0wLHk9MDt5PGMubGVuZ3RoO3krKylmb3IoRz1HPDw4fGNbeV0scCs9ODs2PD1wOyl7dmFyIEY9Rz4+cC02JjYzO3AtPTY7Qys9IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8iW0ZdfTI9PQpwPyhDKz0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyJbKEcmMyk8PDRdLEMrPSI9PSIpOjQ9PXAmJihDKz0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyJbKEcmMTUpPDwyXSxDKz0iPSIpO3cuc3JjPSJkYXRhOmF1ZGlvL3gtIitkLnN1YnN0cigtMykrIjtiYXNlNjQsIitDO2wodyl9fTt3LnNyYz12O1hlKGZ1bmN0aW9uKCl7bCh3KX0sMUU0KX1lbHNlIHJldHVybiBuKCl9fSk7dmFyIGI9Zy5jYW52YXM7YiYmKGIucmVxdWVzdFBvaW50ZXJMb2NrPWIucmVxdWVzdFBvaW50ZXJMb2NrfHxiLm1velJlcXVlc3RQb2ludGVyTG9ja3x8Yi53ZWJraXRSZXF1ZXN0UG9pbnRlckxvY2t8fGIubXNSZXF1ZXN0UG9pbnRlckxvY2t8fCgoKT0+e30pLGIuZXhpdFBvaW50ZXJMb2NrPWRvY3VtZW50LmV4aXRQb2ludGVyTG9ja3x8ZG9jdW1lbnQubW96RXhpdFBvaW50ZXJMb2NrfHwKZG9jdW1lbnQud2Via2l0RXhpdFBvaW50ZXJMb2NrfHxkb2N1bWVudC5tc0V4aXRQb2ludGVyTG9ja3x8KCgpPT57fSksYi5leGl0UG9pbnRlckxvY2s9Yi5leGl0UG9pbnRlckxvY2suYmluZChkb2N1bWVudCksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigicG9pbnRlcmxvY2tjaGFuZ2UiLGEsITEpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIm1venBvaW50ZXJsb2NrY2hhbmdlIixhLCExKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCJ3ZWJraXRwb2ludGVybG9ja2NoYW5nZSIsYSwhMSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigibXNwb2ludGVybG9ja2NoYW5nZSIsYSwhMSksZy5lbGVtZW50UG9pbnRlckxvY2smJmIuYWRkRXZlbnRMaXN0ZW5lcigiY2xpY2siLGM9PnshYWYmJmcuY2FudmFzLnJlcXVlc3RQb2ludGVyTG9jayYmKGcuY2FudmFzLnJlcXVlc3RQb2ludGVyTG9jaygpLGMucHJldmVudERlZmF1bHQoKSl9LCExKSl9fQpmdW5jdGlvbiBZYyhhLGIsYyxkKXtjZigpO3ZhciBlPSExO2cucHJlbG9hZFBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbihmKXshZSYmZi5jYW5IYW5kbGUoYikmJihmLmhhbmRsZShhLGIsYyxkKSxlPSEwKX0pO3JldHVybiBlfQpmdW5jdGlvbiBqZihhLGIsYyxkKXtpZihiJiZnLlJpJiZhPT1nLmNhbnZhcylyZXR1cm4gZy5SaTt2YXIgZTtpZihiKXt2YXIgZj17YW50aWFsaWFzOiExLGFscGhhOiExLHlqOiJ1bmRlZmluZWQiIT10eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dD8yOjF9O2lmKGQpZm9yKHZhciBsIGluIGQpZltsXT1kW2xdO2lmKCJ1bmRlZmluZWQiIT10eXBlb2Yga2YmJihlPWxmKGEsZikpKXZhciBuPW1mW2VdLkxpfWVsc2Ugbj1hLmdldENvbnRleHQoIjJkIik7aWYoIW4pcmV0dXJuIG51bGw7YyYmKGJ8fCJ1bmRlZmluZWQiPT10eXBlb2YgTnx8VmEoImNhbm5vdCBzZXQgaW4gbW9kdWxlIGlmIEdMY3R4IGlzIHVzZWQsIGJ1dCB3ZSBhcmUgYSBub24tR0wgY29udGV4dCB0aGF0IHdvdWxkIHJlcGxhY2UgaXQiKSxnLlJpPW4sYiYmbmYoZSksZy5zbD1iLGJmLmZvckVhY2goZnVuY3Rpb24ocSl7cSgpfSksY2YoKSk7cmV0dXJuIG59dmFyIG9mPSExLHBmPXZvaWQgMCxxZj12b2lkIDA7CmZ1bmN0aW9uIHJmKGEsYil7ZnVuY3Rpb24gYygpeyRlPSExO3ZhciBmPWQucGFyZW50Tm9kZTsoZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnR8fGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50fHxkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbGVtZW50fHxkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudHx8ZG9jdW1lbnQud2Via2l0Q3VycmVudEZ1bGxTY3JlZW5FbGVtZW50KT09PWY/KGQuZXhpdEZ1bGxzY3JlZW49c2YscGYmJmQucmVxdWVzdFBvaW50ZXJMb2NrKCksJGU9ITAscWY/KCJ1bmRlZmluZWQiIT10eXBlb2YgU0RMJiYoRFtTREwuc2NyZWVuPj4yXT1oW1NETC5zY3JlZW4+PjJdfDgzODg2MDgpLHRmKGcuY2FudmFzKSx1ZigpKTp0ZihkKSk6KGYucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZCxmKSxmLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZikscWY/KCJ1bmRlZmluZWQiIT10eXBlb2YgU0RMJiYoRFtTREwuc2NyZWVuPj4yXT1oW1NETC5zY3JlZW4+PjJdJgotODM4ODYwOSksdGYoZy5jYW52YXMpLHVmKCkpOnRmKGQpKTtpZihnLm9uRnVsbFNjcmVlbilnLm9uRnVsbFNjcmVlbigkZSk7aWYoZy5vbkZ1bGxzY3JlZW4pZy5vbkZ1bGxzY3JlZW4oJGUpfXBmPWE7cWY9YjsidW5kZWZpbmVkIj09dHlwZW9mIHBmJiYocGY9ITApOyJ1bmRlZmluZWQiPT10eXBlb2YgcWYmJihxZj0hMSk7dmFyIGQ9Zy5jYW52YXM7b2Z8fChvZj0hMCxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCJmdWxsc2NyZWVuY2hhbmdlIixjLCExKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCJtb3pmdWxsc2NyZWVuY2hhbmdlIixjLCExKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCJ3ZWJraXRmdWxsc2NyZWVuY2hhbmdlIixjLCExKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCJNU0Z1bGxzY3JlZW5DaGFuZ2UiLGMsITEpKTt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtkLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsZCk7ZS5hcHBlbmRDaGlsZChkKTsKZS5yZXF1ZXN0RnVsbHNjcmVlbj1lLnJlcXVlc3RGdWxsc2NyZWVufHxlLm1velJlcXVlc3RGdWxsU2NyZWVufHxlLm1zUmVxdWVzdEZ1bGxzY3JlZW58fChlLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuPygpPT5lLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKEVsZW1lbnQuQUxMT1dfS0VZQk9BUkRfSU5QVVQpOm51bGwpfHwoZS53ZWJraXRSZXF1ZXN0RnVsbFNjcmVlbj8oKT0+ZS53ZWJraXRSZXF1ZXN0RnVsbFNjcmVlbihFbGVtZW50LkFMTE9XX0tFWUJPQVJEX0lOUFVUKTpudWxsKTtlLnJlcXVlc3RGdWxsc2NyZWVuKCl9CmZ1bmN0aW9uIHNmKCl7aWYoISRlKXJldHVybiExOyhkb2N1bWVudC5leGl0RnVsbHNjcmVlbnx8ZG9jdW1lbnQuY2FuY2VsRnVsbFNjcmVlbnx8ZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbnx8ZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbnx8ZG9jdW1lbnQud2Via2l0Q2FuY2VsRnVsbFNjcmVlbnx8ZnVuY3Rpb24oKXt9KS5hcHBseShkb2N1bWVudCxbXSk7cmV0dXJuITB9dmFyIHZmPTA7ZnVuY3Rpb24gTmUoYSl7aWYoImZ1bmN0aW9uIj09dHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSlyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYSk7ZWxzZXt2YXIgYj1EYXRlLm5vdygpO2lmKDA9PT12Zil2Zj1iKzFFMy82MDtlbHNlIGZvcig7YisyPj12ZjspdmYrPTFFMy82MDtzZXRUaW1lb3V0KGEsTWF0aC5tYXgodmYtYiwwKSl9fWZ1bmN0aW9uIHdmKGEpe05lKGZ1bmN0aW9uKCl7V2UoYSl9KX0KZnVuY3Rpb24gaGYoYSl7cmV0dXJue2pwZzoiaW1hZ2UvanBlZyIsanBlZzoiaW1hZ2UvanBlZyIscG5nOiJpbWFnZS9wbmciLGJtcDoiaW1hZ2UvYm1wIixvZ2c6ImF1ZGlvL29nZyIsd2F2OiJhdWRpby93YXYiLG1wMzoiYXVkaW8vbXBlZyJ9W2Euc3Vic3RyKGEubGFzdEluZGV4T2YoIi4iKSsxKV19dmFyIHhmPVtdO2Z1bmN0aW9uIHVmKCl7dmFyIGE9Zy5jYW52YXM7eGYuZm9yRWFjaChmdW5jdGlvbihiKXtiKGEud2lkdGgsYS5oZWlnaHQpfSl9CmZ1bmN0aW9uIHRmKGEsYixjKXtiJiZjPyhhLlprPWIsYS53az1jKTooYj1hLlprLGM9YS53ayk7dmFyIGQ9YixlPWM7Zy5mb3JjZWRBc3BlY3RSYXRpbyYmMDxnLmZvcmNlZEFzcGVjdFJhdGlvJiYoZC9lPGcuZm9yY2VkQXNwZWN0UmF0aW8/ZD1NYXRoLnJvdW5kKGUqZy5mb3JjZWRBc3BlY3RSYXRpbyk6ZT1NYXRoLnJvdW5kKGQvZy5mb3JjZWRBc3BlY3RSYXRpbykpO2lmKChkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudHx8ZG9jdW1lbnQubW96RnVsbFNjcmVlbkVsZW1lbnR8fGRvY3VtZW50Lm1zRnVsbHNjcmVlbkVsZW1lbnR8fGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50fHxkb2N1bWVudC53ZWJraXRDdXJyZW50RnVsbFNjcmVlbkVsZW1lbnQpPT09YS5wYXJlbnROb2RlJiYidW5kZWZpbmVkIiE9dHlwZW9mIHNjcmVlbil7dmFyIGY9TWF0aC5taW4oc2NyZWVuLndpZHRoL2Qsc2NyZWVuLmhlaWdodC9lKTtkPU1hdGgucm91bmQoZCpmKTtlPU1hdGgucm91bmQoZSoKZil9cWY/KGEud2lkdGghPWQmJihhLndpZHRoPWQpLGEuaGVpZ2h0IT1lJiYoYS5oZWlnaHQ9ZSksInVuZGVmaW5lZCIhPXR5cGVvZiBhLnN0eWxlJiYoYS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgid2lkdGgiKSxhLnN0eWxlLnJlbW92ZVByb3BlcnR5KCJoZWlnaHQiKSkpOihhLndpZHRoIT1iJiYoYS53aWR0aD1iKSxhLmhlaWdodCE9YyYmKGEuaGVpZ2h0PWMpLCJ1bmRlZmluZWQiIT10eXBlb2YgYS5zdHlsZSYmKGQhPWJ8fGUhPWM/KGEuc3R5bGUuc2V0UHJvcGVydHkoIndpZHRoIixkKyJweCIsImltcG9ydGFudCIpLGEuc3R5bGUuc2V0UHJvcGVydHkoImhlaWdodCIsZSsicHgiLCJpbXBvcnRhbnQiKSk6KGEuc3R5bGUucmVtb3ZlUHJvcGVydHkoIndpZHRoIiksYS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgiaGVpZ2h0IikpKSl9dmFyIGRmLGVmLGZmLGdmOwpmdW5jdGlvbiB5ZihhKXt2YXIgYj1hLmdldEV4dGVuc2lvbigiQU5HTEVfaW5zdGFuY2VkX2FycmF5cyIpO2ImJihhLnZlcnRleEF0dHJpYkRpdmlzb3I9ZnVuY3Rpb24oYyxkKXtiLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShjLGQpfSxhLmRyYXdBcnJheXNJbnN0YW5jZWQ9ZnVuY3Rpb24oYyxkLGUsZil7Yi5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoYyxkLGUsZil9LGEuZHJhd0VsZW1lbnRzSW5zdGFuY2VkPWZ1bmN0aW9uKGMsZCxlLGYsbCl7Yi5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRShjLGQsZSxmLGwpfSl9CmZ1bmN0aW9uIHpmKGEpe3ZhciBiPWEuZ2V0RXh0ZW5zaW9uKCJPRVNfdmVydGV4X2FycmF5X29iamVjdCIpO2ImJihhLmNyZWF0ZVZlcnRleEFycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIGIuY3JlYXRlVmVydGV4QXJyYXlPRVMoKX0sYS5kZWxldGVWZXJ0ZXhBcnJheT1mdW5jdGlvbihjKXtiLmRlbGV0ZVZlcnRleEFycmF5T0VTKGMpfSxhLmJpbmRWZXJ0ZXhBcnJheT1mdW5jdGlvbihjKXtiLmJpbmRWZXJ0ZXhBcnJheU9FUyhjKX0sYS5pc1ZlcnRleEFycmF5PWZ1bmN0aW9uKGMpe3JldHVybiBiLmlzVmVydGV4QXJyYXlPRVMoYyl9KX1mdW5jdGlvbiBBZihhKXt2YXIgYj1hLmdldEV4dGVuc2lvbigiV0VCR0xfZHJhd19idWZmZXJzIik7YiYmKGEuZHJhd0J1ZmZlcnM9ZnVuY3Rpb24oYyxkKXtiLmRyYXdCdWZmZXJzV0VCR0woYyxkKX0pfQp2YXIgQmY9MSxDZj1bXSxEZj1bXSxFZj1bXSxGZj1bXSxHZj1bXSxIZj1bXSxJZj1bXSxtZj1bXSxKZj17fSxLZj1bXSxMZj1bXSxNZj1bXSxOZj1bXSxPZj17fSxQZj17fSxRZj00O2Z1bmN0aW9uIE8oYSl7UmZ8fChSZj1hKX1mdW5jdGlvbiBTZihhKXtmb3IodmFyIGI9QmYrKyxjPWEubGVuZ3RoO2M8YjtjKyspYVtjXT1udWxsO3JldHVybiBifWZ1bmN0aW9uIFRmKGEsYixjKXtmb3IodmFyIGQ9IiIsZT0wO2U8YTsrK2Upe3ZhciBmPWM/RFtjKzQqZT4+Ml06LTE7ZCs9ZGIoRFtiKzQqZT4+Ml0sMD5mP3ZvaWQgMDpmKX1yZXR1cm4gZH0KZnVuY3Rpb24gbGYoYSxiKXthLmxpfHwoYS5saT1hLmdldENvbnRleHQsYS5nZXRDb250ZXh0PWZ1bmN0aW9uKGQsZSl7ZT1hLmxpKGQsZSk7cmV0dXJuIndlYmdsIj09ZD09ZSBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dD9lOm51bGx9KTt2YXIgYz0xPGIueWo/YS5nZXRDb250ZXh0KCJ3ZWJnbDIiLGIpOmEuZ2V0Q29udGV4dCgid2ViZ2wiLGIpO3JldHVybiBjP1VmKGMsYik6MH1mdW5jdGlvbiBVZihhLGIpe3ZhciBjPVNmKG1mKSxkPXtpbDpjLGF0dHJpYnV0ZXM6Yix2ZXJzaW9uOmIueWosTGk6YX07YS5jYW52YXMmJihhLmNhbnZhcy5oaz1kKTttZltjXT1kOygidW5kZWZpbmVkIj09dHlwZW9mIGIuU2p8fGIuU2opJiZWZihkKTtyZXR1cm4gY31mdW5jdGlvbiBuZihhKXtUPW1mW2FdO2cuUmk9Tj1UJiZULkxpO3JldHVybiEoYSYmIU4pfQpmdW5jdGlvbiBWZihhKXthfHwoYT1UKTtpZighYS55ayl7YS55az0hMDt2YXIgYj1hLkxpO3lmKGIpO3pmKGIpO0FmKGIpO2IuY2w9Yi5nZXRFeHRlbnNpb24oIldFQkdMX2RyYXdfaW5zdGFuY2VkX2Jhc2VfdmVydGV4X2Jhc2VfaW5zdGFuY2UiKTtiLmpsPWIuZ2V0RXh0ZW5zaW9uKCJXRUJHTF9tdWx0aV9kcmF3X2luc3RhbmNlZF9iYXNlX3ZlcnRleF9iYXNlX2luc3RhbmNlIik7Mjw9YS52ZXJzaW9uJiYoYi5uaT1iLmdldEV4dGVuc2lvbigiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMiIpKTtpZigyPmEudmVyc2lvbnx8IWIubmkpYi5uaT1iLmdldEV4dGVuc2lvbigiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5Iik7Yi5sbD1iLmdldEV4dGVuc2lvbigiV0VCR0xfbXVsdGlfZHJhdyIpOyhiLmdldFN1cHBvcnRlZEV4dGVuc2lvbnMoKXx8W10pLmZvckVhY2goZnVuY3Rpb24oYyl7Yy5pbmNsdWRlcygibG9zZV9jb250ZXh0Iil8fGMuaW5jbHVkZXMoImRlYnVnIil8fGIuZ2V0RXh0ZW5zaW9uKGMpfSl9fQp2YXIga2Y9e30sUmYsVCxXZj1bXTtmdW5jdGlvbiBYZihhLGIsYyxkKXtOLmRyYXdFbGVtZW50cyhhLGIsYyxkKX1mdW5jdGlvbiBZZihhLGIsYyxkKXtmb3IodmFyIGU9MDtlPGE7ZSsrKXt2YXIgZj1OW2NdKCksbD1mJiZTZihkKTtmPyhmLm5hbWU9bCxkW2xdPWYpOk8oMTI4Mik7RFtiKzQqZT4+Ml09bH19ZnVuY3Rpb24gWmYoYSxiLGMsZCxlLGYsbCxuKXtiPURmW2JdO2lmKGE9TlthXShiLGMpKWQ9biYmZWIoYS5uYW1lLHQsbixkKSxlJiYoRFtlPj4yXT1kKSxmJiYoRFtmPj4yXT1hLnNpemUpLGwmJihEW2w+PjJdPWEudHlwZSl9ZnVuY3Rpb24gJGYoYSxiKXtoW2E+PjJdPWI7aFthKzQ+PjJdPShiLWhbYT4+Ml0pLzQyOTQ5NjcyOTZ9CmZ1bmN0aW9uIGFnKGEsYixjKXtpZihiKXt2YXIgZD12b2lkIDA7c3dpdGNoKGEpe2Nhc2UgMzYzNDY6ZD0xO2JyZWFrO2Nhc2UgMzYzNDQ6MCE9YyYmMSE9YyYmTygxMjgwKTtyZXR1cm47Y2FzZSAzNDgxNDpjYXNlIDM2MzQ1OmQ9MDticmVhaztjYXNlIDM0NDY2OnZhciBlPU4uZ2V0UGFyYW1ldGVyKDM0NDY3KTtkPWU/ZS5sZW5ndGg6MDticmVhaztjYXNlIDMzMzA5OmlmKDI+VC52ZXJzaW9uKXtPKDEyODIpO3JldHVybn1kPTIqKE4uZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucygpfHxbXSkubGVuZ3RoO2JyZWFrO2Nhc2UgMzMzMDc6Y2FzZSAzMzMwODppZigyPlQudmVyc2lvbil7TygxMjgwKTtyZXR1cm59ZD0zMzMwNz09YT8zOjB9aWYodm9pZCAwPT09ZClzd2l0Y2goZT1OLmdldFBhcmFtZXRlcihhKSx0eXBlb2YgZSl7Y2FzZSAibnVtYmVyIjpkPWU7YnJlYWs7Y2FzZSAiYm9vbGVhbiI6ZD1lPzE6MDticmVhaztjYXNlICJzdHJpbmciOk8oMTI4MCk7cmV0dXJuO2Nhc2UgIm9iamVjdCI6aWYobnVsbD09PQplKXN3aXRjaChhKXtjYXNlIDM0OTY0OmNhc2UgMzU3MjU6Y2FzZSAzNDk2NTpjYXNlIDM2MDA2OmNhc2UgMzYwMDc6Y2FzZSAzMjg3MzpjYXNlIDM0MjI5OmNhc2UgMzY2NjI6Y2FzZSAzNjY2MzpjYXNlIDM1MDUzOmNhc2UgMzUwNTU6Y2FzZSAzNjAxMDpjYXNlIDM1MDk3OmNhc2UgMzU4Njk6Y2FzZSAzMjg3NDpjYXNlIDM2Mzg5OmNhc2UgMzU5ODM6Y2FzZSAzNTM2ODpjYXNlIDM0MDY4OmQ9MDticmVhaztkZWZhdWx0Ok8oMTI4MCk7cmV0dXJufWVsc2V7aWYoZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8ZSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5fHxlIGluc3RhbmNlb2YgSW50MzJBcnJheXx8ZSBpbnN0YW5jZW9mIEFycmF5KXtmb3IoYT0wO2E8ZS5sZW5ndGg7KythKXN3aXRjaChjKXtjYXNlIDA6RFtiKzQqYT4+Ml09ZVthXTticmVhaztjYXNlIDI6QltiKzQqYT4+Ml09ZVthXTticmVhaztjYXNlIDQ6amJbYithPj4wXT1lW2FdPzE6MH1yZXR1cm59dHJ5e2Q9ZS5uYW1lfDB9Y2F0Y2goZil7TygxMjgwKTsKUmEoIkdMX0lOVkFMSURfRU5VTSBpbiBnbEdldCIrYysidjogVW5rbm93biBvYmplY3QgcmV0dXJuZWQgZnJvbSBXZWJHTCBnZXRQYXJhbWV0ZXIoIithKyIpISAoZXJyb3I6ICIrZisiKSIpO3JldHVybn19YnJlYWs7ZGVmYXVsdDpPKDEyODApO1JhKCJHTF9JTlZBTElEX0VOVU0gaW4gZ2xHZXQiK2MrInY6IE5hdGl2ZSBjb2RlIGNhbGxpbmcgZ2xHZXQiK2MrInYoIithKyIpIGFuZCBpdCByZXR1cm5zICIrZSsiIG9mIHR5cGUgIit0eXBlb2YgZSsiISIpO3JldHVybn1zd2l0Y2goYyl7Y2FzZSAxOiRmKGIsZCk7YnJlYWs7Y2FzZSAwOkRbYj4+Ml09ZDticmVhaztjYXNlIDI6QltiPj4yXT1kO2JyZWFrO2Nhc2UgNDpqYltiPj4wXT1kPzE6MH19ZWxzZSBPKDEyODEpfQpmdW5jdGlvbiBiZyhhLGIsYyxkKXtpZihjKXtiPU4uZ2V0SW5kZXhlZFBhcmFtZXRlcihhLGIpO3N3aXRjaCh0eXBlb2YgYil7Y2FzZSAiYm9vbGVhbiI6YT1iPzE6MDticmVhaztjYXNlICJudW1iZXIiOmE9YjticmVhaztjYXNlICJvYmplY3QiOmlmKG51bGw9PT1iKXN3aXRjaChhKXtjYXNlIDM1OTgzOmNhc2UgMzUzNjg6YT0wO2JyZWFrO2RlZmF1bHQ6TygxMjgwKTtyZXR1cm59ZWxzZSBpZihiIGluc3RhbmNlb2YgV2ViR0xCdWZmZXIpYT1iLm5hbWV8MDtlbHNle08oMTI4MCk7cmV0dXJufWJyZWFrO2RlZmF1bHQ6TygxMjgwKTtyZXR1cm59c3dpdGNoKGQpe2Nhc2UgMTokZihjLGEpO2JyZWFrO2Nhc2UgMDpEW2M+PjJdPWE7YnJlYWs7Y2FzZSAyOkJbYz4+Ml09YTticmVhaztjYXNlIDQ6amJbYz4+MF09YT8xOjA7YnJlYWs7ZGVmYXVsdDp0aHJvdyJpbnRlcm5hbCBlbXNjcmlwdGVuV2ViR0xHZXRJbmRleGVkKCkgZXJyb3IsIGJhZCB0eXBlOiAiK2Q7fX1lbHNlIE8oMTI4MSl9CmZ1bmN0aW9uIGNnKGEpe3ZhciBiPWZiKGEpKzEsYz1kZyhiKTtlYihhLHQsYyxiKTtyZXR1cm4gY31mdW5jdGlvbiBlZyhhKXtyZXR1cm4iXSI9PWEuc2xpY2UoLTEpJiZhLmxhc3RJbmRleE9mKCJbIil9ZnVuY3Rpb24gZmcoYSl7dmFyIGI9YS5LaSxjPWEubmosZDtpZighYilmb3IoYS5LaT1iPXt9LGEuZms9e30sZD0wO2Q8Ti5nZXRQcm9ncmFtUGFyYW1ldGVyKGEsMzU3MTgpOysrZCl7dmFyIGU9Ti5nZXRBY3RpdmVVbmlmb3JtKGEsZCk7dmFyIGY9ZS5uYW1lO2U9ZS5zaXplO3ZhciBsPWVnKGYpO2w9MDxsP2Yuc2xpY2UoMCxsKTpmO3ZhciBuPWEubWo7YS5tais9ZTtjW2xdPVtlLG5dO2ZvcihmPTA7ZjxlOysrZiliW25dPWYsYS5ma1tuKytdPWx9fQpmdW5jdGlvbiBWKGEpe3ZhciBiPU4uUWo7aWYoYil7dmFyIGM9Yi5LaVthXTsibnVtYmVyIj09dHlwZW9mIGMmJihiLktpW2FdPWM9Ti5nZXRVbmlmb3JtTG9jYXRpb24oYixiLmZrW2FdKygwPGM/IlsiK2MrIl0iOiIiKSkpO3JldHVybiBjfU8oMTI4Mil9ZnVuY3Rpb24gZ2coYSxiLGMsZCl7aWYoYylpZihhPURmW2FdLGZnKGEpLGE9Ti5nZXRVbmlmb3JtKGEsVihiKSksIm51bWJlciI9PXR5cGVvZiBhfHwiYm9vbGVhbiI9PXR5cGVvZiBhKXN3aXRjaChkKXtjYXNlIDA6RFtjPj4yXT1hO2JyZWFrO2Nhc2UgMjpCW2M+PjJdPWF9ZWxzZSBmb3IoYj0wO2I8YS5sZW5ndGg7YisrKXN3aXRjaChkKXtjYXNlIDA6RFtjKzQqYj4+Ml09YVtiXTticmVhaztjYXNlIDI6QltjKzQqYj4+Ml09YVtiXX1lbHNlIE8oMTI4MSl9CmZ1bmN0aW9uIGhnKGEsYixjLGQpe2lmKGMpaWYoYT1OLmdldFZlcnRleEF0dHJpYihhLGIpLDM0OTc1PT1iKURbYz4+Ml09YSYmYS5uYW1lO2Vsc2UgaWYoIm51bWJlciI9PXR5cGVvZiBhfHwiYm9vbGVhbiI9PXR5cGVvZiBhKXN3aXRjaChkKXtjYXNlIDA6RFtjPj4yXT1hO2JyZWFrO2Nhc2UgMjpCW2M+PjJdPWE7YnJlYWs7Y2FzZSA1OkRbYz4+Ml09TWF0aC5mcm91bmQoYSl9ZWxzZSBmb3IoYj0wO2I8YS5sZW5ndGg7YisrKXN3aXRjaChkKXtjYXNlIDA6RFtjKzQqYj4+Ml09YVtiXTticmVhaztjYXNlIDI6QltjKzQqYj4+Ml09YVtiXTticmVhaztjYXNlIDU6RFtjKzQqYj4+Ml09TWF0aC5mcm91bmQoYVtiXSl9ZWxzZSBPKDEyODEpfWZ1bmN0aW9uIGlnKGEpe2EtPTUxMjA7cmV0dXJuIDA9PWE/amI6MT09YT90OjI9PWE/a2I6ND09YT9EOjY9PWE/Qjo1PT1hfHwyODkyMj09YXx8Mjg1MjA9PWF8fDMwNzc5PT1hfHwzMDc4Mj09YT9oOmxifQpmdW5jdGlvbiBqZyhhKXtyZXR1cm4gMzEtTWF0aC5jbHozMihhLkJZVEVTX1BFUl9FTEVNRU5UKX1mdW5jdGlvbiBrZyhhLGIsYyxkLGUpe2E9aWcoYSk7dmFyIGY9amcoYSksbD1RZjtyZXR1cm4gYS5zdWJhcnJheShlPj5mLGUrZCooYyooezU6Myw2OjQsODoyLDI5NTAyOjMsMjk1MDQ6NCwyNjkxNzoyLDI2OTE4OjIsMjk4NDY6MywyOTg0Nzo0fVtiLTY0MDJdfHwxKSooMTw8ZikrbC0xJi1sKT4+Zil9dmFyIGxnPVtdLG1nPVtdLG5nPVtdLG9nPXt9LHBnPVsiZGVmYXVsdCIsImxvdy1wb3dlciIsImhpZ2gtcGVyZm9ybWFuY2UiXSxxZz1bMCwidW5kZWZpbmVkIiE9dHlwZW9mIGRvY3VtZW50P2RvY3VtZW50OjAsInVuZGVmaW5lZCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OjBdOwpmdW5jdGlvbiByZyhhKXt0cnl7aWYoIWEpcmV0dXJuIHdpbmRvdzsibnVtYmVyIj09dHlwZW9mIGEmJihhPXFnW2FdfHxkYihhKSk7cmV0dXJuIiN3aW5kb3ciPT09YT93aW5kb3c6IiNkb2N1bWVudCI9PT1hP2RvY3VtZW50OiIjc2NyZWVuIj09PWE/c2NyZWVuOiIjY2FudmFzIj09PWE/Zy5jYW52YXM6InN0cmluZyI9PXR5cGVvZiBhP2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpOmF9Y2F0Y2goYil7cmV0dXJuIG51bGx9fXZhciBzZz17fTsKZnVuY3Rpb24gdGcoKXtpZighdWcpe3ZhciBhPXtVU0VSOiJ3ZWJfdXNlciIsTE9HTkFNRToid2ViX3VzZXIiLFBBVEg6Ii8iLFBXRDoiLyIsSE9NRToiL2hvbWUvd2ViX3VzZXIiLExBTkc6KCJvYmplY3QiPT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHwiQyIpLnJlcGxhY2UoIi0iLCJfIikrIi5VVEYtOCIsXzpBYXx8Ii4vdGhpcy5wcm9ncmFtIn0sYjtmb3IoYiBpbiBzZyl2b2lkIDA9PT1zZ1tiXT9kZWxldGUgYVtiXTphW2JdPXNnW2JdO3ZhciBjPVtdO2ZvcihiIGluIGEpYy5wdXNoKGIrIj0iK2FbYl0pO3VnPWN9cmV0dXJuIHVnfXZhciB1ZzsKZnVuY3Rpb24gdmcoYSxiKXthPW5ldyBVaW50OEFycmF5KGEpO3ZhciBjPWEuYnl0ZUxlbmd0aDtnLllqKz1jKzI0O2lmKDMyNzY4MD49Yyl7dmFyIGQ9bWEoKTt0cnl7dmFyIGU9bmEoYyk7dC5zdWJhcnJheShlLGUrYykuc2V0KGEpO2IoZSxjKX1maW5hbGx5e3NhKGQpfX1lbHNle2U9ZGcoYyk7dHJ5e3Quc3ViYXJyYXkoZSxlK2MpLnNldChhKSxiKGUsYyl9ZmluYWxseXtiZShlKX19fQp2YXIgeGc9e2Nvbm5lY3Q6ZnVuY3Rpb24oYSxiLGMpe2cucWo9YjtnLmpqPXdnKCJ3ZWJTb2NrZXRIYW5kbGVyT25NZXNzYWdlIixudWxsLFsibnVtYmVyIiwibnVtYmVyIiwibnVtYmVyIiwibnVtYmVyIl0pO2cuSGk/Zy5IaSsrOmcuSGk9MTtnLmVrPSExO2lmKCFnLndvcmtlcil7YT1uZXcgV29ya2VyKFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoWyd2YXIgc29ja2V0O3NlbGYub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHRpZiAoZXZlbnQuZGF0YS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcdFx0c29ja2V0LnNlbmQgKGV2ZW50LmRhdGEpO1x0fSBlbHNlIGlmIChldmVudC5kYXRhWzBdID09PSAiY29ubmVjdCIpIHtcdFx0c29ja2V0ID0gbmV3IFdlYlNvY2tldCAoZXZlbnQuZGF0YVsxXSk7XHRcdHNvY2tldC5iaW5hcnlUeXBlID0gImFycmF5YnVmZmVyIjtcdFx0dmFyIHRva2VuID0gZXZlbnQuZGF0YVsyXTtcdFx0c29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcdFx0XHRzZWxmLnBvc3RNZXNzYWdlIChbImNsb3NlIiwgdG9rZW5dKTtcdFx0fTtcdFx0c29ja2V0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcdFx0XHRzZWxmLnBvc3RNZXNzYWdlIChbImVycm9yIiwgdG9rZW5dKTtcdFx0fTtcdFx0c29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uIChldmVudCkge1x0XHRcdHNlbGYucG9zdE1lc3NhZ2UgKFsib3BlbiIsIHRva2VuXSk7XHRcdH07XHRcdHNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcdFx0XHRzZWxmLnBvc3RNZXNzYWdlIChbImRhdGEiLCBldmVudC5kYXRhLCB0b2tlbl0sIFtldmVudC5kYXRhXSk7XHRcdH07XHR9IGVsc2UgaWYgKGV2ZW50LmRhdGFbMF0gPT09ICJjbG9zZSIpIHtcdFx0c29ja2V0LmNsb3NlICgpO1x0fX0nXSx7dHlwZToiYXBwbGljYXRpb24vamF2YXNjcmlwdCJ9KSkpOwpnLndvcmtlcj1hO3ZhciBkPWZ1bmN0aW9uKGUsZil7Zy5qaihlLGYsZy5xaiwyKX07YS5vbm1lc3NhZ2U9ZnVuY3Rpb24oZSl7Zy4kJGZhY2FkZSYmKCJkYXRhIj09PWUuZGF0YVswXT9lLmRhdGFbMl09PT1nLkhpJiZ2ZyhlLmRhdGFbMV0sZCk6Im9wZW4iPT09ZS5kYXRhWzBdP2UuZGF0YVsxXT09PWcuSGkmJihnLmVrPSEwLGcuamooMCwwLGcucWosMCkpOiJjbG9zZSI9PT1lLmRhdGFbMF0/ZS5kYXRhWzFdPT09Zy5IaSYmKGcuamooMCwwLGcucWosMyksZy5naSgid2Vic29ja2V0X2Nvbm5lY3Rpb25fY2xvc2VkIikpOiJlcnJvciI9PT1lLmRhdGFbMF0mJmUuZGF0YVsxXT09PWcuSGkmJmcuZ2koZy5laz8ic29ja2V0X2Vycm9yIjoic29ja2V0X29wZW5fZmFpbGVkIikpfX1nLndvcmtlci5wb3N0TWVzc2FnZShbImNvbm5lY3QiLGRiKGMpLGcuSGldKX0sRmo6ZnVuY3Rpb24oYSxiKXtnLndvcmtlciYmKGE9KG5ldyBVaW50OEFycmF5KHQuc3ViYXJyYXkoYSxhK2IpKSkuYnVmZmVyLApnLndvcmtlci5wb3N0TWVzc2FnZShhLFthXSkpfSxjbG9zZTpmdW5jdGlvbigpe2cud29ya2VyJiZnLndvcmtlci5wb3N0TWVzc2FnZShbImNsb3NlIl0pO2cuamo9ZnVuY3Rpb24oKXt9fX0seWc9e2Nvbm5lY3Q6ZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQobixxKXtmKG4scSxiLDIpfWE9ZGIoYyk7dmFyIGU9bmV3IFdlYlNvY2tldChhKTtnLkNpPWU7ZS5iaW5hcnlUeXBlPSJhcnJheWJ1ZmZlciI7dmFyIGY9d2coIndlYlNvY2tldEhhbmRsZXJPbk1lc3NhZ2UiLG51bGwsWyJudW1iZXIiLCJudW1iZXIiLCJudW1iZXIiLCJudW1iZXIiXSksbD0hMTtlLm9uY2xvc2U9ZnVuY3Rpb24oKXtnLkNpPT09ZSYmKGYoMCwwLGIsMyksZy5naSgid2Vic29ja2V0X2Nvbm5lY3Rpb25fY2xvc2VkIikpfTtlLm9uZXJyb3I9ZnVuY3Rpb24oKXtnLkNpPT09ZSYmZy5naShsPyJzb2NrZXRfZXJyb3IiOiJzb2NrZXRfb3Blbl9mYWlsZWQiKX07ZS5vbm9wZW49ZnVuY3Rpb24oKXtnLkNpPT09ZSYmCihsPSEwLGYoMCwwLGIsMCkpfTtlLm9ubWVzc2FnZT1mdW5jdGlvbihuKXtnLkNpPT09ZSYmdmcobi5kYXRhLGQpfX0sRmo6ZnVuY3Rpb24oYSxiKXtnLkNpJiZnLkNpLnNlbmQodC5zdWJhcnJheShhLGErYikpfSxjbG9zZTpmdW5jdGlvbigpe2cuQ2kmJmcuQ2kuY2xvc2UoKTtkZWxldGUgZy5DaX19O2Z1bmN0aW9uIHpnKGEpe3JldHVybiAwPT09YSU0JiYoMCE9PWElMTAwfHwwPT09YSU0MDApfXZhciBBZz1bMzEsMjksMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdLEJnPVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07CmZ1bmN0aW9uIENnKGEsYixjLGQpe2Z1bmN0aW9uIGUocCx5LEYpe2ZvcihwPSJudW1iZXIiPT10eXBlb2YgcD9wLnRvU3RyaW5nKCk6cHx8IiI7cC5sZW5ndGg8eTspcD1GWzBdK3A7cmV0dXJuIHB9ZnVuY3Rpb24gZihwLHkpe3JldHVybiBlKHAseSwiMCIpfWZ1bmN0aW9uIGwocCx5KXtmdW5jdGlvbiBGKGJhKXtyZXR1cm4gMD5iYT8tMTowPGJhPzE6MH12YXIgUjswPT09KFI9RihwLmdldEZ1bGxZZWFyKCkteS5nZXRGdWxsWWVhcigpKSkmJjA9PT0oUj1GKHAuZ2V0TW9udGgoKS15LmdldE1vbnRoKCkpKSYmKFI9RihwLmdldERhdGUoKS15LmdldERhdGUoKSkpO3JldHVybiBSfWZ1bmN0aW9uIG4ocCl7c3dpdGNoKHAuZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUocC5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gcDtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKHAuZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUocC5nZXRGdWxsWWVhcigpLAowLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUocC5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZShwLmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZShwLmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIHEocCl7dmFyIHk9cC5JaTtmb3IocD1uZXcgRGF0ZSgobmV3IERhdGUocC5KaSsxOTAwLDAsMSkpLmdldFRpbWUoKSk7MDx5Oyl7dmFyIEY9cC5nZXRNb250aCgpLFI9KHpnKHAuZ2V0RnVsbFllYXIoKSk/QWc6QmcpW0ZdO2lmKHk+Ui1wLmdldERhdGUoKSl5LT1SLXAuZ2V0RGF0ZSgpKzEscC5zZXREYXRlKDEpLDExPkY/cC5zZXRNb250aChGKzEpOihwLnNldE1vbnRoKDApLHAuc2V0RnVsbFllYXIocC5nZXRGdWxsWWVhcigpKzEpKTtlbHNle3Auc2V0RGF0ZShwLmdldERhdGUoKSt5KTticmVha319Rj1uZXcgRGF0ZShwLmdldEZ1bGxZZWFyKCkrMSwwLDQpO3k9bihuZXcgRGF0ZShwLmdldEZ1bGxZZWFyKCksCjAsNCkpO0Y9bihGKTtyZXR1cm4gMD49bCh5LHApPzA+PWwoRixwKT9wLmdldEZ1bGxZZWFyKCkrMTpwLmdldEZ1bGxZZWFyKCk6cC5nZXRGdWxsWWVhcigpLTF9dmFyIHY9RFtkKzQwPj4yXTtkPXtXazpEW2Q+PjJdLFZrOkRbZCs0Pj4yXSxrajpEW2QrOD4+Ml0sSmo6RFtkKzEyPj4yXSxsajpEW2QrMTY+PjJdLEppOkRbZCsyMD4+Ml0sd2k6RFtkKzI0Pj4yXSxJaTpEW2QrMjg+PjJdLHFsOkRbZCszMj4+Ml0sVWs6RFtkKzM2Pj4yXSxYazp2P2RiKHYpOiIifTtjPWRiKGMpO3Y9eyIlYyI6IiVhICViICVkICVIOiVNOiVTICVZIiwiJUQiOiIlbS8lZC8leSIsIiVGIjoiJVktJW0tJWQiLCIlaCI6IiViIiwiJXIiOiIlSTolTTolUyAlcCIsIiVSIjoiJUg6JU0iLCIlVCI6IiVIOiVNOiVTIiwiJXgiOiIlbS8lZC8leSIsIiVYIjoiJUg6JU06JVMiLCIlRWMiOiIlYyIsIiVFQyI6IiVDIiwiJUV4IjoiJW0vJWQvJXkiLCIlRVgiOiIlSDolTTolUyIsIiVFeSI6IiV5IiwiJUVZIjoiJVkiLAoiJU9kIjoiJWQiLCIlT2UiOiIlZSIsIiVPSCI6IiVIIiwiJU9JIjoiJUkiLCIlT20iOiIlbSIsIiVPTSI6IiVNIiwiJU9TIjoiJVMiLCIlT3UiOiIldSIsIiVPVSI6IiVVIiwiJU9WIjoiJVYiLCIlT3ciOiIldyIsIiVPVyI6IiVXIiwiJU95IjoiJXkifTtmb3IodmFyIHcgaW4gdiljPWMucmVwbGFjZShuZXcgUmVnRXhwKHcsImciKSx2W3ddKTt2YXIgQz0iU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXkiLnNwbGl0KCIgIiksRz0iSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlciIuc3BsaXQoIiAiKTt2PXsiJWEiOmZ1bmN0aW9uKHApe3JldHVybiBDW3Aud2ldLnN1YnN0cmluZygwLDMpfSwiJUEiOmZ1bmN0aW9uKHApe3JldHVybiBDW3Aud2ldfSwiJWIiOmZ1bmN0aW9uKHApe3JldHVybiBHW3AubGpdLnN1YnN0cmluZygwLDMpfSwKIiVCIjpmdW5jdGlvbihwKXtyZXR1cm4gR1twLmxqXX0sIiVDIjpmdW5jdGlvbihwKXtyZXR1cm4gZigocC5KaSsxOTAwKS8xMDB8MCwyKX0sIiVkIjpmdW5jdGlvbihwKXtyZXR1cm4gZihwLkpqLDIpfSwiJWUiOmZ1bmN0aW9uKHApe3JldHVybiBlKHAuSmosMiwiICIpfSwiJWciOmZ1bmN0aW9uKHApe3JldHVybiBxKHApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSwiJUciOmZ1bmN0aW9uKHApe3JldHVybiBxKHApfSwiJUgiOmZ1bmN0aW9uKHApe3JldHVybiBmKHAua2osMil9LCIlSSI6ZnVuY3Rpb24ocCl7cD1wLmtqOzA9PXA/cD0xMjoxMjxwJiYocC09MTIpO3JldHVybiBmKHAsMil9LCIlaiI6ZnVuY3Rpb24ocCl7Zm9yKHZhciB5PTAsRj0wO0Y8PXAubGotMTt5Kz0oemcocC5KaSsxOTAwKT9BZzpCZylbRisrXSk7cmV0dXJuIGYocC5Kait5LDMpfSwiJW0iOmZ1bmN0aW9uKHApe3JldHVybiBmKHAubGorMSwyKX0sIiVNIjpmdW5jdGlvbihwKXtyZXR1cm4gZihwLlZrLDIpfSwKIiVuIjpmdW5jdGlvbigpe3JldHVybiJcbiJ9LCIlcCI6ZnVuY3Rpb24ocCl7cmV0dXJuIDA8PXAua2omJjEyPnAua2o/IkFNIjoiUE0ifSwiJVMiOmZ1bmN0aW9uKHApe3JldHVybiBmKHAuV2ssMil9LCIldCI6ZnVuY3Rpb24oKXtyZXR1cm4iXHQifSwiJXUiOmZ1bmN0aW9uKHApe3JldHVybiBwLndpfHw3fSwiJVUiOmZ1bmN0aW9uKHApe3JldHVybiBmKE1hdGguZmxvb3IoKHAuSWkrNy1wLndpKS83KSwyKX0sIiVWIjpmdW5jdGlvbihwKXt2YXIgeT1NYXRoLmZsb29yKChwLklpKzctKHAud2krNiklNykvNyk7Mj49KHAud2krMzcxLXAuSWktMiklNyYmeSsrO2lmKHkpNTM9PXkmJihGPShwLndpKzM3MS1wLklpKSU3LDQ9PUZ8fDM9PUYmJnpnKHAuSmkpfHwoeT0xKSk7ZWxzZXt5PTUyO3ZhciBGPShwLndpKzctcC5JaS0xKSU3Oyg0PT1GfHw1PT1GJiZ6ZyhwLkppJTQwMC0xKSkmJnkrK31yZXR1cm4gZih5LDIpfSwiJXciOmZ1bmN0aW9uKHApe3JldHVybiBwLndpfSwiJVciOmZ1bmN0aW9uKHApe3JldHVybiBmKE1hdGguZmxvb3IoKHAuSWkrCjctKHAud2krNiklNykvNyksMil9LCIleSI6ZnVuY3Rpb24ocCl7cmV0dXJuKHAuSmkrMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LCIlWSI6ZnVuY3Rpb24ocCl7cmV0dXJuIHAuSmkrMTkwMH0sIiV6IjpmdW5jdGlvbihwKXtwPXAuVWs7dmFyIHk9MDw9cDtwPU1hdGguYWJzKHApLzYwO3JldHVybih5PyIrIjoiLSIpK1N0cmluZygiMDAwMCIrKHAvNjAqMTAwK3AlNjApKS5zbGljZSgtNCl9LCIlWiI6ZnVuY3Rpb24ocCl7cmV0dXJuIHAuWGt9LCIlJSI6ZnVuY3Rpb24oKXtyZXR1cm4iJSJ9fTtjPWMucmVwbGFjZSgvJSUvZywiXHgwMFx4MDAiKTtmb3IodyBpbiB2KWMuaW5jbHVkZXModykmJihjPWMucmVwbGFjZShuZXcgUmVnRXhwKHcsImciKSx2W3ddKGQpKSk7Yz1jLnJlcGxhY2UoL1wwXDAvZywiJSIpO3c9V2IoYywhMSk7aWYody5sZW5ndGg+YilyZXR1cm4gMDtqYi5zZXQodyxhKTtyZXR1cm4gdy5sZW5ndGgtMX0KZnVuY3Rpb24gRGcoYSxiLGMsZCl7dmFyIGU9e3N0cmluZzp2PT57dmFyIHc9MDtpZihudWxsIT09diYmdm9pZCAwIT09diYmMCE9PXYpe3ZhciBDPSh2Lmxlbmd0aDw8MikrMTt3PW5hKEMpO2ViKHYsdCx3LEMpfXJldHVybiB3fSxhcnJheTp2PT57dmFyIHc9bmEodi5sZW5ndGgpO2piLnNldCh2LHcpO3JldHVybiB3fX07YT1nWyJfIithXTt2YXIgZj1bXSxsPTA7aWYoZClmb3IodmFyIG49MDtuPGQubGVuZ3RoO24rKyl7dmFyIHE9ZVtjW25dXTtxPygwPT09bCYmKGw9bWEoKSksZltuXT1xKGRbbl0pKTpmW25dPWRbbl19Yz1hLmFwcGx5KG51bGwsZik7cmV0dXJuIGM9ZnVuY3Rpb24odil7MCE9PWwmJnNhKGwpO3JldHVybiJzdHJpbmciPT09Yj9kYih2KToiYm9vbGVhbiI9PT1iPyEhdjp2fShjKX0KZnVuY3Rpb24gd2coYSxiLGMsZCl7Yz1jfHxbXTt2YXIgZT1jLmV2ZXJ5KGY9PiJudW1iZXIiPT09Znx8ImJvb2xlYW4iPT09Zik7cmV0dXJuInN0cmluZyIhPT1iJiZlJiYhZD9nWyJfIithXTpmdW5jdGlvbigpe3JldHVybiBEZyhhLGIsYyxhcmd1bWVudHMsZCl9fWZ1bmN0aW9uIHRjKGEsYixjLGQpe2F8fChhPXRoaXMpO3RoaXMucGFyZW50PWE7dGhpcy5BaT1hLkFpO3RoaXMuVGk9bnVsbDt0aGlzLmlkPWxjKys7dGhpcy5uYW1lPWI7dGhpcy5tb2RlPWM7dGhpcy5laT17fTt0aGlzLmZpPXt9O3RoaXMucmRldj1kfQpPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0Yy5wcm90b3R5cGUse3JlYWQ6e2dldDpmdW5jdGlvbigpe3JldHVybiAzNjU9PT0odGhpcy5tb2RlJjM2NSl9LHNldDpmdW5jdGlvbihhKXthP3RoaXMubW9kZXw9MzY1OnRoaXMubW9kZSY9LTM2Nn19LHdyaXRlOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gMTQ2PT09KHRoaXMubW9kZSYxNDYpfSxzZXQ6ZnVuY3Rpb24oYSl7YT90aGlzLm1vZGV8PTE0Njp0aGlzLm1vZGUmPS0xNDd9fSxCazp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDE2Mzg0PT09KHRoaXMubW9kZSY2MTQ0MCl9fSxBazp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDgxOTI9PT0odGhpcy5tb2RlJjYxNDQwKX19fSk7UGMoKTttYz1BcnJheSg0MDk2KTtBYyhKLCIvIik7QmMoIi90bXAiLDE2ODk1LDApO0JjKCIvaG9tZSIsMTY4OTUsMCk7QmMoIi9ob21lL3dlYl91c2VyIiwxNjg5NSwwKTsKKCgpPT57QmMoIi9kZXYiLDE2ODk1LDApO1piKDI1OSx7cmVhZDooKT0+MCx3cml0ZTooYixjLGQsZSk9PmV9KTtDYygiL2Rldi9udWxsIiwyNTkpO1liKDEyODAsYWMpO1liKDE1MzYsYmMpO0NjKCIvZGV2L3R0eSIsMTI4MCk7Q2MoIi9kZXYvdHR5MSIsMTUzNik7dmFyIGE9VWIoKTtWYygiL2RldiIsInJhbmRvbSIsYSk7VmMoIi9kZXYiLCJ1cmFuZG9tIixhKTtCYygiL2Rldi9zaG0iLDE2ODk1LDApO0JjKCIvZGV2L3NobS90bXAiLDE2ODk1LDApfSkoKTsKKCgpPT57QmMoIi9wcm9jIiwxNjg5NSwwKTt2YXIgYT1CYygiL3Byb2Mvc2VsZiIsMTY4OTUsMCk7QmMoIi9wcm9jL3NlbGYvZmQiLDE2ODk1LDApO0FjKHtBaTooKT0+e3ZhciBiPWRjKGEsImZkIiwxNjg5NSw3Myk7Yi5laT17bG9va3VwOihjLGQpPT57dmFyIGU9a2NbK2RdO2lmKCFlKXRocm93IG5ldyBJKDgpO2M9e3BhcmVudDpudWxsLEFpOnskajoiZmFrZSJ9LGVpOntyZWFkbGluazooKT0+ZS5wYXRofX07cmV0dXJuIGMucGFyZW50PWN9fTtyZXR1cm4gYn19LCIvcHJvYy9zZWxmL2ZkIil9KSgpO2cuRlNfY3JlYXRlUGF0aD1TYztnLkZTX2NyZWF0ZURhdGFGaWxlPVVjO2cuRlNfY3JlYXRlUHJlbG9hZGVkRmlsZT1aYztnLkZTX3VubGluaz1FYztnLkZTX2NyZWF0ZUxhenlGaWxlPVhjO2cuRlNfY3JlYXRlRGV2aWNlPVZjO25kPWcuSW50ZXJuYWxFcnJvcj1tZCgiSW50ZXJuYWxFcnJvciIpO2Zvcih2YXIgRWc9QXJyYXkoMjU2KSxGZz0wOzI1Nj5GZzsrK0ZnKUVnW0ZnXT1TdHJpbmcuZnJvbUNoYXJDb2RlKEZnKTsKdGQ9RWc7dmQ9Zy5CaW5kaW5nRXJyb3I9bWQoIkJpbmRpbmdFcnJvciIpO0xkLnByb3RvdHlwZS5pc0FsaWFzT2Y9ZnVuY3Rpb24oYSl7aWYoISh0aGlzIGluc3RhbmNlb2YgTGQmJmEgaW5zdGFuY2VvZiBMZCkpcmV0dXJuITE7dmFyIGI9dGhpcy5jaS5raS5qaSxjPXRoaXMuY2kuaGksZD1hLmNpLmtpLmppO2ZvcihhPWEuY2kuaGk7Yi51aTspYz1iLldpKGMpLGI9Yi51aTtmb3IoO2QudWk7KWE9ZC5XaShhKSxkPWQudWk7cmV0dXJuIGI9PT1kJiZjPT09YX07CkxkLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3RoaXMuY2kuaGl8fHlkKHRoaXMpO2lmKHRoaXMuY2kuVWkpcmV0dXJuIHRoaXMuY2kuY291bnQudmFsdWUrPTEsdGhpczt2YXIgYT1LZCxiPU9iamVjdCxjPWIuY3JlYXRlLGQ9T2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLGU9dGhpcy5jaTthPWEoYy5jYWxsKGIsZCx7Y2k6e3ZhbHVlOntjb3VudDplLmNvdW50LE1pOmUuTWksVWk6ZS5VaSxoaTplLmhpLGtpOmUua2ksb2k6ZS5vaSx0aTplLnRpfX19KSk7YS5jaS5jb3VudC52YWx1ZSs9MTthLmNpLk1pPSExO3JldHVybiBhfTtMZC5wcm90b3R5cGVbImRlbGV0ZSJdPWZ1bmN0aW9uKCl7dGhpcy5jaS5oaXx8eWQodGhpcyk7dGhpcy5jaS5NaSYmIXRoaXMuY2kuVWkmJnhkKCJPYmplY3QgYWxyZWFkeSBzY2hlZHVsZWQgZm9yIGRlbGV0aW9uIik7QWQodGhpcyk7QmQodGhpcy5jaSk7dGhpcy5jaS5VaXx8KHRoaXMuY2kub2k9dm9pZCAwLHRoaXMuY2kuaGk9dm9pZCAwKX07CkxkLnByb3RvdHlwZS5pc0RlbGV0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5jaS5oaX07TGQucHJvdG90eXBlLmRlbGV0ZUxhdGVyPWZ1bmN0aW9uKCl7dGhpcy5jaS5oaXx8eWQodGhpcyk7dGhpcy5jaS5NaSYmIXRoaXMuY2kuVWkmJnhkKCJPYmplY3QgYWxyZWFkeSBzY2hlZHVsZWQgZm9yIGRlbGV0aW9uIik7RWQucHVzaCh0aGlzKTsxPT09RWQubGVuZ3RoJiZHZCYmR2QoRmQpO3RoaXMuY2kuTWk9ITA7cmV0dXJuIHRoaXN9O2cuZ2V0SW5oZXJpdGVkSW5zdGFuY2VDb3VudD1mdW5jdGlvbigpe3JldHVybiBPYmplY3Qua2V5cyhIZCkubGVuZ3RofTtnLmdldExpdmVJbmhlcml0ZWRJbnN0YW5jZXM9ZnVuY3Rpb24oKXt2YXIgYT1bXSxiO2ZvcihiIGluIEhkKUhkLmhhc093blByb3BlcnR5KGIpJiZhLnB1c2goSGRbYl0pO3JldHVybiBhfTtnLmZsdXNoUGVuZGluZ0RlbGV0ZXM9RmQ7Zy5zZXREZWxheUZ1bmN0aW9uPWZ1bmN0aW9uKGEpe0dkPWE7RWQubGVuZ3RoJiZHZCYmR2QoRmQpfTsKVmQucHJvdG90eXBlLnVrPWZ1bmN0aW9uKGEpe3RoaXMuY2smJihhPXRoaXMuY2soYSkpO3JldHVybiBhfTtWZC5wcm90b3R5cGUuUmo9ZnVuY3Rpb24oYSl7dGhpcy5zaSYmdGhpcy5zaShhKX07VmQucHJvdG90eXBlLmFyZ1BhY2tBZHZhbmNlPTg7VmQucHJvdG90eXBlLnJlYWRWYWx1ZUZyb21Qb2ludGVyPWZkO1ZkLnByb3RvdHlwZS5kZWxldGVPYmplY3Q9ZnVuY3Rpb24oYSl7aWYobnVsbCE9PWEpYVsiZGVsZXRlIl0oKX07ClZkLnByb3RvdHlwZS5mcm9tV2lyZVR5cGU9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYigpe3JldHVybiB0aGlzLmRqP0pkKHRoaXMuamkuU2kse2tpOnRoaXMuR2ssaGk6Yyx0aTp0aGlzLG9pOmF9KTpKZCh0aGlzLmppLlNpLHtraTp0aGlzLGhpOmF9KX12YXIgYz10aGlzLnVrKGEpO2lmKCFjKXJldHVybiB0aGlzLlJqKGEpLG51bGw7dmFyIGQ9SWQodGhpcy5qaSxjKTtpZih2b2lkIDAhPT1kKXtpZigwPT09ZC5jaS5jb3VudC52YWx1ZSlyZXR1cm4gZC5jaS5oaT1jLGQuY2kub2k9YSxkLmNsb25lKCk7ZD1kLmNsb25lKCk7dGhpcy5SaihhKTtyZXR1cm4gZH1kPXRoaXMuamkudGsoYyk7ZD1EZFtkXTtpZighZClyZXR1cm4gYi5jYWxsKHRoaXMpO2Q9dGhpcy5jaj9kLm1rOmQucG9pbnRlclR5cGU7dmFyIGU9Q2QoYyx0aGlzLmppLGQuamkpO3JldHVybiBudWxsPT09ZT9iLmNhbGwodGhpcyk6dGhpcy5kaj9KZChkLmppLlNpLHtraTpkLGhpOmUsdGk6dGhpcyxvaTphfSk6SmQoZC5qaS5TaSwKe2tpOmQsaGk6ZX0pfTtaZD1nLlVuYm91bmRUeXBlRXJyb3I9bWQoIlVuYm91bmRUeXBlRXJyb3IiKTtnLmNvdW50X2VtdmFsX2hhbmRsZXM9ZnVuY3Rpb24oKXtmb3IodmFyIGE9MCxiPTU7YjxnZS5sZW5ndGg7KytiKXZvaWQgMCE9PWdlW2JdJiYrK2E7cmV0dXJuIGF9O2cuZ2V0X2ZpcnN0X2VtdmFsPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPTU7YTxnZS5sZW5ndGg7KythKWlmKHZvaWQgMCE9PWdlW2FdKXJldHVybiBnZVthXTtyZXR1cm4gbnVsbH07Zy5yZXF1ZXN0RnVsbHNjcmVlbj1mdW5jdGlvbihhLGIpe3JmKGEsYil9O2cucmVxdWVzdEFuaW1hdGlvbkZyYW1lPWZ1bmN0aW9uKGEpe05lKGEpfTtnLnNldENhbnZhc1NpemU9ZnVuY3Rpb24oYSxiLGMpe3RmKGcuY2FudmFzLGEsYik7Y3x8dWYoKX07Zy5wYXVzZU1haW5Mb29wPWZ1bmN0aW9uKCl7SmU9bnVsbDtSZSsrfTsKZy5yZXN1bWVNYWluTG9vcD1mdW5jdGlvbigpe1JlKys7dmFyIGE9RmUsYj1HZSxjPUhlO0hlPW51bGw7UWUoYyk7RWUoYSxiKTtKZSgpfTtnLmdldFVzZXJNZWRpYT1mdW5jdGlvbigpe3dpbmRvdy5nZXRVc2VyTWVkaWF8fCh3aW5kb3cuZ2V0VXNlck1lZGlhPW5hdmlnYXRvci5nZXRVc2VyTWVkaWF8fG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEpO3dpbmRvdy5nZXRVc2VyTWVkaWEodm9pZCAwKX07Zy5jcmVhdGVDb250ZXh0PWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBqZihhLGIsYyxkKX07Zm9yKHZhciBOLEdnPTA7MzI+R2c7KytHZylXZi5wdXNoKEFycmF5KEdnKSk7dmFyIEhnPW5ldyBGbG9hdDMyQXJyYXkoMjg4KTtmb3IoR2c9MDsyODg+R2c7KytHZylsZ1tHZ109SGcuc3ViYXJyYXkoMCxHZysxKTt2YXIgSWc9bmV3IEludDMyQXJyYXkoMjg4KTtmb3IoR2c9MDsyODg+R2c7KytHZyltZ1tHZ109SWcuc3ViYXJyYXkoMCxHZysxKTsKdmFyIEtnPXtLYTpmdW5jdGlvbihhLGIsYyl7TGJbYV09dm9pZCAwO3RyeXt2YXIgZD1bbmV3IEZsb2F0MzJBcnJheShiKSxuZXcgVWludDE2QXJyYXkoYyldfWNhdGNoKGUpe3JldHVybiAwfUxiW2FdPWQ7cmV0dXJuIDF9LEphOmZ1bmN0aW9uKGEsYixjLGQsZSl7TGJbYV09dm9pZCAwO2M+Pj0yO2U+Pj0xO3RyeXt2YXIgZj1bbmV3IEZsb2F0MzJBcnJheShCLnN1YmFycmF5KGMsYytiKSksbmV3IFVpbnQxNkFycmF5KGxiLnN1YmFycmF5KGUsZStkKSldfWNhdGNoKGwpe3JldHVybiAwfUxiW2FdPWY7cmV0dXJuIDF9LExhOmZ1bmN0aW9uKGEpe0xiW2FdPXZvaWQgMH0sTmE6ZnVuY3Rpb24oKXtpZihNYi5sZW5ndGgpcmV0dXJuIE1iLnBvcCgpO3ZhciBhPUxiLmxlbmd0aDtMYlthXT12b2lkIDA7cmV0dXJuIGF9LE1hOmZ1bmN0aW9uKGEpe0xiW2FdPXZvaWQgMDtNYi5wdXNoKGEpfSxEaDpmdW5jdGlvbihhLGIpe2lmKCFiKXJldHVybiAwO2E9TGJbYV07aWYoIWEpcmV0dXJuIDA7CmE9YVsxXTtyZXR1cm4gYS5sZW5ndGg/KGxiLnNldChhLGI+PjEpLDEpOjB9LEVoOmZ1bmN0aW9uKGEsYil7aWYoIWIpcmV0dXJuIDA7YT1MYlthXTtpZighYSlyZXR1cm4gMDthPWFbMF07cmV0dXJuIGEubGVuZ3RoPyhCLnNldChhLGI+PjIpLDEpOjB9LEhhOmZ1bmN0aW9uKGEpe3JldHVybihhPUxiW2FdKT9hWzFdLmxlbmd0aDowfSxCaDpmdW5jdGlvbihhLGIpe2E9TGJbYV07aWYoIWEpcmV0dXJuIDA7YT1hWzFdO3JldHVybiBhLmxlbmd0aD8oTi5idWZmZXJTdWJEYXRhKE4uRUxFTUVOVF9BUlJBWV9CVUZGRVIsYixhKSwxKTowfSx6aDpmdW5jdGlvbihhLGIsYyxkKXthPUxiW2FdO2lmKCFhKXJldHVybiAwO2E9YVsxXTt0cnl7dmFyIGU9bmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsYixjKX1jYXRjaChmKXtyZXR1cm4gMH1yZXR1cm4gZS5sZW5ndGg/KE4uYnVmZmVyU3ViRGF0YShOLkVMRU1FTlRfQVJSQVlfQlVGRkVSLGQsZSksMSk6MH0sQ2g6ZnVuY3Rpb24oYSxiKXthPUxiW2FdOwppZighYSlyZXR1cm4gMDthPWFbMF07cmV0dXJuIGEubGVuZ3RoPyhOLmJ1ZmZlclN1YkRhdGEoTi5BUlJBWV9CVUZGRVIsYixhKSwxKTowfSxBaDpmdW5jdGlvbihhLGIsYyxkKXthPUxiW2FdO2lmKCFhKXJldHVybiAwO2E9YVswXTt0cnl7dmFyIGU9bmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsYixjKX1jYXRjaChmKXtyZXR1cm4gMH1yZXR1cm4gZS5sZW5ndGg/KE4uYnVmZmVyU3ViRGF0YShOLkFSUkFZX0JVRkZFUixkLGUpLDEpOjB9LEdhOmZ1bmN0aW9uKGEsYixjLGQpe2E9TGJbYV07aWYoIWEpcmV0dXJuIDA7YT1hWzBdO3JldHVybiBhLmxlbmd0aCYmYjxhLmxlbmd0aCYmYS5sZW5ndGgtYj49Yz8oZD4+PTIsYS5zZXQoQi5zdWJhcnJheShkLGQrYyksYiksMSk6MH0sSWE6ZnVuY3Rpb24oYSl7cmV0dXJuKGE9TGJbYV0pP2FbMF0ubGVuZ3RoOjB9LEViOmZ1bmN0aW9uKGEsYil7MD5hJiYoYSs9NDI5NDk2NzI5Nik7MD5iJiYoYis9NDI5NDk2NzI5Nik7Zy5naSgiYW5ub3VuY2VfbW9kZWwiLAphLGIpfSxZOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1nLiQkZmFjYWRlO2lmKGQpe3ZhciBlPWcuY2FsbEFmdGVyTWFwLGY9KytlLmluZGV4LGw9ZnVuY3Rpb24obil7ZD09PWcuJCRmYWNhZGUmJkRnKCJjYWxsRnVuY1dyYXBwZXIiLG51bGwsWyJudW1iZXIiLCJudW1iZXIiLCJudW1iZXIiXSxbYSwhbixiXSk7ZGVsZXRlIGUuaW5kZXhlZFdyYXBwZXJzW2ZdfTtlLmluZGV4ZWRXcmFwcGVyc1tmXT1sOzA8PWM/WGUobCxjKTp3ZihsKX19LHNlOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPWcuY2FsbEFmdGVyTWFwLGI9YS5pbmRleGVkV3JhcHBlcnMsYz1PYmplY3Qua2V5cyhiKSxkPTA7ZDxjLmxlbmd0aDsrK2QpYltjW2RdXSghMCk7YS5pbmRleGVkV3JhcHBlcnM9e307YS5pbmRleD0wfSx3YjpmdW5jdGlvbihhLGIpe2cuZ2koImNhcHBpbmdfaWRsZSIsISFhLGIpfSxvYjpmdW5jdGlvbihhKXswPmEmJihhKz00Mjk0OTY3Mjk2KTtnLmdpKCJkYXRhX2FjY2Vzc19hdHRhY2hlZCIsYSl9LG5iOmZ1bmN0aW9uKCl7Zy5naSgiZmlyc3RfaW5zdGFuY2UiKX0sClg6ZnVuY3Rpb24oYSl7Zy5naShkYihhKSl9LGZhOmZ1bmN0aW9uKGEsYil7Yj1kYihiKTt0cnl7dmFyIGM9SlNPTi5wYXJzZShiKX1jYXRjaChkKXtjPWJ9Zy5naShkYihhKSxjKX0sdGI6ZnVuY3Rpb24oYSxiLGMpezA+YSYmKGErPTQyOTQ5NjcyOTYpOzA+YiYmKGIrPTQyOTQ5NjcyOTYpOzA+YyYmKGMrPTQyOTQ5NjcyOTYpO2cuZ2koImluY2x1c2lvbiIsYSxiLGMpfSxPYzpmdW5jdGlvbihhLGIsYyxkKXtnLmdpKCJtZXRhX2RhdGEiLGEsYixnLkhFQVBVOC5zdWJhcnJheShjLGMrZCkpfSxzYjpmdW5jdGlvbihhLGIpezA+YSYmKGErPTQyOTQ5NjcyOTYpO2I9ZGIoYik7Zy5naSgibWlzc2luZ19tb2RlbCIsYSxiKX0sUGI6ZnVuY3Rpb24oYSl7Zy5naSgibmV0d29ya19yZWNlaXZlX2RhdGEiLGEpfSxEYzpmdW5jdGlvbihhKXtnLmdpKCJwb3N0X2RyYXdfanNvbiIsInsiK2RiKGEpKyJ9Iil9LHBiOmZ1bmN0aW9uKGEsYil7MD5hJiYoYSs9NDI5NDk2NzI5Nik7MD5iJiYoYis9NDI5NDk2NzI5Nik7CmcuZ2koInByaW9yaXR5X21ldGFfZGF0YV9zZW50IixhLGIpfSxxYjpmdW5jdGlvbihhLGIsYyxkKXswPmEmJihhKz00Mjk0OTY3Mjk2KTswPmImJihiKz00Mjk0OTY3Mjk2KTswPmMmJihjKz00Mjk0OTY3Mjk2KTswPmQmJihkKz00Mjk0OTY3Mjk2KTtnLmdpKCJyZW1hcF9pbmNsdXNpb24iLGEsYixjLGQpfSxyYjpmdW5jdGlvbihhLGIsYyl7MD5hJiYoYSs9NDI5NDk2NzI5Nik7MD5iJiYoYis9NDI5NDk2NzI5Nik7MD5jJiYoYys9NDI5NDk2NzI5Nik7Zy5naSgicmVtYXBfbW9kZWwiLGEsYixjKX0saDpmdW5jdGlvbihhLGIpe2cub2omJihhPWcuSEVBUDguYnVmZmVyLnNsaWNlKGEsYiksZy5vai5LayhhKSl9LGljOmZ1bmN0aW9uKCl7Zy5naSgic2Vzc2lvbl9zdGFydGVkIil9LFlkOmZ1bmN0aW9uKCl7Zy4kJHNldFJlYWR5KCl9LGw6ZnVuY3Rpb24oYSxiLGMsZCl7VmEoIkFzc2VydGlvbiBmYWlsZWQ6ICIrZGIoYSkrIiwgYXQ6ICIrW2I/ZGIoYik6InVua25vd24gZmlsZW5hbWUiLApjLGQ/ZGIoZCk6InVua25vd24gZnVuY3Rpb24iXSl9LHJhOmZ1bmN0aW9uKGEsYixjKXthZD1jO3RyeXt2YXIgZD1jZChhKTtzd2l0Y2goYil7Y2FzZSAwOnZhciBlPWJkKCk7cmV0dXJuIDA+ZT8tMjg6emMoZCxlKS5mZDtjYXNlIDE6Y2FzZSAyOnJldHVybiAwO2Nhc2UgMzpyZXR1cm4gZC5mbGFncztjYXNlIDQ6cmV0dXJuIGU9YmQoKSxkLmZsYWdzfD1lLDA7Y2FzZSA1OnJldHVybiBlPWJkKCksa2JbZSswPj4xXT0yLDA7Y2FzZSA2OmNhc2UgNzpyZXR1cm4gMDtjYXNlIDE2OmNhc2UgODpyZXR1cm4tMjg7Y2FzZSA5OnJldHVybiBEW0pnKCk+PjJdPTI4LC0xO2RlZmF1bHQ6cmV0dXJuLTI4fX1jYXRjaChmKXtpZigidW5kZWZpbmVkIj09dHlwZW9mICRjfHwhKGYgaW5zdGFuY2VvZiBJKSl0aHJvdyBmO3JldHVybi1mLkRpfX0sRGI6ZnVuY3Rpb24oYSxiLGMpe2FkPWM7dHJ5e3ZhciBkPWNkKGEpO3N3aXRjaChiKXtjYXNlIDIxNTA5OmNhc2UgMjE1MDU6cmV0dXJuIGQudHR5PzA6Ci01OTtjYXNlIDIxNTEwOmNhc2UgMjE1MTE6Y2FzZSAyMTUxMjpjYXNlIDIxNTA2OmNhc2UgMjE1MDc6Y2FzZSAyMTUwODpyZXR1cm4gZC50dHk/MDotNTk7Y2FzZSAyMTUxOTppZighZC50dHkpcmV0dXJuLTU5O3ZhciBlPWJkKCk7cmV0dXJuIERbZT4+Ml09MDtjYXNlIDIxNTIwOnJldHVybiBkLnR0eT8tMjg6LTU5O2Nhc2UgMjE1MzE6YT1lPWJkKCk7aWYoIWQuZmkuemspdGhyb3cgbmV3IEkoNTkpO3JldHVybiBkLmZpLnprKGQsYixhKTtjYXNlIDIxNTIzOnJldHVybiBkLnR0eT8wOi01OTtjYXNlIDIxNTI0OnJldHVybiBkLnR0eT8wOi01OTtkZWZhdWx0OnJldHVybi0yOH19Y2F0Y2goZil7aWYoInVuZGVmaW5lZCI9PXR5cGVvZiAkY3x8IShmIGluc3RhbmNlb2YgSSkpdGhyb3cgZjtyZXR1cm4tZi5EaX19LEZiOmZ1bmN0aW9uKGEsYixjLGQpe2FkPWQ7dHJ5e2I9ZGIoYik7dmFyIGU9YjtpZigiLyI9PT1lLmNoYXJBdCgwKSliPWU7ZWxzZXt2YXIgZj0tMTAwPT09YT8iLyI6Y2QoYSkucGF0aDsKaWYoMD09ZS5sZW5ndGgpdGhyb3cgbmV3IEkoNDQpO2I9UmIoZisiLyIrZSl9dmFyIGw9ZD9iZCgpOjA7cmV0dXJuIEhjKGIsYyxsKS5mZH1jYXRjaChuKXtpZigidW5kZWZpbmVkIj09dHlwZW9mICRjfHwhKG4gaW5zdGFuY2VvZiBJKSl0aHJvdyBuO3JldHVybi1uLkRpfX0sdzpmdW5jdGlvbihhKXt2YXIgYj1kZFthXTtkZWxldGUgZGRbYV07dmFyIGM9Yi5lbGVtZW50cyxkPWMubGVuZ3RoLGU9Yy5tYXAoZnVuY3Rpb24obil7cmV0dXJuIG4udWp9KS5jb25jYXQoYy5tYXAoZnVuY3Rpb24obil7cmV0dXJuIG4uSGp9KSksZj1iLlZpLGw9Yi5zaTtwZChbYV0sZSxmdW5jdGlvbihuKXtjLmZvckVhY2goKHEsdik9Pnt2YXIgdz1uW3ZdLEM9cS5OaSxHPXEudGoscD1uW3YrZF0seT1xLkdqLEY9cS5JajtxLnJlYWQ9Uj0+dy5mcm9tV2lyZVR5cGUoQyhHLFIpKTtxLndyaXRlPShSLGJhKT0+e3ZhciBNPVtdO3koRixSLHAudG9XaXJlVHlwZShNLGJhKSk7ZWQoTSl9fSk7cmV0dXJuW3tuYW1lOmIubmFtZSwKZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKHEpe2Zvcih2YXIgdj1BcnJheShkKSx3PTA7dzxkOysrdyl2W3ddPWNbd10ucmVhZChxKTtsKHEpO3JldHVybiB2fSx0b1dpcmVUeXBlOmZ1bmN0aW9uKHEsdil7aWYoZCE9PXYubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoIkluY29ycmVjdCBudW1iZXIgb2YgdHVwbGUgZWxlbWVudHMgZm9yICIrYi5uYW1lKyI6IGV4cGVjdGVkPSIrZCsiLCBhY3R1YWw9Iit2Lmxlbmd0aCk7Zm9yKHZhciB3PWYoKSxDPTA7QzxkOysrQyljW0NdLndyaXRlKHcsdltDXSk7bnVsbCE9PXEmJnEucHVzaChsLHcpO3JldHVybiB3fSxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmZkLHBpOmx9XX0pfSxKOmZ1bmN0aW9uKGEpe3ZhciBiPXJkW2FdO2RlbGV0ZSByZFthXTt2YXIgYz1iLlZpLGQ9Yi5zaSxlPWIuVWosZj1lLm1hcChsPT5sLnVqKS5jb25jYXQoZS5tYXAobD0+bC5IaikpO3BkKFthXSxmLGw9Pnt2YXIgbj17fTtlLmZvckVhY2goKHEsCnYpPT57dmFyIHc9bFt2XSxDPXEuTmksRz1xLnRqLHA9bFt2K2UubGVuZ3RoXSx5PXEuR2osRj1xLklqO25bcS5za109e3JlYWQ6Uj0+dy5mcm9tV2lyZVR5cGUoQyhHLFIpKSx3cml0ZTooUixiYSk9Pnt2YXIgTT1bXTt5KEYsUixwLnRvV2lyZVR5cGUoTSxiYSkpO2VkKE0pfX19KTtyZXR1cm5be25hbWU6Yi5uYW1lLGZyb21XaXJlVHlwZTpmdW5jdGlvbihxKXt2YXIgdj17fSx3O2Zvcih3IGluIG4pdlt3XT1uW3ddLnJlYWQocSk7ZChxKTtyZXR1cm4gdn0sdG9XaXJlVHlwZTpmdW5jdGlvbihxLHYpe2Zvcih2YXIgdyBpbiBuKWlmKCEodyBpbiB2KSl0aHJvdyBuZXcgVHlwZUVycm9yKCdNaXNzaW5nIGZpZWxkOiAgIicrdysnIicpO3ZhciBDPWMoKTtmb3IodyBpbiBuKW5bd10ud3JpdGUoQyx2W3ddKTtudWxsIT09cSYmcS5wdXNoKGQsQyk7cmV0dXJuIEN9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6ZmQscGk6ZH1dfSl9LHZiOmZ1bmN0aW9uKCl7fSxUZzpmdW5jdGlvbihhLApiLGMsZCxlKXt2YXIgZj1zZChjKTtiPXVkKGIpO3FkKGEse25hbWU6Yixmcm9tV2lyZVR5cGU6ZnVuY3Rpb24obCl7cmV0dXJuISFsfSx0b1dpcmVUeXBlOmZ1bmN0aW9uKGwsbil7cmV0dXJuIG4/ZDplfSxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmZ1bmN0aW9uKGwpe2lmKDE9PT1jKXZhciBuPWpiO2Vsc2UgaWYoMj09PWMpbj1rYjtlbHNlIGlmKDQ9PT1jKW49RDtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gYm9vbGVhbiB0eXBlIHNpemU6ICIrYik7cmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKG5bbD4+Zl0pfSxwaTpudWxsfSl9LGdhOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGwsbixxLHYsdyxDLEcpe3c9dWQodyk7Zj1ZZChlLGYpO24mJihuPVlkKGwsbikpO3YmJih2PVlkKHEsdikpO0c9WWQoQyxHKTt2YXIgcD1rZCh3KTtOZChwLGZ1bmN0aW9uKCl7Y2UoIkNhbm5vdCBjb25zdHJ1Y3QgIit3KyIgZHVlIHRvIHVuYm91bmQgdHlwZXMiLFtkXSl9KTsKcGQoW2EsYixjXSxkP1tkXTpbXSxmdW5jdGlvbih5KXt5PXlbMF07aWYoZCl7dmFyIEY9eS5qaTt2YXIgUj1GLlNpfWVsc2UgUj1MZC5wcm90b3R5cGU7eT1sZChwLGZ1bmN0aW9uKCl7aWYoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpIT09YmEpdGhyb3cgbmV3IHZkKCJVc2UgJ25ldycgdG8gY29uc3RydWN0ICIrdyk7aWYodm9pZCAwPT09TS5saSl0aHJvdyBuZXcgdmQodysiIGhhcyBubyBhY2Nlc3NpYmxlIGNvbnN0cnVjdG9yIik7dmFyIEE9TS5saVthcmd1bWVudHMubGVuZ3RoXTtpZih2b2lkIDA9PT1BKXRocm93IG5ldyB2ZCgiVHJpZWQgdG8gaW52b2tlIGN0b3Igb2YgIit3KyIgd2l0aCBpbnZhbGlkIG51bWJlciBvZiBwYXJhbWV0ZXJzICgiK2FyZ3VtZW50cy5sZW5ndGgrIikgLSBleHBlY3RlZCAoIitPYmplY3Qua2V5cyhNLmxpKS50b1N0cmluZygpKyIpIHBhcmFtZXRlcnMgaW5zdGVhZCEiKTtyZXR1cm4gQS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KTt2YXIgYmE9Ck9iamVjdC5jcmVhdGUoUix7Y29uc3RydWN0b3I6e3ZhbHVlOnl9fSk7eS5wcm90b3R5cGU9YmE7dmFyIE09bmV3IE9kKHcseSxiYSxHLEYsZixuLHYpO0Y9bmV3IFZkKHcsTSwhMCwhMSk7Uj1uZXcgVmQodysiKiIsTSwhMSwhMSk7dmFyIEU9bmV3IFZkKHcrIiBjb25zdCoiLE0sITEsITApO0RkW2FdPXtwb2ludGVyVHlwZTpSLG1rOkV9O1dkKHAseSk7cmV0dXJuW0YsUixFXX0pfSxiOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGwpe3ZhciBuPWVlKGMsZCk7Yj11ZChiKTtmPVlkKGUsZik7cGQoW10sW2FdLGZ1bmN0aW9uKHEpe2Z1bmN0aW9uIHYoKXtjZSgiQ2Fubm90IGNhbGwgIit3KyIgZHVlIHRvIHVuYm91bmQgdHlwZXMiLG4pfXE9cVswXTt2YXIgdz1xLm5hbWUrIi4iK2I7Yi5zdGFydHNXaXRoKCJAQCIpJiYoYj1TeW1ib2xbYi5zdWJzdHJpbmcoMildKTt2YXIgQz1xLmppLmNvbnN0cnVjdG9yO3ZvaWQgMD09PUNbYl0/KHYucGo9Yy0xLENbYl09dik6KE1kKEMsYix3KSxDW2JdLkJpW2MtCjFdPXYpO3BkKFtdLG4sZnVuY3Rpb24oRyl7Rz1bR1swXSxudWxsXS5jb25jYXQoRy5zbGljZSgxKSk7dmFyIHA9dyx5PWYsRj1HLmxlbmd0aDsyPkYmJnhkKCJhcmdUeXBlcyBhcnJheSBzaXplIG1pc21hdGNoISBNdXN0IGF0IGxlYXN0IGdldCByZXR1cm4gdmFsdWUgYW5kICd0aGlzJyB0eXBlcyEiKTtmb3IodmFyIFI9bnVsbCE9PUdbMV0mJiExLGJhPSExLE09MTtNPEcubGVuZ3RoOysrTSlpZihudWxsIT09R1tNXSYmdm9pZCAwPT09R1tNXS5waSl7YmE9ITA7YnJlYWt9dmFyIEU9InZvaWQiIT09R1swXS5uYW1lLEE9IiIsVT0iIjtmb3IoTT0wO008Ri0yOysrTSlBKz0oMCE9PU0/IiwgIjoiIikrImFyZyIrTSxVKz0oMCE9PU0/IiwgIjoiIikrImFyZyIrTSsiV2lyZWQiO3A9InJldHVybiBmdW5jdGlvbiAiK2tkKHApKyIoIitBKyIpIHtcbmlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAiKyhGLTIpKyIpIHtcbnRocm93QmluZGluZ0Vycm9yKCdmdW5jdGlvbiAiK3ArIiBjYWxsZWQgd2l0aCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLCBleHBlY3RlZCAiKwooRi0yKSsiIGFyZ3MhJyk7XG59XG4iO2JhJiYocCs9InZhciBkZXN0cnVjdG9ycyA9IFtdO1xuIik7dmFyIEs9YmE/ImRlc3RydWN0b3JzIjoibnVsbCI7QT0idGhyb3dCaW5kaW5nRXJyb3IgaW52b2tlciBmbiBydW5EZXN0cnVjdG9ycyByZXRUeXBlIGNsYXNzUGFyYW0iLnNwbGl0KCIgIik7eT1beGQseSxsLGVkLEdbMF0sR1sxXV07UiYmKHArPSJ2YXIgdGhpc1dpcmVkID0gY2xhc3NQYXJhbS50b1dpcmVUeXBlKCIrSysiLCB0aGlzKTtcbiIpO2ZvcihNPTA7TTxGLTI7KytNKXArPSJ2YXIgYXJnIitNKyJXaXJlZCA9IGFyZ1R5cGUiK00rIi50b1dpcmVUeXBlKCIrSysiLCBhcmciK00rIik7IC8vICIrR1tNKzJdLm5hbWUrIlxuIixBLnB1c2goImFyZ1R5cGUiK00pLHkucHVzaChHW00rMl0pO1ImJihVPSJ0aGlzV2lyZWQiKygwPFUubGVuZ3RoPyIsICI6IiIpK1UpO3ArPShFPyJ2YXIgcnYgPSAiOiIiKSsiaW52b2tlcihmbiIrKDA8VS5sZW5ndGg/IiwgIjoiIikrVSsiKTtcbiI7CmlmKGJhKXArPSJydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycyk7XG4iO2Vsc2UgZm9yKE09Uj8xOjI7TTxHLmxlbmd0aDsrK00pRj0xPT09TT8idGhpc1dpcmVkIjoiYXJnIisoTS0yKSsiV2lyZWQiLG51bGwhPT1HW01dLnBpJiYocCs9RisiX2R0b3IoIitGKyIpOyAvLyAiK0dbTV0ubmFtZSsiXG4iLEEucHVzaChGKyJfZHRvciIpLHkucHVzaChHW01dLnBpKSk7RSYmKHArPSJ2YXIgcmV0ID0gcmV0VHlwZS5mcm9tV2lyZVR5cGUocnYpO1xucmV0dXJuIHJldDtcbiIpO0EucHVzaChwKyJ9XG4iKTtHPWRlKEEpLmFwcGx5KG51bGwseSk7dm9pZCAwPT09Q1tiXS5CaT8oRy5waj1jLTEsQ1tiXT1HKTpDW2JdLkJpW2MtMV09RztyZXR1cm5bXX0pO3JldHVybltdfSl9LFNnOmZ1bmN0aW9uKGEsYil7Yj11ZChiKTtxZChhLHtuYW1lOmIsZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKGMpe3ZhciBkPWllKGMpO2hlKGMpO3JldHVybiBkfSx0b1dpcmVUeXBlOmZ1bmN0aW9uKGMsZCl7cmV0dXJuIFRkKGQpfSwKYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpmZCxwaTpudWxsfSl9LE06ZnVuY3Rpb24oYSxiLGMsZCl7ZnVuY3Rpb24gZSgpe31jPXNkKGMpO2I9dWQoYik7ZS52YWx1ZXM9e307cWQoYSx7bmFtZTpiLGNvbnN0cnVjdG9yOmUsZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKGYpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnZhbHVlc1tmXX0sdG9XaXJlVHlwZTpmdW5jdGlvbihmLGwpe3JldHVybiBsLnZhbHVlfSxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmplKGIsYyxkKSxwaTpudWxsfSk7TmQoYixlKX0seTpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9a2UoYSwiZW51bSIpO2I9dWQoYik7YT1kLmNvbnN0cnVjdG9yO2Q9T2JqZWN0LmNyZWF0ZShkLmNvbnN0cnVjdG9yLnByb3RvdHlwZSx7dmFsdWU6e3ZhbHVlOmN9LGNvbnN0cnVjdG9yOnt2YWx1ZTpsZChkLm5hbWUrIl8iK2IsZnVuY3Rpb24oKXt9KX19KTthLnZhbHVlc1tjXT1kO2FbYl09ZH0sCnVhOmZ1bmN0aW9uKGEsYixjKXtjPXNkKGMpO2I9dWQoYik7cWQoYSx7bmFtZTpiLGZyb21XaXJlVHlwZTpmdW5jdGlvbihkKXtyZXR1cm4gZH0sdG9XaXJlVHlwZTpmdW5jdGlvbihkLGUpe3JldHVybiBlfSxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmxlKGIsYykscGk6bnVsbH0pfSxQOmZ1bmN0aW9uKGEsYixjLGQsZSl7Yj11ZChiKTstMT09PWUmJihlPTQyOTQ5NjcyOTUpO2U9c2QoYyk7dmFyIGY9bj0+bjtpZigwPT09ZCl7dmFyIGw9MzItOCpjO2Y9bj0+bjw8bD4+Pmx9Yz1iLmluY2x1ZGVzKCJ1bnNpZ25lZCIpP2Z1bmN0aW9uKG4scSl7cmV0dXJuIHE+Pj4wfTpmdW5jdGlvbihuLHEpe3JldHVybiBxfTtxZChhLHtuYW1lOmIsZnJvbVdpcmVUeXBlOmYsdG9XaXJlVHlwZTpjLGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6bWUoYixlLDAhPT1kKSxwaTpudWxsfSl9LEQ6ZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoZil7Zj4+PQoyO3ZhciBsPWg7cmV0dXJuIG5ldyBlKGdiLGxbZisxXSxsW2ZdKX12YXIgZT1bSW50OEFycmF5LFVpbnQ4QXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXldW2JdO2M9dWQoYyk7cWQoYSx7bmFtZTpjLGZyb21XaXJlVHlwZTpkLGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6ZH0se3hrOiEwfSl9LHRhOmZ1bmN0aW9uKGEsYil7Yj11ZChiKTt2YXIgYz0ic3RkOjpzdHJpbmciPT09YjtxZChhLHtuYW1lOmIsZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKGQpe3ZhciBlPWhbZD4+Ml0sZj1kKzQ7aWYoYylmb3IodmFyIGw9ZixuPTA7bjw9ZTsrK24pe3ZhciBxPWYrbjtpZihuPT1lfHwwPT10W3FdKXtsPWRiKGwscS1sKTtpZih2b2lkIDA9PT12KXZhciB2PWw7ZWxzZSB2Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKDApLHYrPWw7bD1xKzF9fWVsc2V7dj1BcnJheShlKTtmb3Iobj0wO248ZTsrK24pdltuXT0KU3RyaW5nLmZyb21DaGFyQ29kZSh0W2Yrbl0pO3Y9di5qb2luKCIiKX1iZShkKTtyZXR1cm4gdn0sdG9XaXJlVHlwZTpmdW5jdGlvbihkLGUpe2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciYmKGU9bmV3IFVpbnQ4QXJyYXkoZSkpO3ZhciBmPSJzdHJpbmciPT10eXBlb2YgZTtmfHxlIGluc3RhbmNlb2YgVWludDhBcnJheXx8ZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5fHxlIGluc3RhbmNlb2YgSW50OEFycmF5fHx4ZCgiQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBzdGQ6OnN0cmluZyIpO3ZhciBsPWMmJmY/ZmIoZSk6ZS5sZW5ndGg7dmFyIG49ZGcoNCtsKzEpLHE9bis0O2hbbj4+Ml09bDtpZihjJiZmKWViKGUsdCxxLGwrMSk7ZWxzZSBpZihmKWZvcihmPTA7ZjxsOysrZil7dmFyIHY9ZS5jaGFyQ29kZUF0KGYpOzI1NTx2JiYoYmUocSkseGQoIlN0cmluZyBoYXMgVVRGLTE2IGNvZGUgdW5pdHMgdGhhdCBkbyBub3QgZml0IGluIDggYml0cyIpKTt0W3ErZl09dn1lbHNlIGZvcihmPQowO2Y8bDsrK2YpdFtxK2ZdPWVbZl07bnVsbCE9PWQmJmQucHVzaChiZSxuKTtyZXR1cm4gbn0sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpmZCxwaTpmdW5jdGlvbihkKXtiZShkKX19KX0saGE6ZnVuY3Rpb24oYSxiLGMpe2M9dWQoYyk7aWYoMj09PWIpe3ZhciBkPW9lO3ZhciBlPXBlO3ZhciBmPXFlO3ZhciBsPSgpPT5sYjt2YXIgbj0xfWVsc2UgND09PWImJihkPXJlLGU9c2UsZj10ZSxsPSgpPT5oLG49Mik7cWQoYSx7bmFtZTpjLGZyb21XaXJlVHlwZTpmdW5jdGlvbihxKXtmb3IodmFyIHY9aFtxPj4yXSx3PWwoKSxDLEc9cSs0LHA9MDtwPD12OysrcCl7dmFyIHk9cSs0K3AqYjtpZihwPT12fHwwPT13W3k+Pm5dKUc9ZChHLHktRyksdm9pZCAwPT09Qz9DPUc6KEMrPVN0cmluZy5mcm9tQ2hhckNvZGUoMCksQys9RyksRz15K2J9YmUocSk7cmV0dXJuIEN9LHRvV2lyZVR5cGU6ZnVuY3Rpb24ocSx2KXsic3RyaW5nIiE9dHlwZW9mIHYmJnhkKCJDYW5ub3QgcGFzcyBub24tc3RyaW5nIHRvIEMrKyBzdHJpbmcgdHlwZSAiKwpjKTt2YXIgdz1mKHYpLEM9ZGcoNCt3K2IpO2hbQz4+Ml09dz4+bjtlKHYsQys0LHcrYik7bnVsbCE9PXEmJnEucHVzaChiZSxDKTtyZXR1cm4gQ30sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpmZCxwaTpmdW5jdGlvbihxKXtiZShxKX19KX0seDpmdW5jdGlvbihhLGIsYyxkLGUsZil7ZGRbYV09e25hbWU6dWQoYiksVmk6WWQoYyxkKSxzaTpZZChlLGYpLGVsZW1lbnRzOltdfX0saTpmdW5jdGlvbihhLGIsYyxkLGUsZixsLG4scSl7ZGRbYV0uZWxlbWVudHMucHVzaCh7dWo6YixOaTpZZChjLGQpLHRqOmUsSGo6ZixHajpZZChsLG4pLElqOnF9KX0sSzpmdW5jdGlvbihhLGIsYyxkLGUsZil7cmRbYV09e25hbWU6dWQoYiksVmk6WWQoYyxkKSxzaTpZZChlLGYpLFVqOltdfX0sdDpmdW5jdGlvbihhLGIsYyxkLGUsZixsLG4scSx2KXtyZFthXS5Vai5wdXNoKHtzazp1ZChiKSx1ajpjLE5pOllkKGQsZSksdGo6ZixIajpsLEdqOllkKG4scSksSWo6dn0pfSxVZzpmdW5jdGlvbihhLApiKXtiPXVkKGIpO3FkKGEse0NrOiEwLG5hbWU6YixhcmdQYWNrQWR2YW5jZTowLGZyb21XaXJlVHlwZTpmdW5jdGlvbigpe30sdG9XaXJlVHlwZTpmdW5jdGlvbigpe319KX0sVmc6ZnVuY3Rpb24oYSl7ZG97dmFyIGI9aFthPj4yXTthKz00O3ZhciBjPWhbYT4+Ml07YSs9NDt2YXIgZD1oW2E+PjJdO2ErPTQ7Yj1kYihiKTtTYygiLyIsU2IoYiksITAsITApO1VjKGIsbnVsbCxqYi5zdWJhcnJheShkLGQrYyksITAsITAsITApfXdoaWxlKGhbYT4+Ml0pfSxBYjpmdW5jdGlvbigpe3JldHVybiEwfSxwOmZ1bmN0aW9uKGEsYixjKXthPWllKGEpO2I9a2UoYiwiZW12YWw6OmFzIik7dmFyIGQ9W10sZT1UZChkKTtoW2M+PjJdPWU7cmV0dXJuIGIudG9XaXJlVHlwZShkLGEpfSxqOmZ1bmN0aW9uKGEsYixjLGQpe2E9aWUoYSk7Yz11ZShiLGMpO2Zvcih2YXIgZT1BcnJheShiKSxmPTA7ZjxiOysrZil7dmFyIGw9Y1tmXTtlW2ZdPWwucmVhZFZhbHVlRnJvbVBvaW50ZXIoZCk7ZCs9bC5hcmdQYWNrQWR2YW5jZX1hPQphLmFwcGx5KHZvaWQgMCxlKTtyZXR1cm4gVGQoYSl9LFE6ZnVuY3Rpb24oYSxiLGMsZCxlKXthPXhlW2FdO2I9aWUoYik7Yz13ZShjKTt2YXIgZj1bXTtoW2Q+PjJdPVRkKGYpO3JldHVybiBhKGIsYyxmLGUpfSxhOmhlLEw6ZnVuY3Rpb24oYSl7aWYoMD09PWEpcmV0dXJuIFRkKHllKCkpO2E9d2UoYSk7cmV0dXJuIFRkKHllKClbYV0pfSxSOmZ1bmN0aW9uKGEsYil7dmFyIGM9dWUoYSxiKSxkPWNbMF07Yj1kLm5hbWUrIl8kIitjLnNsaWNlKDEpLm1hcChmdW5jdGlvbih3KXtyZXR1cm4gdy5uYW1lfSkuam9pbigiXyIpKyIkIjt2YXIgZT1BZVtiXTtpZih2b2lkIDAhPT1lKXJldHVybiBlO2U9WyJyZXRUeXBlIl07Zm9yKHZhciBmPVtkXSxsPSIiLG49MDtuPGEtMTsrK24pbCs9KDAhPT1uPyIsICI6IiIpKyJhcmciK24sZS5wdXNoKCJhcmdUeXBlIituKSxmLnB1c2goY1sxK25dKTt2YXIgcT0icmV0dXJuIGZ1bmN0aW9uICIra2QoIm1ldGhvZENhbGxlcl8iK2IpKyIoaGFuZGxlLCBuYW1lLCBkZXN0cnVjdG9ycywgYXJncykge1xuIiwKdj0wO2ZvcihuPTA7bjxhLTE7KytuKXErPSIgICAgdmFyIGFyZyIrbisiID0gYXJnVHlwZSIrbisiLnJlYWRWYWx1ZUZyb21Qb2ludGVyKGFyZ3MiKyh2PyIrIit2OiIiKSsiKTtcbiIsdis9Y1tuKzFdLmFyZ1BhY2tBZHZhbmNlO3ErPSIgICAgdmFyIHJ2ID0gaGFuZGxlW25hbWVdKCIrbCsiKTtcbiI7Zm9yKG49MDtuPGEtMTsrK24pY1tuKzFdLmRlbGV0ZU9iamVjdCYmKHErPSIgICAgYXJnVHlwZSIrbisiLmRlbGV0ZU9iamVjdChhcmciK24rIik7XG4iKTtkLkNrfHwocSs9IiAgICByZXR1cm4gcmV0VHlwZS50b1dpcmVUeXBlKGRlc3RydWN0b3JzLCBydik7XG4iKTtlLnB1c2gocSsifTtcbiIpO2E9ZGUoZSkuYXBwbHkobnVsbCxmKTtlPXplKGEpO3JldHVybiBBZVtiXT1lfSxfOmZ1bmN0aW9uKGEpe2E9d2UoYSk7cmV0dXJuIFRkKGdbYV0pfSxvOmZ1bmN0aW9uKGEsYil7YT1pZShhKTtiPWllKGIpO3JldHVybiBUZChhW2JdKX0sZDpmdW5jdGlvbihhKXs0PGEmJihnZVthXS5Dais9CjEpfSxTOmZ1bmN0aW9uKGEsYixjLGQpe2E9aWUoYSk7dmFyIGU9Q2VbYl07ZXx8KGU9QmUoYiksQ2VbYl09ZSk7cmV0dXJuIGUoYSxjLGQpfSx2OmZ1bmN0aW9uKCl7cmV0dXJuIFRkKFtdKX0sZjpmdW5jdGlvbihhKXtyZXR1cm4gVGQod2UoYSkpfSxCOmZ1bmN0aW9uKCl7cmV0dXJuIFRkKHt9KX0sbTpmdW5jdGlvbihhKXt2YXIgYj1pZShhKTtlZChiKTtoZShhKX0sZzpmdW5jdGlvbihhLGIsYyl7YT1pZShhKTtiPWllKGIpO2M9aWUoYyk7YVtiXT1jfSxlOmZ1bmN0aW9uKGEsYil7YT1rZShhLCJfZW12YWxfdGFrZV92YWx1ZSIpO2E9YS5yZWFkVmFsdWVGcm9tUG9pbnRlcihiKTtyZXR1cm4gVGQoYSl9LGM6ZnVuY3Rpb24oKXtWYSgiIil9LGJhOmZ1bmN0aW9uKGEsYixjKXtEZS5sZW5ndGg9MDt2YXIgZDtmb3IoYz4+PTI7ZD10W2IrK107KWMrPTEwNSE9ZCZjLERlLnB1c2goMTA1PT1kP0RbY106aGFbYysrPj4xXSksKytjO3JldHVybiBKYlthXS5hcHBseShudWxsLERlKX0saGU6ZnVuY3Rpb24oYSwKYixjKXt2YXIgZD1nLmNhbnZhcztEW2E+PjJdPWQud2lkdGg7RFtiPj4yXT1kLmhlaWdodDtEW2M+PjJdPSRlPzE6MH0sQTpMZSx5ZzpmdW5jdGlvbihhKXtOLmFjdGl2ZVRleHR1cmUoYSl9LHhnOmZ1bmN0aW9uKGEsYil7Ti5hdHRhY2hTaGFkZXIoRGZbYV0sSGZbYl0pfSx6ZDpmdW5jdGlvbihhLGIpe04uYmVnaW5RdWVyeShhLEtmW2JdKX0sT2c6ZnVuY3Rpb24oYSxiKXtOLm5pLmJlZ2luUXVlcnlFWFQoYSxLZltiXSl9LGZkOmZ1bmN0aW9uKGEpe04uYmVnaW5UcmFuc2Zvcm1GZWVkYmFjayhhKX0sd2c6ZnVuY3Rpb24oYSxiLGMpe04uYmluZEF0dHJpYkxvY2F0aW9uKERmW2FdLGIsZGIoYykpfSx2ZzpmdW5jdGlvbihhLGIpezM1MDUxPT1hP04uRmk9YjozNTA1Mj09YSYmKE4ubWk9Yik7Ti5iaW5kQnVmZmVyKGEsQ2ZbYl0pfSxjZDpmdW5jdGlvbihhLGIsYyl7Ti5iaW5kQnVmZmVyQmFzZShhLGIsQ2ZbY10pfSxkZDpmdW5jdGlvbihhLGIsYyxkLGUpe04uYmluZEJ1ZmZlclJhbmdlKGEsCmIsQ2ZbY10sZCxlKX0sdWc6ZnVuY3Rpb24oYSxiKXtOLmJpbmRGcmFtZWJ1ZmZlcihhLEVmW2JdKX0sdGc6ZnVuY3Rpb24oYSxiKXtOLmJpbmRSZW5kZXJidWZmZXIoYSxGZltiXSl9LGdjOmZ1bmN0aW9uKGEsYil7Ti5iaW5kU2FtcGxlcihhLExmW2JdKX0sc2c6ZnVuY3Rpb24oYSxiKXtOLmJpbmRUZXh0dXJlKGEsR2ZbYl0pfSxfYjpmdW5jdGlvbihhLGIpe04uYmluZFRyYW5zZm9ybUZlZWRiYWNrKGEsTWZbYl0pfSxsZDpmdW5jdGlvbihhKXtOLmJpbmRWZXJ0ZXhBcnJheShJZlthXSl9LEdnOmZ1bmN0aW9uKGEpe04uYmluZFZlcnRleEFycmF5KElmW2FdKX0scmc6ZnVuY3Rpb24oYSxiLGMsZCl7Ti5ibGVuZENvbG9yKGEsYixjLGQpfSxxZzpmdW5jdGlvbihhKXtOLmJsZW5kRXF1YXRpb24oYSl9LHBnOmZ1bmN0aW9uKGEsYil7Ti5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoYSxiKX0sb2c6ZnVuY3Rpb24oYSxiKXtOLmJsZW5kRnVuYyhhLGIpfSxuZzpmdW5jdGlvbihhLGIsYyxkKXtOLmJsZW5kRnVuY1NlcGFyYXRlKGEsCmIsYyxkKX0sb2Q6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsbCxuLHEsdil7Ti5ibGl0RnJhbWVidWZmZXIoYSxiLGMsZCxlLGYsbCxuLHEsdil9LG1nOmZ1bmN0aW9uKGEsYixjLGQpezI8PVQudmVyc2lvbj9jJiZiP04uYnVmZmVyRGF0YShhLHQsZCxjLGIpOk4uYnVmZmVyRGF0YShhLGIsZCk6Ti5idWZmZXJEYXRhKGEsYz90LnN1YmFycmF5KGMsYytiKTpiLGQpfSxsZzpmdW5jdGlvbihhLGIsYyxkKXsyPD1ULnZlcnNpb24/YyYmTi5idWZmZXJTdWJEYXRhKGEsYix0LGQsYyk6Ti5idWZmZXJTdWJEYXRhKGEsYix0LnN1YmFycmF5KGQsZCtjKSl9LGtnOmZ1bmN0aW9uKGEpe3JldHVybiBOLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoYSl9LGpnOmZ1bmN0aW9uKGEpe04uY2xlYXIoYSl9LEZjOmZ1bmN0aW9uKGEsYixjLGQpe04uY2xlYXJCdWZmZXJmaShhLGIsYyxkKX0sR2M6ZnVuY3Rpb24oYSxiLGMpe04uY2xlYXJCdWZmZXJmdihhLGIsQixjPj4yKX0sSWM6ZnVuY3Rpb24oYSxiLGMpe04uY2xlYXJCdWZmZXJpdihhLApiLEQsYz4+Mil9LEhjOmZ1bmN0aW9uKGEsYixjKXtOLmNsZWFyQnVmZmVydWl2KGEsYixoLGM+PjIpfSxpZzpmdW5jdGlvbihhLGIsYyxkKXtOLmNsZWFyQ29sb3IoYSxiLGMsZCl9LGhnOmZ1bmN0aW9uKGEpe04uY2xlYXJEZXB0aChhKX0sZ2c6ZnVuY3Rpb24oYSl7Ti5jbGVhclN0ZW5jaWwoYSl9LHFjOmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBOLmNsaWVudFdhaXRTeW5jKE5mW2FdLGIsKGM+Pj4wKSs0Mjk0OTY3Mjk2KmQpfSxmZzpmdW5jdGlvbihhLGIsYyxkKXtOLmNvbG9yTWFzayghIWEsISFiLCEhYywhIWQpfSxlZzpmdW5jdGlvbihhKXtOLmNvbXBpbGVTaGFkZXIoSGZbYV0pfSxkZzpmdW5jdGlvbihhLGIsYyxkLGUsZixsLG4pezI8PVQudmVyc2lvbj9OLm1pfHwhbD9OLmNvbXByZXNzZWRUZXhJbWFnZTJEKGEsYixjLGQsZSxmLGwsbik6Ti5jb21wcmVzc2VkVGV4SW1hZ2UyRChhLGIsYyxkLGUsZix0LG4sbCk6Ti5jb21wcmVzc2VkVGV4SW1hZ2UyRChhLGIsYyxkLGUsCmYsbj90LnN1YmFycmF5KG4sbitsKTpudWxsKX0sRmQ6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsbCxuLHEpe04ubWk/Ti5jb21wcmVzc2VkVGV4SW1hZ2UzRChhLGIsYyxkLGUsZixsLG4scSk6Ti5jb21wcmVzc2VkVGV4SW1hZ2UzRChhLGIsYyxkLGUsZixsLHQscSxuKX0sY2c6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsbCxuLHEpezI8PVQudmVyc2lvbj9OLm1pfHwhbj9OLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKGEsYixjLGQsZSxmLGwsbixxKTpOLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKGEsYixjLGQsZSxmLGwsdCxxLG4pOk4uY29tcHJlc3NlZFRleFN1YkltYWdlMkQoYSxiLGMsZCxlLGYsbCxxP3Quc3ViYXJyYXkocSxxK24pOm51bGwpfSxFZDpmdW5jdGlvbihhLGIsYyxkLGUsZixsLG4scSx2LHcpe04ubWk/Ti5jb21wcmVzc2VkVGV4U3ViSW1hZ2UzRChhLGIsYyxkLGUsZixsLG4scSx2LHcpOk4uY29tcHJlc3NlZFRleFN1YkltYWdlM0QoYSxiLGMsZCxlLGYsbCxuLHEsdCx3LAp2KX0sQ2M6ZnVuY3Rpb24oYSxiLGMsZCxlKXtOLmNvcHlCdWZmZXJTdWJEYXRhKGEsYixjLGQsZSl9LGJnOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGwsbil7Ti5jb3B5VGV4SW1hZ2UyRChhLGIsYyxkLGUsZixsLG4pfSxhZzpmdW5jdGlvbihhLGIsYyxkLGUsZixsLG4pe04uY29weVRleFN1YkltYWdlMkQoYSxiLGMsZCxlLGYsbCxuKX0sR2Q6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsbCxuLHEpe04uY29weVRleFN1YkltYWdlM0QoYSxiLGMsZCxlLGYsbCxuLHEpfSwkZjpmdW5jdGlvbigpe3ZhciBhPVNmKERmKSxiPU4uY3JlYXRlUHJvZ3JhbSgpO2IubmFtZT1hO2Iuemk9Yi54aT1iLnlpPTA7Yi5taj0xO0RmW2FdPWI7cmV0dXJuIGF9LF9mOmZ1bmN0aW9uKGEpe3ZhciBiPVNmKEhmKTtIZltiXT1OLmNyZWF0ZVNoYWRlcihhKTtyZXR1cm4gYn0sWmY6ZnVuY3Rpb24oYSl7Ti5jdWxsRmFjZShhKX0sWWY6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MDtjPGE7YysrKXt2YXIgZD1EW2IrNCoKYz4+Ml0sZT1DZltkXTtlJiYoTi5kZWxldGVCdWZmZXIoZSksZS5uYW1lPTAsQ2ZbZF09bnVsbCxkPT1OLkZpJiYoTi5GaT0wKSxkPT1OLm1pJiYoTi5taT0wKSl9fSxYZjpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wO2M8YTsrK2Mpe3ZhciBkPURbYis0KmM+PjJdLGU9RWZbZF07ZSYmKE4uZGVsZXRlRnJhbWVidWZmZXIoZSksZS5uYW1lPTAsRWZbZF09bnVsbCl9fSxXZjpmdW5jdGlvbihhKXtpZihhKXt2YXIgYj1EZlthXTtiPyhOLmRlbGV0ZVByb2dyYW0oYiksYi5uYW1lPTAsRGZbYV09bnVsbCk6TygxMjgxKX19LEJkOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTA7YzxhO2MrKyl7dmFyIGQ9RFtiKzQqYz4+Ml0sZT1LZltkXTtlJiYoTi5kZWxldGVRdWVyeShlKSxLZltkXT1udWxsKX19LFFnOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTA7YzxhO2MrKyl7dmFyIGQ9RFtiKzQqYz4+Ml0sZT1LZltkXTtlJiYoTi5uaS5kZWxldGVRdWVyeUVYVChlKSxLZltkXT1udWxsKX19LFZmOmZ1bmN0aW9uKGEsCmIpe2Zvcih2YXIgYz0wO2M8YTtjKyspe3ZhciBkPURbYis0KmM+PjJdLGU9RmZbZF07ZSYmKE4uZGVsZXRlUmVuZGVyYnVmZmVyKGUpLGUubmFtZT0wLEZmW2RdPW51bGwpfX0samM6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MDtjPGE7YysrKXt2YXIgZD1EW2IrNCpjPj4yXSxlPUxmW2RdO2UmJihOLmRlbGV0ZVNhbXBsZXIoZSksZS5uYW1lPTAsTGZbZF09bnVsbCl9fSxVZjpmdW5jdGlvbihhKXtpZihhKXt2YXIgYj1IZlthXTtiPyhOLmRlbGV0ZVNoYWRlcihiKSxIZlthXT1udWxsKTpPKDEyODEpfX0scmM6ZnVuY3Rpb24oYSl7aWYoYSl7dmFyIGI9TmZbYV07Yj8oTi5kZWxldGVTeW5jKGIpLGIubmFtZT0wLE5mW2FdPW51bGwpOk8oMTI4MSl9fSxUZjpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wO2M8YTtjKyspe3ZhciBkPURbYis0KmM+PjJdLGU9R2ZbZF07ZSYmKE4uZGVsZXRlVGV4dHVyZShlKSxlLm5hbWU9MCxHZltkXT1udWxsKX19LFpiOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPQowO2M8YTtjKyspe3ZhciBkPURbYis0KmM+PjJdLGU9TWZbZF07ZSYmKE4uZGVsZXRlVHJhbnNmb3JtRmVlZGJhY2soZSksZS5uYW1lPTAsTWZbZF09bnVsbCl9fSxrZDpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wO2M8YTtjKyspe3ZhciBkPURbYis0KmM+PjJdO04uZGVsZXRlVmVydGV4QXJyYXkoSWZbZF0pO0lmW2RdPW51bGx9fSxGZzpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wO2M8YTtjKyspe3ZhciBkPURbYis0KmM+PjJdO04uZGVsZXRlVmVydGV4QXJyYXkoSWZbZF0pO0lmW2RdPW51bGx9fSxTZjpmdW5jdGlvbihhKXtOLmRlcHRoRnVuYyhhKX0sUmY6ZnVuY3Rpb24oYSl7Ti5kZXB0aE1hc2soISFhKX0sUWY6ZnVuY3Rpb24oYSxiKXtOLmRlcHRoUmFuZ2UoYSxiKX0sUGY6ZnVuY3Rpb24oYSxiKXtOLmRldGFjaFNoYWRlcihEZlthXSxIZltiXSl9LE9mOmZ1bmN0aW9uKGEpe04uZGlzYWJsZShhKX0sTmY6ZnVuY3Rpb24oYSl7Ti5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoYSl9LApNZjpmdW5jdGlvbihhLGIsYyl7Ti5kcmF3QXJyYXlzKGEsYixjKX0sdmM6ZnVuY3Rpb24oYSxiLGMsZCl7Ti5kcmF3QXJyYXlzSW5zdGFuY2VkKGEsYixjLGQpfSxCZzpmdW5jdGlvbihhLGIsYyxkKXtOLmRyYXdBcnJheXNJbnN0YW5jZWQoYSxiLGMsZCl9LEliOmZ1bmN0aW9uKGEsYixjLGQpe04uZHJhd0FycmF5c0luc3RhbmNlZChhLGIsYyxkKX0sTmQ6ZnVuY3Rpb24oYSxiLGMsZCl7Ti5kcmF3QXJyYXlzSW5zdGFuY2VkKGEsYixjLGQpfSxKYjpmdW5jdGlvbihhLGIsYyxkKXtOLmRyYXdBcnJheXNJbnN0YW5jZWQoYSxiLGMsZCl9LHZkOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPVdmW2FdLGQ9MDtkPGE7ZCsrKWNbZF09RFtiKzQqZD4+Ml07Ti5kcmF3QnVmZmVycyhjKX0sTGQ6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9V2ZbYV0sZD0wO2Q8YTtkKyspY1tkXT1EW2IrNCpkPj4yXTtOLmRyYXdCdWZmZXJzKGMpfSxDZzpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1XZlthXSxkPTA7ZDwKYTtkKyspY1tkXT1EW2IrNCpkPj4yXTtOLmRyYXdCdWZmZXJzKGMpfSxMZjpmdW5jdGlvbihhLGIsYyxkKXtOLmRyYXdFbGVtZW50cyhhLGIsYyxkKX0sdWM6ZnVuY3Rpb24oYSxiLGMsZCxlKXtOLmRyYXdFbGVtZW50c0luc3RhbmNlZChhLGIsYyxkLGUpfSxBZzpmdW5jdGlvbihhLGIsYyxkLGUpe04uZHJhd0VsZW1lbnRzSW5zdGFuY2VkKGEsYixjLGQsZSl9LEdiOmZ1bmN0aW9uKGEsYixjLGQsZSl7Ti5kcmF3RWxlbWVudHNJbnN0YW5jZWQoYSxiLGMsZCxlKX0sSGI6ZnVuY3Rpb24oYSxiLGMsZCxlKXtOLmRyYXdFbGVtZW50c0luc3RhbmNlZChhLGIsYyxkLGUpfSxNZDpmdW5jdGlvbihhLGIsYyxkLGUpe04uZHJhd0VsZW1lbnRzSW5zdGFuY2VkKGEsYixjLGQsZSl9LEpkOmZ1bmN0aW9uKGEsYixjLGQsZSxmKXtYZihhLGQsZSxmKX0sS2Y6ZnVuY3Rpb24oYSl7Ti5lbmFibGUoYSl9LEpmOmZ1bmN0aW9uKGEpe04uZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYSl9LHlkOmZ1bmN0aW9uKGEpe04uZW5kUXVlcnkoYSl9LApOZzpmdW5jdGlvbihhKXtOLm5pLmVuZFF1ZXJ5RVhUKGEpfSxlZDpmdW5jdGlvbigpe04uZW5kVHJhbnNmb3JtRmVlZGJhY2soKX0sdGM6ZnVuY3Rpb24oYSxiKXtyZXR1cm4oYT1OLmZlbmNlU3luYyhhLGIpKT8oYj1TZihOZiksYS5uYW1lPWIsTmZbYl09YSxiKTowfSxJZjpmdW5jdGlvbigpe04uZmluaXNoKCl9LEhmOmZ1bmN0aW9uKCl7Ti5mbHVzaCgpfSxHZjpmdW5jdGlvbihhLGIsYyxkKXtOLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGEsYixjLEZmW2RdKX0sRmY6ZnVuY3Rpb24oYSxiLGMsZCxlKXtOLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGEsYixjLEdmW2RdLGUpfSxtZDpmdW5jdGlvbihhLGIsYyxkLGUpe04uZnJhbWVidWZmZXJUZXh0dXJlTGF5ZXIoYSxiLEdmW2NdLGQsZSl9LEVmOmZ1bmN0aW9uKGEpe04uZnJvbnRGYWNlKGEpfSxEZjpmdW5jdGlvbihhLGIpe1lmKGEsYiwiY3JlYXRlQnVmZmVyIixDZil9LEJmOmZ1bmN0aW9uKGEsYil7WWYoYSxiLCJjcmVhdGVGcmFtZWJ1ZmZlciIsCkVmKX0sQ2Q6ZnVuY3Rpb24oYSxiKXtZZihhLGIsImNyZWF0ZVF1ZXJ5IixLZil9LFJnOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTA7YzxhO2MrKyl7dmFyIGQ9Ti5uaS5jcmVhdGVRdWVyeUVYVCgpO2lmKCFkKXtmb3IoTygxMjgyKTtjPGE7KURbYis0KmMrKz4+Ml09MDticmVha312YXIgZT1TZihLZik7ZC5uYW1lPWU7S2ZbZV09ZDtEW2IrNCpjPj4yXT1lfX0sQWY6ZnVuY3Rpb24oYSxiKXtZZihhLGIsImNyZWF0ZVJlbmRlcmJ1ZmZlciIsRmYpfSxrYzpmdW5jdGlvbihhLGIpe1lmKGEsYiwiY3JlYXRlU2FtcGxlciIsTGYpfSx6ZjpmdW5jdGlvbihhLGIpe1lmKGEsYiwiY3JlYXRlVGV4dHVyZSIsR2YpfSxZYjpmdW5jdGlvbihhLGIpe1lmKGEsYiwiY3JlYXRlVHJhbnNmb3JtRmVlZGJhY2siLE1mKX0samQ6ZnVuY3Rpb24oYSxiKXtZZihhLGIsImNyZWF0ZVZlcnRleEFycmF5IixJZil9LEVnOmZ1bmN0aW9uKGEsYil7WWYoYSxiLCJjcmVhdGVWZXJ0ZXhBcnJheSIsSWYpfSxDZjpmdW5jdGlvbihhKXtOLmdlbmVyYXRlTWlwbWFwKGEpfSwKeWY6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsbCl7WmYoImdldEFjdGl2ZUF0dHJpYiIsYSxiLGMsZCxlLGYsbCl9LHhmOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGwpe1pmKCJnZXRBY3RpdmVVbmlmb3JtIixhLGIsYyxkLGUsZixsKX0seGM6ZnVuY3Rpb24oYSxiLGMsZCxlKXthPURmW2FdO2lmKGE9Ti5nZXRBY3RpdmVVbmlmb3JtQmxvY2tOYW1lKGEsYikpZSYmMDxjPyhjPWViKGEsdCxlLGMpLGQmJihEW2Q+PjJdPWMpKTpkJiYoRFtkPj4yXT0wKX0seWM6ZnVuY3Rpb24oYSxiLGMsZCl7aWYoZClpZihhPURmW2FdLDM1MzkzPT1jKWM9Ti5nZXRBY3RpdmVVbmlmb3JtQmxvY2tOYW1lKGEsYiksRFtkPj4yXT1jLmxlbmd0aCsxO2Vsc2V7aWYoYT1OLmdldEFjdGl2ZVVuaWZvcm1CbG9ja1BhcmFtZXRlcihhLGIsYyksbnVsbCE9PWEpaWYoMzUzOTU9PWMpZm9yKGM9MDtjPGEubGVuZ3RoO2MrKylEW2QrNCpjPj4yXT1hW2NdO2Vsc2UgRFtkPj4yXT1hfWVsc2UgTygxMjgxKX0sQWM6ZnVuY3Rpb24oYSwKYixjLGQsZSl7aWYoZSlpZigwPGImJjA9PWMpTygxMjgxKTtlbHNle2E9RGZbYV07Zm9yKHZhciBmPVtdLGw9MDtsPGI7bCsrKWYucHVzaChEW2MrNCpsPj4yXSk7aWYoYT1OLmdldEFjdGl2ZVVuaWZvcm1zKGEsZixkKSlmb3IoYj1hLmxlbmd0aCxsPTA7bDxiO2wrKylEW2UrNCpsPj4yXT1hW2xdfWVsc2UgTygxMjgxKX0sd2Y6ZnVuY3Rpb24oYSxiLGMsZCl7YT1OLmdldEF0dGFjaGVkU2hhZGVycyhEZlthXSk7dmFyIGU9YS5sZW5ndGg7ZT5iJiYoZT1iKTtEW2M+PjJdPWU7Zm9yKGI9MDtiPGU7KytiKURbZCs0KmI+PjJdPUhmLmluZGV4T2YoYVtiXSl9LHZmOmZ1bmN0aW9uKGEsYil7cmV0dXJuIE4uZ2V0QXR0cmliTG9jYXRpb24oRGZbYV0sZGIoYikpfSx1ZjpmdW5jdGlvbihhLGIpe2FnKGEsYiw0KX0sbGM6ZnVuY3Rpb24oYSxiLGMpe2M/JGYoYyxOLmdldEJ1ZmZlclBhcmFtZXRlcihhLGIpKTpPKDEyODEpfSx0ZjpmdW5jdGlvbihhLGIsYyl7Yz9EW2M+PjJdPU4uZ2V0QnVmZmVyUGFyYW1ldGVyKGEsCmIpOk8oMTI4MSl9LHNmOmZ1bmN0aW9uKCl7dmFyIGE9Ti5nZXRFcnJvcigpfHxSZjtSZj0wO3JldHVybiBhfSxyZjpmdW5jdGlvbihhLGIpe2FnKGEsYiwyKX0sU2M6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gTi5nZXRGcmFnRGF0YUxvY2F0aW9uKERmW2FdLGRiKGIpKX0scWY6ZnVuY3Rpb24oYSxiLGMsZCl7YT1OLmdldEZyYW1lYnVmZmVyQXR0YWNobWVudFBhcmFtZXRlcihhLGIsYyk7aWYoYSBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyYnVmZmVyfHxhIGluc3RhbmNlb2YgV2ViR0xUZXh0dXJlKWE9YS5uYW1lfDA7RFtkPj4yXT1hfSxtYzpmdW5jdGlvbihhLGIsYyl7YmcoYSxiLGMsMSl9LG9jOmZ1bmN0aW9uKGEsYil7YWcoYSxiLDEpfSxnZDpmdW5jdGlvbihhLGIsYyl7YmcoYSxiLGMsMCl9LHBmOmZ1bmN0aW9uKGEsYil7YWcoYSxiLDApfSxNYjpmdW5jdGlvbihhLGIsYyxkLGUpe2lmKDA+ZClPKDEyODEpO2Vsc2UgaWYoZSl7aWYoYT1OLmdldEludGVybmFsZm9ybWF0UGFyYW1ldGVyKGEsCmIsYyksbnVsbCE9PWEpZm9yKGI9MDtiPGEubGVuZ3RoJiZiPGQ7KytiKURbZSs0KmI+PjJdPWFbYl19ZWxzZSBPKDEyODEpfSxVYjpmdW5jdGlvbigpe08oMTI4Mil9LG5mOmZ1bmN0aW9uKGEsYixjLGQpe2E9Ti5nZXRQcm9ncmFtSW5mb0xvZyhEZlthXSk7bnVsbD09PWEmJihhPSIodW5rbm93biBlcnJvcikiKTtiPTA8YiYmZD9lYihhLHQsZCxiKTowO2MmJihEW2M+PjJdPWIpfSxvZjpmdW5jdGlvbihhLGIsYyl7aWYoYylpZihhPj1CZilPKDEyODEpO2Vsc2UgaWYoYT1EZlthXSwzNTcxNj09YilhPU4uZ2V0UHJvZ3JhbUluZm9Mb2coYSksbnVsbD09PWEmJihhPSIodW5rbm93biBlcnJvcikiKSxEW2M+PjJdPWEubGVuZ3RoKzE7ZWxzZSBpZigzNTcxOT09Yil7aWYoIWEuemkpZm9yKGI9MDtiPE4uZ2V0UHJvZ3JhbVBhcmFtZXRlcihhLDM1NzE4KTsrK2IpYS56aT1NYXRoLm1heChhLnppLE4uZ2V0QWN0aXZlVW5pZm9ybShhLGIpLm5hbWUubGVuZ3RoKzEpO0RbYz4+Ml09YS56aX1lbHNlIGlmKDM1NzIyPT0KYil7aWYoIWEueGkpZm9yKGI9MDtiPE4uZ2V0UHJvZ3JhbVBhcmFtZXRlcihhLDM1NzIxKTsrK2IpYS54aT1NYXRoLm1heChhLnhpLE4uZ2V0QWN0aXZlQXR0cmliKGEsYikubmFtZS5sZW5ndGgrMSk7RFtjPj4yXT1hLnhpfWVsc2UgaWYoMzUzODE9PWIpe2lmKCFhLnlpKWZvcihiPTA7YjxOLmdldFByb2dyYW1QYXJhbWV0ZXIoYSwzNTM4Mik7KytiKWEueWk9TWF0aC5tYXgoYS55aSxOLmdldEFjdGl2ZVVuaWZvcm1CbG9ja05hbWUoYSxiKS5sZW5ndGgrMSk7RFtjPj4yXT1hLnlpfWVsc2UgRFtjPj4yXT1OLmdldFByb2dyYW1QYXJhbWV0ZXIoYSxiKTtlbHNlIE8oMTI4MSl9LElnOmZ1bmN0aW9uKGEsYixjKXtpZihjKXthPUtmW2FdO2I9Mj5ULnZlcnNpb24/Ti5uaS5nZXRRdWVyeU9iamVjdEVYVChhLGIpOk4uZ2V0UXVlcnlQYXJhbWV0ZXIoYSxiKTt2YXIgZDsiYm9vbGVhbiI9PXR5cGVvZiBiP2Q9Yj8xOjA6ZD1iOyRmKGMsZCl9ZWxzZSBPKDEyODEpfSxLZzpmdW5jdGlvbihhLApiLGMpe2lmKGMpe2E9Ti5uaS5nZXRRdWVyeU9iamVjdEVYVChLZlthXSxiKTt2YXIgZDsiYm9vbGVhbiI9PXR5cGVvZiBhP2Q9YT8xOjA6ZD1hO0RbYz4+Ml09ZH1lbHNlIE8oMTI4MSl9LEhnOmZ1bmN0aW9uKGEsYixjKXtpZihjKXthPUtmW2FdO2I9Mj5ULnZlcnNpb24/Ti5uaS5nZXRRdWVyeU9iamVjdEVYVChhLGIpOk4uZ2V0UXVlcnlQYXJhbWV0ZXIoYSxiKTt2YXIgZDsiYm9vbGVhbiI9PXR5cGVvZiBiP2Q9Yj8xOjA6ZD1iOyRmKGMsZCl9ZWxzZSBPKDEyODEpfSx3ZDpmdW5jdGlvbihhLGIsYyl7aWYoYyl7YT1OLmdldFF1ZXJ5UGFyYW1ldGVyKEtmW2FdLGIpO3ZhciBkOyJib29sZWFuIj09dHlwZW9mIGE/ZD1hPzE6MDpkPWE7RFtjPj4yXT1kfWVsc2UgTygxMjgxKX0sSmc6ZnVuY3Rpb24oYSxiLGMpe2lmKGMpe2E9Ti5uaS5nZXRRdWVyeU9iamVjdEVYVChLZlthXSxiKTt2YXIgZDsiYm9vbGVhbiI9PXR5cGVvZiBhP2Q9YT8xOjA6ZD1hO0RbYz4+Ml09ZH1lbHNlIE8oMTI4MSl9LAp4ZDpmdW5jdGlvbihhLGIsYyl7Yz9EW2M+PjJdPU4uZ2V0UXVlcnkoYSxiKTpPKDEyODEpfSxMZzpmdW5jdGlvbihhLGIsYyl7Yz9EW2M+PjJdPU4ubmkuZ2V0UXVlcnlFWFQoYSxiKTpPKDEyODEpfSxtZjpmdW5jdGlvbihhLGIsYyl7Yz9EW2M+PjJdPU4uZ2V0UmVuZGVyYnVmZmVyUGFyYW1ldGVyKGEsYik6TygxMjgxKX0sYWM6ZnVuY3Rpb24oYSxiLGMpe2M/QltjPj4yXT1OLmdldFNhbXBsZXJQYXJhbWV0ZXIoTGZbYV0sYik6TygxMjgxKX0sYmM6ZnVuY3Rpb24oYSxiLGMpe2M/RFtjPj4yXT1OLmdldFNhbXBsZXJQYXJhbWV0ZXIoTGZbYV0sYik6TygxMjgxKX0sa2Y6ZnVuY3Rpb24oYSxiLGMsZCl7YT1OLmdldFNoYWRlckluZm9Mb2coSGZbYV0pO251bGw9PT1hJiYoYT0iKHVua25vd24gZXJyb3IpIik7Yj0wPGImJmQ/ZWIoYSx0LGQsYik6MDtjJiYoRFtjPj4yXT1iKX0samY6ZnVuY3Rpb24oYSxiLGMsZCl7YT1OLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChhLGIpO0RbYz4+CjJdPWEucmFuZ2VNaW47RFtjKzQ+PjJdPWEucmFuZ2VNYXg7RFtkPj4yXT1hLnByZWNpc2lvbn0saGY6ZnVuY3Rpb24oYSxiLGMsZCl7aWYoYT1OLmdldFNoYWRlclNvdXJjZShIZlthXSkpYj0wPGImJmQ/ZWIoYSx0LGQsYik6MCxjJiYoRFtjPj4yXT1iKX0sbGY6ZnVuY3Rpb24oYSxiLGMpe2M/MzU3MTY9PWI/KGE9Ti5nZXRTaGFkZXJJbmZvTG9nKEhmW2FdKSxudWxsPT09YSYmKGE9Iih1bmtub3duIGVycm9yKSIpLERbYz4+Ml09YT9hLmxlbmd0aCsxOjApOjM1NzIwPT1iPyhhPU4uZ2V0U2hhZGVyU291cmNlKEhmW2FdKSxEW2M+PjJdPWE/YS5sZW5ndGgrMTowKTpEW2M+PjJdPU4uZ2V0U2hhZGVyUGFyYW1ldGVyKEhmW2FdLGIpOk8oMTI4MSl9LGdmOmZ1bmN0aW9uKGEpe3ZhciBiPU9mW2FdO2lmKCFiKXtzd2l0Y2goYSl7Y2FzZSA3OTM5OmI9Ti5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zKCl8fFtdO2I9Yi5jb25jYXQoYi5tYXAoZnVuY3Rpb24oZCl7cmV0dXJuIkdMXyIrZH0pKTsKYj1jZyhiLmpvaW4oIiAiKSk7YnJlYWs7Y2FzZSA3OTM2OmNhc2UgNzkzNzpjYXNlIDM3NDQ1OmNhc2UgMzc0NDY6KGI9Ti5nZXRQYXJhbWV0ZXIoYSkpfHxPKDEyODApO2I9YiYmY2coYik7YnJlYWs7Y2FzZSA3OTM4OmI9Ti5nZXRQYXJhbWV0ZXIoNzkzOCk7Yj0yPD1ULnZlcnNpb24/Ik9wZW5HTCBFUyAzLjAgKCIrYisiKSI6Ik9wZW5HTCBFUyAyLjAgKCIrYisiKSI7Yj1jZyhiKTticmVhaztjYXNlIDM1NzI0OmI9Ti5nZXRQYXJhbWV0ZXIoMzU3MjQpO3ZhciBjPWIubWF0Y2goL15XZWJHTCBHTFNMIEVTIChbMC05XVwuWzAtOV1bMC05XT8pKD86JHwgLiopLyk7bnVsbCE9PWMmJigzPT1jWzFdLmxlbmd0aCYmKGNbMV0rPSIwIiksYj0iT3BlbkdMIEVTIEdMU0wgRVMgIitjWzFdKyIgKCIrYisiKSIpO2I9Y2coYik7YnJlYWs7ZGVmYXVsdDpPKDEyODApfU9mW2FdPWJ9cmV0dXJuIGJ9LEVjOmZ1bmN0aW9uKGEsYil7aWYoMj5ULnZlcnNpb24pcmV0dXJuIE8oMTI4MiksMDt2YXIgYz0KUGZbYV07aWYoYylyZXR1cm4gMD5ifHxiPj1jLmxlbmd0aD8oTygxMjgxKSwwKTpjW2JdO3N3aXRjaChhKXtjYXNlIDc5Mzk6cmV0dXJuIGM9Ti5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zKCl8fFtdLGM9Yy5jb25jYXQoYy5tYXAoZnVuY3Rpb24oZCl7cmV0dXJuIkdMXyIrZH0pKSxjPWMubWFwKGZ1bmN0aW9uKGQpe3JldHVybiBjZyhkKX0pLGM9UGZbYV09YywwPmJ8fGI+PWMubGVuZ3RoPyhPKDEyODEpLDApOmNbYl07ZGVmYXVsdDpyZXR1cm4gTygxMjgwKSwwfX0sbmM6ZnVuY3Rpb24oYSxiLGMsZCxlKXswPmM/TygxMjgxKTplPyhhPU4uZ2V0U3luY1BhcmFtZXRlcihOZlthXSxiKSxudWxsIT09YSYmKERbZT4+Ml09YSxkJiYoRFtkPj4yXT0xKSkpOk8oMTI4MSl9LGZmOmZ1bmN0aW9uKGEsYixjKXtjP0JbYz4+Ml09Ti5nZXRUZXhQYXJhbWV0ZXIoYSxiKTpPKDEyODEpfSxlZjpmdW5jdGlvbihhLGIsYyl7Yz9EW2M+PjJdPU4uZ2V0VGV4UGFyYW1ldGVyKGEsYik6TygxMjgxKX0sCmFkOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGwpe2E9RGZbYV07aWYoYT1OLmdldFRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZyhhLGIpKWwmJjA8Yz8oYz1lYihhLm5hbWUsdCxsLGMpLGQmJihEW2Q+PjJdPWMpKTpkJiYoRFtkPj4yXT0wKSxlJiYoRFtlPj4yXT1hLnNpemUpLGYmJihEW2Y+PjJdPWEudHlwZSl9LHpjOmZ1bmN0aW9uKGEsYil7cmV0dXJuIE4uZ2V0VW5pZm9ybUJsb2NrSW5kZXgoRGZbYV0sZGIoYikpfSxCYzpmdW5jdGlvbihhLGIsYyxkKXtpZihkKWlmKDA8YiYmKDA9PWN8fDA9PWQpKU8oMTI4MSk7ZWxzZXthPURmW2FdO2Zvcih2YXIgZT1bXSxmPTA7ZjxiO2YrKyllLnB1c2goZGIoRFtjKzQqZj4+Ml0pKTtpZihhPU4uZ2V0VW5pZm9ybUluZGljZXMoYSxlKSlmb3IoYj1hLmxlbmd0aCxmPTA7ZjxiO2YrKylEW2QrNCpmPj4yXT1hW2ZdfWVsc2UgTygxMjgxKX0sYmY6ZnVuY3Rpb24oYSxiKXtiPWRiKGIpO2lmKGE9RGZbYV0pe2ZnKGEpO3ZhciBjPWEuS2ksZD0wLGU9YiwKZj1lZyhiKTswPGYmJihkPXBhcnNlSW50KGIuc2xpY2UoZisxKSk+Pj4wLGU9Yi5zbGljZSgwLGYpKTtpZigoZT1hLm5qW2VdKSYmZDxlWzBdJiYoZCs9ZVsxXSxjW2RdPWNbZF18fE4uZ2V0VW5pZm9ybUxvY2F0aW9uKGEsYikpKXJldHVybiBkfWVsc2UgTygxMjgxKTtyZXR1cm4tMX0sZGY6ZnVuY3Rpb24oYSxiLGMpe2dnKGEsYixjLDIpfSxjZjpmdW5jdGlvbihhLGIsYyl7Z2coYSxiLGMsMCl9LFRjOmZ1bmN0aW9uKGEsYixjKXtnZyhhLGIsYywwKX0sX2M6ZnVuY3Rpb24oYSxiLGMpe2hnKGEsYixjLDApfSxZYzpmdW5jdGlvbihhLGIsYyl7aGcoYSxiLGMsMCl9LF9lOmZ1bmN0aW9uKGEsYixjKXtjP0RbYz4+Ml09Ti5nZXRWZXJ0ZXhBdHRyaWJPZmZzZXQoYSxiKTpPKDEyODEpfSxhZjpmdW5jdGlvbihhLGIsYyl7aGcoYSxiLGMsMil9LCRlOmZ1bmN0aW9uKGEsYixjKXtoZyhhLGIsYyw1KX0sWmU6ZnVuY3Rpb24oYSxiKXtOLmhpbnQoYSxiKX0sUmI6ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD0KV2ZbYl0sZT0wO2U8YjtlKyspZFtlXT1EW2MrNCplPj4yXTtOLmludmFsaWRhdGVGcmFtZWJ1ZmZlcihhLGQpfSxRYjpmdW5jdGlvbihhLGIsYyxkLGUsZixsKXtmb3IodmFyIG49V2ZbYl0scT0wO3E8YjtxKyspbltxXT1EW2MrNCpxPj4yXTtOLmludmFsaWRhdGVTdWJGcmFtZWJ1ZmZlcihhLG4sZCxlLGYsbCl9LFllOmZ1bmN0aW9uKGEpe3JldHVybihhPUNmW2FdKT9OLmlzQnVmZmVyKGEpOjB9LFhlOmZ1bmN0aW9uKGEpe3JldHVybiBOLmlzRW5hYmxlZChhKX0sV2U6ZnVuY3Rpb24oYSl7cmV0dXJuKGE9RWZbYV0pP04uaXNGcmFtZWJ1ZmZlcihhKTowfSxWZTpmdW5jdGlvbihhKXtyZXR1cm4oYT1EZlthXSk/Ti5pc1Byb2dyYW0oYSk6MH0sQWQ6ZnVuY3Rpb24oYSl7cmV0dXJuKGE9S2ZbYV0pP04uaXNRdWVyeShhKTowfSxQZzpmdW5jdGlvbihhKXtyZXR1cm4oYT1LZlthXSk/Ti5uaS5pc1F1ZXJ5RVhUKGEpOjB9LFVlOmZ1bmN0aW9uKGEpe3JldHVybihhPUZmW2FdKT9OLmlzUmVuZGVyYnVmZmVyKGEpOgowfSxoYzpmdW5jdGlvbihhKXtyZXR1cm4oYT1MZlthXSk/Ti5pc1NhbXBsZXIoYSk6MH0sVGU6ZnVuY3Rpb24oYSl7cmV0dXJuKGE9SGZbYV0pP04uaXNTaGFkZXIoYSk6MH0sc2M6ZnVuY3Rpb24oYSl7cmV0dXJuIE4uaXNTeW5jKE5mW2FdKX0sU2U6ZnVuY3Rpb24oYSl7cmV0dXJuKGE9R2ZbYV0pP04uaXNUZXh0dXJlKGEpOjB9LFhiOmZ1bmN0aW9uKGEpe3JldHVybiBOLmlzVHJhbnNmb3JtRmVlZGJhY2soTWZbYV0pfSxoZDpmdW5jdGlvbihhKXtyZXR1cm4oYT1JZlthXSk/Ti5pc1ZlcnRleEFycmF5KGEpOjB9LERnOmZ1bmN0aW9uKGEpe3JldHVybihhPUlmW2FdKT9OLmlzVmVydGV4QXJyYXkoYSk6MH0sUmU6ZnVuY3Rpb24oYSl7Ti5saW5lV2lkdGgoYSl9LFFlOmZ1bmN0aW9uKGEpe2E9RGZbYV07Ti5saW5rUHJvZ3JhbShhKTthLktpPTA7YS5uaj17fX0sV2I6ZnVuY3Rpb24oKXtOLnBhdXNlVHJhbnNmb3JtRmVlZGJhY2soKX0sUGU6ZnVuY3Rpb24oYSxiKXszMzE3PT1hJiYKKFFmPWIpO04ucGl4ZWxTdG9yZWkoYSxiKX0sT2U6ZnVuY3Rpb24oYSxiKXtOLnBvbHlnb25PZmZzZXQoYSxiKX0sVGI6ZnVuY3Rpb24oKXtPKDEyODApfSxTYjpmdW5jdGlvbigpe08oMTI4MCl9LE1nOmZ1bmN0aW9uKGEsYil7Ti5uaS5xdWVyeUNvdW50ZXJFWFQoS2ZbYV0sYil9LEtkOmZ1bmN0aW9uKGEpe04ucmVhZEJ1ZmZlcihhKX0sTmU6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsbCl7aWYoMjw9VC52ZXJzaW9uKWlmKE4uRmkpTi5yZWFkUGl4ZWxzKGEsYixjLGQsZSxmLGwpO2Vsc2V7dmFyIG49aWcoZik7Ti5yZWFkUGl4ZWxzKGEsYixjLGQsZSxmLG4sbD4+amcobikpfWVsc2UobD1rZyhmLGUsYyxkLGwpKT9OLnJlYWRQaXhlbHMoYSxiLGMsZCxlLGYsbCk6TygxMjgwKX0sTWU6ZnVuY3Rpb24oKXt9LExlOmZ1bmN0aW9uKGEsYixjLGQpe04ucmVuZGVyYnVmZmVyU3RvcmFnZShhLGIsYyxkKX0sbmQ6ZnVuY3Rpb24oYSxiLGMsZCxlKXtOLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZShhLApiLGMsZCxlKX0sVmI6ZnVuY3Rpb24oKXtOLnJlc3VtZVRyYW5zZm9ybUZlZWRiYWNrKCl9LEtlOmZ1bmN0aW9uKGEsYil7Ti5zYW1wbGVDb3ZlcmFnZShhLCEhYil9LGRjOmZ1bmN0aW9uKGEsYixjKXtOLnNhbXBsZXJQYXJhbWV0ZXJmKExmW2FdLGIsYyl9LGNjOmZ1bmN0aW9uKGEsYixjKXtOLnNhbXBsZXJQYXJhbWV0ZXJmKExmW2FdLGIsQltjPj4yXSl9LGZjOmZ1bmN0aW9uKGEsYixjKXtOLnNhbXBsZXJQYXJhbWV0ZXJpKExmW2FdLGIsYyl9LGVjOmZ1bmN0aW9uKGEsYixjKXtOLnNhbXBsZXJQYXJhbWV0ZXJpKExmW2FdLGIsRFtjPj4yXSl9LEplOmZ1bmN0aW9uKGEsYixjLGQpe04uc2Npc3NvcihhLGIsYyxkKX0sSWU6ZnVuY3Rpb24oKXtPKDEyODApfSxIZTpmdW5jdGlvbihhLGIsYyxkKXtiPVRmKGIsYyxkKTtOLnNoYWRlclNvdXJjZShIZlthXSxiKX0sR2U6ZnVuY3Rpb24oYSxiLGMpe04uc3RlbmNpbEZ1bmMoYSxiLGMpfSxGZTpmdW5jdGlvbihhLGIsYyxkKXtOLnN0ZW5jaWxGdW5jU2VwYXJhdGUoYSwKYixjLGQpfSxFZTpmdW5jdGlvbihhKXtOLnN0ZW5jaWxNYXNrKGEpfSxEZTpmdW5jdGlvbihhLGIpe04uc3RlbmNpbE1hc2tTZXBhcmF0ZShhLGIpfSxDZTpmdW5jdGlvbihhLGIsYyl7Ti5zdGVuY2lsT3AoYSxiLGMpfSxCZTpmdW5jdGlvbihhLGIsYyxkKXtOLnN0ZW5jaWxPcFNlcGFyYXRlKGEsYixjLGQpfSxBZTpmdW5jdGlvbihhLGIsYyxkLGUsZixsLG4scSl7aWYoMjw9VC52ZXJzaW9uKWlmKE4ubWkpTi50ZXhJbWFnZTJEKGEsYixjLGQsZSxmLGwsbixxKTtlbHNlIGlmKHEpe3ZhciB2PWlnKG4pO04udGV4SW1hZ2UyRChhLGIsYyxkLGUsZixsLG4sdixxPj5qZyh2KSl9ZWxzZSBOLnRleEltYWdlMkQoYSxiLGMsZCxlLGYsbCxuLG51bGwpO2Vsc2UgTi50ZXhJbWFnZTJEKGEsYixjLGQsZSxmLGwsbixxP2tnKG4sbCxkLGUscSk6bnVsbCl9LElkOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGwsbixxLHYpe2lmKE4ubWkpTi50ZXhJbWFnZTNEKGEsYixjLGQsZSxmLGwsbixxLHYpO2Vsc2UgaWYodil7dmFyIHc9CmlnKHEpO04udGV4SW1hZ2UzRChhLGIsYyxkLGUsZixsLG4scSx3LHY+PmpnKHcpKX1lbHNlIE4udGV4SW1hZ2UzRChhLGIsYyxkLGUsZixsLG4scSxudWxsKX0semU6ZnVuY3Rpb24oYSxiLGMpe04udGV4UGFyYW1ldGVyZihhLGIsYyl9LHllOmZ1bmN0aW9uKGEsYixjKXtOLnRleFBhcmFtZXRlcmYoYSxiLEJbYz4+Ml0pfSx4ZTpmdW5jdGlvbihhLGIsYyl7Ti50ZXhQYXJhbWV0ZXJpKGEsYixjKX0sd2U6ZnVuY3Rpb24oYSxiLGMpe04udGV4UGFyYW1ldGVyaShhLGIsRFtjPj4yXSl9LE9iOmZ1bmN0aW9uKGEsYixjLGQsZSl7Ti50ZXhTdG9yYWdlMkQoYSxiLGMsZCxlKX0sTmI6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe04udGV4U3RvcmFnZTNEKGEsYixjLGQsZSxmKX0sdmU6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsbCxuLHEpe2lmKDI8PVQudmVyc2lvbilpZihOLm1pKU4udGV4U3ViSW1hZ2UyRChhLGIsYyxkLGUsZixsLG4scSk7ZWxzZSBpZihxKXt2YXIgdj1pZyhuKTtOLnRleFN1YkltYWdlMkQoYSwKYixjLGQsZSxmLGwsbix2LHE+PmpnKHYpKX1lbHNlIE4udGV4U3ViSW1hZ2UyRChhLGIsYyxkLGUsZixsLG4sbnVsbCk7ZWxzZSB2PW51bGwscSYmKHY9a2cobixsLGUsZixxKSksTi50ZXhTdWJJbWFnZTJEKGEsYixjLGQsZSxmLGwsbix2KX0sSGQ6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsbCxuLHEsdix3KXtpZihOLm1pKU4udGV4U3ViSW1hZ2UzRChhLGIsYyxkLGUsZixsLG4scSx2LHcpO2Vsc2UgaWYodyl7dmFyIEM9aWcodik7Ti50ZXhTdWJJbWFnZTNEKGEsYixjLGQsZSxmLGwsbixxLHYsQyx3Pj5qZyhDKSl9ZWxzZSBOLnRleFN1YkltYWdlM0QoYSxiLGMsZCxlLGYsbCxuLHEsdixudWxsKX0sYmQ6ZnVuY3Rpb24oYSxiLGMsZCl7YT1EZlthXTtmb3IodmFyIGU9W10sZj0wO2Y8YjtmKyspZS5wdXNoKGRiKERbYys0KmY+PjJdKSk7Ti50cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzKGEsZSxkKX0sdWU6ZnVuY3Rpb24oYSxiKXtOLnVuaWZvcm0xZihWKGEpLGIpfSx0ZTpmdW5jdGlvbihhLApiLGMpe2lmKDI8PVQudmVyc2lvbiliJiZOLnVuaWZvcm0xZnYoVihhKSxCLGM+PjIsYik7ZWxzZXtpZigyODg+PWIpZm9yKHZhciBkPWxnW2ItMV0sZT0wO2U8YjsrK2UpZFtlXT1CW2MrNCplPj4yXTtlbHNlIGQ9Qi5zdWJhcnJheShjPj4yLGMrNCpiPj4yKTtOLnVuaWZvcm0xZnYoVihhKSxkKX19LHJlOmZ1bmN0aW9uKGEsYil7Ti51bmlmb3JtMWkoVihhKSxiKX0scWU6ZnVuY3Rpb24oYSxiLGMpe2lmKDI8PVQudmVyc2lvbiliJiZOLnVuaWZvcm0xaXYoVihhKSxELGM+PjIsYik7ZWxzZXtpZigyODg+PWIpZm9yKHZhciBkPW1nW2ItMV0sZT0wO2U8YjsrK2UpZFtlXT1EW2MrNCplPj4yXTtlbHNlIGQ9RC5zdWJhcnJheShjPj4yLGMrNCpiPj4yKTtOLnVuaWZvcm0xaXYoVihhKSxkKX19LFJjOmZ1bmN0aW9uKGEsYil7Ti51bmlmb3JtMXVpKFYoYSksYil9LE1jOmZ1bmN0aW9uKGEsYixjKXtiJiZOLnVuaWZvcm0xdWl2KFYoYSksaCxjPj4yLGIpfSxwZTpmdW5jdGlvbihhLGIsYyl7Ti51bmlmb3JtMmYoVihhKSwKYixjKX0sb2U6ZnVuY3Rpb24oYSxiLGMpe2lmKDI8PVQudmVyc2lvbiliJiZOLnVuaWZvcm0yZnYoVihhKSxCLGM+PjIsMipiKTtlbHNle2lmKDE0ND49Yilmb3IodmFyIGQ9bGdbMipiLTFdLGU9MDtlPDIqYjtlKz0yKWRbZV09QltjKzQqZT4+Ml0sZFtlKzFdPUJbYysoNCplKzQpPj4yXTtlbHNlIGQ9Qi5zdWJhcnJheShjPj4yLGMrOCpiPj4yKTtOLnVuaWZvcm0yZnYoVihhKSxkKX19LG5lOmZ1bmN0aW9uKGEsYixjKXtOLnVuaWZvcm0yaShWKGEpLGIsYyl9LG1lOmZ1bmN0aW9uKGEsYixjKXtpZigyPD1ULnZlcnNpb24pYiYmTi51bmlmb3JtMml2KFYoYSksRCxjPj4yLDIqYik7ZWxzZXtpZigxNDQ+PWIpZm9yKHZhciBkPW1nWzIqYi0xXSxlPTA7ZTwyKmI7ZSs9MilkW2VdPURbYys0KmU+PjJdLGRbZSsxXT1EW2MrKDQqZSs0KT4+Ml07ZWxzZSBkPUQuc3ViYXJyYXkoYz4+MixjKzgqYj4+Mik7Ti51bmlmb3JtMml2KFYoYSksZCl9fSxRYzpmdW5jdGlvbihhLGIsYyl7Ti51bmlmb3JtMnVpKFYoYSksCmIsYyl9LExjOmZ1bmN0aW9uKGEsYixjKXtiJiZOLnVuaWZvcm0ydWl2KFYoYSksaCxjPj4yLDIqYil9LGxlOmZ1bmN0aW9uKGEsYixjLGQpe04udW5pZm9ybTNmKFYoYSksYixjLGQpfSxrZTpmdW5jdGlvbihhLGIsYyl7aWYoMjw9VC52ZXJzaW9uKWImJk4udW5pZm9ybTNmdihWKGEpLEIsYz4+MiwzKmIpO2Vsc2V7aWYoOTY+PWIpZm9yKHZhciBkPWxnWzMqYi0xXSxlPTA7ZTwzKmI7ZSs9MylkW2VdPUJbYys0KmU+PjJdLGRbZSsxXT1CW2MrKDQqZSs0KT4+Ml0sZFtlKzJdPUJbYysoNCplKzgpPj4yXTtlbHNlIGQ9Qi5zdWJhcnJheShjPj4yLGMrMTIqYj4+Mik7Ti51bmlmb3JtM2Z2KFYoYSksZCl9fSxqZTpmdW5jdGlvbihhLGIsYyxkKXtOLnVuaWZvcm0zaShWKGEpLGIsYyxkKX0saWU6ZnVuY3Rpb24oYSxiLGMpe2lmKDI8PVQudmVyc2lvbiliJiZOLnVuaWZvcm0zaXYoVihhKSxELGM+PjIsMypiKTtlbHNle2lmKDk2Pj1iKWZvcih2YXIgZD1tZ1szKmItMV0sZT0wO2U8MypiO2UrPQozKWRbZV09RFtjKzQqZT4+Ml0sZFtlKzFdPURbYysoNCplKzQpPj4yXSxkW2UrMl09RFtjKyg0KmUrOCk+PjJdO2Vsc2UgZD1ELnN1YmFycmF5KGM+PjIsYysxMipiPj4yKTtOLnVuaWZvcm0zaXYoVihhKSxkKX19LFBjOmZ1bmN0aW9uKGEsYixjLGQpe04udW5pZm9ybTN1aShWKGEpLGIsYyxkKX0sS2M6ZnVuY3Rpb24oYSxiLGMpe2ImJk4udW5pZm9ybTN1aXYoVihhKSxoLGM+PjIsMypiKX0sZ2U6ZnVuY3Rpb24oYSxiLGMsZCxlKXtOLnVuaWZvcm00ZihWKGEpLGIsYyxkLGUpfSxmZTpmdW5jdGlvbihhLGIsYyl7aWYoMjw9VC52ZXJzaW9uKWImJk4udW5pZm9ybTRmdihWKGEpLEIsYz4+Miw0KmIpO2Vsc2V7aWYoNzI+PWIpe3ZhciBkPWxnWzQqYi0xXSxlPUI7Yz4+PTI7Zm9yKHZhciBmPTA7Zjw0KmI7Zis9NCl7dmFyIGw9YytmO2RbZl09ZVtsXTtkW2YrMV09ZVtsKzFdO2RbZisyXT1lW2wrMl07ZFtmKzNdPWVbbCszXX19ZWxzZSBkPUIuc3ViYXJyYXkoYz4+MixjKzE2KmI+PjIpOwpOLnVuaWZvcm00ZnYoVihhKSxkKX19LGVlOmZ1bmN0aW9uKGEsYixjLGQsZSl7Ti51bmlmb3JtNGkoVihhKSxiLGMsZCxlKX0sZGU6ZnVuY3Rpb24oYSxiLGMpe2lmKDI8PVQudmVyc2lvbiliJiZOLnVuaWZvcm00aXYoVihhKSxELGM+PjIsNCpiKTtlbHNle2lmKDcyPj1iKWZvcih2YXIgZD1tZ1s0KmItMV0sZT0wO2U8NCpiO2UrPTQpZFtlXT1EW2MrNCplPj4yXSxkW2UrMV09RFtjKyg0KmUrNCk+PjJdLGRbZSsyXT1EW2MrKDQqZSs4KT4+Ml0sZFtlKzNdPURbYysoNCplKzEyKT4+Ml07ZWxzZSBkPUQuc3ViYXJyYXkoYz4+MixjKzE2KmI+PjIpO04udW5pZm9ybTRpdihWKGEpLGQpfX0sTmM6ZnVuY3Rpb24oYSxiLGMsZCxlKXtOLnVuaWZvcm00dWkoVihhKSxiLGMsZCxlKX0sSmM6ZnVuY3Rpb24oYSxiLGMpe2ImJk4udW5pZm9ybTR1aXYoVihhKSxoLGM+PjIsNCpiKX0sd2M6ZnVuY3Rpb24oYSxiLGMpe2E9RGZbYV07Ti51bmlmb3JtQmxvY2tCaW5kaW5nKGEsYixjKX0sY2U6ZnVuY3Rpb24oYSwKYixjLGQpe2lmKDI8PVQudmVyc2lvbiliJiZOLnVuaWZvcm1NYXRyaXgyZnYoVihhKSwhIWMsQixkPj4yLDQqYik7ZWxzZXtpZig3Mj49Yilmb3IodmFyIGU9bGdbNCpiLTFdLGY9MDtmPDQqYjtmKz00KWVbZl09QltkKzQqZj4+Ml0sZVtmKzFdPUJbZCsoNCpmKzQpPj4yXSxlW2YrMl09QltkKyg0KmYrOCk+PjJdLGVbZiszXT1CW2QrKDQqZisxMik+PjJdO2Vsc2UgZT1CLnN1YmFycmF5KGQ+PjIsZCsxNipiPj4yKTtOLnVuaWZvcm1NYXRyaXgyZnYoVihhKSwhIWMsZSl9fSx1ZDpmdW5jdGlvbihhLGIsYyxkKXtiJiZOLnVuaWZvcm1NYXRyaXgyeDNmdihWKGEpLCEhYyxCLGQ+PjIsNipiKX0sc2Q6ZnVuY3Rpb24oYSxiLGMsZCl7YiYmTi51bmlmb3JtTWF0cml4Mng0ZnYoVihhKSwhIWMsQixkPj4yLDgqYil9LGJlOmZ1bmN0aW9uKGEsYixjLGQpe2lmKDI8PVQudmVyc2lvbiliJiZOLnVuaWZvcm1NYXRyaXgzZnYoVihhKSwhIWMsQixkPj4yLDkqYik7ZWxzZXtpZigzMj49Yilmb3IodmFyIGU9CmxnWzkqYi0xXSxmPTA7Zjw5KmI7Zis9OSllW2ZdPUJbZCs0KmY+PjJdLGVbZisxXT1CW2QrKDQqZis0KT4+Ml0sZVtmKzJdPUJbZCsoNCpmKzgpPj4yXSxlW2YrM109QltkKyg0KmYrMTIpPj4yXSxlW2YrNF09QltkKyg0KmYrMTYpPj4yXSxlW2YrNV09QltkKyg0KmYrMjApPj4yXSxlW2YrNl09QltkKyg0KmYrMjQpPj4yXSxlW2YrN109QltkKyg0KmYrMjgpPj4yXSxlW2YrOF09QltkKyg0KmYrMzIpPj4yXTtlbHNlIGU9Qi5zdWJhcnJheShkPj4yLGQrMzYqYj4+Mik7Ti51bmlmb3JtTWF0cml4M2Z2KFYoYSksISFjLGUpfX0sdGQ6ZnVuY3Rpb24oYSxiLGMsZCl7YiYmTi51bmlmb3JtTWF0cml4M3gyZnYoVihhKSwhIWMsQixkPj4yLDYqYil9LHFkOmZ1bmN0aW9uKGEsYixjLGQpe2ImJk4udW5pZm9ybU1hdHJpeDN4NGZ2KFYoYSksISFjLEIsZD4+MiwxMipiKX0sYWU6ZnVuY3Rpb24oYSxiLGMsZCl7aWYoMjw9VC52ZXJzaW9uKWImJk4udW5pZm9ybU1hdHJpeDRmdihWKGEpLCEhYywKQixkPj4yLDE2KmIpO2Vsc2V7aWYoMTg+PWIpe3ZhciBlPWxnWzE2KmItMV0sZj1CO2Q+Pj0yO2Zvcih2YXIgbD0wO2w8MTYqYjtsKz0xNil7dmFyIG49ZCtsO2VbbF09ZltuXTtlW2wrMV09ZltuKzFdO2VbbCsyXT1mW24rMl07ZVtsKzNdPWZbbiszXTtlW2wrNF09ZltuKzRdO2VbbCs1XT1mW24rNV07ZVtsKzZdPWZbbis2XTtlW2wrN109ZltuKzddO2VbbCs4XT1mW24rOF07ZVtsKzldPWZbbis5XTtlW2wrMTBdPWZbbisxMF07ZVtsKzExXT1mW24rMTFdO2VbbCsxMl09ZltuKzEyXTtlW2wrMTNdPWZbbisxM107ZVtsKzE0XT1mW24rMTRdO2VbbCsxNV09ZltuKzE1XX19ZWxzZSBlPUIuc3ViYXJyYXkoZD4+MixkKzY0KmI+PjIpO04udW5pZm9ybU1hdHJpeDRmdihWKGEpLCEhYyxlKX19LHJkOmZ1bmN0aW9uKGEsYixjLGQpe2ImJk4udW5pZm9ybU1hdHJpeDR4MmZ2KFYoYSksISFjLEIsZD4+Miw4KmIpfSxwZDpmdW5jdGlvbihhLGIsYyxkKXtiJiZOLnVuaWZvcm1NYXRyaXg0eDNmdihWKGEpLAohIWMsQixkPj4yLDEyKmIpfSwkZDpmdW5jdGlvbihhKXthPURmW2FdO04udXNlUHJvZ3JhbShhKTtOLlFqPWF9LF9kOmZ1bmN0aW9uKGEpe04udmFsaWRhdGVQcm9ncmFtKERmW2FdKX0sWmQ6ZnVuY3Rpb24oYSxiKXtOLnZlcnRleEF0dHJpYjFmKGEsYil9LFhkOmZ1bmN0aW9uKGEsYil7Ti52ZXJ0ZXhBdHRyaWIxZihhLEJbYj4+Ml0pfSxXZDpmdW5jdGlvbihhLGIsYyl7Ti52ZXJ0ZXhBdHRyaWIyZihhLGIsYyl9LFZkOmZ1bmN0aW9uKGEsYil7Ti52ZXJ0ZXhBdHRyaWIyZihhLEJbYj4+Ml0sQltiKzQ+PjJdKX0sVWQ6ZnVuY3Rpb24oYSxiLGMsZCl7Ti52ZXJ0ZXhBdHRyaWIzZihhLGIsYyxkKX0sVGQ6ZnVuY3Rpb24oYSxiKXtOLnZlcnRleEF0dHJpYjNmKGEsQltiPj4yXSxCW2IrND4+Ml0sQltiKzg+PjJdKX0sU2Q6ZnVuY3Rpb24oYSxiLGMsZCxlKXtOLnZlcnRleEF0dHJpYjRmKGEsYixjLGQsZSl9LFJkOmZ1bmN0aW9uKGEsYil7Ti52ZXJ0ZXhBdHRyaWI0ZihhLEJbYj4+Ml0sCkJbYis0Pj4yXSxCW2IrOD4+Ml0sQltiKzEyPj4yXSl9LCRiOmZ1bmN0aW9uKGEsYil7Ti52ZXJ0ZXhBdHRyaWJEaXZpc29yKGEsYil9LHpnOmZ1bmN0aW9uKGEsYil7Ti52ZXJ0ZXhBdHRyaWJEaXZpc29yKGEsYil9LEtiOmZ1bmN0aW9uKGEsYil7Ti52ZXJ0ZXhBdHRyaWJEaXZpc29yKGEsYil9LE9kOmZ1bmN0aW9uKGEsYil7Ti52ZXJ0ZXhBdHRyaWJEaXZpc29yKGEsYil9LExiOmZ1bmN0aW9uKGEsYil7Ti52ZXJ0ZXhBdHRyaWJEaXZpc29yKGEsYil9LFhjOmZ1bmN0aW9uKGEsYixjLGQsZSl7Ti52ZXJ0ZXhBdHRyaWJJNGkoYSxiLGMsZCxlKX0sVmM6ZnVuY3Rpb24oYSxiKXtOLnZlcnRleEF0dHJpYkk0aShhLERbYj4+Ml0sRFtiKzQ+PjJdLERbYis4Pj4yXSxEW2IrMTI+PjJdKX0sV2M6ZnVuY3Rpb24oYSxiLGMsZCxlKXtOLnZlcnRleEF0dHJpYkk0dWkoYSxiLGMsZCxlKX0sVWM6ZnVuY3Rpb24oYSxiKXtOLnZlcnRleEF0dHJpYkk0dWkoYSxoW2I+PjJdLGhbYis0Pj4yXSxoW2IrCjg+PjJdLGhbYisxMj4+Ml0pfSwkYzpmdW5jdGlvbihhLGIsYyxkLGUpe04udmVydGV4QXR0cmliSVBvaW50ZXIoYSxiLGMsZCxlKX0sUWQ6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe04udmVydGV4QXR0cmliUG9pbnRlcihhLGIsYywhIWQsZSxmKX0sUGQ6ZnVuY3Rpb24oYSxiLGMsZCl7Ti52aWV3cG9ydChhLGIsYyxkKX0scGM6ZnVuY3Rpb24oYSxiLGMsZCl7Ti53YWl0U3luYyhOZlthXSxiLChjPj4+MCkrNDI5NDk2NzI5NipkKX0sQmI6ZnVuY3Rpb24oYSl7dmFyIGI9dC5sZW5ndGg7YT4+Pj0wO2lmKDIxNDc0ODM2NDg8YSlyZXR1cm4hMTtmb3IodmFyIGM9MTs0Pj1jO2MqPTIpe3ZhciBkPWIqKDErLjIvYyk7ZD1NYXRoLm1pbihkLGErMTAwNjYzMjk2KTt2YXIgZT1NYXRoO2Q9TWF0aC5tYXgoYSxkKTtlPWUubWluLmNhbGwoZSwyMTQ3NDgzNjQ4LGQrKDY1NTM2LWQlNjU1MzYpJTY1NTM2KTthOnt0cnl7V2EuZ3JvdyhlLWdiLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNik7bWIoKTt2YXIgZj0KMTticmVhayBhfWNhdGNoKGwpe31mPXZvaWQgMH1pZihmKXJldHVybiEwfXJldHVybiExfSxzYTpmdW5jdGlvbihhLGIpe2I+Pj0yO2I9e2FscGhhOiEhRFtiXSxkZXB0aDohIURbYisxXSxzdGVuY2lsOiEhRFtiKzJdLGFudGlhbGlhczohIURbYiszXSxwcmVtdWx0aXBsaWVkQWxwaGE6ISFEW2IrNF0scHJlc2VydmVEcmF3aW5nQnVmZmVyOiEhRFtiKzVdLHBvd2VyUHJlZmVyZW5jZTpwZ1tEW2IrNl1dLGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6ISFEW2IrN10seWo6RFtiKzhdLGtsOkRbYis5XSxTajpEW2IrMTBdLHJrOkRbYisxMV0sb2w6RFtiKzEyXSxwbDpEW2IrMTNdfTsibnVtYmVyIj09dHlwZW9mIGEmJihhPWRiKGEpKTthPWEmJiIjY2FudmFzIiE9PWE/InVuZGVmaW5lZCIhPXR5cGVvZiBrZiYmSmZbYV0/SmZbYV06cmcoYSk6InVuZGVmaW5lZCIhPXR5cGVvZiBrZiYmSmYuY2FudmFzP0pmLmNhbnZhczpnLmNhbnZhcztyZXR1cm4hYXx8Yi5yaz8wOmxmKGEsYil9LApaYzpmdW5jdGlvbihhKXtUPT1hJiYoVD0wKTtUPT09bWZbYV0mJihUPW51bGwpO2lmKCJvYmplY3QiPT10eXBlb2Ygb2cpZm9yKHZhciBiPW1mW2FdLkxpLmNhbnZhcyxjPTA7YzxuZy5sZW5ndGg7KytjKWlmKG5nW2NdLnRhcmdldD09Yil7dmFyIGQ9Yy0tLGU9bmdbZF07ZS50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLmVsLGUuZGwsZS5ybCk7bmcuc3BsaWNlKGQsMSl9bWZbYV0mJm1mW2FdLkxpLmNhbnZhcyYmKG1mW2FdLkxpLmNhbnZhcy5oaz12b2lkIDApO21mW2FdPW51bGx9LERkOmZ1bmN0aW9uKGEpe2E+Pj0yO2Zvcih2YXIgYj0wOzE0PmI7KytiKURbYStiXT0wO0RbYV09RFthKzFdPURbYSszXT1EW2ErNF09RFthKzhdPURbYSsxMF09MX0saWQ6ZnVuY3Rpb24oYSl7cmV0dXJuIG5mKGEpPzA6LTV9LHliOmZ1bmN0aW9uKGEsYil7dmFyIGM9MDt0ZygpLmZvckVhY2goZnVuY3Rpb24oZCxlKXt2YXIgZj1iK2M7ZT1oW2ErNCplPj4yXT1mO2ZvcihmPTA7ZjxkLmxlbmd0aDsrK2YpamJbZSsrPj4KMF09ZC5jaGFyQ29kZUF0KGYpO2piW2U+PjBdPTA7Yys9ZC5sZW5ndGgrMX0pO3JldHVybiAwfSx6YjpmdW5jdGlvbihhLGIpe3ZhciBjPXRnKCk7aFthPj4yXT1jLmxlbmd0aDt2YXIgZD0wO2MuZm9yRWFjaChmdW5jdGlvbihlKXtkKz1lLmxlbmd0aCsxfSk7aFtiPj4yXT1kO3JldHVybiAwfSxpYTpPZSxwYTpmdW5jdGlvbihhKXt0cnl7dmFyIGI9Y2QoYSk7SWMoYik7cmV0dXJuIDB9Y2F0Y2goYyl7aWYoInVuZGVmaW5lZCI9PXR5cGVvZiAkY3x8IShjIGluc3RhbmNlb2YgSSkpdGhyb3cgYztyZXR1cm4gYy5EaX19LENiOmZ1bmN0aW9uKGEsYixjLGQpe3RyeXthOnt2YXIgZT1jZChhKTthPWI7Zm9yKHZhciBmPWI9MDtmPGM7ZisrKXt2YXIgbD1oW2E+PjJdLG49aFthKzQ+PjJdO2ErPTg7dmFyIHE9ZSx2PWwsdz1uLEM9dm9pZCAwLEc9amI7aWYoMD53fHwwPkMpdGhyb3cgbmV3IEkoMjgpO2lmKG51bGw9PT1xLmZkKXRocm93IG5ldyBJKDgpO2lmKDE9PT0ocS5mbGFncyYyMDk3MTU1KSl0aHJvdyBuZXcgSSg4KTsKaWYoMTYzODQ9PT0ocS5ub2RlLm1vZGUmNjE0NDApKXRocm93IG5ldyBJKDMxKTtpZighcS5maS5yZWFkKXRocm93IG5ldyBJKDI4KTt2YXIgcD0idW5kZWZpbmVkIiE9dHlwZW9mIEM7aWYoIXApQz1xLnBvc2l0aW9uO2Vsc2UgaWYoIXEuc2Vla2FibGUpdGhyb3cgbmV3IEkoNzApO3ZhciB5PXEuZmkucmVhZChxLEcsdix3LEMpO3B8fChxLnBvc2l0aW9uKz15KTt2YXIgRj15O2lmKDA+Ril7dmFyIFI9LTE7YnJlYWsgYX1iKz1GO2lmKEY8bilicmVha31SPWJ9aFtkPj4yXT1SO3JldHVybiAwfWNhdGNoKGJhKXtpZigidW5kZWZpbmVkIj09dHlwZW9mICRjfHwhKGJhIGluc3RhbmNlb2YgSSkpdGhyb3cgYmE7cmV0dXJuIGJhLkRpfX0sdWI6ZnVuY3Rpb24oYSxiLGMsZCxlKXt0cnl7Yj1jKzIwOTcxNTI+Pj4wPDQxOTQzMDUtISFiPyhiPj4+MCkrNDI5NDk2NzI5NipjOk5hTjtpZihpc05hTihiKSlyZXR1cm4gNjE7dmFyIGY9Y2QoYSk7SmMoZixiLGQpO0liPVtmLnBvc2l0aW9uPj4+CjAsKEhiPWYucG9zaXRpb24sMTw9K01hdGguYWJzKEhiKT8wPEhiPyhNYXRoLm1pbigrTWF0aC5mbG9vcihIYi80Mjk0OTY3Mjk2KSw0Mjk0OTY3Mjk1KXwwKT4+PjA6fn4rTWF0aC5jZWlsKChIYi0rKH5+SGI+Pj4wKSkvNDI5NDk2NzI5Nik+Pj4wOjApXTtEW2U+PjJdPUliWzBdO0RbZSs0Pj4yXT1JYlsxXTtmLnNqJiYwPT09YiYmMD09PWQmJihmLnNqPW51bGwpO3JldHVybiAwfWNhdGNoKGwpe2lmKCJ1bmRlZmluZWQiPT10eXBlb2YgJGN8fCEobCBpbnN0YW5jZW9mIEkpKXRocm93IGw7cmV0dXJuIGwuRGl9fSxxYTpmdW5jdGlvbihhLGIsYyxkKXt0cnl7YTp7dmFyIGU9Y2QoYSk7YT1iO2Zvcih2YXIgZj1iPTA7ZjxjO2YrKyl7dmFyIGw9aFthPj4yXSxuPWhbYSs0Pj4yXTthKz04O3ZhciBxPU9jKGUsamIsbCxuKTtpZigwPnEpe3ZhciB2PS0xO2JyZWFrIGF9Yis9cX12PWJ9aFtkPj4yXT12O3JldHVybiAwfWNhdGNoKHcpe2lmKCJ1bmRlZmluZWQiPT10eXBlb2YgJGN8fCEodyBpbnN0YW5jZW9mCkkpKXRocm93IHc7cmV0dXJuIHcuRGl9fSxlYTpmdW5jdGlvbihhKXtOLmFjdGl2ZVRleHR1cmUoYSl9LGxhOmZ1bmN0aW9uKGEsYil7Ti5hdHRhY2hTaGFkZXIoRGZbYV0sSGZbYl0pfSxfZzpmdW5jdGlvbihhLGIpe04uYmVnaW5RdWVyeShhLEtmW2JdKX0sYWE6ZnVuY3Rpb24oYSxiKXszNTA1MT09YT9OLkZpPWI6MzUwNTI9PWEmJihOLm1pPWIpO04uYmluZEJ1ZmZlcihhLENmW2JdKX0sZGE6ZnVuY3Rpb24oYSxiKXtOLmJpbmRGcmFtZWJ1ZmZlcihhLEVmW2JdKX0sZWI6ZnVuY3Rpb24oYSxiKXtOLmJpbmRSZW5kZXJidWZmZXIoYSxGZltiXSl9LGliOmZ1bmN0aW9uKGEsYil7Ti5iaW5kVGV4dHVyZShhLEdmW2JdKX0sV2E6ZnVuY3Rpb24oYSxiKXtOLmJsZW5kRnVuYyhhLGIpfSxYYTpmdW5jdGlvbihhLGIsYyxkKXtOLmJsZW5kRnVuY1NlcGFyYXRlKGEsYixjLGQpfSx4aDpmdW5jdGlvbihhLGIsYyxkKXsyPD1ULnZlcnNpb24/YyYmYj9OLmJ1ZmZlckRhdGEoYSx0LGQsYyxiKToKTi5idWZmZXJEYXRhKGEsYixkKTpOLmJ1ZmZlckRhdGEoYSxjP3Quc3ViYXJyYXkoYyxjK2IpOmIsZCl9LHdoOmZ1bmN0aW9uKGEsYixjLGQpezI8PVQudmVyc2lvbj9jJiZOLmJ1ZmZlclN1YkRhdGEoYSxiLHQsZCxjKTpOLmJ1ZmZlclN1YkRhdGEoYSxiLHQuc3ViYXJyYXkoZCxkK2MpKX0sczpmdW5jdGlvbihhKXtOLmNsZWFyKGEpfSxaYTpmdW5jdGlvbihhLGIsYyxkKXtOLmNsZWFyQ29sb3IoYSxiLGMsZCl9LFlhOmZ1bmN0aW9uKGEpe04uY2xlYXJTdGVuY2lsKGEpfSxhYjpmdW5jdGlvbihhLGIsYyxkKXtOLmNvbG9yTWFzayghIWEsISFiLCEhYywhIWQpfSxvaDpmdW5jdGlvbihhKXtOLmNvbXBpbGVTaGFkZXIoSGZbYV0pfSxGYTpmdW5jdGlvbigpe3ZhciBhPVNmKERmKSxiPU4uY3JlYXRlUHJvZ3JhbSgpO2IubmFtZT1hO2Iuemk9Yi54aT1iLnlpPTA7Yi5taj0xO0RmW2FdPWI7cmV0dXJuIGF9LHFoOmZ1bmN0aW9uKGEpe3ZhciBiPVNmKEhmKTtIZltiXT1OLmNyZWF0ZVNoYWRlcihhKTsKcmV0dXJuIGJ9LGdiOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTA7YzxhO2MrKyl7dmFyIGQ9RFtiKzQqYz4+Ml0sZT1DZltkXTtlJiYoTi5kZWxldGVCdWZmZXIoZSksZS5uYW1lPTAsQ2ZbZF09bnVsbCxkPT1OLkZpJiYoTi5GaT0wKSxkPT1OLm1pJiYoTi5taT0wKSl9fSxjYjpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wO2M8YTsrK2Mpe3ZhciBkPURbYis0KmM+PjJdLGU9RWZbZF07ZSYmKE4uZGVsZXRlRnJhbWVidWZmZXIoZSksZS5uYW1lPTAsRWZbZF09bnVsbCl9fSxuaDpmdW5jdGlvbihhKXtpZihhKXt2YXIgYj1EZlthXTtiPyhOLmRlbGV0ZVByb2dyYW0oYiksYi5uYW1lPTAsRGZbYV09bnVsbCk6TygxMjgxKX19LCRnOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTA7YzxhO2MrKyl7dmFyIGQ9RFtiKzQqYz4+Ml0sZT1LZltkXTtlJiYoTi5kZWxldGVRdWVyeShlKSxLZltkXT1udWxsKX19LGRiOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTA7YzxhO2MrKyl7dmFyIGQ9RFtiKwo0KmM+PjJdLGU9RmZbZF07ZSYmKE4uZGVsZXRlUmVuZGVyYnVmZmVyKGUpLGUubmFtZT0wLEZmW2RdPW51bGwpfX0scmg6ZnVuY3Rpb24oYSl7aWYoYSl7dmFyIGI9SGZbYV07Yj8oTi5kZWxldGVTaGFkZXIoYiksSGZbYV09bnVsbCk6TygxMjgxKX19LGhiOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTA7YzxhO2MrKyl7dmFyIGQ9RFtiKzQqYz4+Ml0sZT1HZltkXTtlJiYoTi5kZWxldGVUZXh0dXJlKGUpLGUubmFtZT0wLEdmW2RdPW51bGwpfX0sVmE6ZnVuY3Rpb24oYSl7Ti5kZXB0aEZ1bmMoYSl9LCRhOmZ1bmN0aW9uKGEpe04uZGVwdGhNYXNrKCEhYSl9LFVhOmZ1bmN0aW9uKGEsYil7Ti5kZXB0aFJhbmdlKGEsYil9LE9hOmZ1bmN0aW9uKGEpe04uZGlzYWJsZShhKX0sSTpmdW5jdGlvbihhKXtOLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShhKX0sVTpmdW5jdGlvbihhLGIsYyl7Ti5kcmF3QXJyYXlzKGEsYixjKX0seWE6ZnVuY3Rpb24oYSxiLGMsZCl7Ti5kcmF3QXJyYXlzSW5zdGFuY2VkKGEsCmIsYyxkKX0sZmg6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9V2ZbYV0sZD0wO2Q8YTtkKyspY1tkXT1EW2IrNCpkPj4yXTtOLmRyYXdCdWZmZXJzKGMpfSxEYTpYZix6YTpmdW5jdGlvbihhLGIsYyxkLGUpe04uZHJhd0VsZW1lbnRzSW5zdGFuY2VkKGEsYixjLGQsZSl9LFBhOmZ1bmN0aW9uKGEpe04uZW5hYmxlKGEpfSxFOmZ1bmN0aW9uKGEpe04uZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYSl9LFpnOmZ1bmN0aW9uKGEpe04uZW5kUXVlcnkoYSl9LGloOmZ1bmN0aW9uKCl7Ti5maW5pc2goKX0sQmE6ZnVuY3Rpb24oYSxiLGMsZCl7Ti5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihhLGIsYyxGZltkXSl9LGVoOmZ1bmN0aW9uKGEsYixjLGQsZSl7Ti5mcmFtZWJ1ZmZlclRleHR1cmUyRChhLGIsYyxHZltkXSxlKX0sX2E6ZnVuY3Rpb24oYSl7Ti5mcm9udEZhY2UoYSl9LHloOmZ1bmN0aW9uKGEsYil7WWYoYSxiLCJjcmVhdGVCdWZmZXIiLENmKX0sQ2E6ZnVuY3Rpb24oYSxiKXtZZihhLApiLCJjcmVhdGVGcmFtZWJ1ZmZlciIsRWYpfSxhaDpmdW5jdGlvbihhLGIpe1lmKGEsYiwiY3JlYXRlUXVlcnkiLEtmKX0saGg6ZnVuY3Rpb24oYSxiKXtZZihhLGIsImNyZWF0ZVJlbmRlcmJ1ZmZlciIsRmYpfSx0aDpmdW5jdGlvbihhLGIpe1lmKGEsYiwiY3JlYXRlVGV4dHVyZSIsR2YpfSx2aDpmdW5jdGlvbihhKXtOLmdlbmVyYXRlTWlwbWFwKGEpfSxraDpmdW5jdGlvbihhLGIsYyxkLGUsZixsKXtaZigiZ2V0QWN0aXZlQXR0cmliIixhLGIsYyxkLGUsZixsKX0samg6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsbCl7WmYoImdldEFjdGl2ZVVuaWZvcm0iLGEsYixjLGQsZSxmLGwpfSxtaDpmdW5jdGlvbihhLGIpe3JldHVybiBOLmdldEF0dHJpYkxvY2F0aW9uKERmW2FdLGRiKGIpKX0sa2I6ZnVuY3Rpb24oYSxiKXthZyhhLGIsNCl9LG1iOmZ1bmN0aW9uKCl7dmFyIGE9Ti5nZXRFcnJvcigpfHxSZjtSZj0wO3JldHVybiBhfSxXOmZ1bmN0aW9uKGEsYil7YWcoYSxiLDIpfSxuOmZ1bmN0aW9uKGEsCmIpe2FnKGEsYiwwKX0sJDpmdW5jdGlvbihhLGIsYyl7aWYoYylpZihhPj1CZilPKDEyODEpO2Vsc2UgaWYoYT1EZlthXSwzNTcxNj09YilhPU4uZ2V0UHJvZ3JhbUluZm9Mb2coYSksbnVsbD09PWEmJihhPSIodW5rbm93biBlcnJvcikiKSxEW2M+PjJdPWEubGVuZ3RoKzE7ZWxzZSBpZigzNTcxOT09Yil7aWYoIWEuemkpZm9yKGI9MDtiPE4uZ2V0UHJvZ3JhbVBhcmFtZXRlcihhLDM1NzE4KTsrK2IpYS56aT1NYXRoLm1heChhLnppLE4uZ2V0QWN0aXZlVW5pZm9ybShhLGIpLm5hbWUubGVuZ3RoKzEpO0RbYz4+Ml09YS56aX1lbHNlIGlmKDM1NzIyPT1iKXtpZighYS54aSlmb3IoYj0wO2I8Ti5nZXRQcm9ncmFtUGFyYW1ldGVyKGEsMzU3MjEpOysrYilhLnhpPU1hdGgubWF4KGEueGksTi5nZXRBY3RpdmVBdHRyaWIoYSxiKS5uYW1lLmxlbmd0aCsxKTtEW2M+PjJdPWEueGl9ZWxzZSBpZigzNTM4MT09Yil7aWYoIWEueWkpZm9yKGI9MDtiPE4uZ2V0UHJvZ3JhbVBhcmFtZXRlcihhLAozNTM4Mik7KytiKWEueWk9TWF0aC5tYXgoYS55aSxOLmdldEFjdGl2ZVVuaWZvcm1CbG9ja05hbWUoYSxiKS5sZW5ndGgrMSk7RFtjPj4yXT1hLnlpfWVsc2UgRFtjPj4yXT1OLmdldFByb2dyYW1QYXJhbWV0ZXIoYSxiKTtlbHNlIE8oMTI4MSl9LHdhOmZ1bmN0aW9uKGEsYixjKXtpZihjKXthPU4uZ2V0UXVlcnlQYXJhbWV0ZXIoS2ZbYV0sYik7dmFyIGQ7ImJvb2xlYW4iPT10eXBlb2YgYT9kPWE/MTowOmQ9YTtEW2M+PjJdPWR9ZWxzZSBPKDEyODEpfSxsYjpmdW5jdGlvbihhLGIsYyxkKXthPU4uZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGEsYik7RFtjPj4yXT1hLnJhbmdlTWluO0RbYys0Pj4yXT1hLnJhbmdlTWF4O0RbZD4+Ml09YS5wcmVjaXNpb259LG9hOmZ1bmN0aW9uKGEpe3ZhciBiPU9mW2FdO2lmKCFiKXtzd2l0Y2goYSl7Y2FzZSA3OTM5OmI9Ti5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zKCl8fFtdO2I9Yi5jb25jYXQoYi5tYXAoZnVuY3Rpb24oZCl7cmV0dXJuIkdMXyIrCmR9KSk7Yj1jZyhiLmpvaW4oIiAiKSk7YnJlYWs7Y2FzZSA3OTM2OmNhc2UgNzkzNzpjYXNlIDM3NDQ1OmNhc2UgMzc0NDY6KGI9Ti5nZXRQYXJhbWV0ZXIoYSkpfHxPKDEyODApO2I9YiYmY2coYik7YnJlYWs7Y2FzZSA3OTM4OmI9Ti5nZXRQYXJhbWV0ZXIoNzkzOCk7Yj0yPD1ULnZlcnNpb24/Ik9wZW5HTCBFUyAzLjAgKCIrYisiKSI6Ik9wZW5HTCBFUyAyLjAgKCIrYisiKSI7Yj1jZyhiKTticmVhaztjYXNlIDM1NzI0OmI9Ti5nZXRQYXJhbWV0ZXIoMzU3MjQpO3ZhciBjPWIubWF0Y2goL15XZWJHTCBHTFNMIEVTIChbMC05XVwuWzAtOV1bMC05XT8pKD86JHwgLiopLyk7bnVsbCE9PWMmJigzPT1jWzFdLmxlbmd0aCYmKGNbMV0rPSIwIiksYj0iT3BlbkdMIEVTIEdMU0wgRVMgIitjWzFdKyIgKCIrYisiKSIpO2I9Y2coYik7YnJlYWs7ZGVmYXVsdDpPKDEyODApfU9mW2FdPWJ9cmV0dXJuIGJ9LGxoOmZ1bmN0aW9uKGEsYil7Yj1kYihiKTtpZihhPURmW2FdKXtmZyhhKTt2YXIgYz0KYS5LaSxkPTAsZT1iLGY9ZWcoYik7MDxmJiYoZD1wYXJzZUludChiLnNsaWNlKGYrMSkpPj4+MCxlPWIuc2xpY2UoMCxmKSk7aWYoKGU9YS5ualtlXSkmJmQ8ZVswXSYmKGQrPWVbMV0sY1tkXT1jW2RdfHxOLmdldFVuaWZvcm1Mb2NhdGlvbihhLGIpKSlyZXR1cm4gZH1lbHNlIE8oMTI4MSk7cmV0dXJuLTF9LE86ZnVuY3Rpb24oYSl7cmV0dXJuIE4uaXNFbmFibGVkKGEpfSxFYTpmdW5jdGlvbihhKXthPURmW2FdO04ubGlua1Byb2dyYW0oYSk7YS5LaT0wO2Eubmo9e319LGJiOmZ1bmN0aW9uKGEsYil7MzMxNz09YSYmKFFmPWIpO04ucGl4ZWxTdG9yZWkoYSxiKX0sVGE6ZnVuY3Rpb24oYSxiKXtOLnBvbHlnb25PZmZzZXQoYSxiKX0sZGg6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsbCl7aWYoMjw9VC52ZXJzaW9uKWlmKE4uRmkpTi5yZWFkUGl4ZWxzKGEsYixjLGQsZSxmLGwpO2Vsc2V7dmFyIG49aWcoZik7Ti5yZWFkUGl4ZWxzKGEsYixjLGQsZSxmLG4sbD4+amcobikpfWVsc2UobD1rZyhmLAplLGMsZCxsKSk/Ti5yZWFkUGl4ZWxzKGEsYixjLGQsZSxmLGwpOk8oMTI4MCl9LGdoOmZ1bmN0aW9uKGEsYixjLGQpe04ucmVuZGVyYnVmZmVyU3RvcmFnZShhLGIsYyxkKX0sU2E6ZnVuY3Rpb24oYSxiLGMsZCl7Ti5zY2lzc29yKGEsYixjLGQpfSxwaDpmdW5jdGlvbihhLGIsYyxkKXtiPVRmKGIsYyxkKTtOLnNoYWRlclNvdXJjZShIZlthXSxiKX0sY2E6ZnVuY3Rpb24oYSxiLGMpe04uc3RlbmNpbEZ1bmMoYSxiLGMpfSxWOmZ1bmN0aW9uKGEsYixjLGQpe04uc3RlbmNpbEZ1bmNTZXBhcmF0ZShhLGIsYyxkKX0sUmE6ZnVuY3Rpb24oYSl7Ti5zdGVuY2lsTWFzayhhKX0sbmE6ZnVuY3Rpb24oYSxiKXtOLnN0ZW5jaWxNYXNrU2VwYXJhdGUoYSxiKX0sUWE6ZnVuY3Rpb24oYSxiLGMpe04uc3RlbmNpbE9wKGEsYixjKX0sbWE6ZnVuY3Rpb24oYSxiLGMsZCl7Ti5zdGVuY2lsT3BTZXBhcmF0ZShhLGIsYyxkKX0sWjpmdW5jdGlvbihhLGIsYyxkLGUsZixsLG4scSl7aWYoMjw9VC52ZXJzaW9uKWlmKE4ubWkpTi50ZXhJbWFnZTJEKGEsCmIsYyxkLGUsZixsLG4scSk7ZWxzZSBpZihxKXt2YXIgdj1pZyhuKTtOLnRleEltYWdlMkQoYSxiLGMsZCxlLGYsbCxuLHYscT4+amcodikpfWVsc2UgTi50ZXhJbWFnZTJEKGEsYixjLGQsZSxmLGwsbixudWxsKTtlbHNlIE4udGV4SW1hZ2UyRChhLGIsYyxkLGUsZixsLG4scT9rZyhuLGwsZCxlLHEpOm51bGwpfSx1aDpmdW5jdGlvbihhLGIsYyl7Ti50ZXhQYXJhbWV0ZXJmKGEsYixjKX0sRjpmdW5jdGlvbihhLGIsYyl7Ti50ZXhQYXJhbWV0ZXJpKGEsYixjKX0scTpmdW5jdGlvbihhLGIpe04udW5pZm9ybTFmKFYoYSksYil9LE46ZnVuY3Rpb24oYSxiLGMpe2lmKDI8PVQudmVyc2lvbiliJiZOLnVuaWZvcm0xZnYoVihhKSxCLGM+PjIsYik7ZWxzZXtpZigyODg+PWIpZm9yKHZhciBkPWxnW2ItMV0sZT0wO2U8YjsrK2UpZFtlXT1CW2MrNCplPj4yXTtlbHNlIGQ9Qi5zdWJhcnJheShjPj4yLGMrNCpiPj4yKTtOLnVuaWZvcm0xZnYoVihhKSxkKX19LGs6ZnVuY3Rpb24oYSxiKXtOLnVuaWZvcm0xaShWKGEpLApiKX0sejpmdW5jdGlvbihhLGIsYyl7Ti51bmlmb3JtMmYoVihhKSxiLGMpfSxBYTpmdW5jdGlvbihhLGIsYyl7aWYoMjw9VC52ZXJzaW9uKWImJk4udW5pZm9ybTJmdihWKGEpLEIsYz4+MiwyKmIpO2Vsc2V7aWYoMTQ0Pj1iKWZvcih2YXIgZD1sZ1syKmItMV0sZT0wO2U8MipiO2UrPTIpZFtlXT1CW2MrNCplPj4yXSxkW2UrMV09QltjKyg0KmUrNCk+PjJdO2Vsc2UgZD1CLnN1YmFycmF5KGM+PjIsYys4KmI+PjIpO04udW5pZm9ybTJmdihWKGEpLGQpfX0sY2g6ZnVuY3Rpb24oYSxiLGMpe04udW5pZm9ybTJpKFYoYSksYixjKX0samE6ZnVuY3Rpb24oYSxiLGMsZCl7Ti51bmlmb3JtM2YoVihhKSxiLGMsZCl9LEg6ZnVuY3Rpb24oYSxiLGMpe2lmKDI8PVQudmVyc2lvbiliJiZOLnVuaWZvcm0zZnYoVihhKSxCLGM+PjIsMypiKTtlbHNle2lmKDk2Pj1iKWZvcih2YXIgZD1sZ1szKmItMV0sZT0wO2U8MypiO2UrPTMpZFtlXT1CW2MrNCplPj4yXSxkW2UrMV09QltjKyg0KmUrNCk+PjJdLApkW2UrMl09QltjKyg0KmUrOCk+PjJdO2Vsc2UgZD1CLnN1YmFycmF5KGM+PjIsYysxMipiPj4yKTtOLnVuaWZvcm0zZnYoVihhKSxkKX19LFQ6ZnVuY3Rpb24oYSxiLGMsZCxlKXtOLnVuaWZvcm00ZihWKGEpLGIsYyxkLGUpfSxyOmZ1bmN0aW9uKGEsYixjKXtpZigyPD1ULnZlcnNpb24pYiYmTi51bmlmb3JtNGZ2KFYoYSksQixjPj4yLDQqYik7ZWxzZXtpZig3Mj49Yil7dmFyIGQ9bGdbNCpiLTFdLGU9QjtjPj49Mjtmb3IodmFyIGY9MDtmPDQqYjtmKz00KXt2YXIgbD1jK2Y7ZFtmXT1lW2xdO2RbZisxXT1lW2wrMV07ZFtmKzJdPWVbbCsyXTtkW2YrM109ZVtsKzNdfX1lbHNlIGQ9Qi5zdWJhcnJheShjPj4yLGMrMTYqYj4+Mik7Ti51bmlmb3JtNGZ2KFYoYSksZCl9fSxrYTpmdW5jdGlvbihhLGIsYyxkKXtpZigyPD1ULnZlcnNpb24pYiYmTi51bmlmb3JtTWF0cml4M2Z2KFYoYSksISFjLEIsZD4+Miw5KmIpO2Vsc2V7aWYoMzI+PWIpZm9yKHZhciBlPWxnWzkqYi0xXSxmPTA7ZjwKOSpiO2YrPTkpZVtmXT1CW2QrNCpmPj4yXSxlW2YrMV09QltkKyg0KmYrNCk+PjJdLGVbZisyXT1CW2QrKDQqZis4KT4+Ml0sZVtmKzNdPUJbZCsoNCpmKzEyKT4+Ml0sZVtmKzRdPUJbZCsoNCpmKzE2KT4+Ml0sZVtmKzVdPUJbZCsoNCpmKzIwKT4+Ml0sZVtmKzZdPUJbZCsoNCpmKzI0KT4+Ml0sZVtmKzddPUJbZCsoNCpmKzI4KT4+Ml0sZVtmKzhdPUJbZCsoNCpmKzMyKT4+Ml07ZWxzZSBlPUIuc3ViYXJyYXkoZD4+MixkKzM2KmI+PjIpO04udW5pZm9ybU1hdHJpeDNmdihWKGEpLCEhYyxlKX19LHU6ZnVuY3Rpb24oYSxiLGMsZCl7aWYoMjw9VC52ZXJzaW9uKWImJk4udW5pZm9ybU1hdHJpeDRmdihWKGEpLCEhYyxCLGQ+PjIsMTYqYik7ZWxzZXtpZigxOD49Yil7dmFyIGU9bGdbMTYqYi0xXSxmPUI7ZD4+PTI7Zm9yKHZhciBsPTA7bDwxNipiO2wrPTE2KXt2YXIgbj1kK2w7ZVtsXT1mW25dO2VbbCsxXT1mW24rMV07ZVtsKzJdPWZbbisyXTtlW2wrM109ZltuKzNdO2VbbCs0XT1mW24rCjRdO2VbbCs1XT1mW24rNV07ZVtsKzZdPWZbbis2XTtlW2wrN109ZltuKzddO2VbbCs4XT1mW24rOF07ZVtsKzldPWZbbis5XTtlW2wrMTBdPWZbbisxMF07ZVtsKzExXT1mW24rMTFdO2VbbCsxMl09ZltuKzEyXTtlW2wrMTNdPWZbbisxM107ZVtsKzE0XT1mW24rMTRdO2VbbCsxNV09ZltuKzE1XX19ZWxzZSBlPUIuc3ViYXJyYXkoZD4+MixkKzY0KmI+PjIpO04udW5pZm9ybU1hdHJpeDRmdihWKGEpLCEhYyxlKX19LGZiOmZ1bmN0aW9uKGEpe2E9RGZbYV07Ti51c2VQcm9ncmFtKGEpO04uUWo9YX0seGE6ZnVuY3Rpb24oYSxiKXtOLnZlcnRleEF0dHJpYjFmKGEsYil9LGJoOmZ1bmN0aW9uKGEsYixjLGQsZSl7Ti52ZXJ0ZXhBdHRyaWI0ZihhLGIsYyxkLGUpfSxHOmZ1bmN0aW9uKGEsYil7Ti52ZXJ0ZXhBdHRyaWJEaXZpc29yKGEsYil9LEM6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe04udmVydGV4QXR0cmliUG9pbnRlcihhLGIsYywhIWQsZSxmKX0samI6ZnVuY3Rpb24oYSxiLGMsZCl7Ti52aWV3cG9ydChhLApiLGMsZCl9LHNoOmZ1bmN0aW9uKGEsYixjLGQsZSl7Y2YoKTthPXQuc3ViYXJyYXkoYSxhK2IpO2I9bnVsbDtjPVsiaW1hZ2UvanBlZyIsImltYWdlL3BuZyIsImltYWdlL2dpZiIsImltYWdlL2JtcCIsImltYWdlL3N2Zyt4bWwiXVtjXTt2YXIgZj1bTi5MVU1JTkFOQ0UsTi5MVU1JTkFOQ0VfQUxQSEEsTi5SR0IsTi5SR0JBXVtkLTFdO3ZvaWQgMD09PWYmJihmPU4uUkdCQSk7aWYoZWYpdHJ5e2I9bmV3IEJsb2IoW2FdLHt0eXBlOmN9KSxiLnNpemUhPT1hLmxlbmd0aCYmKGI9bmV3IEJsb2IoWyhuZXcgVWludDhBcnJheShhKSkuYnVmZmVyXSx7dHlwZTpjfSkpfWNhdGNoKEcpe31ifHwoYz1uZXcgZmYsYy5hcHBlbmQoKG5ldyBVaW50OEFycmF5KGEpKS5idWZmZXIpLGI9Yy5nZXRCbG9iKCkpO3ZhciBsPXdnKCJ3cmFwcGVyVGV4dHVyZVByZUxvYWQiLCJudW1iZXIiLFsibnVtYmVyIiwibnVtYmVyIiwibnVtYmVyIiwibnVtYmVyIl0pLG49d2coIndyYXBwZXJUZXh0dXJlUG9zdExvYWQiLApudWxsLFsibnVtYmVyIiwibnVtYmVyIiwibnVtYmVyIl0pLHE9d2coIndyYXBwZXJUZXh0dXJlT25FcnJvciIsbnVsbCxbIm51bWJlciIsIm51bWJlciJdKSx2PWdmLmNyZWF0ZU9iamVjdFVSTChiKSx3PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImltZyIpLEM9Zy4kJGZhY2FkZTt3Lm9ubG9hZD1mdW5jdGlvbigpe2lmKEM9PT1nLiQkZmFjYWRlKXt2YXIgRz0xO2wmJihHPWwoZSx3LndpZHRoLHcuaGVpZ2h0LGQpKTt2YXIgcD0wO2lmKEcpdHJ5e04udGV4SW1hZ2UyRChOLlRFWFRVUkVfMkQsMCxmLGYsTi5VTlNJR05FRF9CWVRFLHcpLHA9MX1jYXRjaCh5KXt9biYmbigwLGUscCl9ZWxzZSBuJiZuKDEsZSwwKTtnZi5yZXZva2VPYmplY3RVUkwodil9O3cub25lcnJvcj1mdW5jdGlvbigpe0M9PT1nLiQkZmFjYWRlP3EmJnEoMCxlKTpxJiZxKDEsZSk7Z2YucmV2b2tlT2JqZWN0VVJMKHYpfTt3LnNyYz12fSx2YTpmdW5jdGlvbigpe3JldHVybiBnLllpP3hnLmNsb3NlLmFwcGx5KHhnLAphcmd1bWVudHMpOnlnLmNsb3NlLmFwcGx5KHlnLGFyZ3VtZW50cyl9LFlnOmZ1bmN0aW9uKCl7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoImJlZm9yZXVubG9hZCIsZnVuY3Rpb24oKXtnLllpP3hnLmNsb3NlKCk6eWcuY2xvc2UoKX0pfSxYZzpmdW5jdGlvbihhLGIsYyl7Zy5Zaj0wO3NlbGYuYm93c2VyLmNocm9tZSYmMD5zZWxmLmJvd3Nlci5jb21wYXJlVmVyc2lvbnMoW3NlbGYuYm93c2VyLnZlcnNpb24sIjY4Il0pJiYoZy5ZaT0hMCk7cmV0dXJuIGcuWWk/eGcuY29ubmVjdC5hcHBseSh4Zyxhcmd1bWVudHMpOnlnLmNvbm5lY3QuYXBwbHkoeWcsYXJndW1lbnRzKX0sV2c6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gZy5ZaT94Zy5Gai5hcHBseSh4Zyxhcmd1bWVudHMpOnlnLkZqLmFwcGx5KHlnLGFyZ3VtZW50cyl9LHhiOmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBDZyhhLGIsYyxkKX19OwooZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGUpe2cuYXNtPWUuZXhwb3J0cztXYT1nLmFzbS5GaDttYigpO25iPWcuYXNtLkhoO3BiLnVuc2hpZnQoZy5hc20uR2gpO3liKCJ3YXNtLWluc3RhbnRpYXRlIil9ZnVuY3Rpb24gYihlKXthKGUuaW5zdGFuY2UpfWZ1bmN0aW9uIGMoZSl7cmV0dXJuIEdiKCkudGhlbihmdW5jdGlvbihmKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoZixkKX0pLnRoZW4oZnVuY3Rpb24oZil7cmV0dXJuIGZ9KS50aGVuKGUsZnVuY3Rpb24oZil7UmEoImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICIrZik7VmEoZil9KX12YXIgZD17YTpLZ307eGIoIndhc20taW5zdGFudGlhdGUiKTtpZihnLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIGcuaW5zdGFudGlhdGVXYXNtKGQsYSl9Y2F0Y2goZSl7UmEoIk1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6ICIrZSksZWEoZSl9KGZ1bmN0aW9uKCl7cmV0dXJuIFVhfHwKImZ1bmN0aW9uIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHx6YigpfHxEYi5zdGFydHNXaXRoKCJmaWxlOi8vIil8fEdhfHwiZnVuY3Rpb24iIT10eXBlb2YgZmV0Y2g/YyhiKTpmZXRjaChEYix7Y3JlZGVudGlhbHM6InNhbWUtb3JpZ2luIn0pLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKGUsZCkudGhlbihiLGZ1bmN0aW9uKGYpe1JhKCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogIitmKTtSYSgiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb24iKTtyZXR1cm4gYyhiKX0pfSl9KSgpLmNhdGNoKGVhKTtyZXR1cm57fX0pKCk7Zy5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4oZy5fX193YXNtX2NhbGxfY3RvcnM9Zy5hc20uR2gpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07CmcuX2NhbGxGdW5jV3JhcHBlcj1mdW5jdGlvbigpe3JldHVybihnLl9jYWxsRnVuY1dyYXBwZXI9Zy5hc20uSWgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07Zy5fbWFpbj1mdW5jdGlvbigpe3JldHVybihnLl9tYWluPWcuYXNtLkpoKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2cuX3dyYXBwZXJUZXh0dXJlUHJlTG9hZD1mdW5jdGlvbigpe3JldHVybihnLl93cmFwcGVyVGV4dHVyZVByZUxvYWQ9Zy5hc20uS2gpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07Zy5fd3JhcHBlclRleHR1cmVQb3N0TG9hZD1mdW5jdGlvbigpe3JldHVybihnLl93cmFwcGVyVGV4dHVyZVBvc3RMb2FkPWcuYXNtLkxoKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2cuX3dyYXBwZXJUZXh0dXJlT25FcnJvcj1mdW5jdGlvbigpe3JldHVybihnLl93cmFwcGVyVGV4dHVyZU9uRXJyb3I9Zy5hc20uTWgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07CnZhciBiZT1nLl9mcmVlPWZ1bmN0aW9uKCl7cmV0dXJuKGJlPWcuX2ZyZWU9Zy5hc20uTmgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSmc9Zy5fX19lcnJub19sb2NhdGlvbj1mdW5jdGlvbigpe3JldHVybihKZz1nLl9fX2Vycm5vX2xvY2F0aW9uPWcuYXNtLk9oKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGRnPWcuX21hbGxvYz1mdW5jdGlvbigpe3JldHVybihkZz1nLl9tYWxsb2M9Zy5hc20uUGgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07Zy5fd2ViU29ja2V0SGFuZGxlck9uTWVzc2FnZT1mdW5jdGlvbigpe3JldHVybihnLl93ZWJTb2NrZXRIYW5kbGVyT25NZXNzYWdlPWcuYXNtLlFoKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBhZT1nLl9fX2dldFR5cGVOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKGFlPWcuX19fZ2V0VHlwZU5hbWU9Zy5hc20uUmgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07CmcuX19lbWJpbmRfaW5pdGlhbGl6ZV9iaW5kaW5ncz1mdW5jdGlvbigpe3JldHVybihnLl9fZW1iaW5kX2luaXRpYWxpemVfYmluZGluZ3M9Zy5hc20uU2gpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIG1hPWcuc3RhY2tTYXZlPWZ1bmN0aW9uKCl7cmV0dXJuKG1hPWcuc3RhY2tTYXZlPWcuYXNtLlRoKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHNhPWcuc3RhY2tSZXN0b3JlPWZ1bmN0aW9uKCl7cmV0dXJuKHNhPWcuc3RhY2tSZXN0b3JlPWcuYXNtLlVoKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG5hPWcuc3RhY2tBbGxvYz1mdW5jdGlvbigpe3JldHVybihuYT1nLnN0YWNrQWxsb2M9Zy5hc20uVmgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07Zy5keW5DYWxsX3ZpaWlqaWlpaWlpaWlpaWk9ZnVuY3Rpb24oKXtyZXR1cm4oZy5keW5DYWxsX3ZpaWlqaWlpaWlpaWlpaWk9Zy5hc20uV2gpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07CmcuZHluQ2FsbF9paWo9ZnVuY3Rpb24oKXtyZXR1cm4oZy5keW5DYWxsX2lpaj1nLmFzbS5YaCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtnLmR5bkNhbGxfaWlpaWlpamlpPWZ1bmN0aW9uKCl7cmV0dXJuKGcuZHluQ2FsbF9paWlpaWlqaWk9Zy5hc20uWWgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07Zy5keW5DYWxsX2ppamk9ZnVuY3Rpb24oKXtyZXR1cm4oZy5keW5DYWxsX2ppamk9Zy5hc20uWmgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07Zy5keW5DYWxsX3ZpaWppaT1mdW5jdGlvbigpe3JldHVybihnLmR5bkNhbGxfdmlpamlpPWcuYXNtLl9oKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2cuZHluQ2FsbF9paWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oZy5keW5DYWxsX2lpaWlpaj1nLmFzbS4kaCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtnLmR5bkNhbGxfaWlpaWlqaj1mdW5jdGlvbigpe3JldHVybihnLmR5bkNhbGxfaWlpaWlqaj1nLmFzbS5haSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTsKZy5keW5DYWxsX2lpaWlpaWpqPWZ1bmN0aW9uKCl7cmV0dXJuKGcuZHluQ2FsbF9paWlpaWlqaj1nLmFzbS5iaSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtnLl9fX2Vtc2NyaXB0ZW5fZW1iZWRkZWRfZmlsZV9kYXRhPTY1ODgyNDtnLmFkZFJ1bkRlcGVuZGVuY3k9eGI7Zy5yZW1vdmVSdW5EZXBlbmRlbmN5PXliO2cuRlNfY3JlYXRlUGF0aD1TYztnLkZTX2NyZWF0ZURhdGFGaWxlPVVjO2cuRlNfY3JlYXRlUHJlbG9hZGVkRmlsZT1aYztnLkZTX2NyZWF0ZUxhenlGaWxlPVhjO2cuRlNfY3JlYXRlRGV2aWNlPVZjO2cuRlNfdW5saW5rPUVjO2cuY2NhbGw9RGc7Zy5jd3JhcD13Zzt2YXIgTGc7d2I9ZnVuY3Rpb24gTWcoKXtMZ3x8TmcoKTtMZ3x8KHdiPU1nKX07CmZ1bmN0aW9uIE5nKCl7ZnVuY3Rpb24gYSgpe2lmKCFMZyYmKExnPSEwLGcuY2FsbGVkUnVuPSEwLCFiYikpe2cubm9GU0luaXR8fFFjfHwoUWM9ITAsUGMoKSxnLnN0ZGluPWcuc3RkaW4sZy5zdGRvdXQ9Zy5zdGRvdXQsZy5zdGRlcnI9Zy5zdGRlcnIsZy5zdGRpbj9WYygiL2RldiIsInN0ZGluIixnLnN0ZGluKTpEYygiL2Rldi90dHkiLCIvZGV2L3N0ZGluIiksZy5zdGRvdXQ/VmMoIi9kZXYiLCJzdGRvdXQiLG51bGwsZy5zdGRvdXQpOkRjKCIvZGV2L3R0eSIsIi9kZXYvc3Rkb3V0IiksZy5zdGRlcnI/VmMoIi9kZXYiLCJzdGRlcnIiLG51bGwsZy5zdGRlcnIpOkRjKCIvZGV2L3R0eTEiLCIvZGV2L3N0ZGVyciIpLEhjKCIvZGV2L3N0ZGluIiwwKSxIYygiL2Rldi9zdGRvdXQiLDEpLEhjKCIvZGV2L3N0ZGVyciIsMSkpO25jPSExO0tiKHBiKTtLYihyYik7YWEoZyk7aWYoZy5vblJ1bnRpbWVJbml0aWFsaXplZClnLm9uUnVudGltZUluaXRpYWxpemVkKCk7aWYoT2cpe3ZhciBiPQpnLl9tYWluO3RyeXt2YXIgYz1iKDAsMCk7T2UoYywhMCl9Y2F0Y2goZCl7UGUoZCl9fWlmKGcucG9zdFJ1bilmb3IoImZ1bmN0aW9uIj09dHlwZW9mIGcucG9zdFJ1biYmKGcucG9zdFJ1bj1bZy5wb3N0UnVuXSk7Zy5wb3N0UnVuLmxlbmd0aDspYj1nLnBvc3RSdW4uc2hpZnQoKSxzYi51bnNoaWZ0KGIpO0tiKHNiKX19aWYoISgwPHViKSl7aWYoZy5wcmVSdW4pZm9yKCJmdW5jdGlvbiI9PXR5cGVvZiBnLnByZVJ1biYmKGcucHJlUnVuPVtnLnByZVJ1bl0pO2cucHJlUnVuLmxlbmd0aDspdGIoKTtLYihvYik7MDx1Ynx8KGcuc2V0U3RhdHVzPyhnLnNldFN0YXR1cygiUnVubmluZy4uLiIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Zy5zZXRTdGF0dXMoIiIpfSwxKTthKCl9LDEpKTphKCkpfX1pZihnLnByZUluaXQpZm9yKCJmdW5jdGlvbiI9PXR5cGVvZiBnLnByZUluaXQmJihnLnByZUluaXQ9W2cucHJlSW5pdF0pOzA8Zy5wcmVJbml0Lmxlbmd0aDspZy5wcmVJbml0LnBvcCgpKCk7CnZhciBPZz0hMDtnLm5vSW5pdGlhbFJ1biYmKE9nPSExKTtOZygpOwoKCiAgcmV0dXJuIFNjRW5naW5lTW9kdWxlLnJlYWR5Cn0KKTsKfSkoKTsKZXhwb3J0IGRlZmF1bHQgU2NFbmdpbmVNb2R1bGU7", mg = dg;
window.bowser = ug;
function pg(n) {
  return n !== null && typeof n == "object" && "isWrapper" in n && !!n.isWrapper && "base" in n && n.base !== void 0 && "args" in n && n.args !== void 0;
}
const vi = class {
  // store instance arguments and return empty base object that will
  // be populated asynchronously
  static async createInstance(n) {
    const t = {
      isWrapper: !0,
      base: {},
      args: n,
      enginePath: n.enginePath ?? vi.defaultEnginePath
    };
    return await vi.createScInstance(t), t.base;
  }
  static catchExceptions(n, t) {
    return function(...e) {
      try {
        t.apply(this, e);
      } catch (i) {
        console.log("Unhandled exception in " + n + "():"), console.log(i);
      }
    };
  }
  static getElement(n) {
    return typeof n != "string" ? n : document.getElementById(n);
  }
  static getAvailableCore() {
    for (const n of vi.core_pool)
      if (n.$$available)
        return n;
    return null;
  }
  static createCore(n) {
    const t = {
      $$available: !1,
      $$wrapper: document.createElement("div"),
      $$facade: n,
      callAfterMap: { index: 0, indexedWrappers: {} },
      canvas: document.createElement("canvas"),
      wasmBinary: vi.defaultBinary
    };
    return vi.core_pool.push(t), t.$$wrapper.setAttribute(
      "style",
      "position: absolute; overflow: hidden; width: 100%; height: 100%; padding: 0; margin: 0; border: 0;"
    ), t.canvas.setAttribute(
      "style",
      "position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 0; margin: 0; border: 0;"
    ), t;
  }
  static getCore(n, t) {
    let e = vi.getAvailableCore();
    const i = !e;
    return e === null && (e = vi.createCore(n)), e.$$available = !1, e.canvas.style.display = "", e.$$wrapper.appendChild(e.canvas), e.$$facade = n, e.$$onReady = vi.catchExceptions("onReady", function() {
      const s = t.onReady;
      typeof s == "function" && s(n);
    }), typeof t.onError == "function" && (e.onAbort = vi.catchExceptions("onError", function(s) {
      t.onError("fatal error: see console " + s);
    })), typeof t.enginePath == "string" && (e.locateFile = (s) => `${t.enginePath}/${s}`), { core: e, isNew: i };
  }
  static getFacade(n) {
    let t, e;
    pg(n) ? (t = n.base, e = n.args) : (t = {}, e = n);
    const i = vi.getElement(e.container);
    if (!i)
      throw new TypeError("'container' argument is missing or invalid");
    return t.container = i, { facade: t, args: e };
  }
  static createSubContainer(n, t) {
    const e = document.createElement("div");
    e.setAttribute(
      "style",
      "position: relative; overflow: hidden; width: 100%; height: 100%; padding: 0; margin: 0; border: 0;"
    );
    const i = document.createElement("div");
    return i.setAttribute(
      "style",
      "position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 0; margin: 0; border: 0;"
    ), i.onmousedown = function(s) {
      s.preventDefault();
    }, i.oncontextmenu = function(s) {
      s.preventDefault();
    }, e.appendChild(t.$$wrapper), e.appendChild(i), n.container.innerHTML = "", n.container.appendChild(e), e;
  }
  static async createScInstance(n) {
    const { facade: t, args: e } = vi.getFacade(n), { core: i, isNew: s } = vi.getCore(t, e);
    return vi.createSubContainer(t, i), s ? i.locateFile ? import(i.locateFile("engine.esm.js")).then((o) => {
      o.default(i);
    }) : vi.defaultModule ? vi.defaultModule(i) : import(
      /* @vite-ignore */
      mg
    ).then((r) => {
      vi.defaultModule = r.default, r.default(i);
    }) : setTimeout(function() {
      i.$$setReady && i.$$setReady();
    }), t;
  }
};
let Ro = vi;
Ro.core_pool = [];
const P0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AntiAliasingMode: ch,
  AttachScope: ar,
  BimMask: ei,
  BimType: xo,
  BlurIntervalUnit: So,
  CullingVectorSpace: ad,
  CuttingSectionKey: kr,
  DataKey: bl,
  DrawMode: Dn,
  DrawStrategy: ld,
  ElementMask: cd,
  ElementType: Je,
  GroupKey: td,
  HighlightFilter: Ss,
  HighlightMode: hh,
  ImageFormat: xs,
  ImageKey: ed,
  InclusionKey: ve,
  InstanceKey: lh,
  Key: ah,
  LightKey: id,
  LightSpace: rd,
  LightType: od,
  LinePatternLengthUnit: hd,
  MasterModelKey: Hn,
  MatrixKey: nd,
  MeshKey: vo,
  ModelKey: Bi,
  OverlayAnchor: kn,
  OverlayUnit: Co,
  PointShape: ud,
  PointSizeUnit: dd,
  Projection: No,
  SessionType: Ke,
  SetVisibility: hs,
  SimpleReflectionAttenuationUnit: uh,
  SmaaQuality: md,
  StateFailure: dh,
  StreamcacheModule: Ro,
  TextureInterpolation: $a,
  TextureMipMapping: tl,
  TextureModifier: Zo,
  TextureParameterization: el,
  TextureTiling: il,
  TransparencyMode: pd,
  UnspecifiedMeasurementUnit: nn,
  ViewKey: sd,
  XRayGroup: nl,
  getStateFailure: gd,
  isError: qs
}, Symbol.toStringTag, { value: "Module" }));
function wl(n) {
  const t = /* @__PURE__ */ new Map();
  return n.forEach((e, i) => {
    t.set(i, e);
  }), t;
}
function gg(n) {
  const t = /* @__PURE__ */ new Set();
  return n.forEach((e) => {
    t.add(e);
  }), t;
}
function ko(n) {
  const t = /* @__PURE__ */ new Set();
  for (const e of n)
    t.add(e);
  return t;
}
function us(n) {
  const t = [];
  return n.forEach((e) => {
    t.push(e);
  }), t;
}
function bc(n, t) {
  const e = us(n).filter((i) => !t.has(i));
  return ko(e);
}
function sl(n) {
  const t = {
    origin: [],
    direction: []
  };
  return n.origin.toArray(t.origin), n.direction.toArray(t.direction), t;
}
function va(n) {
  const t = new y_();
  return t.pos1.fromArray(n.point1), t.pos2.fromArray(n.point2), t.distance = n.distance, t;
}
function Ct(n, t) {
  return (n & t) === t;
}
function Yr(n, t, e) {
  return e ? n | t : n & ~t;
}
function fg(n) {
  let t = "";
  const e = n.byteLength;
  for (let i = 0; i < e; i++)
    t += String.fromCharCode(n[i]);
  return window.btoa(t);
}
function iu(n) {
  let t = Math.abs(n.x), e = Math.abs(n.y), i = Math.abs(n.z);
  return t = +t.toFixed(6), e = +e.toFixed(6), i = +i.toFixed(6), t > e && t > i ? new d(1, 0, 0) : e > t && e > i ? new d(0, 1, 0) : i > t && i > e ? new d(0, 0, 1) : null;
}
function Lo(n) {
  return JSON.parse(JSON.stringify(n));
}
function _g(n, t) {
  for (const e in n)
    Object.prototype.hasOwnProperty.call(n, e) && (t[e] = n[e]);
}
function vr(n, t) {
  return n === void 0 ? t : n;
}
function mh(n, t) {
  const e = n.length > t.length ? n.length : t.length;
  for (let i = 0; i < e; ++i) {
    const s = n[i] || 0, r = t[i] || 0;
    if (s > r)
      return !0;
    if (s < r)
      return !1;
  }
  return !0;
}
function yd(n) {
  if (n.length === 0)
    return "";
  let t = `${n[0]}`;
  for (let e = 1; e < n.length; ++e)
    t += `.${n[e]}`;
  return t;
}
function yg() {
  return window.crypto || window.msCrypto;
}
const bg = "²", Ig = "³";
function nu(n) {
  if (n instanceof Map)
    return n;
  const t = /* @__PURE__ */ new Map(), e = Object.keys(n);
  for (const i of e) {
    const s = n[i];
    t.set(parseInt(i, 10), s);
  }
  return t;
}
const bd = /* @__PURE__ */ new Map();
function Ui(n, t) {
  bd.set(n, t);
}
function ph(n) {
  return bd.get(n);
}
const en = -1;
function Hr(n) {
  return console.assert(n !== en), n > en;
}
function wg(n) {
  return console.assert(Hr(n)), n;
}
function Ks(n, t) {
  return Hr(n) ? Ne(t).toRuntimeId(n) : n;
}
class gh {
  static parseXml(t) {
    console.assert(t.localName === "Material");
    let e = null, i = null;
    const s = t.getAttribute("Color");
    if (s !== null) {
      const r = s.split(" ");
      if (r.length !== 4)
        throw new ce('Expected "Color" attribute to have four channel components.');
      const o = parseFloat(r[0]), a = parseFloat(r[1]), l = parseFloat(r[2]), c = parseFloat(r[3]);
      e = new it(o, a, l), i = c;
    }
    return new gh(e, i);
  }
  constructor(t, e) {
    t !== null && (this._color = t), e !== null && (this._alpha = e);
  }
  getColor() {
    return this._color !== void 0 ? this._color : null;
  }
  getAlpha() {
    return this._alpha !== void 0 ? this._alpha : null;
  }
}
var Qt = /* @__PURE__ */ ((n) => (n[n.Id = 1] = "Id", n[n.Name = 2] = "Name", n[n.Visiblity = 4] = "Visiblity", n[n.Transform = 8] = "Transform", n[n.SubNodes = 16] = "SubNodes", n[n.Instance = 32] = "Instance", n[n.InstanceQuickAccess = 64] = "InstanceQuickAccess", n[n.BodyInstances = 128] = "BodyInstances", n[n.Attributes = 256] = "Attributes", n[n.PartDataLink = 512] = "PartDataLink", n[n.Bodies = 1024] = "Bodies", n[n.FaceMeasurement = 2048] = "FaceMeasurement", n[n.EdgeMeasurement = 4096] = "EdgeMeasurement", n[n.MeshKey = 8192] = "MeshKey", n[n.Unit = 16384] = "Unit", n[n.Views = 32768] = "Views", n[n.Pmis = 65536] = "Pmis", n[n.ScInclusionKey = 131072] = "ScInclusionKey", n[n.ScInstanceKey = 262144] = "ScInstanceKey", n[n.ExternalModel = 524288] = "ExternalModel", n[n.PhysicalProperties = 1048576] = "PhysicalProperties", n[n.VersionNumber = 2097152] = "VersionNumber", n[n.ProductBits = 4194304] = "ProductBits", n[n.Header = 8388608] = "Header", n[n.FrontUpVector = 16777216] = "FrontUpVector", n[n.ExchangeId = 33554432] = "ExchangeId", n[n.LayerId = 67108864] = "LayerId", n[n.LayerList = 134217728] = "LayerList", n[n.Filters = 268435456] = "Filters", n[n.UserData = 536870912] = "UserData", n[n.UseNodeParseBits2 = 1073741824] = "UseNodeParseBits2", n))(Qt || {}), Un = /* @__PURE__ */ ((n) => (n[n.FaceAttributes = 1] = "FaceAttributes", n[n.EdgeAttributes = 2] = "EdgeAttributes", n[n.OriginalName = 4] = "OriginalName", n[n.GenericTypes = 8] = "GenericTypes", n[n.GenericTypeId = 16] = "GenericTypeId", n[n.GenericId = 32] = "GenericId", n[n.DoublePrecisionMatrices = 64] = "DoublePrecisionMatrices", n[n.PointAttributes = 128] = "PointAttributes", n[n.Relationships = 256] = "Relationships", n))(Un || {}), ui = /* @__PURE__ */ ((n) => (n[n.Name = 1] = "Name", n[n.Camera = 2] = "Camera", n[n.Pmi = 4] = "Pmi", n[n.Frame = 8] = "Frame", n[n.ShowNodes = 16] = "ShowNodes", n[n.HideNodes = 32] = "HideNodes", n[n.MoveNodes = 64] = "MoveNodes", n[n.CuttingPlanes = 128] = "CuttingPlanes", n[n.IsAnnotationView = 256] = "IsAnnotationView", n[n.IsNotCameraSet = 512] = "IsNotCameraSet", n[n.IsNotPmiFilteringSet = 1024] = "IsNotPmiFilteringSet", n[n.IsNotGeomFilteringSet = 2048] = "IsNotGeomFilteringSet", n[n.IsNotCrosssectionSet = 4096] = "IsNotCrosssectionSet", n[n.IsNotExplosionSet = 8192] = "IsNotExplosionSet", n[n.IsCombineState = 16384] = "IsCombineState", n[n.IsPerspective = 32768] = "IsPerspective", n[n.IsDefaultView = 65536] = "IsDefaultView", n))(ui || {}), Hs = /* @__PURE__ */ ((n) => (n[n.Name = 1] = "Name", n[n.TopoRef = 2] = "TopoRef", n[n.Attributes = 4] = "Attributes", n[n.InitiallyHidden = 8] = "InitiallyHidden", n[n.HasMultipleBodies = 16] = "HasMultipleBodies", n[n.ExchangeId = 32] = "ExchangeId", n))(Hs || {}), Ya = /* @__PURE__ */ ((n) => (n[n.Name = 1] = "Name", n[n.LayerItem = 2] = "LayerItem", n[n.EntityItem = 4] = "EntityItem", n))(Ya || {}), Id = /* @__PURE__ */ ((n) => (n[n.Name = 1] = "Name", n))(Id || {}), Ic = /* @__PURE__ */ ((n) => (n[n.ValueName = 1] = "ValueName", n[n.Units = 2] = "Units", n))(Ic || {}), Ga = /* @__PURE__ */ ((n) => (n[n.Type = 1] = "Type", n[n.Related = 2] = "Related", n[n.Relating = 4] = "Relating", n))(Ga || {}), mi = /* @__PURE__ */ ((n) => (n[n.BeforeAction = 0] = "BeforeAction", n[n.AfterAction = 1] = "AfterAction", n))(mi || {});
function vg(n, t) {
  let e = 0;
  for (let i = 0; i < n.length; ++i) {
    const s = n[i];
    t(s) && (n[e++] = s);
  }
  n.length = e;
}
class ji {
  /**
   * Creates a new lazy value, which is the result of the supplied function
   * once the lazy value is forced.
   */
  static create(t) {
    return new ji(t);
  }
  constructor(t) {
    this._deferredValue = t;
  }
  /**
   * Forces the lazy value given at construction and returns it.
   */
  get() {
    return this._deferredValue !== null && (this._resolvedValue = this._deferredValue(), this._deferredValue = null), this._resolvedValue;
  }
}
const xg = 1024;
class su {
  constructor() {
    this.items = [], this.next = null;
  }
}
class wd {
  constructor() {
    this.clear();
  }
  clear() {
    this._head = new su(), this._tail = this._head, this._size = 0;
  }
  get length() {
    return this._size;
  }
  push(t) {
    if (++this._size, this._tail.items.length === xg) {
      const e = new su();
      this._tail.next = e, this._tail = e;
    }
    this._tail.items.push(t);
  }
  pop() {
    console.assert(this._size > 0), console.assert(this._head.items.length > 0), --this._size;
    const t = this._head.items.shift();
    if (this._head.items.length === 0) {
      const e = this._head.next;
      e === null ? console.assert(this._head === this._tail) : this._head = e;
    }
    return t;
  }
}
function ye() {
  let n, t;
  const e = new Promise((i, s) => {
    n = i, t = s;
  });
  return e.resolve = n, e.reject = t, e;
}
class Mo {
  /**
   * Creates a new [ActionQueue]
   * @param maxActivePromises Max number of promises to leave open before they begin getting deferred
   * @param suppressFailures Whether or not rejected promises and actions that throw cause the queue to fail
   */
  constructor(t, e) {
    this._failed = !1, this._failureError = null, this._activePromiseCount = 0, this._idlePromise = null, console.assert(t > 0, "Don't create a non-progressible queue."), this._maxActivePromises = t, this._suppressFailures = e, this._deferredActions = new wd();
  }
  /**
   * Returns `true` if there are no actions waiting to be evaluated
   * @returns Boolean indicating idle status
   */
  isIdle() {
    return this._activePromiseCount === 0;
  }
  /**
   * Returns a `Promise<void>` that resolves when all actions have been completed or rejects if there
   * was a failure
   *
   * It should be noted that if the queue is configured not to suppress failures and an action throws an error,
   * any deferred actions (actions that were queued but not active at the time of the failure) will be
   * cleared from the queue and will not be evaluated
   * @returns A promise that resolves/rejects when all actions have been completed
   */
  async waitForIdle() {
    if (this.isIdle()) {
      if (this._failed)
        throw this._failureError;
      return;
    }
    return this._idlePromise === null && (this._idlePromise = ye()), this._idlePromise;
  }
  /**
   * Pushes a new [ActionLike] to be evaluated onto the queue
   * @param action
   */
  push(t) {
    typeof t == "function" && (t = ji.create(t)), this._activePromiseCount < this._maxActivePromises ? (console.assert(this._deferredActions.length === 0), this._immediateAction(t)) : this._deferredActions.push(t);
  }
  _immediateAction(t) {
    if (this._failed)
      return console.assert(this._deferredActions.length === 0), !0;
    let e;
    try {
      e = t.get();
    } catch (i) {
      this._suppressFailures || (this._failed = !0, this._failureError = i, this._deferredActions.clear());
    }
    return e === void 0 ? !0 : (++this._activePromiseCount, e.then((i) => (this._finalizePromise(), i)).catch((i) => {
      throw this._finalizePromise(), i;
    }), !1);
  }
  _finalizePromise() {
    if (--this._activePromiseCount, this._failed && console.assert(this._deferredActions.length === 0), this._deferredActions.length > 0)
      do {
        const t = this._deferredActions.pop();
        if (!this._immediateAction(t))
          break;
      } while (this._deferredActions.length > 0);
    this._tryActivateIdlePromise();
  }
  _tryActivateIdlePromise() {
    this._activePromiseCount === 0 && (console.assert(this._deferredActions.length === 0), this._idlePromise !== null && (this._failed ? this._idlePromise.reject(this._failureError) : this._idlePromise.resolve(), this._idlePromise = null));
  }
}
class fs {
  /**
   * Creates a new `CurrentAction`.
   * @param suppressFailures Controls whether or not thrown action errors cause `waitForIdle` to throw.
   */
  constructor(t) {
    this._active = null, this._pending = null, this._idlePromise = null, this._suppressFailures = t;
  }
  /**
   * Queries the idle state of this object.
   * @return `true` if there are no executing actions and `false` otherwise.
   */
  isIdle() {
    return this._active === null;
  }
  /**
   * Creates `Promise` that can be used to wait for this object to become idle.
   *
   * If this object was created with `suppressFailures`, then the returned `Promise`
   * never throws. Otherwise action failures (from `this.set`) propagate to the returned `Promise`.
   *
   * @return The idle `Promise`.
   */
  waitForIdle() {
    return this.isIdle() ? Promise.resolve() : (this._idlePromise === null && (this._idlePromise = ye()), this._idlePromise);
  }
  /**
   * Sets the action to execute to the one supplied.
   *
   * If this object is idle, then the action is immediately executed,
   * and this object is no longer as long as the action is running.
   *
   * Otherwise if the object is not idle, then action becomes pended
   * and will execute after the current one finishes. If an action is
   * already pended, then the prior pending action is replaced by the
   * newly supplied action and is discarded.
   *
   * @param action
   */
  set(t) {
    if (typeof t == "function" && (t = ji.create(t)), this._active === null) {
      let e;
      try {
        e = t.get();
      } catch (i) {
        return this._advance(!this._suppressFailures, i);
      }
      if (e === void 0)
        return this._advance(!1, null);
      this._active = e.then(() => {
        this._advance(!1, null);
      }).catch((i) => {
        this._advance(!this._suppressFailures, i);
      });
    } else
      this._pending = t;
  }
  _advance(t, e) {
    if (this._active = null, t && (this._pending = null), this._pending === null)
      this._idlePromise !== null && (t ? this._idlePromise.reject(e) : this._idlePromise.resolve(), this._idlePromise = null);
    else {
      const i = this._pending;
      this._pending = null, this.set(i);
    }
  }
  /**
   * Clears and discards any pending actions. If an action is
   * currently being executed, it remains unaffected by this.
   */
  clear() {
    this._pending = null;
  }
}
function zt(n) {
  return Promise.all(n);
}
class Sg {
  constructor(t) {
    this.promise = ye(), this.ids = t;
  }
}
class Zg {
  constructor() {
    this._aliasMap = /* @__PURE__ */ new Map(), this._callbackMap = /* @__PURE__ */ new Map(), this._activeTriggerDepth = 0, this._pendingClearUnboundFilteredNames = /* @__PURE__ */ new Set(), this._aliasMap.set("sceneRendered", "frameDrawn");
  }
  _filterName(t) {
    const e = this._aliasMap.get(t);
    return e === void 0 ? t : e;
  }
  bind(t, e) {
    const i = Object.keys(t);
    for (const s of i) {
      const r = t[s];
      if (typeof r == "function") {
        const o = this._filterName(s), a = this._callbackMap.get(o);
        a === void 0 ? this._callbackMap.set(o, [r]) : e ? a.unshift(r) : a.push(r);
      }
    }
  }
  unbind(t) {
    const e = Object.keys(t);
    for (const i of e) {
      const s = this._filterName(i), r = this._callbackMap.get(s);
      if (r !== void 0) {
        const o = t[i];
        for (let a = 0; a < r.length; a++)
          r[a] === o && (r[a] = null, this._pendingClearUnboundFilteredNames.add(s));
      }
    }
    this._clearUnboundCallbacks();
  }
  _clearUnboundCallbacks() {
    this._pendingClearUnboundFilteredNames.size !== 0 && this._activeTriggerDepth === 0 && (this._pendingClearUnboundFilteredNames.forEach((t) => {
      let e = this._callbackMap.get(t);
      e !== void 0 && (e = e.filter((i) => i !== null), e.length === 0 ? this._callbackMap.delete(t) : this._callbackMap.set(t, e));
    }), this._pendingClearUnboundFilteredNames.clear());
  }
  async promiseTrigger(t, e, ...i) {
    console.assert(t !== e);
    try {
      await this._unsafePromiseTrigger(t, i);
    } catch (s) {
      console.error(`Rejected promise in '${t}' callback:`, s);
    } finally {
      e !== null && this.unsafeTrigger(e, i);
    }
  }
  // Unsafe from a type safety point of view.
  _unsafePromiseTrigger(t, e) {
    const i = this._filterName(t), s = this._callbackMap.get(i), r = [];
    if (s !== void 0) {
      ++this._activeTriggerDepth;
      for (const o of s)
        if (o !== null)
          try {
            r.push(o(...e ?? []));
          } catch (a) {
            console.error(`Unhandled exception in '${t}' callback:`, a);
          }
      --this._activeTriggerDepth, this._clearUnboundCallbacks();
    }
    return zt(r);
  }
  trigger(t, ...e) {
    this.unsafeTrigger(t, e);
  }
  // Unsafe from a type safety point of view.
  unsafeTrigger(t, e) {
    const i = this._filterName(t), s = this._callbackMap.get(i);
    if (s !== void 0) {
      ++this._activeTriggerDepth;
      for (const r of s)
        if (r !== null)
          try {
            r(...e ?? []);
          } catch (o) {
            console.error(`Unhandled exception in '${t}' callback:`, o);
          }
      --this._activeTriggerDepth, this._clearUnboundCallbacks();
    }
  }
}
var vd = /* @__PURE__ */ ((n) => (n[n.Undefined = 0] = "Undefined", n[n.Line = 1] = "Line", n[n.Circle = 2] = "Circle", n[n.Other = 6] = "Other", n))(vd || {}), xd = /* @__PURE__ */ ((n) => (n[n.Undefined = 0] = "Undefined", n[n.Cylinder = 3] = "Cylinder", n[n.Plane = 4] = "Plane", n[n.Cone = 5] = "Cone", n[n.Other = 6] = "Other", n[n.Sphere = 7] = "Sphere", n[n.Torus = 8] = "Torus", n[n.Blend01 = 9] = "Blend01", n[n.Blend02 = 10] = "Blend02", n[n.Blend03 = 11] = "Blend03", n[n.Nurbs = 12] = "Nurbs", n[n.Cylindrical = 13] = "Cylindrical", n[n.Offset = 14] = "Offset", n[n.Pipe = 15] = "Pipe", n[n.Ruled = 16] = "Ruled", n[n.Revolution = 17] = "Revolution", n[n.Extrusion = 18] = "Extrusion", n[n.FromCurves = 19] = "FromCurves", n[n.Transform = 20] = "Transform", n))(xd || {});
let vl = class wc {
  constructor(t) {
    this.length = t;
  }
  static fromJson(t) {
    return new wc(t.length);
  }
  copy() {
    return new wc(this.length);
  }
  type() {
    return 1;
  }
}, ha = class vc {
  constructor(t, e, i) {
    this.radius = t, this.origin = e.copy(), this.normal = i.copy();
  }
  static fromJson(t) {
    const e = t.radius, i = new d(t.origin.x, t.origin.y, t.origin.z), s = new d(t.normal.x, t.normal.y, t.normal.z);
    return new vc(e, i, s);
  }
  copy() {
    return new vc(this.radius, this.origin, this.normal);
  }
  type() {
    return 2;
  }
};
class lr {
  constructor(t) {
    this.length = t;
  }
  static fromJson(t) {
    return new lr(t.length);
  }
  copy() {
    return new lr(this.length);
  }
  type() {
    return 6;
  }
}
class xl {
  copy() {
    return new xl();
  }
  type() {
    return 6;
  }
}
class Me {
  constructor(t, e, i) {
    this.radius = t, this.origin = e.copy(), this.normal = i.copy();
  }
  static fromJson(t) {
    const e = t.radius, i = new d(t.origin.x, t.origin.y, t.origin.z), s = new d(t.normal.x, t.normal.y, t.normal.z);
    return new Me(e, i, s);
  }
  copy() {
    return new Me(this.radius, this.origin, this.normal);
  }
  type() {
    return 3;
  }
}
class Be {
  constructor(t, e) {
    this.origin = t.copy(), this.normal = e.copy();
  }
  static fromJson(t) {
    const e = new d(t.origin.x, t.origin.y, t.origin.z), i = new d(t.normal.x, t.normal.y, t.normal.z);
    return new Be(e, i);
  }
  copy() {
    return new Be(this.origin, this.normal);
  }
  type() {
    return 4;
  }
}
class Nr {
  constructor(t, e, i, s) {
    this.radius = t, this.origin = e.copy(), this.normal = i.copy(), this.halfAngle = s;
  }
  static fromJson(t) {
    const e = t.radius, i = t.halfAngle, s = new d(t.origin.x, t.origin.y, t.origin.z), r = new d(t.normal.x, t.normal.y, t.normal.z);
    return new Nr(e, s, r, i);
  }
  copy() {
    return new Nr(this.radius, this.origin, this.normal, this.halfAngle);
  }
  type() {
    return 5;
  }
}
class Rr {
  constructor(t, e, i) {
    this.radius = t, this.origin = e.copy(), this.normal = i.copy();
  }
  static fromJson(t) {
    const e = t.radius, i = new d(t.origin.x, t.origin.y, t.origin.z), s = new d(t.normal.x, t.normal.y, t.normal.z);
    return new Rr(e, i, s);
  }
  copy() {
    return new Rr(this.radius, this.origin, this.normal);
  }
  type() {
    return 7;
  }
}
class Lr {
  constructor(t, e, i, s) {
    this.majorRadius = t, this.minorRadius = e, this.origin = i.copy(), this.normal = s.copy();
  }
  static fromJson(t) {
    const e = new d(t.origin.x, t.origin.y, t.origin.z), i = new d(t.normal.x, t.normal.y, t.normal.z), s = t.majRadius, r = t.minRadius;
    return new Lr(s, r, e, i);
  }
  copy() {
    return new Lr(this.majorRadius, this.minorRadius, this.origin, this.normal);
  }
  type() {
    return 8;
  }
}
class Sl {
  copy() {
    return new Sl();
  }
  type() {
    return 9;
  }
}
class Zl {
  copy() {
    return new Zl();
  }
  type() {
    return 10;
  }
}
class Cl {
  copy() {
    return new Cl();
  }
  type() {
    return 11;
  }
}
class kl {
  copy() {
    return new kl();
  }
  type() {
    return 12;
  }
}
class Ml {
  copy() {
    return new Ml();
  }
  type() {
    return 13;
  }
}
class Wl {
  copy() {
    return new Wl();
  }
  type() {
    return 14;
  }
}
class Pl {
  copy() {
    return new Pl();
  }
  type() {
    return 15;
  }
}
class Vl {
  copy() {
    return new Vl();
  }
  type() {
    return 16;
  }
}
class Yl {
  copy() {
    return new Yl();
  }
  type() {
    return 17;
  }
}
class Gl {
  copy() {
    return new Gl();
  }
  type() {
    return 18;
  }
}
class Tl {
  copy() {
    return new Tl();
  }
  type() {
    return 19;
  }
}
class El {
  copy() {
    return new El();
  }
  type() {
    return 20;
  }
}
function fh() {
  let n, t;
  const e = new Promise((i, s) => {
    n = (r) => {
      e.state = ds.Resolved, i(r);
    }, t = (r) => {
      e.state = ds.Rejected, s(r);
    };
  });
  return e.state = ds.Pending, e.resolve = n, e.reject = t, e;
}
function os(n, t) {
  const e = new Promise((i, s) => {
    t.then(() => {
      e.isReady = !0, i(n);
    }, s);
  });
  return e.unsafeValue = n, e.readyPromise = t, e.isReady = !1, e;
}
class Hi {
  constructor() {
    this._faceMeshData = [], this._pointMeshData = [], this._polylineMeshData = [], this._faceWinding = yn.CounterClockwise, this._backfacesEnabled = !1, this._isManifold = !1;
  }
  /**
   * Adds face data to the mesh. Note that the arrays passed into this function are not copied and should remain unchanged until the mesh has been created.
   * When adding vertex data into the mesh using this method, it is important to note that the data is interpreted as triangles in which each vertex must be explicitly enumerated.
   * @param vertexData floating point data describing the points in space for the faces to be added to the mesh
   * @param normalData normals for the corresponding vertex data points.
   * @param rgba32data colors for the corresponding vertex data points (four bytes per rbga).
   * @param uvs texture parameters for the corresponding vertex data points.
   * @param bits bitmask associated with the face.
   */
  addFaces(t, e, i, s, r = 0) {
    this._faceMeshData.push(new Cg(t, e, i, s, r));
  }
  /**
   * Adds point data to the mesh. Note that the arrays passed into this function are not copied and should remain unchanged until the mesh has been created.
   * @param pointData floating point data describing the points to be added to the mesh
   * @param rgba32data colors for the corresponding vertex data points (four bytes per rbga).
   * @param bits bitmask associated with the point.
   */
  addPoints(t, e, i = 0) {
    this._pointMeshData.push(new Mg(t, e, i));
  }
  /**
   * Adds polyline data to the mesh.Note that the arrays passed into this function are not copied and should remain unchanged until the mesh has been created.
   * @param polylineData floating point data describing the polyline to be added to the mesh
   * @param rgba32data colors for the corresponding vertex data points (four bytes per rbga).
   * @param bits bitmask associated with the line.
   */
  addPolyline(t, e, i = 0) {
    this._polylineMeshData.push(new kg(t, e, i));
  }
  /**
   * Removes all data from the object.
   */
  clear() {
    this._faceMeshData.length = 0, this._pointMeshData.length = 0, this._polylineMeshData.length = 0;
  }
  /**
   * Sets the face winding to be used for this mesh. The default value is CounterClockwise.
   * @param faceWinding the face winding to use for mesh geometry.
   */
  setFaceWinding(t) {
    this._faceWinding = t;
  }
  /**
   * Gets the face winding used for this mesh.
   */
  getFaceWinding() {
    return this._faceWinding;
  }
  /**
   * Sets whether backfaces should be enabled for this geometry. The default value is false.
   * Setting this to true for geometry with a large amount of faces may affect performance.
   * @param backfacesEnabled indicated whether backfaces should be enabled for this geometry.
   */
  setBackfacesEnabled(t) {
    this._backfacesEnabled = t;
  }
  /**
   * Gets whether backfaces are enabled for this geometry
   * @returns value indicting whether backfaces are enabled for this geometry.
   */
  getBackfacesEnabled() {
    return this._backfacesEnabled;
  }
  /**
   * Sets whether the mesh is a manifold one or not (if the mesh is not set as manifold, then capping won't happen while cutting).
   * @param isManifold indicated whether or not it's a manifold mesh.
   */
  setManifold(t) {
    this._isManifold = t;
  }
  /**
   * Gets if the mesh is set as manifold.
   * @returns value indicating whether or not it's a manifold mesh.
   */
  isManifold() {
    return this._isManifold;
  }
  /** @hidden */
  _getFaceData() {
    return this._faceMeshData;
  }
  /** @hidden */
  _getPointData() {
    return this._pointMeshData;
  }
  /** @hidden */
  _getPolylineData() {
    return this._polylineMeshData;
  }
}
class bn {
  /**
   * Creates a new MeshInstanceData object.
   * @param meshId the [[MeshId]] of the mesh to instantiate
   * @param matrix a matrix that will be applied to this instance
   * @param instanceName a name that will be visible when querying the model hierarchy
   * @param faceColor the color for faces of this instance
   * @param lineColor the color for lines of this instance
   * @param pointColor the color for points of this instance
   * @param creationFlags additional options that can be used to alter the behavior of this instance
   */
  constructor(t, e, i, s, r, o, a) {
    this._meshId = null, this._matrix = null, this._faceColor = null, this._lineColor = null, this._pointColor = null, this._instanceName = null, this._faceOpacity = 1, this._lineOpacity = 1, this._pointOpacity = 1, this._creationFlags = xt.None, this._overlayIndex = 0, t && (this._meshId = t.slice()), e && (this._matrix = e.copy()), i && (this._instanceName = i), s && (this._faceColor = s.copy()), r && (this._lineColor = r.copy()), o && (this._pointColor = o.copy()), a && (this._creationFlags = a);
  }
  /**
   * Creates a copy of this MeshInstanceData.
   * @returns Copy of this MeshInstanceData object.
   */
  copy() {
    const t = new bn(
      this.getMeshId(),
      this.getMatrix(),
      this.getInstanceName(),
      this.getFaceColor(),
      this.getLineColor(),
      this.getPointColor(),
      this.getCreationFlags()
    );
    return t.setPointOpacity(this.getOpacity()), t.setLineOpacity(this.getLineOpacity()), t.setOpacity(this.getOpacity()), t.setOverlayIndex(this.getOverlayIndex()), t;
  }
  /**
   * Resets all fields of this object.
   */
  clear() {
    this._meshId = null, this._matrix = null, this._faceColor = null, this._lineColor = null, this._pointColor = null, this._instanceName = null, this._faceOpacity = 1, this._lineOpacity = 1, this._pointOpacity = 1, this._creationFlags = xt.None, this._overlayIndex = 0;
  }
  /**
   * Gets the [[MeshId]] of the mesh to use for this instance.
   * [[MeshId]]s are created with [[Model.createMesh]] or retrieved with [[Model.getMeshIds]].
   * @returns the mesh ID to use for this instance.
   */
  getMeshId() {
    return this._meshId !== null ? this._meshId.slice() : null;
  }
  /**
   * Sets the [[MeshId]] of the mesh to use for the instance.
   * [[MeshId]]s are created with [[Model.createMesh]] or retrieved with [[Model.getMeshIds]].
   * @param meshId the [[MeshId]] to use.
   */
  setMeshId(t) {
    this._meshId = t.slice();
  }
  /**
   * Gets the matrix to apply to this instance.
   * @returns the current matrix that will be applied to this instance upon creation.
   */
  getMatrix() {
    return this._matrix !== null ? this._matrix.copy() : null;
  }
  /**
   * Gets the mesh instance creation flags (SuppressCameraScale, DoNotExplode, DoNotLight...)
   * @returns the mesh instance creation flags (null if none set)
   */
  getCreationFlags() {
    return this._creationFlags;
  }
  /**
   * Sets the mesh instance creation flags (SuppressCameraScale, DoNotExplode, DoNotLight...)
   * @param flags creation flags
   */
  setCreationFlags(t) {
    this._creationFlags = t;
  }
  /**
   * Sets the matrix that will be applied to this instance.
   * @param matrix the matrix to apply.
   */
  setMatrix(t) {
    this._matrix = t.copy();
  }
  /**
   * Gets the name that will be applied to the instance.
   * @returns the instance name.
   */
  getInstanceName() {
    return this._instanceName;
  }
  /**
   * Sets the name that will be assigned to this instance. This name will be visible when querying the model hierarchy.
   * @param instanceName the name to assign to this instance.
   */
  setInstanceName(t) {
    this._instanceName = t;
  }
  /**
   * Sets the color for face elements in this instance.
   * @param faceColor the color to apply to face elements.
   */
  setFaceColor(t) {
    this._faceColor = t.copy();
  }
  /**
   * Gets the color for face elements in this instance.
   * @returns the color for face elements.
   */
  getFaceColor() {
    return this._faceColor !== null ? this._faceColor.copy() : null;
  }
  /**
   * Sets the color for line elements in this instance.
   * @param lineColor the color to apply to line elements.
   */
  setLineColor(t) {
    this._lineColor = t.copy();
  }
  /**
   * Gets the color for line elements in this instance.
   * @returns the color for line elements.
   */
  getLineColor() {
    return this._lineColor !== null ? this._lineColor.copy() : null;
  }
  /**
   * Sets the color for point elements in this instance.
   * @param pointColor the color to apply to point elements.
   */
  setPointColor(t) {
    this._pointColor = t.copy();
  }
  /**
   * Gets the color for point elements in this instance.
   * @returns the color for point elements.
   */
  getPointColor() {
    return this._pointColor !== null ? this._pointColor.copy() : null;
  }
  /**
   * Sets the point opacity for this instance.
   * @param pointOpacity opacity value to set.
   */
  setPointOpacity(t) {
    this._pointOpacity = t;
  }
  /**
   * Gets the point opacity value for this instance.
   * @returns the point opacity value for this instance.
   */
  getPointOpacity() {
    return this._pointOpacity;
  }
  /**
   * Sets the line opacity for this instance.
   * @param lineOpacity opacity value to set.
   */
  setLineOpacity(t) {
    this._lineOpacity = t;
  }
  /**
   * Gets the line opacity value for this instance.
   * @returns the line opacity value for this instance.
   */
  getLineOpacity() {
    return this._lineOpacity;
  }
  /**
   * Sets the face opacity for this instance.
   * @param faceOpacity opacity value to set.
   */
  setOpacity(t) {
    this._faceOpacity = t;
  }
  /**
   * Gets the face opacity value for this instance.
   * @returns the face opacity value for this instance.
   */
  getOpacity() {
    return this._faceOpacity;
  }
  /**
   * Sets the overlay index for this instance.
   * @param overlayIndex overlay index to set.
   */
  setOverlayIndex(t) {
    this._overlayIndex = t;
  }
  /**
   * Gets the overlay index for this instance.
   * @returns the overlay index for this instance.
   */
  getOverlayIndex() {
    return this._overlayIndex;
  }
}
class Cg {
  constructor(t, e, i, s, r = 0) {
    this.vertexData = t, this.normalData = e, this.rgba32data = i, this.uvData = s, this.bits = r;
  }
}
class kg {
  constructor(t, e, i = 0) {
    this.vertexData = t, this.rgba32data = e, this.bits = i;
  }
}
class Mg {
  constructor(t, e, i = 0) {
    this.vertexData = t, this.rgba32data = e, this.bits = i;
  }
}
function Sd() {
  const n = (1 + Math.sqrt(5)) / 2, t = Math.sqrt(10 + 2 * Math.sqrt(5)) / (4 * n), e = t / 2, i = t / (2 * n), s = [];
  s[0] = new d(-i, e, 0), s[1] = new d(i, e, 0), s[2] = new d(-i, -e, 0), s[3] = new d(i, -e, 0), s[4] = new d(0, -i, e), s[5] = new d(0, i, e), s[6] = new d(0, -i, -e), s[7] = new d(0, i, -e), s[8] = new d(e, 0, -i), s[9] = new d(e, 0, i), s[10] = new d(-e, 0, -i), s[11] = new d(-e, 0, i);
  for (const u of s)
    u.normalize();
  let r = [
    [0, 11, 5],
    [0, 5, 1],
    [0, 1, 7],
    [0, 7, 10],
    [0, 10, 11],
    [1, 5, 9],
    [5, 11, 4],
    [11, 10, 2],
    [10, 7, 6],
    [7, 1, 8],
    [3, 9, 4],
    [3, 4, 2],
    [3, 2, 6],
    [3, 6, 8],
    [3, 8, 9],
    [4, 9, 5],
    [2, 4, 11],
    [6, 2, 10],
    [8, 6, 7],
    [9, 8, 1]
  ], o = 12;
  const a = 2;
  for (let u = 0; u < a; u++) {
    const p = [];
    r.map((m) => {
      const g = s[m[0]], _ = s[m[1]], y = s[m[2]];
      s[o++] = new d(g.x + _.x, g.y + _.y, g.z + _.z).scale(0.5).normalize(), s[o++] = new d(_.x + y.x, _.y + y.y, _.z + y.z).scale(0.5).normalize(), s[o++] = new d(y.x + g.x, y.y + g.y, y.z + g.z).scale(0.5).normalize(), p.push([m[0], o - 3, o - 1]), p.push([o - 3, o - 2, o - 1]), p.push([o - 3, m[1], o - 2]), p.push([o - 2, m[2], o - 1]);
    }), r = p;
  }
  const l = [], c = [];
  for (const u of r)
    for (let p = 0; p < 3; p++) {
      const m = u[p];
      l.push(s[m].x), l.push(s[m].y), l.push(s[m].z);
      const g = s[m].normalize();
      c.push(g.x), c.push(g.y), c.push(g.z);
    }
  const h = new Hi();
  return h.addFaces(l, c), h.setFaceWinding(yn.CounterClockwise), h;
}
function _h(n, t, e, i, s, r) {
  const o = new Q(), a = Pg(
    i,
    t,
    e + r,
    s,
    o
  ), l = Wg(n, t, e, o), c = Vg(
    n,
    i,
    t,
    e,
    r
  ), h = a[0].concat(l[0]).concat(c[0]), u = a[1].concat(l[1]).concat(c[1]), p = new Hi();
  return p.setFaceWinding(yn.Clockwise), p.addFaces(h, u), p;
}
function Zd(n) {
  const t = Math.PI * 2 / n, e = [];
  for (let i = 0; i < n; i++) {
    const s = i * t, r = Math.cos(s), o = Math.sin(s);
    e.push(r), e.push(o);
  }
  return e;
}
function Zs(n, t, e, i = 1) {
  let s = d.cross(e, new d(0, 1, 0));
  s.length() < 1e-3 && (s = d.cross(e, new d(0, 0, 1)));
  const r = d.cross(s, e), o = Math.PI * 2 / n, a = [];
  for (let l = 0; l < n; l++) {
    const c = l * o, h = Math.sin(c), u = Math.cos(c), p = s.copy().scale(h).add(r.copy().scale(u)).scale(i).add(t);
    a.push(p);
  }
  return a;
}
function Cd(n, t, e, i) {
  const o = [], a = [];
  let l;
  for (let v = 0; v < n.length - 3; v += 3) {
    const C = new d(n[v], n[v + 1], n[v + 2]), k = new d(n[v + 3], n[v + 4], n[v + 5]), Y = Zs(e, C, t, i), P = Zs(e, k, t, i);
    l = Ta(C, k, Y, P, !1), Array.prototype.push.apply(o, l[0]), Array.prototype.push.apply(a, l[1]);
  }
  const c = n.length;
  let h = new d(n[c - 3], n[c - 2], n[c - 1]), u = h.copy().subtract(new d(n[c - 6], n[c - 5], n[c - 4])).normalize(), p = Zs(
    e * 2,
    h,
    t,
    i
  ), m = h.copy().add(u.copy().scale(2 / 3)), g = Zs(
    e * 2,
    m,
    t,
    i * 2
  ), _ = m.copy().add(u.copy().scale(2));
  l = Ta(
    h,
    m,
    p,
    g,
    !1
  ), Array.prototype.push.apply(o, l[0]), Array.prototype.push.apply(a, l[1]);
  for (let v = 0; v < p.length; v++) {
    const C = (v + 1) % p.length;
    o.push(_), o.push(g[v]), o.push(g[C]);
    const k = g[v].copy().subtract(m).normalize().add(_.copy().normalize()).normalize();
    a.push(k), a.push(k), a.push(k);
  }
  h = new d(n[0], n[1], n[2]), u = h.copy().subtract(new d(n[3], n[4], n[5])).normalize(), p = Zs(
    e * 2,
    h,
    t,
    i
  ), m = h.copy().add(u.copy().scale(2 / 3)), g = Zs(
    e * 2,
    m,
    t,
    i * 2
  ), _ = m.copy().add(u.copy().scale(2)), l = Ta(
    m,
    h,
    g,
    p,
    !1
  ), Array.prototype.push.apply(o, l[0]), Array.prototype.push.apply(a, l[1]);
  for (let v = 0; v < p.length; v++) {
    const C = (v + 1) % p.length;
    o.push(_), o.push(g[C]), o.push(g[v]);
    const k = g[v].copy().subtract(m).normalize().add(_.copy().normalize()).normalize();
    a.push(k), a.push(k), a.push(k);
  }
  const y = [], b = [];
  for (let v = 0; v < o.length; v++) {
    const C = o[v];
    y.push(C.x), y.push(C.y), y.push(C.z);
    const k = a[v];
    b.push(k.x), b.push(k.y), b.push(k.z);
  }
  const w = new Hi();
  return w.setFaceWinding(yn.CounterClockwise), w.addFaces(y, b), w;
}
function Ta(n, t, e, i, s) {
  const r = [], o = [];
  for (let a = 0; a < e.length; a++) {
    const l = (a + 1) % e.length;
    r.push(e[a]), r.push(e[l]), r.push(i[a]), r.push(e[l]), r.push(i[l]), r.push(i[a]), o.push(d.subtract(e[a], n)), o.push(d.subtract(e[l], n)), o.push(d.subtract(i[a], t)), o.push(d.subtract(e[l], n)), o.push(d.subtract(i[l], t)), o.push(d.subtract(i[a], t));
  }
  if (s) {
    const a = d.subtract(n, t);
    for (const l of o)
      l.add(a).normalize();
  }
  return [r, o];
}
function Wg(n, t, e, i) {
  const s = [], r = [], o = Zd(t), a = o;
  for (let p = 0; p < a.length; p++)
    a[p] *= n;
  const l = [], c = [];
  for (let p = 0; p < a.length; p += 2) {
    const m = a[p], g = a[p + 1], _ = (p + 2) % a.length, y = a[_], b = a[_ + 1], w = o[p], v = o[p + 1], C = o[_], k = o[_ + 1];
    l[0] = new d(m, e, g), l[1] = new d(m, 0, g), l[2] = new d(y, 0, b), l[3] = new d(y, 0, b), l[4] = new d(y, e, b), l[5] = new d(m, e, g), c[0] = new d(w, 0, v), c[1] = new d(w, 0, v), c[2] = new d(C, 0, k), c[3] = new d(C, 0, k), c[4] = new d(C, 0, k), c[5] = new d(w, 0, v);
    for (let Y = 0; Y < l.length; Y++) {
      const P = i.transform(l[Y]);
      s.push(P);
      const L = i.transform(c[Y]);
      r.push(L);
    }
    l[0] = new d(y, 0, b), l[1] = new d(m, 0, g), l[2] = d.zero(), c[0] = new d(0, -1, 0), c[1] = new d(0, -1, 0), c[2] = new d(0, -1, 0);
    for (let Y = 0; Y < 3; Y++) {
      const P = i.transform(l[Y]);
      s.push(P);
      const L = i.transform(c[Y]);
      r.push(L);
    }
  }
  const h = [], u = [];
  for (let p = 0; p < s.length; p++) {
    const m = s[p];
    h.push(m.x), h.push(m.y), h.push(m.z);
    const g = r[p];
    u.push(g.x), u.push(g.y), u.push(g.z);
  }
  return [h, u];
}
function Pg(n, t, e, i, s) {
  const r = Zd(t), o = r;
  for (let _ = 0; _ < o.length; _++)
    o[_] *= n;
  const a = new d(0, e + i, 0), l = new d(0, e, 0), c = s.transform(a), h = s.transform(l), u = [], p = [];
  for (let _ = 0; _ < o.length; _ += 2) {
    const y = o[_], b = o[_ + 1], w = (_ + 2) % o.length, v = o[w], C = o[w + 1], k = r[_], Y = r[_ + 1], P = r[w], L = r[w + 1], N = new d(y, e, b), D = new d(v, e, C), B = s.transform(N), V = s.transform(D);
    u.push(c), u.push(B), u.push(V);
    const X = new d(0, 1, 0), Z = new d(k, 0, Y), W = new d(P, 0, L), st = s.transform(X), j = s.transform(Z), gt = s.transform(W);
    p.push(st), p.push(j), p.push(gt);
    const U = new d(y, e, b), ht = new d(v, e, C), z = s.transform(U), O = s.transform(ht);
    u.push(h), u.push(O), u.push(z);
    const _t = new d(0, -1, 0), rt = s.transform(_t);
    p.push(rt), p.push(rt), p.push(rt);
  }
  const m = [], g = [];
  for (let _ = 0; _ < u.length; _++) {
    const y = u[_];
    m.push(y.x), m.push(y.y), m.push(y.z);
    const b = p[_];
    g.push(b.x), g.push(b.y), g.push(b.z);
  }
  return [m, g];
}
function Vg(n, t, e, i, s) {
  const r = new d(0, 0, i), o = new d(0, 0, i + s), a = new d(0, 0, 1), l = Zs(e, r, a, n), c = Zs(e, o, a, t), h = Ta(r, o, l, c, !0), u = [], p = [];
  for (let m = 0; m < h[0].length; m++)
    u.push(h[0][m].x), u.push(h[0][m].z), u.push(h[0][m].y), p.push(h[1][m].x), p.push(h[1][m].z), p.push(h[1][m].y);
  return [u, p];
}
function Yg(n) {
}
function $n(n) {
  throw new re();
}
class Gg {
  constructor(t, e) {
    this._state = t, this._reducer = e;
  }
  /**
   * Handle an action and update the state
   *
   * @param evt The action to handle
   * @param payload The payload if any
   */
  handle(t, e) {
    this._state = this._reducer(this._state, { name: t, payload: e });
  }
}
function Nl(n) {
  return new Promise((t) => {
    setTimeout(t, n);
  });
}
function Tg(n, ...t) {
  return setTimeout(n, 0, ...t);
}
function Eg(n, t) {
  return n === t;
}
class Os {
  constructor() {
    this._timerId = null, this._action = null, this._beforeActionIdlePromise = null, this._afterActionIdlePromise = null;
  }
  /**
   * Returns true if no pending action exists and false otherwise.
   */
  isIdle(t) {
    return t === mi.BeforeAction ? this._timerId === null : this._action === null;
  }
  /**
   * Returns a promise that resolves when the timer becomes (or already is) idle.
   */
  waitForIdle(t) {
    return t === mi.BeforeAction ? this._timerId === null ? Promise.resolve() : (this._beforeActionIdlePromise === null && (this._beforeActionIdlePromise = ye()), this._beforeActionIdlePromise) : this._action === null ? Promise.resolve() : (this._afterActionIdlePromise === null && (this._afterActionIdlePromise = ye()), this._afterActionIdlePromise);
  }
  _triggerIdlePromise(t) {
    t === mi.BeforeAction ? this._beforeActionIdlePromise !== null && (this._beforeActionIdlePromise.resolve(), this._beforeActionIdlePromise = null) : this._afterActionIdlePromise !== null && (this._afterActionIdlePromise.resolve(), this._afterActionIdlePromise = null);
  }
  _clearTimeout() {
    this._timerId !== null && (clearTimeout(this._timerId), this._timerId = null);
  }
  /**
   * Clears the pending action if it exists.
   */
  clear() {
    this._clearTimeout(), this._triggerIdlePromise(mi.BeforeAction), this._action = null, this._triggerIdlePromise(mi.AfterAction);
  }
  /**
   * Sets a new delayed action. If one is already pending before this call is made, it gets cleared.
   * @param delay The delay in milliseconds to pend the action.
   * @param action The action to pend.
   */
  set(t, e) {
    this._clearTimeout(), this._action = e, this._timerId = setTimeout(() => {
      this._timerId = null, this._triggerIdlePromise(mi.BeforeAction);
      const i = this._afterActionIdlePromise;
      this._afterActionIdlePromise = null, this._action(), this._timerId === null && (this._action = null), i !== null && i.resolve();
    }, t);
  }
}
function Ng() {
  const n = new Os();
  n.set(0, () => {
    n.set(0, () => {
    }), n.waitForIdle(mi.AfterAction).then(() => {
      console.log("inner-1");
    }), n.clear(), n.waitForIdle(mi.AfterAction).then(() => {
      console.log("inner-2");
    }), n.set(0, () => {
    }), n.waitForIdle(mi.AfterAction).then(() => {
      console.log("inner-3");
    });
  }), n.waitForIdle(mi.AfterAction).then(() => {
    console.log("outer");
  });
}
const V0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ActionQueue: Mo,
  CurrentAction: fs,
  Lazy: ji,
  StateMachine: Gg,
  Timer: Os,
  TimerIdleType: mi,
  TypeAssert: Yg,
  TypeAssertNever: $n,
  _timerStressTest: Ng,
  copyMap: wl,
  copySet: gg,
  createCylinderMeshDataFromArc: Cd,
  createOpenPromise: ye,
  createTrackedOpenPromise: fh,
  createUnsafePromise: os,
  delayCall: Tg,
  exchangeIdEqual: Eg,
  filterInPlace: vg,
  generateConeCylinderMeshData: _h,
  generateSphereMeshData: Sd,
  setSubtraction: bc,
  setToArray: us,
  sleep: Nl,
  toSet: ko,
  waitForAll: zt
}, Symbol.toStringTag, { value: "Module" }));
var ds = /* @__PURE__ */ ((n) => (n[n.Pending = 0] = "Pending", n[n.Resolved = 1] = "Resolved", n[n.Rejected = 2] = "Rejected", n))(ds || {}), Di = /* @__PURE__ */ ((n) => (n[n.Direct = 0] = "Direct", n[n.Indirect = 1] = "Indirect", n))(Di || {}), Ea = /* @__PURE__ */ ((n) => (n[n.X = 2] = "X", n[n.Y = 4] = "Y", n[n.Z = 8] = "Z", n))(Ea || {}), Na = /* @__PURE__ */ ((n) => (n[n.X = 16] = "X", n[n.Y = 32] = "Y", n[n.Z = 64] = "Z", n))(Na || {}), ao = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.EyeX_UpY = 34] = "EyeX_UpY", n[n.EyeX_UpZ = 66] = "EyeX_UpZ", n[n.EyeY_UpX = 20] = "EyeY_UpX", n[n.EyeY_UpZ = 68] = "EyeY_UpZ", n[n.EyeZ_UpX = 24] = "EyeZ_UpX", n[n.EyeZ_UpY = 40] = "EyeZ_UpY", n))(ao || {}), dn = /* @__PURE__ */ ((n) => (n[n.StemHeight = 2] = "StemHeight", n[n.CapHeight = 0.5] = "CapHeight", n[n.TaperHeight = 0.1] = "TaperHeight", n[n.SegmentCount = 20] = "SegmentCount", n[n.CylinderRadius = 0.2] = "CylinderRadius", n[n.ConeBaseRadius = 0.4] = "ConeBaseRadius", n[n.LetterOffsetPos = 0.6] = "LetterOffsetPos", n[n.LetterWidth = 0.3] = "LetterWidth", n[n.LetterHeight = 0.5] = "LetterHeight", n))(dn || {}), ki = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Position = 1] = "Position", n[n.Target = 2] = "Target", n[n.Up = 4] = "Up", n[n.Width = 8] = "Width", n[n.Height = 16] = "Height", n[n.Projection = 32] = "Projection", n[n.NearLimit = 64] = "NearLimit", n))(ki || {}), rl = /* @__PURE__ */ ((n) => (n[n.Attachment = 0] = "Attachment", n[n.Model = 1] = "Model", n))(rl || {}), ol = /* @__PURE__ */ ((n) => (n[n.AllKeys = 0] = "AllKeys", n[n.KeyCountOnly = 1] = "KeyCountOnly", n))(ol || {}), lo = /* @__PURE__ */ ((n) => (n[n.Add = 0] = "Add", n[n.Update = 1] = "Update", n))(lo || {}), co = /* @__PURE__ */ ((n) => (n[n.MetaData = 0] = "MetaData", n[n.Count = 1] = "Count", n))(co || {}), kd = /* @__PURE__ */ ((n) => (n[n.SelectionBitsFaceHasMeasurementData = 1] = "SelectionBitsFaceHasMeasurementData", n[n.SelectionBitsFacePlanar = 2] = "SelectionBitsFacePlanar", n[n.SelectionBitsEdgeHasMeasurementData = 4] = "SelectionBitsEdgeHasMeasurementData", n))(kd || {}), Ra = /* @__PURE__ */ ((n) => (n[n.Outside = 0] = "Outside", n[n.PartiallyInside = 1] = "PartiallyInside", n[n.FullyInside = 2] = "FullyInside", n))(Ra || {}), Md = /* @__PURE__ */ ((n) => (n[n.Unsent = 0] = "Unsent", n[n.Opened = 1] = "Opened", n[n.HeadersRecieved = 2] = "HeadersRecieved", n[n.Loading = 3] = "Loading", n[n.Done = 4] = "Done", n))(Md || {}), Wd = /* @__PURE__ */ ((n) => (n[n.Ok = 200] = "Ok", n))(Wd || {});
class ci {
  constructor() {
    this._position = new d(0, 0, 1), this._target = d.zero(), this._up = new d(0, 1, 0), this._width = 0, this._height = 0, this._projection = te.Orthographic, this._nearLimit = 0.01, this._cameraFlags = ki.None;
  }
  /** @hidden */
  _clearFlags() {
    this._cameraFlags = ki.None;
  }
  /** @hidden */
  _getFlags() {
    return this._cameraFlags;
  }
  /**
   * Creates a copy of the camera.
   * @returns new object initialized with the current values of this camera
   */
  copy() {
    return ci.create(
      this._position,
      this._target,
      this._up,
      this._projection,
      this._width,
      this._height,
      this._nearLimit
    );
  }
  /**
   * Sets the camera position
   * @param position the new camera position
   */
  setPosition(t) {
    this._position.assign(t), this._cameraFlags |= ki.Position;
  }
  /**
   * gets the camera position
   * @returns the camera position
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Sets the camera target
   * @param target the new camera target
   */
  setTarget(t) {
    this._target.assign(t), this._cameraFlags |= ki.Target;
  }
  /**
   * gets the camera target
   * @returns the camera target
   */
  getTarget() {
    return this._target.copy();
  }
  /**
   * Sets the camera up vector
   * @param up the new camera up vector
   */
  setUp(t) {
    this._up.assign(t), this._cameraFlags |= ki.Up;
  }
  /**
   * gets the camera up vector
   * @returns the camera up vector
   */
  getUp() {
    return this._up.copy();
  }
  /**
   * Sets the camera width
   * @param width the new camera width
   */
  setWidth(t) {
    this._width = t, this._cameraFlags |= ki.Width;
  }
  /**
   * gets the camera width
   * @returns the camera width
   */
  getWidth() {
    return this._width;
  }
  /**
   * Sets the camera height
   * @param height the new camera height
   */
  setHeight(t) {
    this._height = t, this._cameraFlags |= ki.Height;
  }
  /**
   * gets the camera height
   * @returns the camera width
   */
  getHeight() {
    return this._height;
  }
  /**
   * Sets the camera projection
   * @param projection the new camera Projection
   */
  setProjection(t) {
    this._projection = t, this._cameraFlags |= ki.Projection;
  }
  /**
   * gets the camera projection
   * @returns the camera projection
   */
  getProjection() {
    return this._projection;
  }
  /**
   * Sets the camera near clipping limit
   * @param nearLimit the new camera near clipping limit
   */
  setNearLimit(t) {
    this._nearLimit = t, this._cameraFlags |= ki.NearLimit;
  }
  /**
   * gets the camera near clipping limit
   * @returns the camera near clipping limit
   */
  getNearLimit() {
    return this._nearLimit;
  }
  /**
   * Returns checks for equality with another camera
   * @param cam the camera to compare against
   */
  equals(t) {
    return this._position.equals(t._position) && this._target.equals(t._target) && this._up.equals(t._up) && this._width === t._width && this._height === t._height && this._projection === t._projection && this._nearLimit === t._nearLimit;
  }
  /**
   * Returns checks for equality with another camera with tolerance
   * @param cam the camera to compare against
   * @param tolerance floating point tolerance
   */
  equalsWithTolerance(t, e) {
    const i = (s, r) => Math.abs(s - r) < e;
    return this._position.equalsWithTolerance(t._position, e) && this._target.equalsWithTolerance(t._target, e) && this._up.equalsWithTolerance(t._up, e) && i(this._width, t._width) && i(this._height, t._height) && i(this._projection, t._projection) && i(this._nearLimit, t._nearLimit);
  }
  /**
   * Move the camera along a delta
   * @param delta
   */
  dolly(t) {
    this._position.subtract(t), this._target.subtract(t);
  }
  /**
   * Finds the intersection point with the camera plane
   * @param point
   * @param view
   */
  getCameraPlaneIntersectionPoint(t, e) {
    const i = d.subtract(this._position, this._target).normalize(), s = je.createFromPointAndNormal(this._target, i), r = e.raycastFromPoint(t);
    if (r === null)
      return null;
    const o = d.zero();
    return s.intersectsRay(r, o) ? o : null;
  }
  /**
   * Returns the camera's view matrix. This matrix places the camera at
   * `<0,0,0>`, with the negative z-axis pointing toward the camera's
   * target and the y-axis in the direction of the camera's up-vector.
   * @param viewer The [[WebViewer]] for which the matrix should be valid.
   */
  getViewMatrix(t) {
    return t._getScEngine().getViewMatrix(this);
  }
  /**
   * Returns the camera's projection matrix.
   * @param viewer The [[WebViewer]] for which the matrix should be valid.
   */
  getProjectionMatrix(t) {
    return t._getScEngine().getProjectionMatrix(this);
  }
  /**
   * Returns the camera's projection matrix multiplied by its view matrix.
   * @param viewer The [[WebViewer]] for which the matrix should be valid.
   */
  getFullMatrix(t) {
    return t._getScEngine().getFullCameraMatrix(this);
  }
  /**
   * Creates a new camera object with the given parameters.
   * @param pos the camera position.
   * @param tar the camera target.
   * @param up the camera up vector.
   * @param projection the camera projection mode.
   * @param width camea view width.
   * @param height camera view height.
   * @param nearLimit the camera near limit.
   * @returns a new camera object.
   */
  static create(t, e, i, s, r, o, a) {
    const l = new ci();
    return l._position.assign(t), l._target.assign(e), l._up.assign(i), l._projection = s, l._width = r, l._height = o, a !== void 0 && (l._nearLimit = a), l;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      position: this._position.toJson(),
      target: this._target.toJson(),
      up: this._up.toJson(),
      width: this._width,
      height: this._height,
      projection: this._projection,
      nearLimit: this._nearLimit,
      className: "Communicator.Camera"
    };
  }
  /**
   * Creates a new [[Camera]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = d.fromJson(e.position), s = d.fromJson(e.target), r = d.fromJson(e.up);
    return ci.create(
      i,
      s,
      r,
      e.projection,
      e.width,
      e.height,
      e.nearLimit
    );
  }
  transform(t) {
    if (t.isIdentity())
      return this.copy();
    const e = Math.abs(this._width), i = Math.abs(this._height), s = this.getUp().normalize().scale(i), r = d.subtract(this._position, this._target), o = d.cross(s, r).normalize().scale(e), a = this.getTarget(), l = d.add(a, o), c = d.add(a, s), h = d.add(a, r);
    t.transform(a, a), t.transform(l, l), t.transform(c, c), t.transform(h, h);
    const u = d.subtract(l, a), p = d.subtract(c, a), m = d.subtract(h, a), g = d.add(a, m), _ = a, y = p.copy().normalize();
    let b = u.length(), w = p.length();
    return this._width < 0 && (b = -b), this._height < 0 && (w = -w), ci.create(
      g,
      _,
      y,
      this._projection,
      b,
      w,
      this._nearLimit
    );
  }
}
function Rg(n) {
  if (typeof window < "u" && n.length < 8192 && "escape" in window) {
    let a;
    try {
      const l = new TextDecoder().decode(n), c = window.escape(l);
      a = decodeURIComponent(c);
    } catch {
      a = "";
    }
    return a;
  }
  let t, e, i, s, r;
  t = "";
  const o = n.length;
  for (e = 0; e < o; )
    switch (i = n[e++], i >> 4) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        t += String.fromCharCode(i);
        break;
      case 12:
      case 13:
        s = n[e++], t += String.fromCharCode((i & 31) << 6 | s & 63);
        break;
      case 14:
        s = n[e++], r = n[e++], t += String.fromCharCode(
          (i & 15) << 12 | (s & 63) << 6 | (r & 63) << 0
        );
        break;
    }
  return t;
}
const Lg = /^\d+$/;
function Pd(n) {
  return Lg.test(n);
}
const xa = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`~!@#$%^&*()_+-=[]{};:'\",.<>\\|/?".split(
  ""
);
function ic(n) {
  if (console.assert(n >= 0), n === 0)
    return xa[0];
  const t = [];
  for (; n !== 0; ) {
    const e = Math.floor(n / xa.length), i = n % xa.length, s = xa[i];
    t.push(s), n = e;
  }
  return t.join("");
}
const Xg = ["0000000", "000000", "00000", "0000", "000", "00", "0", ""];
function Fg(n) {
  const t = n.toString(16);
  return Xg[t.length - 1] + t;
}
class we {
  static _parseUint_32(t) {
    if (!Pd(t))
      return null;
    const e = parseInt(t, 10);
    return e <= 4294967295 ? e : null;
  }
  static _parseFloat(t) {
    const e = parseFloat(t);
    return isNaN(e) ? null : e;
  }
  static parseFloat(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseFloat(i);
  }
  static _parseScKey(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseUint_32(i);
  }
  static parseDataKey(t, e) {
    return this._parseScKey(t, e);
  }
  static parseMeshKey(t, e) {
    return this._parseScKey(t, e);
  }
  static parseInstanceKeyFromInc(t, e) {
    const i = t.getAttribute(e);
    if (i === null)
      return null;
    const s = i.split(" ");
    return s.length !== 2 || this._parseUint_32(s[0]) === null ? null : this._parseUint_32(s[1]);
  }
  static parseNodeId(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseUint_32(i);
  }
  static parseLayerId(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseUint_32(i);
  }
  static parseUint(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseUint_32(i);
  }
  static parseUints(t, e) {
    const i = t.getAttribute(e);
    if (i === null)
      return null;
    const s = [], r = i.match(/[0-9]+/g) || [];
    for (const o of r) {
      const a = this._parseUint_32(o);
      if (a === null)
        return null;
      s.push(a);
    }
    return s;
  }
  static parseFloats(t, e) {
    const i = t.getAttribute(e);
    if (i === null)
      return null;
    const s = [], r = i.match(/\S+/g) || [];
    for (const o of r) {
      const a = this._parseFloat(o);
      if (a === null)
        return null;
      s.push(a);
    }
    return s;
  }
  static parseNodeIds(t, e) {
    return this.parseUints(t, e);
  }
  static _parsePoint3(t, e) {
    const i = t.getAttribute(e);
    if (i === null)
      return null;
    const s = i.split(" ");
    if (s.length !== 3)
      return null;
    const r = [];
    for (const o of s) {
      const a = Number(o);
      if (isNaN(a))
        return null;
      r.push(a);
    }
    return new d(r[0], r[1], r[2]);
  }
  static parseBounding(t, e) {
    const i = t.getElementsByTagName(e);
    if (i.length !== 1)
      return null;
    const s = i[0], r = this._parsePoint3(s, "Min");
    if (r === null)
      return null;
    const o = this._parsePoint3(s, "Max");
    return o === null ? null : new ni(r, o);
  }
  static parseCamera(t) {
    const e = we.parseUint(t, "Projection");
    if (e === null)
      return null;
    const i = t.getAttribute("field");
    if (i === null)
      return null;
    const s = i.split(" ");
    if (s.length !== 2)
      return null;
    const r = parseFloat(s[0]), o = parseFloat(s[1]), a = t.getAttribute("definition");
    if (a === null)
      return null;
    const l = a.split(" ");
    if (l.length !== 9)
      return null;
    const c = (m, g) => new d(
      parseFloat(m[g]),
      parseFloat(m[g + 1]),
      parseFloat(m[g + 2])
    ), h = c(l, 0), u = c(l, 3), p = c(l, 6);
    return ci.create(h, u, p, e, r, o);
  }
}
class Xo {
  constructor() {
    this.isInclusive = !1, this.ids = [];
  }
  static parseBinary(t) {
    const e = new Xo();
    e.isInclusive = t.parseBoolean();
    const i = t.parseCount_32();
    for (let s = 0; s < i; s++)
      e.ids.push(t.parseNodeId());
    return e;
  }
  static parseXml(t) {
    const e = new Xo();
    e.isInclusive = t.getAttribute("Inclusive") === "1";
    const i = we.parseNodeIds(t, "Ids");
    if (i !== null) {
      e.ids = i;
      const s = t.getAttribute("Count");
      if (s !== null) {
        const r = parseInt(s, 10);
        console.assert(r === e.ids.length);
      }
    } else
      console.error("'Entities' tag has missing or malformed 'Ids' attribute");
    return e;
  }
}
class Fo {
  constructor() {
    this.isInclusive = !1, this.authoredIds = [];
  }
  static parseBinary(t) {
    const e = new Fo();
    e.isInclusive = t.parseBoolean();
    const i = t.parseCount_32();
    for (let s = 0; s < i; s++)
      e.authoredIds.push(t.parseLayerId());
    return e;
  }
  static parseXml(t) {
    const e = new Fo();
    e.isInclusive = t.getAttribute("Inclusive") === "1";
    const i = we.parseUints(t, "Ids");
    if (i !== null) {
      e.authoredIds = i;
      const s = t.getAttribute("Count");
      if (s !== null) {
        const r = parseInt(s, 10);
        console.assert(r === e.authoredIds.length);
      }
    } else
      console.error("'Layers' tag has missing or malformed 'Ids' attribute");
    return e;
  }
}
class Ko {
  constructor() {
    this.isDisplayfilter = !1, this.name = null, this.isActive = !1, this.layers = null, this.entities = null;
  }
  static parseBinary(t) {
    const e = new Ko();
    let i = null, s = null;
    const r = t.parseLayerParseBits();
    return e.isDisplayfilter = t.parseBoolean(), Ct(r, Ya.Name) && (e.name = t.parseCString()), e.isActive = t.parseBoolean(), Ct(r, Ya.LayerItem) && (i = Fo.parseBinary(t)), Ct(r, Ya.EntityItem) && (s = Xo.parseBinary(t)), e.layers = i, e.entities = s, e;
  }
  static parseXml(t) {
    const e = new Ko(), i = t.getAttribute("Name");
    i !== null && (e.name = i), e.isDisplayfilter = t.getAttribute("Display") === "1", e.isActive = t.getAttribute("Active") === "1";
    for (let s = t.firstElementChild; s !== null; s = s.nextElementSibling)
      s.localName === "Layers" ? (console.assert(e.layers === null), e.layers = Fo.parseXml(s)) : s.localName === "Entities" ? (console.assert(e.entities === null), e.entities = Xo.parseXml(s)) : console.error(`Unknown tag: ${t.localName}`);
    return e;
  }
}
var Vs = /* @__PURE__ */ ((n) => (n[n.Undefined = 0] = "Undefined", n[n.Unconnected = 1] = "Unconnected", n[n.Connected = 2] = "Connected", n))(Vs || {});
class yh {
  constructor() {
    this.relationships = [];
  }
  static parseBinary(t, e) {
    const i = new yh(), s = e.parseCount_32();
    for (let r = 0; r < s; r++) {
      let o = Vs.Undefined;
      const a = e.parseCString(), l = e.parseCString();
      e.parseBoolean() ? (o = Vs.Connected, cr.registerBimId(a, t)) : o = Vs.Unconnected, i.relationships.push({
        category: o,
        id: a,
        name: l
      });
    }
    return i;
  }
}
class al {
  constructor() {
    this.relationElt = {
      id: "",
      name: "",
      category: Vs.Undefined
    };
  }
  static parseBinary(t, e) {
    const i = new al();
    return i.relationElt.id = e.parseCString(), i.relationElt.name = e.parseCString(), e.parseBoolean() ? (i.relationElt.category = Vs.Connected, cr.registerBimId(i.relationElt.id, t)) : i.relationElt.category = Vs.Unconnected, i;
  }
  //TODO with the writer
  static parseXml(t) {
    return new al();
  }
}
class cr {
  constructor() {
    this.type = qd.Undefined, this.related = null, this.relating = null;
  }
  static registerBimId(t, e) {
    const i = e.toRuntimeId(parseInt(t, 10));
    i !== null && e.addBimIdToMap(t, i);
  }
  static parseBinary(t, e) {
    const i = new cr(), s = e.parseRelationshipParseBits();
    return Ct(s, Ga.Type) && (i.type = e.parseCount_32()), Ct(s, Ga.Relating) && (i.relating = al.parseBinary(t, e)), Ct(s, Ga.Related) && (i.related = yh.parseBinary(t, e)), i;
  }
  //TODO with the writer
  static parseXml(t) {
    const e = new cr(), i = t.getAttribute("Type");
    return i !== null && (e.type = Number(i)), e;
  }
}
class Wn {
  static parseBinary(t) {
    let e = null;
    const i = t.getHeader();
    let s = 0;
    i !== null && i.supportsAttributeBits() && (s = t.parseAttributeParseBits());
    const r = t.parseCString();
    Ct(s, Ic.ValueName) && (e = t.parseCString());
    const o = t.parseAttributeType(), a = t.parseCString();
    let l = [];
    return Ct(s, Ic.Units) && (l = t.parseUnits()), new Wn(o, r, e, a, l);
  }
  static parseXml(t) {
    console.assert(t.localName === "Attr");
    let e = Bn.Undefined, i = "", s = "";
    const r = [], o = t.getAttribute("ValueName"), a = t.getAttribute("Name");
    if (a !== null && (i = a, i === "__PRC_RESERVED_ATTRIBUTE_A3DF_ProductInformation"))
      return new Wn(e, i, o, s, r);
    const l = t.getAttribute("Type");
    if (l !== null)
      switch (l) {
        case "i":
          e = Bn.Int;
          break;
        case "f":
          e = Bn.Float;
          break;
        case "t":
          e = Bn.Time;
          break;
        case "s":
          e = Bn.String;
          break;
      }
    const c = t.getAttribute("Value");
    return c !== null && (s = c), new Wn(e, i, o, s, r);
  }
  constructor(t, e, i, s, r) {
    this._type = t, this._valueName = i, this._title = e, this._value = s, this._unit = r;
  }
  getType() {
    return this._type;
  }
  getValueName() {
    return this._valueName;
  }
  getTitle() {
    return this._title;
  }
  getValue() {
    return this._value;
  }
  getUnit() {
    return ag(this._unit);
  }
  copy() {
    let t = null;
    return this._valueName !== null && (t = this._valueName.slice()), new Wn(
      this._type,
      this._title.slice(),
      t,
      this._value.slice(),
      this._unit.slice()
    );
  }
}
let Xi = class Vd {
  static parseBinary(t) {
    return t.parseMatrix();
  }
  static parseXml(t) {
    console.assert(t.localName === "Transformation");
    const e = [], i = t.getAttribute("RelativeTransfo");
    if (i !== null) {
      const s = i.split(" ");
      console.assert(s.length === 16);
      for (let r = 0; r < 16; ++r) {
        const o = parseFloat(s[r]);
        console.assert(!isNaN(o)), e.push(o);
      }
    }
    return e;
  }
  static getIdentity() {
    return [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
  }
  static copy(t) {
    return t.slice();
  }
  static isIdentity(t) {
    return t[0] === 1 && t[1] === 0 && t[2] === 0 && t[3] === 0 && t[4] === 0 && t[5] === 1 && t[6] === 0 && t[7] === 0 && t[8] === 0 && t[9] === 0 && t[10] === 1 && t[11] === 0 && t[12] === 0 && t[13] === 0 && t[14] === 0 && t[15] === 1;
  }
  static multiply(t, e) {
    const i = Vd.getIdentity();
    return i[0] = t[0] * e[0] + t[1] * e[4] + t[2] * e[8] + t[3] * e[12], i[1] = t[0] * e[1] + t[1] * e[5] + t[2] * e[9] + t[3] * e[13], i[2] = t[0] * e[2] + t[1] * e[6] + t[2] * e[10] + t[3] * e[14], i[3] = t[0] * e[3] + t[1] * e[7] + t[2] * e[11] + t[3] * e[15], i[4] = t[4] * e[0] + t[5] * e[4] + t[6] * e[8] + t[7] * e[12], i[5] = t[4] * e[1] + t[5] * e[5] + t[6] * e[9] + t[7] * e[13], i[6] = t[4] * e[2] + t[5] * e[6] + t[6] * e[10] + t[7] * e[14], i[7] = t[4] * e[3] + t[5] * e[7] + t[6] * e[11] + t[7] * e[15], i[8] = t[8] * e[0] + t[9] * e[4] + t[10] * e[8] + t[11] * e[12], i[9] = t[8] * e[1] + t[9] * e[5] + t[10] * e[9] + t[11] * e[13], i[10] = t[8] * e[2] + t[9] * e[6] + t[10] * e[10] + t[11] * e[14], i[11] = t[8] * e[3] + t[9] * e[7] + t[10] * e[11] + t[11] * e[15], i[12] = t[12] * e[0] + t[13] * e[4] + t[14] * e[8] + t[15] * e[12], i[13] = t[12] * e[1] + t[13] * e[5] + t[14] * e[9] + t[15] * e[13], i[14] = t[12] * e[2] + t[13] * e[6] + t[14] * e[10] + t[15] * e[14], i[15] = t[12] * e[3] + t[13] * e[7] + t[14] * e[11] + t[15] * e[15], i;
  }
  constructor() {
  }
};
const ru = We.InitiallyShown;
let Es = class {
  /**
   * Parses the `NodeInfo` for a node without inserting it into the tree.
   */
  static parseXml(t, e, i) {
    let s = we.parseNodeId(e, "Id");
    s === null && (console.assert(!1), s = t.generateDynamicNodeId());
    const r = e.getAttribute("Name");
    let o = null;
    const a = [];
    let l = e.firstElementChild;
    for (; l !== null; ) {
      if (l.localName === "Transformation")
        console.assert(o === null), o = Xi.parseXml(l), Xi.isIdentity(o) && (o = null);
      else if (l.localName === "Attributes") {
        let u = l.firstElementChild;
        for (; u !== null; ) {
          console.assert(u.localName === "Attr");
          const p = Wn.parseXml(u);
          a.push(p), u = u.nextElementSibling;
        }
      }
      l = l.nextElementSibling;
    }
    const c = e.getAttribute("ExchangeId"), h = i.ignoreLayers ? null : we.parseLayerId(e, "LayerId");
    return {
      nodeId: s,
      bits: ru,
      name: r,
      localTransform: o,
      attributes: a,
      header: _n.dynamic,
      exchangeId: c,
      layerId: h,
      genericTypeId: null,
      genericId: null,
      userDatas: null
    };
  }
  /**
   * Parses the `NodeInfo` for a node without inserting it into the tree.
   */
  static parseBinary(t, e, i, s) {
    let r;
    i.hasBits1(Qt.Id) ? r = e.parseNodeId() : (console.assert(!1), r = t.generateDynamicNodeId());
    const o = i.hasBits1(Qt.Name) ? e.parseCString() : null;
    let a = ru;
    if (i.hasBits1(Qt.Visiblity)) {
      const _ = e.parseVisibility();
      _.shown || (a &= ~We.InitiallyShown), _.removed && (a |= We.InitiallyRemoved);
    }
    let l = null;
    i.hasBits1(Qt.Transform) && (l = Xi.parseBinary(e), Xi.isIdentity(l) && (l = null));
    let c = null;
    i.hasBits1(Qt.Attributes) && (c = e.parseDataKey());
    const h = i.hasBits1(Qt.ExchangeId) ? e.parseCString() : null;
    let u = null;
    if (i.hasBits1(Qt.LayerId)) {
      const _ = e.parseLayerId();
      s.ignoreLayers || (u = _);
    }
    let p = null;
    if (i.hasBits2(Un.GenericTypeId)) {
      const _ = e.parseGenericTypeId();
      s.ignoreGenericTypes || (p = _);
    }
    let m = null;
    i.hasBits2(Un.GenericId) && (m = e.parseGenericId());
    let g = null;
    if (i.hasBits1(Qt.UserData)) {
      g = /* @__PURE__ */ new Map();
      const _ = e.parseCount_32();
      for (let y = 0; y < _; ++y) {
        const b = e.parseUserDataIndex(), w = e.parseCount_32(), v = e.parseBytes(w);
        g.set(b, v);
      }
    }
    return {
      nodeId: r,
      bits: a,
      name: o,
      localTransform: l,
      attributes: c !== null ? c : [],
      header: e.getHeader(),
      exchangeId: h,
      layerId: u,
      genericTypeId: p,
      genericId: m,
      userDatas: g
    };
  }
  constructor() {
    console.assert(!1);
  }
};
function Kg(n, t) {
  const e = typeof n == "number";
  return e === (typeof t == "number") ? n < t ? -1 : n > t ? 1 : 0 : e ? -1 : 1;
}
class Ws {
  /**
   * Creates a new lazy value, which is the result of the supplied function
   * once the lazy value is forced (or the value itself if a `T` is directly supplied).
   */
  static create(t) {
    return new Ws(t);
  }
  constructor(t) {
    this._value = t;
  }
  /**
   * Forces the lazy value given at construction and returns it.
   */
  get() {
    return typeof this._value == "function" && (this._value = this._value()), this._value;
  }
}
class xi {
  /**
   * Creates a new lazy value, which is the result of the supplied function
   * once the lazy value is forced (or the value itself if a `T` is directly supplied).
   */
  static create(t) {
    return new xi(t);
  }
  constructor(t) {
    typeof t == "function" && (t = Ws.create(t)), t instanceof Promise && (t = this._rectifyResult(t)), this._value = t;
  }
  /**
   * Returns whether or not this has been both forced (lazy).
   * This says nothing about resolution (promise).
   */
  isUnforced() {
    return this._value instanceof Ws;
  }
  /**
   * Returns whether or not this has been both forced (lazy) and resolved (promise).
   */
  isResolved() {
    return !(this._value instanceof Ws) && !(this._value instanceof Promise);
  }
  /**
   * Returns the final promised value synchronously.
   *
   * This is only legal to call if `isResolved()` returns `true`.
   *
   */
  getResolved() {
    return console.assert(this.isResolved()), this._value;
  }
  /**
   * Forces the lazy promise and then delegates to the forced promise's `then()` method.
   *
   * Note: This intentionally returns a normal `Promise`, not a `LazyPromise`.
   */
  then(t, e) {
    return this._value instanceof Ws && (this._value = this._rectifyResult(this._value.get())), this._value instanceof Promise ? this._value.then(t, e) : (this._value, Promise.resolve(this._value).then(t, e));
  }
  _rectifyResult(t) {
    return t instanceof Promise ? t.then((e) => (this._value = e, e)) : t;
  }
}
function Og(n) {
  return n == null;
}
function se(n) {
  return Array.isArray(n) ? n.slice() : n == null ? [] : [n];
}
function zi(n) {
  return n.length === 0 ? null : n.length === 1 ? n[0] : n;
}
function Mi(n, t) {
  return n ? Array.isArray(n) ? (n.push(t), n) : [n, t] : t;
}
class Pi {
  constructor(t, e, i) {
    if (this._bits = 0, this._nodeId = i.nodeId, this._bits = i.bits, i.name !== null && (this._name = i.name), i.localTransform !== null && (this._localTransform = Xi.copy(i.localTransform)), typeof i.attributes == "number") {
      const s = i.attributes;
      this._lazyAttributes = Pi._lazyLoadAttributes(
        t,
        e,
        s,
        i.header
      );
    } else
      i.attributes.length > 0 && (this._lazyAttributes = xi.create(i.attributes));
    i.exchangeId !== null && (this._exchangeId = i.exchangeId), i.layerId !== null && (this._layerId = i.layerId), i.genericTypeId !== null && (this._genericTypeId = i.genericTypeId), i.genericId !== null && (this._genericId = i.genericId), i.userDatas !== null && (this._userDatas = wl(i.userDatas));
  }
  static _lazyLoadAttributes(t, e, i, s) {
    return xi.create(async () => {
      const r = t.getAbstractScEngine(), o = await t.enqueue(() => r.safeGetMetaData(e, i)), a = [];
      if (o !== null) {
        const l = new sr(s, o), c = new zo(l);
        for (; c.hasNext(); ) {
          const h = Wn.parseBinary(c);
          a.push(h);
        }
      }
      return a;
    });
  }
  hasAuthoredId() {
    return Hr(this._nodeId);
  }
  getAuthoredId() {
    return wg(this._nodeId);
  }
  getName() {
    return this._name !== void 0 ? this._name : null;
  }
  getExchangeId() {
    return this._exchangeId ?? null;
  }
  getAuthoredLayerId() {
    return this._layerId !== void 0 ? this._layerId : null;
  }
  getGenericTypeId() {
    return this._genericTypeId !== void 0 ? this._genericTypeId : null;
  }
  getGenericId() {
    return this._genericId !== void 0 ? this._genericId : null;
  }
  _hasBits(t) {
    return Ct(this._bits, t);
  }
  isLoaded() {
    return this._hasBits(We.IsLoaded);
  }
  markLoaded() {
    this._bits |= We.IsLoaded;
  }
  _setVisibility(t) {
    this._bits |= We.IsShownSpecified, t ? this._bits |= We.IsShown : this._bits &= ~We.IsShown;
  }
  isVisible() {
    return this._hasBits(We.IsShownSpecified) ? this._hasBits(We.IsShown) : this.isInitiallyShown();
  }
  isInitiallyShown() {
    return this._hasBits(We.InitiallyRemoved) ? !1 : this._hasBits(We.InitiallyShown);
  }
  _toAffineTransformation(t) {
    const e = t.slice();
    return e[3] = 0, e[7] = 0, e[11] = 0, e[15] = 1, e;
  }
  setLocalTransformAsInitial(t) {
    this._localTransform = this._toAffineTransformation(t);
  }
  overrideLocalTransform(t) {
    this._localTransformOverride = this._toAffineTransformation(t);
  }
  hasLocalTransformOverride() {
    return this._localTransformOverride !== void 0;
  }
  removeLocalTransformOverride() {
    console.assert(this._localTransformOverride !== void 0), delete this._localTransformOverride;
  }
  getLocalTransform() {
    return this._localTransformOverride !== void 0 ? this._localTransformOverride : this._localTransform !== void 0 ? this._localTransform : null;
  }
  async getAttributes() {
    return this._lazyAttributes !== void 0 ? this._lazyAttributes.then((t) => {
      if (this._lazyAttributes !== void 0) {
        for (const e of t)
          this.addAttribute(e);
        delete this._lazyAttributes;
      }
      return this.getAttributes();
    }) : se(this._attributes);
  }
  addAttribute(t) {
    this._attributes = Mi(this._attributes, t);
  }
  getUserDataIndices() {
    const t = [];
    return this._userDatas !== void 0 && this._userDatas.forEach((e, i) => {
      t.push(i);
    }), t.sort(Kg);
  }
  getUserData(t) {
    if (this._userDatas !== void 0) {
      const e = this._userDatas.get(t);
      if (e !== void 0)
        return e;
    }
    throw new Zh(t);
  }
}
class Xr {
  static parseBinary(t) {
    const e = t.parseInstanceKey(), i = t.parsePmiTopoRef(), s = t.parseIndex_32();
    return {
      bodyInstanceKey: e,
      topoItemType: i,
      itemIndex: s
    };
  }
  static reify(t, e) {
    const i = t.getInclusionKey();
    return new Xr(
      i,
      e.bodyInstanceKey,
      e.topoItemType,
      e.itemIndex
    );
  }
  static fromBodyInstance(t, e, i) {
    const s = t.getInstanceInc();
    return new Xr(s[0], s[1], e, i);
  }
  constructor(t, e, i, s) {
    this._inclusionKey = t, this._bodyInstanceKey = e, this._topoItemType = i, this._itemIndex = s;
  }
  getBodyInstanceInc() {
    return [this._inclusionKey, this._bodyInstanceKey];
  }
  getTopoItemType() {
    return this._topoItemType;
  }
  getItemIndex() {
    return this._itemIndex;
  }
}
class Ys {
  static parseBinary(t) {
    const e = t.parseLayerParseBits(), i = t.parseLayerId();
    let s = null;
    return Ct(e, Id.Name) && (s = t.parseCString()), {
      id: i,
      name: s
    };
  }
  static parseXml(t) {
    const e = t.getAttribute("Name"), i = we.parseUint(t, "Id");
    return i === null ? (console.error("'Layer' tag missing 'Id' attribute"), null) : {
      id: i,
      name: e
    };
  }
  constructor(t, e, i, s) {
    this.id = t, this.name = e, this.nodes = i, this.treeNodes = s;
  }
}
Ys.NoLayerId = -1;
class Ur extends Pi {
  constructor(t, e, i, s) {
    super(t, e, s.nodeInfo), this._bits |= s.bits, this._parent = i, this._instanceKey = s.instanceKey;
    const r = this.getAuthoredLayerId();
    r !== null && t.registerNodeInLayer(this, r), r !== null && !this.isOutOfHierarchy() && t.registerTreeNodeInLayer(this, r), r === null && !this.isOutOfHierarchy() && Hr(s.nodeInfo.nodeId) && (t.registerNodeInLayer(this, Ys.NoLayerId), t.registerTreeNodeInLayer(this, Ys.NoLayerId));
  }
  setRequested() {
    this._bits |= zn.Requested;
  }
  isRequested() {
    return this._hasBits(zn.Requested);
  }
  isOutOfHierarchy() {
    return this._hasBits(zn.OutOfHierarchy);
  }
  preventFromResetting() {
    return this._hasBits(zn.PreventFromResetting);
  }
  isImplicitBody() {
    return this._hasBits(zn.ImplicitBody);
  }
  getParent() {
    return this._parent;
  }
  getInstanceKey() {
    return this._instanceKey;
  }
}
class Ve extends Ur {
  constructor(t, e, i, s) {
    super(t, e, i, s), t.registerBodyInstance(this, s.inclusionKey);
  }
  static parseXml(t, e, i, s) {
    const r = Es.parseXml(t, e, s), o = we.parseInstanceKeyFromInc(e, "MeshInstanceKey");
    if (o === null)
      throw new ce('Expected "MeshInstanceKey" attribute.');
    return {
      nodeInfo: r,
      inclusionKey: i,
      instanceKey: o,
      bits: 0
    };
  }
  static parseBinary(t, e, i, s) {
    const r = Ce(e), o = r.getRemapper(), a = r.getMasterModelKey(), l = i.parseNodeParseBits(), c = Es.parseBinary(t, i, l, s);
    let h;
    if (l.hasBits1(Qt.ScInclusionKey) ? h = i.parseInclusionKey(o, a) : h = e.getInclusionKey(), !l.hasBits1(Qt.ScInstanceKey))
      throw new ur('Expected "ScInstanceKey" in binary data.');
    const u = i.parseInstanceKey();
    return {
      nodeInfo: c,
      inclusionKey: h,
      instanceKey: u,
      bits: 0
    };
  }
  static reify(t, e, i, s) {
    const r = Ce(i), o = new Ve(t, e, i, s);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  static createDynamic(t, e, i, s, r, o, a, l) {
    const c = Ne(o), u = Ce(c).getMasterModelKey(), g = {
      nodeInfo: {
        nodeId: t.massageAuthoredUserId(c, s),
        bits: a,
        name: r,
        localTransform: null,
        attributes: [],
        header: _n.dynamic,
        exchangeId: null,
        layerId: null,
        genericTypeId: null,
        genericId: null,
        userDatas: null
      },
      inclusionKey: e,
      instanceKey: i,
      bits: l
    };
    return new Ve(t, u, o, g);
  }
  getName() {
    const t = super.getName();
    if (t !== null)
      return t;
    const i = this.getParent().getBodyInstances();
    if (i.length > 1) {
      for (let s = 0; s < i.length; ++s) {
        const r = i[s];
        if (this === r)
          return `body ${s + 1}`;
      }
      console.assert(!1);
    }
    return "body";
  }
  getInstanceInc() {
    const t = this._instanceKey;
    let e = ve.Local;
    return (this.hasAuthoredId() || this.isImplicitBody()) && (e = Ne(this).getInclusionKey()), [e, t];
  }
  setVisibility(t) {
    t !== this.isVisible() && this.getParent().markBranchVisibilityDirty(), this._setVisibility(t);
  }
  getRuntimeId() {
    return Ks(this._nodeId, this);
  }
}
class In extends Ur {
  constructor(t, e, i, s) {
    super(t, e, i, s), t.registerPmiBody(this, s.inclusionKey);
  }
  static parseBinary(t, e, i, s, r) {
    let o = Ve.parseBinary(t, e, i, r);
    if (s) {
      let a = o.nodeInfo, l = a.bits;
      l &= ~We.InitiallyShown, a = { ...a, bits: l }, o = { ...o, nodeInfo: a };
    }
    return o;
  }
  static reify(t, e, i, s) {
    const r = Ce(i), o = new In(t, e, i, s);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  getName() {
    const t = super.getName();
    return t !== null ? t : "PMI body";
  }
  getInstanceInc() {
    const t = this._instanceKey;
    let e = ve.Local;
    return (this.hasAuthoredId() || this.isImplicitBody()) && (e = Ne(this).getInclusionKey()), [e, t];
  }
  setVisibility(t) {
    t !== this.isVisible() && this.getParent().getParent().markBranchVisibilityDirty(), this._setVisibility(t);
  }
  getRuntimeId() {
    return Ks(this._nodeId, this);
  }
}
class Ag {
  constructor(t) {
    this.faceIds = [], this.edgeIds = [], this.body = t;
  }
}
class gi extends Pi {
  constructor(t, e, i, s) {
    const o = Ce(e).getMasterModelKey();
    let a = 0;
    i.initiallyShown && (a |= We.InitiallyShown);
    const l = {
      nodeId: i.nodeId,
      bits: a,
      name: i.name,
      localTransform: null,
      attributes: i.attributesDataKey ? i.attributesDataKey : [],
      header: _n.dynamic,
      exchangeId: null,
      layerId: null,
      genericTypeId: null,
      genericId: null,
      userDatas: null
    };
    super(t, o, l), this._bits |= zn.PreventFromResetting, this._parent = s, this._packed = gi._pack(i.pmiType, i.pmiSubType);
    for (const c of i.pmiBodyInfos) {
      const h = this._loadPmiBody(t, o, c);
      this._pmiBodies = Mi(this._pmiBodies, h), h.markLoaded();
    }
    if (i.topoRefInfos.length > 0 && (this._topoRefs = gi._loadTopoRefs(e, i.topoRefInfos)), i.topoRefs.length > 0)
      if (this._topoRefs === void 0)
        this._topoRefs = i.topoRefs.slice();
      else
        for (const c of i.topoRefs)
          this._topoRefs.push(c);
    t.registerPmi(this);
  }
  static parseBinary(t, e, i, s) {
    const r = i.parsePmiParseBits(), o = i.parseNodeId();
    let a = null;
    Ct(r, Hs.Name) && (a = i.parseCString());
    let l = null;
    Ct(r, Hs.ExchangeId) && (l = i.parseCString());
    let c = null;
    Ct(r, Hs.Attributes) && (c = i.parseDataKey());
    let h = 1;
    Ct(r, Hs.HasMultipleBodies) && (h = i.parseCount_32());
    const u = [], p = Ct(r, Hs.InitiallyHidden);
    for (let b = 0; b < h; ++b) {
      const w = In.parseBinary(
        t,
        e,
        i,
        p,
        s
      );
      u.push(w);
    }
    const m = u.length > 0 ? Ct(u[0].nodeInfo.bits, We.InitiallyShown) : !1, g = i.parsePmiType(), _ = i.parsePmiSubType(), y = [];
    if (Ct(r, Hs.TopoRef)) {
      const b = i.parseCount_32();
      for (let w = 0; w < b; ++w) {
        const v = Xr.parseBinary(i);
        y.push(v);
      }
    }
    return {
      nodeId: o,
      name: a,
      attributesDataKey: c,
      pmiBodyInfos: u,
      initiallyShown: m,
      pmiType: g,
      pmiSubType: _,
      topoRefInfos: y,
      topoRefs: [],
      exchangeId: l
    };
  }
  static reify(t, e, i, s) {
    const r = Ce(e), o = new gi(t, e, i, s);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  static createDynamic(t, e, i, s, r, o, a, l) {
    const h = {
      nodeId: t.generateDynamicNodeId(),
      name: s,
      attributesDataKey: null,
      pmiBodyInfos: a,
      initiallyShown: !0,
      pmiType: r,
      pmiSubType: o,
      topoRefInfos: [],
      topoRefs: l,
      exchangeId: null
    };
    return new gi(t, e, h, i);
  }
  static _loadTopoRefs(t, e) {
    const i = [];
    for (const s of e) {
      const r = Xr.reify(t, s);
      i.push(r);
    }
    return i;
  }
  _loadPmiBody(t, e, i) {
    return In.reify(t, e, this, i);
  }
  getPmiBodies() {
    return se(this._pmiBodies);
  }
  static _pack(t, e) {
    return t + 100 * e;
  }
  getPmiType() {
    return this._packed % 100;
  }
  getPmiSubType() {
    return Math.floor(this._packed / 100) % 100;
  }
  getParent() {
    return this._parent;
  }
  getRuntimeId() {
    return Ks(this._nodeId, this);
  }
  getBranchVisibility() {
    let t = this.isVisible() ? Pt.Shown : Pt.Hidden;
    for (const e of se(this._pmiBodies))
      e.isOutOfHierarchy() || (t |= e.isVisible() ? Pt.Shown : Pt.Hidden);
    return t;
  }
  setVisibility(t) {
    this._setVisibility(t);
  }
  getPmiTopologyReferences(t) {
    if (this._topoRefs === void 0)
      return [];
    const e = /* @__PURE__ */ new Map();
    for (const s of this._topoRefs) {
      const r = s.getBodyInstanceInc(), o = t.lookupAnyBodyByInstanceInc(r[0], r[1]);
      if (o === null)
        continue;
      let a = e.get(o);
      switch (a === void 0 && (a = new Ag(o), e.set(o, a)), s.getTopoItemType()) {
        case Uo.Face:
          a.faceIds.push(s.getItemIndex());
          break;
        case Uo.Edge:
          a.edgeIds.push(s.getItemIndex());
          break;
      }
    }
    const i = [];
    return e.forEach((s) => {
      i.push(s);
    }), i;
  }
}
class nr {
  static parseBinary(t) {
    const e = t.parseFloat_64(), i = t.parseFloat_64(), s = t.parsePoint3_64();
    return new nr(e, i, s);
  }
  constructor(t, e, i) {
    this.surfaceArea = t, this.volume = e, this.centerOfGravity = i;
  }
}
function Dg(n) {
  const t = xd;
  switch (n.parseFaceType()) {
    case t.Cylinder:
      return zg.parseBinary(n);
    case t.Plane:
      return Jg.parseBinary(n);
    case t.Cone:
      return Bg.parseBinary(n);
    case t.Other:
      return Ug.parseBinary(n);
    case t.Sphere:
      return jg.parseBinary(n);
    case t.Torus:
      return Hg.parseBinary(n);
    case t.Blend01:
      return Qg.parseBinary(n);
    case t.Blend02:
      return qg.parseBinary(n);
    case t.Blend03:
      return $g.parseBinary(n);
    case t.Nurbs:
      return tf.parseBinary(n);
    case t.Cylindrical:
      return ef.parseBinary(n);
    case t.Offset:
      return nf.parseBinary(n);
    case t.Pipe:
      return sf.parseBinary(n);
    case t.Ruled:
      return rf.parseBinary(n);
    case t.Revolution:
      return of.parseBinary(n);
    case t.Extrusion:
      return af.parseBinary(n);
    case t.FromCurves:
      return lf.parseBinary(n);
    case t.Transform:
      return cf.parseBinary(n);
    default:
      throw new ur("Unexpected measurement face type.");
  }
}
class zg {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parsePoint3_32(), s = t.parsePoint3_32();
    return new Me(e, i, s);
  }
}
class Jg {
  static parseBinary(t) {
    const e = t.parsePoint3_32(), i = t.parsePoint3_32();
    return new Be(e, i);
  }
}
class Bg {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parsePoint3_32(), s = t.parsePoint3_32(), r = t.parseFloat_32();
    return new Nr(e, i, s, r);
  }
}
class jg {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parsePoint3_32(), s = t.parsePoint3_32();
    return new Rr(e, i, s);
  }
}
class Hg {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parseFloat_32(), s = t.parsePoint3_32(), r = t.parsePoint3_32();
    return new Lr(e, i, s, r);
  }
}
let Ug = class {
  static parseBinary(t) {
    return new xl();
  }
};
class Qg {
  static parseBinary(t) {
    return new Sl();
  }
}
class qg {
  static parseBinary(t) {
    return new Zl();
  }
}
class $g {
  static parseBinary(t) {
    return new Cl();
  }
}
class tf {
  static parseBinary(t) {
    return new kl();
  }
}
class ef {
  static parseBinary(t) {
    return new Ml();
  }
}
let nf = class {
  static parseBinary(t) {
    return new Wl();
  }
};
class sf {
  static parseBinary(t) {
    return new Pl();
  }
}
class rf {
  static parseBinary(t) {
    return new Vl();
  }
}
class of {
  static parseBinary(t) {
    return new Yl();
  }
}
class af {
  static parseBinary(t) {
    return new Gl();
  }
}
class lf {
  static parseBinary(t) {
    return new Tl();
  }
}
let cf = class {
  static parseBinary(t) {
    return new El();
  }
};
function hf(n) {
  const t = vd;
  switch (n.parseEdgeType()) {
    case t.Line:
      return uf.parseBinary(n);
    case t.Circle:
      return df.parseBinary(n);
    case t.Other:
      return mf.parseBinary(n);
    default:
      throw new ur("Unexpected measurement edge type.");
  }
}
let uf = class {
  static parseBinary(t) {
    const e = t.parseFloat_32();
    return new vl(e);
  }
}, df = class {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parsePoint3_32(), s = t.parsePoint3_32();
    return new ha(e, i, s);
  }
};
class mf {
  static parseBinary(t) {
    const e = t.parseFloat_32();
    return new lr(e);
  }
}
class Wo {
  constructor(t) {
    this.attributes = t;
  }
  copy() {
    return new Wo(this.attributes.map((t) => t.copy()));
  }
}
function to(n, t) {
  return n !== void 0 && t < n.length ? n[t] : null;
}
function ou(n, t, e) {
  return n === void 0 && (n = []), n.length = Math.max(n.length, t + 1), n[t] = e, n;
}
var xr = /* @__PURE__ */ ((n) => (n[n.Unknown = 0] = "Unknown", n[n.BRep = 1] = "BRep", n[n.Tessellation = 2] = "Tessellation", n[n.Wireframe = 3] = "Wireframe", n[n.PointCloud = 4] = "PointCloud", n))(xr || {});
class Fe extends Pi {
  constructor(t, e, i, s) {
    if (super(t, e, i.nodeInfo), this._parent = s, this._bodyType = i.bodyType, i.faceMeasurementProps.length > 0 && (this._faceMeasurementProps = i.faceMeasurementProps.slice()), i.edgeMeasurementProps.length > 0 && (this._edgeMeasurementProps = i.edgeMeasurementProps.slice()), i.physicalProps !== null && (this._physicalProps = i.physicalProps), i.faceAttributes.length > 0) {
      this._faceAttributes = [];
      for (const r of i.faceAttributes)
        this._faceAttributes.push(r === null ? null : r.copy());
    }
    if (i.edgeAttributes.length > 0) {
      this._edgeAttributes = [];
      for (const r of i.edgeAttributes)
        this._edgeAttributes.push(r === null ? null : r.copy());
    }
    if (i.pointAttributes.length > 0) {
      this._pointAttributes = [];
      for (const r of i.pointAttributes)
        this._pointAttributes.push(r === null ? null : r.copy());
    }
    t.registerRepresentationItem(this);
  }
  static parseXml(t, e, i) {
    const s = Es.parseXml(t, e, i), r = we.parseMeshKey(e, "TCKey_Mesh");
    return {
      nodeInfo: s,
      meshKey: r,
      bodyType: 0,
      faceMeasurementProps: [],
      edgeMeasurementProps: [],
      physicalProps: null,
      faceAttributes: [],
      edgeAttributes: [],
      pointAttributes: []
    };
  }
  static parseBinary(t, e, i) {
    const s = e.parseNodeParseBits(), r = Es.parseBinary(t, e, s, i), o = e.parseBodyType();
    let a = null;
    s.hasBits1(Qt.MeshKey) && (a = e.parseMeshKey());
    const l = [];
    if (s.hasBits1(Qt.FaceMeasurement)) {
      const g = e.parseCount_32();
      for (let _ = 0; _ < g; ++_) {
        const y = Dg(e);
        l.push(y);
      }
    }
    const c = [];
    if (s.hasBits1(Qt.EdgeMeasurement)) {
      const g = e.parseCount_32();
      for (let _ = 0; _ < g; ++_) {
        const y = hf(e);
        c.push(y);
      }
    }
    let h = null;
    s.hasBits1(Qt.PhysicalProperties) && (h = nr.parseBinary(e));
    const u = [];
    if (s.hasBits2(Un.FaceAttributes)) {
      const g = e.parseCount_32();
      for (let _ = 0; _ < g; _++) {
        const y = [], b = e.parseCount_32();
        for (let w = 0; w < b; w++) {
          const v = Wn.parseBinary(e);
          v.getType() !== Bn.Ignored && y.push(v);
        }
        u.push(y.length > 0 ? new Wo(y) : null);
      }
    }
    const p = [];
    if (s.hasBits2(Un.EdgeAttributes)) {
      const g = e.parseCount_32();
      for (let _ = 0; _ < g; _++) {
        const y = [], b = e.parseCount_32();
        for (let w = 0; w < b; w++) {
          const v = Wn.parseBinary(e);
          v.getType() !== Bn.Ignored && y.push(v);
        }
        p.push(y.length > 0 ? new Wo(y) : null);
      }
    }
    const m = [];
    if (s.hasBits2(Un.PointAttributes)) {
      const g = e.parseCount_32();
      for (let _ = 0; _ < g; _++) {
        const y = [], b = e.parseCount_32();
        for (let w = 0; w < b; w++) {
          const v = Wn.parseBinary(e);
          v.getType() !== Bn.Ignored && y.push(v);
        }
        m.push(y.length > 0 ? new Wo(y) : null);
      }
    }
    return {
      nodeInfo: r,
      meshKey: a,
      bodyType: o,
      faceMeasurementProps: l,
      edgeMeasurementProps: c,
      physicalProps: h,
      faceAttributes: u,
      edgeAttributes: p,
      pointAttributes: m
    };
  }
  static reify(t, e, i, s) {
    return new Fe(t, e, i, s);
  }
  static createDynamic(t, e, i, s, r) {
    const o = r.getInclusionContextForNodeId(), c = {
      nodeInfo: {
        nodeId: t.massageAuthoredUserId(o, e),
        bits: We.InitiallyShown,
        name: i,
        localTransform: null,
        attributes: [],
        header: _n.dynamic,
        exchangeId: null,
        layerId: null,
        genericTypeId: null,
        genericId: null,
        userDatas: null
      },
      meshKey: null,
      bodyType: 0,
      faceMeasurementProps: [],
      edgeMeasurementProps: [],
      physicalProps: null,
      faceAttributes: [],
      edgeAttributes: [],
      pointAttributes: []
    };
    return new Fe(t, s, c, r);
  }
  setPhysicalProperties(t) {
    this._physicalProps = t;
  }
  getPhysicalProperties() {
    return this._physicalProps !== void 0 ? this._physicalProps : null;
  }
  getParent() {
    return this._parent;
  }
  getFaceCount() {
    return this._faceMeasurementProps !== void 0 ? this._faceMeasurementProps.length : 0;
  }
  getEdgeCount() {
    return this._edgeMeasurementProps !== void 0 ? this._edgeMeasurementProps.length : 0;
  }
  getFaceAttributes(t) {
    return to(this._faceAttributes, t);
  }
  getEdgeAttributes(t) {
    return to(this._edgeAttributes, t);
  }
  getPointAttributes(t) {
    return to(this._pointAttributes, t);
  }
  getFaceMeasurementProperty(t) {
    return to(this._faceMeasurementProps, t);
  }
  getEdgeMeasurementProperty(t) {
    return to(this._edgeMeasurementProps, t);
  }
  setFaceMeasurementProperty(t, e) {
    this._faceMeasurementProps = ou(this._faceMeasurementProps, t, e.copy());
  }
  setEdgeMeasurementProperty(t, e) {
    this._edgeMeasurementProps = ou(this._edgeMeasurementProps, t, e.copy());
  }
  getBodyType() {
    return this._bodyType;
  }
  getRuntimeId() {
    return Ks(this._nodeId, this._parent.getInclusionContextForNodeId());
  }
}
class Ei extends Pi {
  constructor(t, e, i, s) {
    const r = i;
    if (super(t, r, s.nodeInfo), this._inclusionContextForNodeId = e, this._modelKey = i, s.repItemInfos.length > 0) {
      const o = this._loadRepresentationItems(
        t,
        r,
        s.repItemInfos
      );
      this._repItems = zi(o);
    }
    t.registerPartDefinition(this);
  }
  static parseXml(t, e, i) {
    let s = Es.parseXml(t, e, i);
    if (s.name === null) {
      const a = e.getAttribute("FilePath");
      a !== null && (s = { ...s, name: a });
    }
    const r = [];
    let o = e.firstElementChild;
    for (; o !== null; ) {
      if (o.localName === "Body") {
        const a = Fe.parseXml(t, o, i);
        r.push(a);
      }
      o = o.nextElementSibling;
    }
    return {
      nodeInfo: s,
      repItemInfos: r
    };
  }
  static parseBinary(t, e, i) {
    const s = e.parseNodeParseBits(), r = Es.parseBinary(t, e, s, i), o = [];
    if (s.hasBits1(Qt.Bodies)) {
      const a = e.parseCount_32();
      for (let l = 0; l < a; ++l) {
        const c = Fe.parseBinary(t, e, i);
        o.push(c);
      }
    }
    return {
      nodeInfo: r,
      repItemInfos: o
    };
  }
  static reify(t, e, i, s) {
    return new Ei(t, e, i, s);
  }
  static createDynamic(t, e, i) {
    const s = t.getRootNode(), r = Ne(s), l = {
      nodeInfo: {
        nodeId: t.massageAuthoredUserId(r, e),
        bits: We.InitiallyShown,
        name: i,
        localTransform: null,
        attributes: [],
        header: _n.dynamic,
        exchangeId: null,
        layerId: null,
        genericTypeId: null,
        genericId: null,
        userDatas: null
      },
      repItemInfos: []
    };
    return new Ei(t, r, Bi.Local, l);
  }
  static createMissing(t) {
    const e = this.createDynamic(t, null, null);
    return e._bits |= yc.IsMissing, e;
  }
  isMissing() {
    return this._hasBits(yc.IsMissing);
  }
  _loadRepresentationItems(t, e, i) {
    const s = [];
    for (const r of i) {
      const o = Fe.reify(t, e, r, this);
      this._addRepresentationItem(o), s.push(o);
    }
    return s;
  }
  getRuntimeId() {
    return Ks(this._nodeId, this._inclusionContextForNodeId);
  }
  getInclusionContextForNodeId() {
    return this._inclusionContextForNodeId;
  }
  addReferrer(t) {
    const e = gn(t), i = gn(this._inclusionContextForNodeId);
    console.assert(e === i), this._referrers = Mi(this._referrers, t);
  }
  createRepItem(t, e) {
    const i = this._modelKey, s = Fe.createDynamic(
      t,
      e,
      null,
      i,
      this
    );
    return this._addRepresentationItem(s), s;
  }
  _addRepresentationItem(t) {
    this._repItems = Mi(this._repItems, t);
  }
  getRepresentationItems() {
    return se(this._repItems);
  }
  getReferrers() {
    return se(this._referrers);
  }
  removeAllReferrers() {
    const t = this.getReferrers();
    for (const e of t) {
      const i = e.removePartDefinition();
      console.assert(this === i);
    }
    delete this._referrers;
  }
  getModelKey() {
    return this._modelKey;
  }
}
class tr {
  static pushRelatedItemFromParser(t) {
    const e = [];
    for (const i of t.relationships)
      e.push({
        category: i.category,
        id: i.id,
        name: i.name
      });
    return e;
  }
  static addFromRelatingElt(t, e) {
    const i = t.related, s = t.type;
    if (s != null)
      if (!e.has(s) && i !== null)
        e.set(s, {
          related: this.pushRelatedItemFromParser(i),
          relating: []
        });
      else {
        const r = t.related;
        if (r !== null)
          for (const o of r.relationships) {
            const a = e.get(s);
            a !== void 0 && this.findBimObjectInArray(a.related, {
              id: o.id,
              category: o.category,
              name: o.name
            }) === !1 && a.related.push({
              id: o.id,
              category: o.category,
              name: o.name
            });
          }
      }
  }
  static findBimObjectInArray(t, e) {
    for (const i of t)
      if (i.category === e.category && i.name === e.name && i.id === e.id)
        return !0;
    return !1;
  }
  static addFromRelatedElt(t, e) {
    const i = t.type;
    i !== null && !e.has(i) && t.relating !== null && e.set(i, {
      related: [],
      relating: [
        {
          category: t.relating.relationElt.category,
          id: t.relating.relationElt.id,
          name: t.relating.relationElt.name
        }
      ]
    });
  }
  static findIndexInRelated(t, e) {
    let i = -1, s = 0;
    for (const r of e) {
      if (r.id === t) {
        i = s;
        break;
      }
      s++;
    }
    return i;
  }
}
class ms extends Ur {
  constructor(t, e, i, s) {
    super(t, e, i, s), this._bits &= ~We.InitiallyShown, t.registerViewFrame(this, s.inclusionKey);
  }
  static parseXml(t, e, i, s) {
    return Ve.parseXml(t, e, i, s);
  }
  static parseBinary(t, e, i, s) {
    return Ve.parseBinary(t, e, i, s);
  }
  static reify(t, e, i, s) {
    const r = Ce(i), o = new ms(t, e, i, s);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  getName() {
    const t = this.getName();
    return t !== null ? t : "CAD View frame";
  }
  getInstanceInc() {
    const t = this._instanceKey;
    let e = ve.Local;
    return (this.hasAuthoredId() || this.isImplicitBody()) && (e = Ne(this).getInclusionKey()), [e, t];
  }
  setVisibility(t) {
    t !== this.isVisible() && this.getParent().getParent().markBranchVisibilityDirty(), this._setVisibility(t);
  }
  getRuntimeId() {
    return Ks(this._nodeId, this);
  }
}
var ft = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.LoadedNodesOnly = 1] = "LoadedNodesOnly", n))(ft || {});
class Yd {
  constructor(t) {
    this._configuration = t.configuration, this._visibilityFormatter = t.visibilityFormatter, this._resetNonAffectedToDefault = t.resetNonAffectedToDefault, this._state = {
      currentNode: null,
      nodeConfiguration: null,
      appliedVisibility: null,
      inheritedVisibilityStack: [],
      bodiesToShow: [],
      bodiesToHide: []
    }, this.enterProductOccurrence = this.enterProductOccurrence.bind(this), this.leaveProductOccurrence = this.leaveProductOccurrence.bind(this), this.enterAnyBody = this.enterAnyBody.bind(this), this.leaveAnyBody = this.leaveAnyBody.bind(this), this.enterCadView = this.enterCadView.bind(this), this.leaveCadView = this.leaveCadView.bind(this), this.enterPmi = this.enterPmi.bind(this), this.leavePmi = this.leavePmi.bind(this);
  }
  /**
   * Get the visibility formatter of the updater.
   */
  get visibilityFormatter() {
    return this._visibilityFormatter;
  }
  /**
   * Set the visibility formatter of the updater.
   * @param func the formatter to use.
   */
  set visibilityFormatter(t) {
    this._visibilityFormatter = t;
  }
  /**
   * The currently visited node
   */
  get currentNode() {
    return this._state.currentNode;
  }
  /**
   * Getter for the visitor's configuration
   */
  get configuration() {
    return this._configuration;
  }
  /**
   * Getter for the current node's configuration
   */
  get nodeConfiguration() {
    return this._state.nodeConfiguration;
  }
  /**
   * Getter for the output visibility for the current node
   */
  get appliedVisibility() {
    return this._state.appliedVisibility;
  }
  /**
   * Getter for the visitor's state
   */
  get state() {
    return this._state;
  }
  /**
   * Getter for the visit result
   *
   * Mainly the bodies to update.
   */
  get result() {
    return {
      bodies: {
        hide: this._state.bodiesToHide,
        show: this._state.bodiesToShow
      }
    };
  }
  /**
   * Update the visitor state and set the node visibility
   * @param node the node to update
   */
  _updateNodeVisibility(t) {
    this._updateVisitorState(t, !1);
    const e = this.appliedVisibility;
    e !== null && t.setVisibility(e);
  }
  /**
   * Get the visibility config for the current node
   * it contains several fields:
   * explicitVisibility: the value of the node from the visibilityFormatter for the current
   * node, if any visible: whether or not the current node is visible initiallyShown: the node
   * initial visibility
   * initiallyOrConfigurationShown: if configuration.initially.shown is true it
   * returns initiallyShown, otherwise it return initiallyShown or true if the configuration
   * is on the same branch.
   * @returns The current node visibility config
   */
  _getVisibilityConfig() {
    const t = this.currentNode, e = t.isInitiallyShown();
    let i = e;
    return !this._configuration.initially.shown && this._configuration.filterByConfiguration && (i = i || !this._configuration.containsAnyConfig || this._configuration.containsCurrentConfig), {
      explicitVisibility: this._visibilityFormatter ? this._visibilityFormatter(t) : void 0,
      visible: t.isVisible(),
      initiallyShown: e,
      initiallyOrConfigurationShown: i
    };
  }
  /**
   * Get the visibility for a PmiBody node
   *
   * For PMI we allow to switch them to visible if you just set the visibility on the PMI
   * (not its body instance subnode), it's because we don't display the PMI body instance in
   * the tree anymore.
   * @returns true or null
   */
  _getPmiBodyVisibility() {
    const e = this.currentNode.getParent();
    return this._visibilityFormatter && this._visibilityFormatter(e) === !0 ? !0 : null;
  }
  /**
   * If a node is initially hidden and has no explicit visibility set then we keep it
   * hidden by returning null, except for a some exceptions like PmiBody nodes.
   * @returns Null for regular node a boolean otherwise.
   */
  _getInitiallyHiddenNodeVisibility() {
    return this.currentNode instanceof In ? this._getPmiBodyVisibility() : null;
  }
  /**
   * Get the inherited visibility value of the node
   * @returns The inherited visibility value of the node if it's different than its current visibility or null
   */
  _getInheritedVisibility() {
    const t = this._state.inheritedVisibilityStack[this._state.inheritedVisibilityStack.length - 1];
    return t !== this.nodeConfiguration.visible ? t && !this.nodeConfiguration.initiallyShown && this._configuration.initially.immutableHidden ? this._getInitiallyHiddenNodeVisibility() : t : null;
  }
  /**
   * When a node is not affected by the traversal, it visibility status is reinitialized if
   * resetNonAffectedToDefault is set and if its not already set to the expected value.
   * @returns The new visibility status if it's different from the current, null otherwise
   */
  _handleNonAffectedNodeVisibility() {
    return this._resetNonAffectedToDefault && this.nodeConfiguration.visible !== this.nodeConfiguration.initiallyOrConfigurationShown ? this._state.nodeConfiguration.initiallyOrConfigurationShown : null;
  }
  /**
   * Get the visibility status of the current node
   * @param preventFromResetting whether or not unaffected node will be reinitialized
   * @returns The new visibility status of the node if it's different from the current one, null otherwise
   */
  _getNodeVisibility(t) {
    return this.nodeConfiguration && this.nodeConfiguration.explicitVisibility !== void 0 ? this.nodeConfiguration.explicitVisibility : ks(this.currentNode) ? null : this._configuration.node !== void 0 && this._configuration.filterByConfiguration && this._configuration.containsAnyConfig && !this._configuration.containsCurrentConfig ? !1 : this._state.inheritedVisibilityStack.length > 0 ? this._getInheritedVisibility() : t ? null : this._handleNonAffectedNodeVisibility();
  }
  /**
   * Update the state of the visitor.
   * It set the given node as the current node, generates it visibility config, update the
   * hierarchy and compute the new visibility status.
   * @param node The current node to visit
   * @param preventFromResetting whether or not to reinitialize the node if its not affected.
   */
  _updateVisitorState(t, e) {
    this._state.currentNode = t, this._state.nodeConfiguration = this._getVisibilityConfig(), this._state.nodeConfiguration.explicitVisibility !== void 0 ? this._state.inheritedVisibilityStack.push(this._state.nodeConfiguration.explicitVisibility) : this._state.inheritedVisibilityStack.length > 0 && this._state.inheritedVisibilityStack.push(
      this._state.inheritedVisibilityStack[this._state.inheritedVisibilityStack.length - 1]
    ), this._state.appliedVisibility = this._getNodeVisibility(e);
  }
  /**
   * When the node is left it's popped out of the hierarchy
   */
  leaveNode() {
    this._state.inheritedVisibilityStack.length > 0 && this._state.inheritedVisibilityStack.pop();
  }
  /**
   * Check whether or not the current node is the configuration node and update the visibility.
   * If it is the configuration node it tags the config so the visitor knows the current
   * branch contains the configuration node.
   *
   * @param node the current node
   */
  enterProductOccurrence(t) {
    t.isAConfigurationNode() && (this._configuration.containsAnyConfig = !0, this._configuration.node === t && (this._configuration.containsCurrentConfig = !0)), this._updateNodeVisibility(t);
  }
  /**
   * Check whether or not the current node is the configuration node and update the visibility.
   * If it is the configuration node it removes the tag so the visitor knows the current
   * branch does not contains the configuration node anymore.
   * @param node
   */
  leaveProductOccurrence(t) {
    this.leaveNode(), t.isAConfigurationNode() && (this._configuration.containsAnyConfig = !1, this._configuration.node === t && (this._configuration.containsCurrentConfig = !1));
  }
  /**
   * Updates visibility for Pmi node
   * @param pmi the current Pmi Node
   */
  enterPmi(t) {
    this._updateNodeVisibility(t);
  }
  /**
   * Pops Pmi from hierarchy
   * @param _ not used
   */
  leavePmi(t) {
    this.leaveNode();
  }
  /**
   * Updates visibility for CadView node
   * @param cadView the current CadView Node
   */
  enterCadView(t) {
    this._updateNodeVisibility(t);
  }
  /**
   * Pops CadView from hierarchy
   * @param _ not used
   */
  leaveCadView(t) {
    this.leaveNode();
  }
  /**
   * Updates the visitor's state and apply the new visibility status if any. If the Visibility
   * changes the body is stored in the list of the bodies to hide or to show depending of it's
   * new status.
   * @param body the current AnyBody node
   */
  enterAnyBody(t) {
    const e = t.preventFromResetting();
    this._updateVisitorState(t, e);
    const i = this.appliedVisibility;
    i !== null && (t.setVisibility(i), i ? this._state.bodiesToShow.push(t) : this._state.bodiesToHide.push(t));
  }
  /**
   * Pops AnyBody from hierarchy
   * @param _ not used
   */
  leaveAnyBody(t) {
    return this.leaveNode();
  }
}
class pf extends Yd {
  constructor(t) {
    super(t), this.enterProductOccurrence = this.enterProductOccurrence.bind(this);
  }
  /**
   * Check whether or not the current node is the configuration node and update the visitor
   * status without updating the node visibility status.
   * If it is the configuration node it tags the config so the visitor knows the current
   * branch contains the configuration node.
   *
   * @param node the current ProductOccurence
   */
  enterProductOccurrence(t) {
    t.isAConfigurationNode() && (this.configuration.containsAnyConfig = !0, this.configuration.node === t && (this.configuration.containsCurrentConfig = !0)), this._updateVisitorState(t, !0);
  }
}
async function Gd(n, t = !1) {
  const e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), s = (a) => t ? a.isInitiallyShown() : a.isVisible(), r = {
    enterAnyBody: (a) => {
      if (a instanceof Ve) {
        const l = a.getRuntimeId();
        s(a) ? e.add(l) : i.add(l);
      }
    }
  };
  await yi.walk(r, n, ft.None);
  const o = e.size >= i.size;
  return new I_(o, o ? i : e);
}
function ll(n) {
  const t = [];
  for (const e of n) {
    const i = e.getInstanceInc();
    t.push(i[0], i[1]);
  }
  return t;
}
function au(n) {
  const t = [];
  for (const e of n) {
    const i = e.getRuntimeId();
    t.push(i);
  }
  return t;
}
class Td {
  constructor(t) {
    this._assemblyTree = t.assemblyTree, this._engine = t.engine, this._callbackManager = t.callbackManager, this._startNode = t.startNode, this._setVisibility = t.setVisibility, this._initiallyHiddenStayHidden = t.initiallyHiddenStayHidden, this._configurationNode = t.configurationNode, this._configuration = null;
  }
  /**
   * Get the visibility formatter for the given attach context
   * @param attachContext the attach context
   * @param setVisibility the visibility directive to apply
   * @returns the default formatter for attach context
   */
  static getAttachContextFormatter(t, e) {
    return (i) => {
      if (i instanceof Yt && t.getChildren().indexOf(i) !== -1)
        switch (e) {
          case hs.Hide:
            return !1;
          case hs.Show:
            return !0;
          case hs.Initial:
            return;
        }
    };
  }
  /**
   * Get the updater configuration
   */
  get configuration() {
    return this._configuration;
  }
  /**
   * Generates the configuration for the updater
   *
   * Determine if the configuration we're activating has initially visible nodes or not.
   *
   * It also checks whether the configuration node is an ancestor of the start node. In this
   * case it tags the configuration so it knows the current branch contains the configuration.
   *
   * In the case of older SCs (pre 2022 SP1) non-default configurations had all their nodes
   * set to initially hidden. Since then that has been changed so that the initial visibility states
   * of nodes under configurations reflects their visibility when the configuration is activated.
   * Thus, we need to know which of those cases we're dealing with, by checking for any nodes set to be
   * initially shown.
   *
   * If we're working with configurations we may need to show initially hidden nodes
   * regardless of assembly tree settings.
   * We want to reveal hidden nodes if the configuration has marked them as hidden.
   * See comment the comment above for more details.
   *
   * @returns a promise resolving with the configuration
   */
  async _generateConfig() {
    let t = !1, e = !1, i = !1, s = !1;
    if (this._configurationNode) {
      console.assert(this._configurationNode.isAConfigurationNode()), t = !0;
      const r = await Gd(this._configurationNode, !0);
      if ((r.defaultVisibility || r.visibilityExceptions.size !== 0) && (s = !0), !(this._startNode instanceof hi)) {
        let o = this._startNode;
        for (; o !== null; ) {
          if (o instanceof Yt && o.isAConfigurationNode()) {
            i = !0, o === this._configurationNode && (e = !0);
            break;
          }
          const a = o.getParent();
          if (!(a instanceof Yt))
            break;
          o = a;
        }
      }
    }
    return this._initiallyHiddenStayHidden === void 0 && (this._configurationNode !== void 0 ? this._initiallyHiddenStayHidden = s : this._initiallyHiddenStayHidden = this._assemblyTree.getInitiallyHiddenStayHidden()), {
      filterByConfiguration: t,
      containsCurrentConfig: e,
      containsAnyConfig: i,
      node: this._configurationNode,
      setVisibility: this._setVisibility,
      initially: {
        shown: s,
        immutableHidden: this._initiallyHiddenStayHidden
      }
    };
  }
  /**
   * Update the visibility of the bodies in the graphic engine.
   *
   * Once the assembly tree has been updated we need to tell the engine that some instances
   * need to be updated so that it can refresh the view.
   *
   * @param bodies the lists of the bodies to show and to hide
   */
  _applyVisibilities(t) {
    if (this._setVisibility) {
      const e = this._startNode.getAttachScope();
      console.assert(e !== ar.OfInitialEmptyModel), this._engine.setVisibilityByAttachment(e, this._setVisibility);
    } else {
      const e = ll(t.show), i = ll(t.hide);
      if (this._engine.pauseRendering(), this._engine.setPartVisibility(e, !0, !0), this._engine.setPartVisibility(i, !1, !0), this._engine.resumeRendering(), this._callbackManager) {
        const s = au(t.show), r = au(t.hide);
        this._callbackManager.trigger("visibilityChanged", s, r);
      }
    }
  }
  /**
   * Traverse the assembly tree within a walker to to allow the given visitor to update it.
   * @param visitor The visitor that will update the assembly tree
   * @param {optional} startNode The root of the traversal, default: the updater startNode
   */
  async traverse(t, e) {
    await yi.walk(t, e || this._startNode, ft.None);
  }
  /**
   * Initialize the configuration and the attach context if needed
   */
  async init() {
    this._startNode instanceof hi || console.assert(this._setVisibility === void 0), this._configuration = await this._generateConfig();
  }
  /**
   * Not effect.
   * To allow inheriting classes to cool down or check result after the update.
   */
  async quit() {
  }
  /**
   * Update the assembly tree and the view using the given visitor.
   * @param visitor the Visitor that will update the assembly tree.
   */
  async update(t, e, ...i) {
    const s = new t({ ...e, configuration: this.configuration }, ...i);
    return await this.traverse(s), this._applyVisibilities(s.result.bodies), s;
  }
  /**
   * Update the assembly tree separately with each node as start node
   * @param visitor the visitor used to update the assembly.
   * @param nodeVisibilities the node roots and their visible status.
   */
  async updatePerNode(t, e, i, ...s) {
    const r = new t({ ...i, configuration: this.configuration }, ...s);
    return e.forEach(async (o, a) => {
      const l = r.visibilityFormatter;
      r.visibilityFormatter = (c) => c === c ? o : l ? l(c) : void 0, await this.traverse(r, a), r.visibilityFormatter = l;
    }), this._applyVisibilities(r.result.bodies), r;
  }
}
async function gf(n) {
  return bh({
    ...n,
    startNode: n.attachContext,
    visibilityFormatter: Td.getAttachContextFormatter(
      n.attachContext,
      n.setVisibility
    ),
    resetNonAffectedToDefault: n.setVisibility === hs.Initial,
    initiallyHiddenStayHidden: n.setVisibility !== hs.Show
  });
}
async function xc(n) {
  return bh(n);
}
async function ff(n) {
  return bh({
    ...n,
    visitorType: pf
  });
}
async function bh(n, ...t) {
  const e = new Td({
    assemblyTree: n.assemblyTree,
    engine: n.engine,
    callbackManager: n.callbackManager,
    startNode: n.startNode,
    setVisibility: n.setVisibility !== null ? n.setVisibility : void 0,
    initiallyHiddenStayHidden: n.initiallyHiddenStayHidden,
    configurationNode: n.configurationNode
  });
  await e.init();
  const i = await e.update(
    n.visitorType || Yd,
    {
      visibilityFormatter: n.visibilityFormatter,
      resetNonAffectedToDefault: n.resetNonAffectedToDefault
    },
    ...t
  );
  console.assert(i.state.inheritedVisibilityStack.length === 0), await e.quit();
}
async function _f(n, t) {
  const e = [], i = [], s = {
    enterAnyBody: (a) => {
      if (a instanceof In || a instanceof ms) {
        const l = a.isVisible();
        a.setVisibility(l), l ? e.push(a) : i.push(a);
      }
    }
  };
  await yi.walk(s, t, ft.None);
  const r = ll(e), o = ll(i);
  n.pauseRendering(), n.synchronizeVisibilities(r, !0), n.synchronizeVisibilities(o, !1), n.resumeRendering();
}
const br = 0, nc = (n) => (n + 1 >>> 1) - 1, Sa = (n) => (n << 1) + 1, eo = (n) => n + 1 << 1;
class yf {
  constructor(t) {
    this._heap = [], this._comparator = t;
  }
  clear() {
    this._heap.length = 0;
  }
  get length() {
    return this._heap.length;
  }
  peek() {
    return this._heap[br];
  }
  push(t) {
    this._heap.push(t), this._siftUp();
  }
  pop() {
    const t = this.peek(), e = this.length - 1;
    return e > br && this._swap(br, e), this._heap.pop(), this._siftDown(), t;
  }
  replace(t) {
    const e = this.peek();
    return this._heap[br] = t, this._siftDown(), e;
  }
  _greater(t, e) {
    return this._comparator(this._heap[t], this._heap[e]);
  }
  _swap(t, e) {
    [this._heap[t], this._heap[e]] = [this._heap[e], this._heap[t]];
  }
  _siftUp() {
    let t = this.length - 1;
    for (; t > br && this._greater(t, nc(t)); )
      this._swap(t, nc(t)), t = nc(t);
  }
  _siftDown() {
    let t = br;
    for (; Sa(t) < this.length && this._greater(Sa(t), t) || eo(t) < this.length && this._greater(eo(t), t); ) {
      const e = eo(t) < this.length && this._greater(eo(t), Sa(t)) ? eo(t) : Sa(t);
      this._swap(t, e), t = e;
    }
  }
}
class Ed {
  constructor(t, e, i) {
    this._lazyPromise = t, this._wrapperPromise = e, i !== null && (this.compareValue = i);
  }
  kill() {
    this._lazyPromise = null;
  }
  /*
   * Causes this promise to be killed, and the associated open promise to be resolved.
   * This allows anything waiting on the associated open promise to resolve.
   */
  cancel(t) {
    this._lazyPromise = null, this._wrapperPromise.resolve(t);
  }
  fetch(t, e) {
    this._lazyPromise === null ? (this._wrapperPromise.reject(null), setTimeout(e, 0)) : t(this._lazyPromise).then((i) => {
      this._wrapperPromise.resolve(i);
    }).catch((i) => {
      this._wrapperPromise.reject(i);
    });
  }
}
class Nd {
  constructor(t, e, i) {
    this._failed = !1, this._failureError = null, this._activePromiseCount = 0, this._idlePromise = null, this._latestPromise = Promise.resolve(), this._needsResorting = !1, console.assert(t > 0, "Don't create a non-progressible queue."), this._maxActivePromises = t, this._deferredPromises = e, this._failureFailsAll = i;
  }
  maxActivePromises() {
    return this._maxActivePromises;
  }
  activePromiseCount() {
    return this._activePromiseCount;
  }
  isIdle() {
    return this._activePromiseCount === 0;
  }
  async waitForIdle() {
    if (this.isIdle()) {
      if (this._failureFailsAll && this._failed)
        throw this._failureError;
      return;
    }
    return this._idlePromise === null && (this._idlePromise = ye()), this._idlePromise;
  }
  killDeferred() {
    const t = [];
    for (; this._deferredPromises.length > 0; ) {
      const e = this._dequeue();
      e.kill(), t.push(e);
    }
    for (const e of t)
      this._queue(e);
  }
  _push(t, e) {
    typeof t == "function" && (t = ji.create(t));
    let i;
    return this._activePromiseCount < this._maxActivePromises ? i = this._immediatePromise(t) : i = this._deferPromise(t, e), this._latestPromise = i, i;
  }
  _resort() {
    console.assert(this._needsResorting), this._needsResorting = !1;
    const t = this._drainQueue();
    for (const e of t)
      this._queue(e);
  }
  _drainQueue() {
    const t = [];
    for (; this._deferredPromises.length > 0; ) {
      const e = this._dequeue();
      t.push(e);
    }
    return t;
  }
  _deferPromise(t, e) {
    const i = ye(), s = new Ed(t, i, e);
    return this._queue(s), i;
  }
  async _immediatePromise(t) {
    if (this._failureFailsAll && this._failed)
      throw this._failureError;
    ++this._activePromiseCount;
    try {
      const e = await t.get();
      return this._finalizePromise(), e;
    } catch (e) {
      throw this._failureFailsAll && !this._failed && (this._failed = !0, this._failureError = e, this._idlePromise !== null && this._idlePromise.reject(e)), this._finalizePromise(), e;
    }
  }
  // Kicks off the next item in the queue.
  // Precondition: _deferredPromises.length > 0 && _activePromiseCount < _maxActivePromises
  _fetchNext() {
    this._dequeue().fetch(
      (t) => this._immediatePromise(t),
      () => {
        this._finalizePromise();
      }
    );
  }
  _finalizePromise() {
    --this._activePromiseCount, this._deferredPromises.length > 0 ? (this._needsResorting && this._resort(), this._fetchNext()) : this._activePromiseCount === 0 && (this._idlePromise !== null && (this._failureFailsAll && this._failed ? this._idlePromise.reject(this._failureError) : this._idlePromise.resolve(), this._idlePromise = null), this._latestPromise = Promise.resolve());
  }
}
class Ns extends Nd {
  _queue(t) {
    this._deferredPromises.push(t);
  }
  _dequeue() {
    return this._deferredPromises.pop();
  }
  constructor(t, e) {
    super(t, new wd(), e);
  }
  push(t) {
    return this._push(t, null);
  }
  async waitOnLatest() {
    await this._latestPromise;
  }
}
class Rd extends Nd {
  _queue(t) {
    this._deferredPromises.push(t);
  }
  _dequeue() {
    return this._deferredPromises.pop();
  }
  constructor(t, e, i) {
    const s = (o, a) => e(o.compareValue, a.compareValue), r = new yf(s);
    super(t, r, i);
  }
  push(t, e) {
    return this._push(t, e);
  }
  markDirty() {
    this._needsResorting = !0;
  }
}
class bf extends Ns {
  _queue(t) {
    this._deferredPromises.clear(), this._deferredPromises.push(t);
  }
  constructor(t) {
    super(1, t);
  }
}
class If extends Rd {
  constructor(t, e, i, s, r) {
    super(i, s, r), this._cutoffAttachments = [], this._attachPriorityManager = e, this._cutoffScale = t;
  }
  setCutoffScale(t) {
    this._cutoffScale = Math.max(Math.min(t, 2), 0);
  }
  cutoffEnabled() {
    return this._cutoffScale !== 0;
  }
  isEmpty() {
    return this._cutoffAttachments.length === 0 && this._deferredPromises.length === 0;
  }
  /*
   * This method will effectively 'cancel' a pending loadSubtreebyXXX operation.
   * The difference between this and the base implementation is that all deferred promises will acually be resolved.
   * This allows for the promise returned by the initial method invocation to resolve when in stream cutoff mode if all items never passed the cutoff test.
   */
  killDeferred() {
    const t = this._drainQueue(), e = this._cutoffAttachments;
    this._cutoffAttachments = [];
    for (const i of t)
      i.cancel(null);
    for (const i of e)
      i.cancel(null);
  }
  /*
   * gets the calculated cutoff value from the attachPriorityManager.
   * Attachments must have a projected size equal to or grater than this value with the current camerta to be considered for fetching.
   * The value returned takes into account the sorting method implemented by the PriorityPromiseQueue
   */
  _getCutoffValue() {
    return this._cutoffScale * -this._attachPriorityManager.getCalculatedCutoff() - 1;
  }
  /*
   * Main entrypoint for items into the prefetch queue.  If cutoff is disabled, then the default behavior will be used and all items streamed.
   * When cutoff scale is enabled, then an items projected size will determine if it is enqueued for fetching or held back for reconsideration on camera update.
   */
  push(t, e) {
    if (!this.cutoffEnabled())
      return this._push(t, e);
    const i = this._attachPriorityManager.getPriorityCompareValue(e), s = this._getCutoffValue();
    if (i > s) {
      typeof t == "function" && (t = ji.create(t));
      const r = ye(), o = new Ed(t, r, e);
      return this._cutoffAttachments.push(o), r;
    } else
      return this._push(t, e);
  }
  /*
   * Override method which will apply the cutoff scale logic on all items currently needing to be fetched.
   * This may cause some items which were in the queue to be held back, and new items cycled in to be fetched based on
   * their projected size and the current camera.
   */
  _resort() {
    if (!this.cutoffEnabled()) {
      super._resort();
      return;
    }
    this._needsResorting = !1;
    const t = this._drainQueue(), e = this._cutoffAttachments;
    this._cutoffAttachments = [], this._updateDeferredPromiseArray(t), this._updateDeferredPromiseArray(e);
  }
  /*
   * If the queue has deferred promises left, it will automatically be resorted by the PromiseQueueImpl when the next promise finalizes.
   * Otherwise, we want to force a resort now and kick off the next attachment fetch
   */
  update() {
    if (!this.cutoffEnabled()) {
      this.markDirty();
      return;
    }
    this._cutoffAttachments.length > 0 && (this._resort(), this._refillQueue());
  }
  _refillQueue() {
    const t = Math.min(
      this.maxActivePromises() - this.activePromiseCount(),
      this._deferredPromises.length
    );
    for (let e = 0; e < t; e++)
      this._fetchNext();
  }
  /*
   * This method will scan an array of deferred promises and either place them in the queue to be fetched if they pass the cutoff scale test.
   * items which do not make the cut will be held back for reconsideration when the camera is updated again.
   */
  _updateDeferredPromiseArray(t) {
    for (const e of t) {
      const i = this._attachPriorityManager.getPriorityCompareValue(
        e.compareValue
      ), s = this._getCutoffValue();
      i > s ? this._cutoffAttachments.push(e) : this._queue(e);
    }
  }
}
async function ho(n, t, e, i) {
  const s = [], r = [], o = [], a = /* @__PURE__ */ new Set(), l = (p) => {
    if (a.has(p))
      return !1;
    a.add(p);
    const m = p.getLocalTransform();
    if (m !== null) {
      let g = s[s.length - 1];
      g = Xi.multiply(m, g), s.push(g);
    }
    return !0;
  }, c = (p) => {
    p.getLocalTransform() !== null && (console.assert(s.length > 1), s.pop());
  }, h = {
    followProductOccurrence: l,
    leaveProductOccurrence: c,
    followPmi: l,
    leavePmi: c,
    followCadView: l,
    leaveCadView: c,
    followAnyBody: l,
    enterAnyBody: (p) => {
      if (!p.isOutOfHierarchy() || i) {
        const m = p.getInstanceInc();
        o.push(m[0], m[1]);
        const g = Q.createFromArray(s[s.length - 1]);
        r.push(g);
      }
    },
    leaveAnyBody: c
  }, u = new Ns(1, !0);
  for (const p of e) {
    const m = ji.create(async () => {
      console.assert(s.length === 0);
      const g = Bo(p.getParent());
      s.push(g), await yi.walk(h, p, ft.None), console.assert(s.length === 1), s.pop();
    });
    u.push(m);
  }
  await u.waitForIdle(), console.assert(2 * r.length === o.length), n.setMatrices(o, r), t.trigger("_updateTransform", i);
}
function Za(n) {
  return n.isLoaded();
}
function Ir() {
  return !0;
}
function un() {
}
class Ld {
  constructor(t, e) {
    this.followProductOccurrence = Ir, this.enterProductOccurrence = un, this.leaveProductOccurrence = un, this.followPartDefinition = Ir, this.enterPartDefinition = un, this.leavePartDefinition = un, this.followRepresentationItem = Ir, this.enterRepresentationItem = un, this.leaveRepresentationItem = un, this.followAnyBody = Ir, this.enterAnyBody = un, this.leaveAnyBody = un, this.followCadView = Ir, this.enterCadView = un, this.leaveCadView = un, this.followPmi = Ir, this.enterPmi = un, this.leavePmi = un, e === ft.LoadedNodesOnly && (console.assert(t.followProductOccurrence === void 0), console.assert(t.followAnyBody === void 0), console.assert(t.followCadView === void 0), console.assert(t.followPmi === void 0), this.followProductOccurrence = Za, this.followAnyBody = Za, this.followCadView = Za, this.followPmi = Za), t.followProductOccurrence !== void 0 && (this.followProductOccurrence = t.followProductOccurrence), t.enterProductOccurrence !== void 0 && (this.enterProductOccurrence = t.enterProductOccurrence), t.leaveProductOccurrence !== void 0 && (this.leaveProductOccurrence = t.leaveProductOccurrence), t.followPartDefinition !== void 0 && (this.followPartDefinition = t.followPartDefinition), t.enterPartDefinition !== void 0 && (this.enterPartDefinition = t.enterPartDefinition), t.leavePartDefinition !== void 0 && (this.leavePartDefinition = t.leavePartDefinition), t.followRepresentationItem !== void 0 && (this.followRepresentationItem = t.followRepresentationItem), t.enterRepresentationItem !== void 0 && (this.enterRepresentationItem = t.enterRepresentationItem), t.leaveRepresentationItem !== void 0 && (this.leaveRepresentationItem = t.leaveRepresentationItem), t.followAnyBody !== void 0 && (this.followAnyBody = t.followAnyBody), t.enterAnyBody !== void 0 && (this.enterAnyBody = t.enterAnyBody), t.leaveAnyBody !== void 0 && (this.leaveAnyBody = t.leaveAnyBody), t.followCadView !== void 0 && (this.followCadView = t.followCadView), t.enterCadView !== void 0 && (this.enterCadView = t.enterCadView), t.leaveCadView !== void 0 && (this.leaveCadView = t.leaveCadView), t.followPmi !== void 0 && (this.followPmi = t.followPmi), t.enterPmi !== void 0 && (this.enterPmi = t.enterPmi), t.leavePmi !== void 0 && (this.leavePmi = t.leavePmi);
  }
}
class ua {
  static walk(t, e, i) {
    if (i === ft.LoadedNodesOnly && !e.isLoaded())
      return;
    const s = new ua(t, i);
    return e instanceof Yt ? s._walkProductOccurrence(e) : e instanceof gi ? s._walkPmi(e) : e instanceof Ni ? s._walkCadView(e) : s._walkAnyBody(e);
  }
  constructor(t, e) {
    this._visitor = new Ld(t, e);
  }
  _walkRepresentationItem(t) {
    console.assert(t.isLoaded()), this._visitor.followRepresentationItem(t) && (this._visitor.enterRepresentationItem(t), this._visitor.leaveRepresentationItem(t));
  }
  _walkPartDefinition(t) {
    if (console.assert(t.isLoaded()), this._visitor.followPartDefinition(t)) {
      this._visitor.enterPartDefinition(t);
      const e = t.getRepresentationItems();
      for (const i of e)
        this._walkRepresentationItem(i);
      this._visitor.leavePartDefinition(t);
    }
  }
  _walkAnyBody(t) {
    console.assert(t.isLoaded()), this._visitor.followAnyBody(t) && (this._visitor.enterAnyBody(t), this._visitor.leaveAnyBody(t));
  }
  _walkPmi(t) {
    if (console.assert(t.isLoaded()), this._visitor.followPmi(t)) {
      this._visitor.enterPmi(t);
      for (const e of t.getPmiBodies())
        this._walkAnyBody(e);
      this._visitor.leavePmi(t);
    }
  }
  _walkCadView(t) {
    if (console.assert(t.isLoaded()), this._visitor.followCadView(t)) {
      this._visitor.enterCadView(t);
      const e = t.getViewFrame();
      e !== null && this._walkAnyBody(e), this._visitor.leaveCadView(t);
    }
  }
  _walkProductOccurrence(t) {
    if (console.assert(t.isLoaded()), this._visitor.followProductOccurrence(t)) {
      this._visitor.enterProductOccurrence(t);
      const e = t.getPartDefinitionSync();
      e !== null && this._walkPartDefinition(e);
      const i = t.getChildrenSync();
      for (const a of i)
        this._walkProductOccurrence(a);
      const s = t.getBodyInstances();
      for (const a of s)
        this._walkAnyBody(a);
      const r = t.getPmis();
      for (const a of r)
        this._walkPmi(a);
      const o = t.getCadViews();
      for (const a of o)
        this._walkCadView(a);
      this._visitor.leaveProductOccurrence(t);
    }
  }
}
function Xd(n, t, e, i, s, r) {
  const o = [], l = {
    enterAnyBody: (h) => {
      if (s.has(h))
        return;
      if (s.add(h), h instanceof Ve) {
        if (!Ct(e, bt.BodyInstance) || h.isOutOfHierarchy() && !i)
          return;
      } else if (h instanceof In) {
        if (!Ct(e, bt.PmiBody))
          return;
      } else if (!Ct(e, bt.ViewFrame))
        return;
      const u = h.getInstanceInc();
      o.push(u[0], u[1]);
    }
  }, c = n.walk(l, t, r);
  return c ? c.then(() => o) : o;
}
function Fd(n, t, e, i) {
  return Xd(
    yi,
    n,
    t,
    e,
    i,
    ft.None
  );
}
function Oo(n, t, e, i, s) {
  return Xd(
    ua,
    n,
    t,
    e,
    i,
    s
  );
}
function Kd(n, t, e, i) {
  let s = null;
  const r = /* @__PURE__ */ new Set();
  for (const o of t) {
    const a = n.lookupAnyTreeNode(o);
    if (a === null)
      throw new sn(o);
    const l = ks(a), c = Oo(
      a,
      e,
      l,
      r,
      i
    );
    if (s === null)
      s = c;
    else
      for (const h of c)
        s.push(h);
  }
  return s !== null ? s : [];
}
async function Od(n, t, e, i, s, r) {
  const o = Kd(
    n,
    e,
    i,
    ft.None
  );
  if (o.length === 0)
    throw new Mt("Cannot get the bounding of node without geometry.");
  return t.getPartsBounding(o, s, r);
}
function wf(n, t) {
  const e = new Ns(1, !0);
  e.push(() => n.clear());
  for (const i of t)
    e.push(() => n.addPlane(i, null));
  return e.waitForIdle();
}
function vf(n, t, e) {
  const i = e.getRuntimeId(), s = n.get(i);
  s !== void 0 ? (e.overrideLocalTransform(s), t.push(e)) : e.hasLocalTransformOverride() && (e.removeLocalTransformOverride(), t.push(e));
}
function xf(n, t) {
  t.hasLocalTransformOverride() && (t.removeLocalTransformOverride(), n.push(t));
}
class Ni extends Pi {
  constructor(t, e, i, s, r) {
    const a = Ce(e).getMasterModelKey(), l = {
      nodeId: i.nodeId,
      bits: 0,
      name: i.name,
      localTransform: null,
      attributes: [],
      header: _n.dynamic,
      exchangeId: null,
      layerId: null,
      genericTypeId: null,
      genericId: null,
      userDatas: null
    };
    if (super(t, a, l), this._parent = r, this._bits |= i.bits, i.camera !== null && (this._camera = {
      initial: i.camera.copy(),
      derived: i.camera.copy()
    }), this._instanceMarkupKeysToShow = ko(i.instanceMarkupKeysToShow), Ni.isAuthoredViewInfo(i, s) ? (this._nodesToShow = Ni._toRuntimeIds(e, i.nodesToShow), this._nodesToHide = Ni._toRuntimeIds(e, i.nodesToHide), i.transformMap.size > 0 && (this._transformMap = /* @__PURE__ */ new Map(), i.transformMap.forEach((c, h) => {
      const u = e.toRuntimeId(h);
      this._transformMap.set(u, Xi.copy(c));
    }))) : (this._nodesToShow = ko(i.nodesToShow), this._nodesToHide = ko(i.nodesToHide), i.transformMap.size > 0 && (this._transformMap = wl(i.transformMap))), i.viewFrameInfo !== null && (this._viewFrame = this._loadViewFrame(t, a, i.viewFrameInfo)), i.cuttingPlanes.length > 0) {
      this._cuttingPlanes = zi(i.cuttingPlanes);
      let c = 1;
      const h = hu(this), u = Ce(h), p = Pn(u);
      if (p) {
        const m = h.getMeasurementUnit(), g = p.getMeasurementUnit();
        m !== g && (c = m / g);
      }
      c !== 1 && se(this._cuttingPlanes).forEach((m) => {
        m.d *= c;
      });
    }
    t.registerCadView(this);
  }
  static parseXml(t, e, i, s) {
    let r = 0;
    const o = we.parseNodeId(e, "Id");
    if (o === null)
      throw new ce('Expected "Id" attribute.');
    const a = e.getAttribute("Name");
    if (a === null)
      throw new ce('Expected "Name" attribute');
    const l = (Y, P, L, N) => {
      const D = Y.getAttribute("Enabled");
      if (D === null)
        throw new ce(`Expected ${L} attribute`);
      return P = Yr(P, N, D === "1"), P;
    }, c = e.getAttribute("isAnnotationView");
    c === null ? r = Yr(r, Ie.IsAnnotationView, !1) : r = Yr(r, Ie.IsAnnotationView, c === "true");
    let h = null, u = null, p = [], m = [], g = [], _ = /* @__PURE__ */ new Map(), y = [];
    const b = (Y) => {
      const P = we.parseUint(Y, "Projection");
      if (P === null)
        throw new ce('Expected "Projection" attribute');
      const L = Y.getAttribute("field");
      if (L === null)
        throw new ce('Expected "field" attribute');
      const N = L.split(" ");
      if (N.length !== 2)
        throw new ce("Expected 2 field values");
      const D = parseFloat(N[0]), B = parseFloat(N[1]), V = Y.getAttribute("definition");
      if (V === null)
        throw new ce('Expected "definition" attribute');
      const X = V.split(" ");
      if (X.length !== 9)
        throw new ce("Expected 9 definition values");
      const Z = (gt, U) => new d(
        parseFloat(gt[U]),
        parseFloat(gt[U + 1]),
        parseFloat(gt[U + 2])
      ), W = Z(X, 0), st = Z(X, 3), j = Z(X, 6);
      return ci.create(W, st, j, P, D, B);
    }, w = (Y) => {
      const P = [];
      if (we.parseUint(Y, "Count") === null)
        throw new ce('Expected "PMIToShow Count" attribute');
      const N = we.parseNodeIds(Y, "IDs");
      if (N === null)
        throw new ce('Expected "PMIToShow Ids" attribute');
      for (let D = 0; D < N.length; D += 2)
        P.push(N[D + 1]);
      return P;
    }, v = (Y) => {
      const P = [], L = we.parseUint(Y, "Count");
      if (L === null)
        throw new ce('Expected "ClipPlanes Count" attribute');
      const N = we.parseFloats(Y, "Plane");
      if (N === null)
        throw new ce('Expected "Plane" attribute');
      if (N.length / 4 !== L)
        throw new ce(`Expected ${L} Planes`);
      for (let D = 0; D < N.length; D += 4)
        P.push(
          je.createFromCoefficients(N[D], N[D + 1], N[D + 2], N[D + 3])
        );
      return P;
    }, C = (Y) => {
      const P = /* @__PURE__ */ new Map(), L = we.parseUint(Y, "Count");
      if (L === null)
        throw new ce('Expected "IDLocalTransform Count" attribute');
      const N = we.parseFloats(Y, "IDTransform");
      if (N === null)
        throw new ce('Expected "IDTransform" attribute');
      {
        if (N.length / 13 !== L)
          throw new ce(`Expected ${L} IDTransform values`);
        const D = (B, V) => {
          const X = Xi.getIdentity();
          return X[1] = B[V + 1], X[2] = B[V + 2], X[3] = B[V + 3], X[4] = B[V + 4], X[6] = B[V + 5], X[7] = B[V + 6], X[8] = B[V + 7], X[9] = B[V + 8], X[11] = B[V + 9], X[12] = B[V + 10], X[13] = B[V + 11], X[14] = B[V + 12], X;
        };
        for (let B = 0; B < N.length; B += 13) {
          const V = N[B], X = D(N, B);
          P.set(V, X);
        }
      }
      return P;
    };
    let k = e.firstElementChild;
    for (; k !== null; )
      k.localName === "Camera" ? (console.assert(h === null), h = b(k)) : k.localName === "Frame" ? u = ms.parseXml(
        t,
        k,
        i.getInclusionKey(),
        s
      ) : k.localName === "PMIToShow" ? p = w(k) : k.localName === "InstanceToShow" ? m = we.parseNodeIds(k, "IDs") : k.localName === "InstanceToHide" ? g = we.parseNodeIds(k, "IDs") : k.localName === "ClipPlanes" ? y = v(k) : k.localName === "IDLocalTransform" ? _ = C(k) : k.localName === "IsCameraSet" ? r = l(
        k,
        r,
        "IsCameraSet",
        Ie.IsCameraSet
      ) : k.localName === "IsPMIFilteringSet" ? r = l(
        k,
        r,
        "IsPMIFilteringSet",
        Ie.IsPmiFilteringSet
      ) : k.localName === "IsGeomFilteringSet" ? r = l(
        k,
        r,
        "IsGeomFilteringSet",
        Ie.IsGeomFilteringSet
      ) : k.localName === "IsCrosssectionSet" ? r = l(
        k,
        r,
        "IsCrosssectionSet",
        Ie.IsCrossSectionSet
      ) : k.localName === "IsExplosionSet" ? r = l(
        k,
        r,
        "IsExplosionSet",
        Ie.IsExplosionSet
      ) : k.localName === "IsCombineState" && (r = l(
        k,
        r,
        "IsCombineState",
        Ie.IsCombineState
      )), k = k.nextElementSibling;
    return {
      nodeId: o,
      name: a,
      camera: h,
      instanceMarkupKeysToShow: p,
      viewFrameInfo: u,
      nodesToShow: m ?? [],
      nodesToHide: g ?? [],
      transformMap: _,
      cuttingPlanes: y,
      bits: r
    };
  }
  static parseBinary(t, e, i, s) {
    const r = i.parseViewParseBits(), o = i.parseNodeId();
    let a = null;
    Ct(r, ui.Name) && (a = i.parseCString());
    let l = 0, c = !1;
    Ct(r, ui.IsAnnotationView) ? (c = !0, a += " # Annotation View") : a !== null && a.indexOf("# Annotation View") >= 0 && (c = !0), c && (l |= Ie.IsAnnotationView), Ct(r, ui.IsNotPmiFilteringSet) || (l |= Ie.IsPmiFilteringSet), Ct(r, ui.IsNotGeomFilteringSet) || (l |= Ie.IsGeomFilteringSet), Ct(r, ui.IsNotCrosssectionSet) || (l |= Ie.IsCrossSectionSet), Ct(r, ui.IsNotExplosionSet) || (l |= Ie.IsExplosionSet), Ct(r, ui.IsCombineState) && (l |= Ie.IsCombineState), Ct(r, ui.IsDefaultView) && (l |= Ie.IsDefaultView);
    const h = Ct(r, ui.IsPerspective);
    h && (l |= Ie.IsPerspective);
    let u = null;
    if (Ct(r, ui.Camera)) {
      const w = h ? te.Perspective : te.Orthographic, v = i.parsePoint3_32(), C = i.parsePoint3_32(), k = i.parsePoint3_32(), Y = i.parseFloat_32(), P = i.parseFloat_32();
      Ct(r, ui.IsNotCameraSet) || (l |= Ie.IsCameraSet, u = ci.create(v, C, k, w, Y, P), (Y < 0 || P < 0) && (l |= Ie.HasDynamicFrame));
    }
    const p = [];
    if (Ct(r, ui.Pmi)) {
      const w = i.parseCount_32();
      for (let v = 0; v < w; ++v) {
        const C = i.parseInstanceKey();
        p.push(C);
      }
    }
    let m = null;
    Ct(r, ui.Frame) && (m = ms.parseBinary(t, e, i, s));
    const g = [];
    if (Ct(r, ui.ShowNodes)) {
      const w = i.parseCount_32();
      for (let v = 0; v < w; ++v) {
        const C = i.parseNodeId();
        g.push(C);
      }
    }
    const _ = [];
    if (Ct(r, ui.HideNodes)) {
      const w = i.parseCount_32();
      for (let v = 0; v < w; ++v) {
        const C = i.parseNodeId();
        _.push(C);
      }
    }
    const y = /* @__PURE__ */ new Map();
    if (Ct(r, ui.MoveNodes)) {
      const w = i.parseCount_32();
      for (let v = 0; v < w; ++v) {
        const C = i.parseNodeId(), k = Xi.parseBinary(i);
        y.set(C, k);
      }
    }
    const b = [];
    if (Ct(r, ui.CuttingPlanes)) {
      const w = i.parseCount_32();
      for (let v = 0; v < w; ++v) {
        const C = i.parsePlane3_32();
        b.push(C);
      }
    }
    return {
      nodeId: o,
      name: a,
      camera: u,
      instanceMarkupKeysToShow: p,
      viewFrameInfo: m,
      nodesToShow: g,
      nodesToHide: _,
      transformMap: y,
      cuttingPlanes: b,
      bits: l
    };
  }
  static reify(t, e, i, s) {
    const r = Ce(e), o = new Ni(t, e, i, 0, s);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  static createDynamic(t, e, i, s, r, o, a, l, c) {
    const h = Ne(e), u = t.generateDynamicNodeId(), p = [];
    for (const _ of r)
      for (const y of _.getPmiBodies()) {
        const b = Ne(y);
        console.assert(h === b);
        const v = y.getInstanceInc()[1];
        p.push(v);
      }
    const m = {
      nodeId: u,
      name: i,
      camera: s,
      instanceMarkupKeysToShow: p,
      viewFrameInfo: null,
      nodesToShow: o,
      nodesToHide: a,
      transformMap: l,
      cuttingPlanes: c !== null ? [c] : [],
      bits: Ie.IsCameraSet
    };
    return new Ni(
      t,
      h,
      m,
      1,
      e
    );
  }
  static isAuthoredViewInfo(t, e) {
    return e === 0;
  }
  static _toRuntimeIds(t, e) {
    const i = /* @__PURE__ */ new Set();
    for (const s of e) {
      const r = t.toRuntimeId(s);
      i.add(r);
    }
    return i;
  }
  _loadViewFrame(t, e, i) {
    return ms.reify(t, e, this, i);
  }
  getViewFrame() {
    return this._viewFrame ?? null;
  }
  getParent() {
    return this._parent;
  }
  getRuntimeId() {
    return Ks(this._nodeId, this);
  }
  getBranchVisibility() {
    let t = this.isVisible() ? Pt.Shown : Pt.Hidden;
    return this._viewFrame !== void 0 && !this._viewFrame.isOutOfHierarchy() && (t |= this._viewFrame.isVisible() ? Pt.Shown : Pt.Hidden), t;
  }
  setVisibility(t) {
    this._setVisibility(t);
  }
  isPmiFilteringSet() {
    return this._hasBits(Ie.IsPmiFilteringSet);
  }
  isDefaultView() {
    return this._hasBits(Ie.IsDefaultView);
  }
  IsCombineState() {
    return this._hasBits(Ie.IsCombineState);
  }
  deactivate(t) {
    return t.clearAllCuttingSections();
  }
  async _replaceCuttingPlanes(t, e) {
    await t.clearAllCuttingSections();
    const i = t.getCuttingSectionCount();
    if (e.length > i)
      throw new Mt(
        `System does not support more than ${i} cutting planes in a CadView`
      );
    const s = e.reduce(
      (r, o, a) => {
        const l = t.getCuttingSection(a);
        return console.assert(l !== null), r.push(wf(l, [o])), r;
      },
      []
    );
    await Promise.all(s), await t.activateCuttingSections();
  }
  async activate(t, e, i, s, r, o, a, l) {
    return await this._activateView(
      t,
      e,
      i,
      s,
      l
    ), this._activateCamera(t, e, r, o, a);
  }
  // XXX: I have doubts that this is implemented correctly. Intentionally matching old behavior for now.
  async _activateView(t, e, i, s, r) {
    const o = t.getRootNode();
    r !== null && console.assert(r.isAConfigurationNode());
    const a = (r == null ? void 0 : r.getRuntimeId()) ?? en;
    let l = en;
    const c = /* @__PURE__ */ new Map(), h = [], u = [];
    let p = xf;
    this._transformMap !== void 0 && (p = (b, w) => {
      vf(this._transformMap, b, w);
    });
    const m = {
      enterProductOccurrence: (b) => {
        const w = b;
        w.isAConfigurationNode() && (l = w.getRuntimeId());
        const v = l, C = w.forEachPmi((k) => {
          const Y = k.getPmiBodies();
          if (Y.length === 0)
            return;
          let P = !0;
          if (this.isPmiFilteringSet()) {
            P = !1;
            for (const L of Y) {
              const D = L.getInstanceInc()[1];
              if (this._instanceMarkupKeysToShow.has(D)) {
                P = !0;
                break;
              }
            }
          }
          r !== null && (P = P && (v === a || v === en)), c.set(k, P);
          for (const L of Y)
            c.set(L, P);
        }).then(() => {
          const k = w.getRuntimeId();
          return this._nodesToHide.has(k) || w.isADrawingSheetNode() ? c.set(w, !1) : this._nodesToShow.has(k) && (r !== null ? c.set(
            w,
            v === a || v === en
          ) : c.set(w, !0)), p(h, w), w.forEachCadView((Y) => {
            const P = Y;
            if (P._viewFrame !== void 0) {
              let L = P === this;
              r !== null && (L = L && (v === a || v === en)), c.set(Y, L), c.set(P._viewFrame, L);
            }
          });
        });
        u.push(C);
      },
      leaveProductOccurrence: (b) => {
        b.isAConfigurationNode() && (l = en);
      },
      enterAnyBody: (b) => {
        if (b.isOutOfHierarchy())
          return;
        p(h, b);
        let w = b.getParent();
        for (; w !== null && !(w instanceof gi); ) {
          const C = w.getRuntimeId();
          if (this._nodesToHide.has(C)) {
            c.set(w, !1);
            break;
          } else if (this._nodesToShow.has(C)) {
            c.set(w, !0);
            break;
          }
          w = Bd(w.getParent());
        }
        const v = b.getRuntimeId();
        this._nodesToShow.has(v) ? c.set(b, !0) : this._nodesToHide.has(v) && c.set(b, !1), r !== null && l !== en && l !== a && c.set(b, !1);
      }
    };
    await yi.walk(m, o, ft.None), await Promise.all(u);
    const g = [];
    let _ = xc({
      assemblyTree: t,
      engine: e,
      startNode: o,
      visibilityFormatter: (b) => c.get(b),
      resetNonAffectedToDefault: !0,
      configurationNode: r ?? void 0,
      callbackManager: i,
      initiallyHiddenStayHidden: !1
    });
    g.push(_), _ = ho(e, i, h, !1), g.push(_), await zt(g);
    const y = se(this._cuttingPlanes);
    await this._replaceCuttingPlanes(s, y);
  }
  async _activateCamera(t, e, i, s, r) {
    const o = this._camera;
    if (o === void 0) {
      t.disableAutomaticFitWorld() || await i.fitWorld(s);
      return;
    }
    if (!r)
      return i._setCameraPromise(o.initial, s);
    const a = hu(this), l = Ce(a), c = Pn(l);
    let h = Q.createFromArray(Bo(l));
    if (c !== null) {
      const u = a.getMeasurementUnit(), p = c.getMeasurementUnit();
      if (u !== p) {
        const m = u / p, g = new Q();
        g.setScaleComponent(m, m, m), h = Q.multiply(g, h);
      }
    }
    if (o.derived = o.initial.transform(h), this._hasBits(Ie.HasDynamicFrame)) {
      const p = this._viewFrame !== void 0 ? await Od(
        t,
        e,
        [this._viewFrame.getRuntimeId()],
        bt.All,
        !1,
        !1
      ) : await e.getModelBounding(!0, !1, !1), m = d.subtract(o.derived.getTarget(), o.derived.getPosition()), g = p.extents().length(), _ = m.copy().normalize().scale(g), y = p.center(), b = d.subtract(y, _);
      return o.derived.setPosition(b), o.derived.setTarget(y), o.derived.setWidth(g), o.derived.setHeight(g), i._setCameraPromise(o.derived, s);
    } else if (o.derived.getProjection() === te.Orthographic) {
      const u = d.subtract(
        o.derived.getTarget(),
        o.derived.getPosition()
      ), p = await e.getModelBounding(!0, !1, !1), m = d.subtract(p.center(), o.derived.getPosition()), g = 1 / u.length(), _ = g * d.dot(u, m);
      if (_ > 0) {
        u.scale(g);
        const y = Math.max(o.derived.getWidth(), o.derived.getHeight()), b = d.add(
          o.derived.getPosition(),
          d.scale(u, _)
        ), w = d.subtract(
          b,
          d.scale(u, 2.5 * y)
        );
        o.derived.setPosition(w), o.derived.setTarget(b);
      }
      return i._setCameraPromise(o.derived, s);
    } else if (o.derived.getProjection() === te.Perspective) {
      const p = await e.getModelBounding(!0, !1, !1), m = d.subtract(p.max, p.min).length(), g = d.subtract(
        o.derived.getTarget(),
        o.derived.getPosition()
      ), _ = g.length(), y = _ / m;
      if (m === 0 || y > 0.01)
        return i._setCameraPromise(o.derived, s);
      const b = m * 0.01 * 1.001, w = o.derived.getWidth() / _, v = o.derived.getHeight() / _, C = w * b, k = v * b, Y = g.copy().normalize().scale(b), P = d.add(o.derived.getPosition(), Y);
      return o.derived.setTarget(P), o.derived.setWidth(C), o.derived.setHeight(k), i._setCameraPromise(o.derived, s);
    } else
      return i._setCameraPromise(o.derived, s);
  }
  hasPmi(t) {
    const e = Ne(this).getInclusionKey(), i = Ne(t).getInclusionKey();
    if (e !== i)
      return !1;
    for (const s of t.getPmiBodies()) {
      const r = s.getInstanceInc()[1];
      if (this._instanceMarkupKeysToShow.has(r))
        return !0;
    }
    return !1;
  }
  isAnnotationView() {
    return this._hasBits(Ie.IsAnnotationView);
  }
  isCombineStateView() {
    return this._hasBits(Ie.IsCombineState);
  }
  setViewFrame(t) {
    console.assert(this._viewFrame === void 0), this._viewFrame = t;
  }
}
class yi {
  static walk(t, e, i) {
    if (i === ft.LoadedNodesOnly && !e.isLoaded())
      return Promise.resolve();
    const s = new yi(t, i);
    if (e instanceof Pi)
      return s._walkAnyTreeNode(e);
    {
      const r = new Mo(1, !1), o = e.getChildren();
      for (const a of o)
        r.push(() => s._walkAnyTreeNode(a));
      return r.waitForIdle();
    }
  }
  static forceLazyPromises(t) {
    return this.walk({}, t, ft.None);
  }
  constructor(t, e) {
    this._visitor = new Ld(t, e);
  }
  _walkAnyTreeNode(t) {
    let e;
    return t instanceof Yt ? e = this._walkProductOccurrence(t) : t instanceof gi ? e = this._walkPmi(t) : t instanceof Ni ? e = this._walkCadView(t) : e = this._walkAnyBody(t), e === void 0 ? Promise.resolve() : e;
  }
  _walkRepresentationItem(t) {
    this._visitor.followRepresentationItem(t) && (this._visitor.enterRepresentationItem(t), this._visitor.leaveRepresentationItem(t));
  }
  _walkPartDefinition(t) {
    if (this._visitor.followPartDefinition(t)) {
      this._visitor.enterPartDefinition(t);
      const e = t.getRepresentationItems();
      for (const i of e)
        this._walkRepresentationItem(i);
      this._visitor.leavePartDefinition(t);
    }
  }
  _walkAnyBody(t) {
    this._visitor.followAnyBody(t) && (this._visitor.enterAnyBody(t), this._visitor.leaveAnyBody(t));
  }
  _walkPmi(t) {
    if (this._visitor.followPmi(t)) {
      this._visitor.enterPmi(t);
      for (const e of t.getPmiBodies())
        this._walkAnyBody(e);
      this._visitor.leavePmi(t);
    }
  }
  _walkCadView(t) {
    if (this._visitor.followCadView(t)) {
      this._visitor.enterCadView(t);
      const e = t.getViewFrame();
      e !== null && this._walkAnyBody(e), this._visitor.leaveCadView(t);
    }
  }
  _walkProductOccurrence(t) {
    const e = new Mo(1, !1);
    if (this._visitor.followProductOccurrence(t)) {
      this._visitor.enterProductOccurrence(t);
      const i = t.getRawPartDefinition();
      i !== null && (i instanceof xi ? e.push(() => {
        if (i.isResolved())
          return this._walkPartDefinition(i.getResolved());
      }) : e.push(() => i.then((l) => {
        if (l !== null) {
          const c = l.value;
          if (c.isResolved())
            return this._walkPartDefinition(c.getResolved());
        }
        return Promise.resolve();
      })));
      const s = t.tryGetChildrenSync();
      if (s !== null)
        for (const l of s)
          e.push(() => this._walkProductOccurrence(l));
      else
        e.push(() => t.getChildren().then((l) => {
          if (l.length === 0)
            return;
          const c = new Mo(1, !1);
          for (const h of l)
            c.push(() => this._walkProductOccurrence(h));
          if (!c.isIdle())
            return c.waitForIdle();
        }));
      const r = t.getBodyInstances();
      for (const l of r)
        e.push(() => this._walkAnyBody(l));
      const o = t.getPmis();
      for (const l of o)
        e.push(() => this._walkPmi(l));
      const a = t.getCadViews();
      for (const l of a)
        e.push(() => this._walkCadView(l));
      e.push(() => this._visitor.leaveProductOccurrence(t));
    }
    if (!e.isIdle())
      return e.waitForIdle();
  }
}
function Ad(n) {
  const t = n.getPrototype();
  if (t === null)
    return;
  let e;
  const i = t.getProductOccurrence();
  return i.isResolved() ? e = Sc(i.getResolved()) : e = i.then(Sc), e.then(() => {
    console.assert(i.isResolved()), i.getResolved().markLoaded();
  });
}
async function Sc(n) {
  const t = [], e = {
    enterProductOccurrence: (i) => {
      const s = Ad(i);
      s !== void 0 && t.push(s);
    }
  };
  return await yi.walk(e, n, ft.None), zt(t);
}
function lu(n) {
  n.markLoaded();
  const t = n.getRepresentationItems();
  for (const e of t)
    e.markLoaded();
}
function cu(n) {
  const t = n.getRawPartDefinition();
  if (t !== null)
    return t instanceof xi ? t.isResolved() ? void 0 : t.then(lu) : t.then((e) => {
      if (e === null)
        return;
      const i = e.value;
      if (!i.isResolved())
        return i.then(lu);
    });
}
function Ao(n) {
  const t = Ad(n);
  return t !== void 0 ? t.then(() => cu(n)) : cu(n);
}
async function Sf(n) {
  const t = [], e = {
    enterProductOccurrence: (i) => {
      const s = Ao(i);
      s !== void 0 && t.push(s);
    }
  };
  return await yi.walk(e, n, ft.None), zt(t);
}
class Ih {
  constructor(t) {
    this._referrers = null, this._prototype = t;
  }
  _addReferrer(t) {
    this._referrers = Mi(this._referrers, t);
  }
  _getReferrers() {
    return se(this._referrers);
  }
  _getPrototype() {
    return this._prototype;
  }
  _removeReferrer(t) {
    let e = !1, i = se(this._referrers);
    return i = i.filter((s) => s === t ? (e = !0, !1) : !0), e ? (i.length === 0 ? this._referrers = null : this._referrers = zi(i), !0) : !1;
  }
  async _purgeContents() {
    this._prototype.isUnforced() || await (await this._prototype).purgeContents();
  }
  _isLoaded() {
    return this._prototype.isResolved() && this._prototype.getResolved().isLoaded();
  }
}
class Mr {
  constructor(t, e) {
    t instanceof Ih && (t = Ws.create(t)), this._shared = t, this._inclusionContext = e;
  }
  getInclusionContext() {
    return this._inclusionContext;
  }
  addReferrer(t) {
    this._shared.get()._addReferrer(t);
  }
  getReferrers() {
    return this._shared.get()._getReferrers();
  }
  getProductOccurrence() {
    return this._shared.get()._getPrototype();
  }
  removeReferrer(t) {
    if (this._shared.get()._removeReferrer(t)) {
      const e = t.removePrototype();
      return console.assert(this === e), !0;
    }
    return !1;
  }
  removeAllReferrers() {
    const t = this.getReferrers();
    for (const e of t)
      this.removeReferrer(e) || console.assert(!1);
  }
  purgeContents() {
    return this._shared.get()._purgeContents();
  }
  isLoaded() {
    return this._shared.get()._isLoaded();
  }
}
function Do(n) {
  return "modelName" in n;
}
function Zf(n) {
  return !Do(n);
}
function Dd(n) {
  return n.config.implicitlyLoadXmlExternalModels || Zf(n);
}
class wh {
  static create(t) {
    return new wh(t);
  }
  constructor(t) {
    this.value = t;
  }
}
function vh(n) {
  if (n.length === 0)
    return;
  const t = n[0].getBranchVisibility();
  for (let e = 1, i = n.length; e < i; ++e)
    if (t !== n[e].getBranchVisibility())
      return Pt.Mixed;
  return t;
}
function Cf(n) {
  const t = n.getBodyInstances();
  if (t.length === 0)
    return;
  const e = t[0].isVisible();
  for (let i = 1, s = t.length; i < s; ++i)
    if (e !== t[i].isVisible())
      return Pt.Mixed;
  return e ? Pt.Shown : Pt.Hidden;
}
function kf(n) {
  return vh(n.getChildrenSync());
}
function Mf(n) {
  return vh(n.getPmis());
}
function Wf(n) {
  return vh(n.getCadViews());
}
function Pf(n) {
  const t = n.isVisible() ? Pt.Shown : Pt.Hidden, e = kf(n);
  if (e !== void 0 && e !== t)
    return Pt.Mixed;
  const i = Cf(n);
  if (i !== void 0 && i !== t)
    return Pt.Mixed;
  const s = Mf(n);
  if (s !== void 0 && s !== t)
    return Pt.Mixed;
  const r = Wf(n);
  return r !== void 0 && r !== t ? Pt.Mixed : e === void 0 && i === void 0 && s === void 0 && r === void 0 ? null : t;
}
const Vf = -2;
function wr(n, t) {
  const e = [];
  for (const i of n) {
    const s = t(i);
    s && e.push(s);
  }
  return zt(e);
}
var Zc = /* @__PURE__ */ ((n) => (n[n.NodeTypeDrawingSheet = 6] = "NodeTypeDrawingSheet", n))(Zc || {}), ne = ((n) => (n[n.IsAConfigurationNode = he.IsAConfigurationNode] = "IsAConfigurationNode", n[n.NodeTypeProduct = he.NodeTypeProduct] = "NodeTypeProduct", n[n.NodeTypeGroup = he.NodeTypeGroup] = "NodeTypeGroup", n[n.NodeTypeDrawingSheet = he.NodeTypeDrawingSheet] = "NodeTypeDrawingSheet", n[n.NodeTypeDrawingView = he.NodeTypeDrawingView] = "NodeTypeDrawingView", n[n.IsADefaultNodeType = he.IsADefaultNodeType] = "IsADefaultNodeType", n[n.BranchVisibilityHidden = he.BranchVisibilityHidden] = "BranchVisibilityHidden", n[n.BranchVisibilityShown = he.BranchVisibilityShown] = "BranchVisibilityShown", n[n.BranchVisibilityDirty = he.BranchVisibilityDirty] = "BranchVisibilityDirty", n[n.IsMissing = he.IsMissing] = "IsMissing", n[n.OutOfHierarchy = he.OutOfHierarchy] = "OutOfHierarchy", n[n.IsExternalModelRoot = he.IsExternalModelRoot] = "IsExternalModelRoot", n))(ne || {});
class Yt extends Pi {
  constructor(t, e, i, s, r, o, a) {
    a = Yt._amendInfo(s, a);
    const l = Ce(r), c = l.getMasterModelKey(), h = gn(l);
    super(s, c, a.nodeInfo), this._parent = o, this._bits |= a.productBits | ne.BranchVisibilityDirty;
    const u = a.nodeInfo.header, p = [];
    if (a.prototypeDataKey !== null && (console.assert(i !== null), this._prototypeContext = this._loadPrototypeContext(
      e,
      i,
      s,
      r,
      a.prototypeDataKey,
      u
    )), console.assert(a.quickAccessPartDefinitionDataId === null || a.partDefinition === null), a.partDefinition !== null ? Array.isArray(a.partDefinition) ? this._partDefinition = this._lazyLoadPartDefinitionById(
      s,
      r,
      a.partDefinition,
      u,
      e
    ) : this._partDefinition = this._lazyLoadPartDefinitionByInfo(
      s,
      r,
      a.partDefinition,
      c
    ) : a.quickAccessPartDefinitionDataId !== null && (this._partDefinition = this._lazyLoadPartDefinitionById(
      s,
      r,
      a.quickAccessPartDefinitionDataId,
      u,
      e
    )), a.childDataKeys.length > 0) {
      console.assert(i !== null);
      const g = (async () => {
        const _ = await this._loadProductOccurrences(
          e,
          i,
          s,
          r,
          a.childDataKeys,
          u
        );
        this._children = zi(_);
      })();
      p.push(g);
    }
    if (a.bodyInstanceInfos.length > 0) {
      const g = this._loadBodyInstances(
        s,
        c,
        a.bodyInstanceInfos
      );
      this._bodyInstances = zi(g);
    }
    if (a.cadViewInfos.length > 0) {
      const g = this._loadCadViews(s, r, a.cadViewInfos);
      this._cadViews = zi(g);
    }
    if (a.pmiInfos.length > 0) {
      const g = this._loadPmis(s, r, a.pmiInfos);
      this._pmis = zi(g);
    }
    if (a.measurementUnit !== null && (this._measurementUnit = a.measurementUnit), a.externalModelInfo !== null)
      if (console.assert(t !== null), console.assert(i !== null), Dd(a.externalModelInfo)) {
        const g = this._loadAndAttachExternalModel(
          i,
          r,
          a.externalModelInfo
        );
        p.push(g);
      } else
        this._pendingExternalModels = Mi(this._pendingExternalModels, a.externalModelInfo);
    for (const g of a.layerInfos) {
      const _ = h.getRuntimeLayerId(g.id);
      _ === null ? s.createLayer(g.id, g.name, h) : g.name !== null && s.updateLayerName(_, g.name);
    }
    for (const g of a.filters)
      s.addFilter(g, h);
    for (const g of a.relationships)
      r.addRelationship(g);
    for (const g of a.bimInfos)
      r.addBimInfos(g);
    const m = this.getAuthoredLayerId();
    if (m !== null && (s.registerNodeInLayer(this, m), this.isOutOfHierarchy() || s.registerTreeNodeInLayer(this, m)), s.registerProductOccurrence(this), t === null) {
      if (p.length > 0)
        throw new re();
    } else
      t.resolve(zt(p));
  }
  static parseXml(t, e, i, s, r) {
    const o = i.getInclusionKey(), a = Es.parseXml(e, s, t), l = we.parseFloat(s, "Unit"), c = [], h = [], u = [], p = [], m = [], g = [];
    let _ = null, y = null, b = null, w = s.firstElementChild;
    for (; w !== null; ) {
      if (w.localName === "PartDefinition") {
        _ = Ei.parseXml(e, w, t);
        break;
      } else if (w.localName === "BodyInstance") {
        const v = Ve.parseXml(
          e,
          w,
          o,
          t
        );
        c.push(v);
      } else if (w.localName === "Material")
        console.assert(y === null), y = gh.parseXml(w);
      else if (w.localName === "ExternalModel") {
        console.assert(b === null);
        const v = w.getAttribute("Name");
        if (v !== null) {
          const C = we.parseFloat(w, "Unit"), k = we.parseBounding(w, "BoundingBox");
          b = {
            config: t,
            modelName: v,
            bounding: k,
            measurementUnit: C,
            toAttachData: r,
            reservedNodeIdOffset: 0
          };
        }
      } else if (w.localName === "CADView" && !t.ignoreCadViews) {
        const v = Ni.parseXml(e, w, i, t);
        g.push(v);
      } else if (w.localName === "Filter" && !t.ignoreFilters)
        h.push(Ko.parseXml(w));
      else if (w.localName === "Layer" && !t.ignoreLayers) {
        const v = Ys.parseXml(w);
        v !== null && u.push(v);
      } else if (w.localName === "Relationships" && !t.ignoreBimRelationships) {
        const v = cr.parseXml(w);
        if (v !== null && p.push(v), v.related !== null)
          for (const C of v.related.relationships)
            tr.findBimObjectInArray(m, C) === !1 && m.push(C);
        v.relating !== null && tr.findBimObjectInArray(
          m,
          v.relating.relationElt
        ) === !1 && m.push(v.relating.relationElt);
      }
      w = w.nextElementSibling;
    }
    return {
      nodeInfo: a,
      productBits: 0,
      childDataKeys: [],
      prototypeDataKey: null,
      partDefinition: _,
      quickAccessPartDefinitionDataId: null,
      externalModelInfo: b,
      bodyInstanceInfos: c,
      cadViewInfos: g,
      pmiInfos: [],
      measurementUnit: l,
      simpleMaterial: y,
      layerInfos: u,
      filters: h,
      relationships: p,
      bimInfos: m
    };
  }
  static parseBinary(t, e, i, s) {
    const r = Ce(i), o = r.getRemapper(), a = s.parseNodeParseBits();
    if (a.hasBits1(Qt.VersionNumber) && s.parseAssemblyDataVersion(2), a.hasBits2(Un.GenericTypes)) {
      const P = s.parseGenericTypes();
      t.ignoreGenericTypes || r.setGenericTypeMaps(P);
    }
    const l = Es.parseBinary(e, s, a, t);
    let c = 0;
    a.hasBits1(Qt.ProductBits) && (c = s.parseProductBits());
    const h = [];
    if (a.hasBits1(Qt.SubNodes)) {
      const P = s.parseCount_32();
      for (let L = 0; L < P; ++L) {
        const N = s.parseDataKey();
        h.push(N);
      }
    }
    let u = null, p = null;
    if (a.hasBits1(Qt.Instance) && (u = s.parseDataKey(), a.hasBits1(Qt.InstanceQuickAccess))) {
      const P = s.parseModelKey(o);
      console.assert(P !== Bi.Local);
      const L = s.parseDataKey();
      p = [P, L];
    }
    const m = [];
    if (a.hasBits1(Qt.BodyInstances)) {
      const P = s.parseCount_32();
      for (let L = 0; L < P; ++L) {
        const N = Ve.parseBinary(
          e,
          i,
          s,
          t
        );
        m.push(N);
      }
    }
    let g = null;
    if (a.hasBits1(Qt.ExternalModel)) {
      const P = s.parseModelKey(o);
      console.assert(P !== Bi.Local);
      const L = s.parseInclusionKey(o, P);
      g = {
        config: t,
        inclusionKey: L,
        modelKey: P
      };
    }
    let _ = null;
    if (a.hasBits1(Qt.PartDataLink)) {
      let P = s.parseModelKey(o);
      P === Bi.Local && (P = r.getMasterModelKey());
      const L = s.parseDataKey();
      _ = [P, L];
    }
    const y = [];
    if (a.hasBits1(Qt.Views)) {
      const P = s.parseCount_32();
      for (let L = 0; L < P; ++L) {
        const N = Ni.parseBinary(e, i, s, t);
        t.ignoreCadViews || y.push(N);
      }
    }
    const b = [];
    if (a.hasBits1(Qt.Pmis)) {
      const P = s.parseCount_32();
      for (let L = 0; L < P; ++L) {
        const N = gi.parseBinary(e, i, s, t);
        b.push(N);
      }
    }
    let w = null;
    if (a.hasBits1(Qt.Unit) && (w = s.parseFloat_64()), a.hasBits1(Qt.FrontUpVector)) {
      const P = s.parsePoint3_64(), L = s.parsePoint3_64();
      e.setViewAxes(P, L);
    }
    const v = [];
    if (a.hasBits1(Qt.LayerList)) {
      const P = s.parseCount_32();
      for (let L = 0; L < P; ++L) {
        const N = Ys.parseBinary(s);
        t.ignoreLayers || v.push(N);
      }
    }
    const C = [];
    if (a.hasBits1(Qt.Filters)) {
      const P = s.parseCount_32();
      for (let L = 0; L < P; ++L) {
        const N = Ko.parseBinary(s);
        t.ignoreFilters || C.push(N);
      }
    }
    const k = [], Y = [];
    if (a.hasBits2(Un.Relationships)) {
      const P = s.parseCount_32();
      for (let L = 0; L < P; ++L) {
        const N = cr.parseBinary(i, s);
        if (t.ignoreBimRelationships || k.push(N), N.relating !== null && !t.ignoreBimRelationships && (tr.findBimObjectInArray(Y, N.relating.relationElt) === !1 && Y.push(N.relating.relationElt), N.related !== null))
          for (const D of N.related.relationships)
            tr.findBimObjectInArray(Y, D) === !1 && Y.push(D);
      }
    }
    return {
      nodeInfo: l,
      productBits: c,
      childDataKeys: h,
      prototypeDataKey: u,
      partDefinition: _,
      quickAccessPartDefinitionDataId: p,
      externalModelInfo: g,
      bodyInstanceInfos: m,
      cadViewInfos: y,
      pmiInfos: b,
      measurementUnit: w,
      simpleMaterial: null,
      layerInfos: v,
      filters: C,
      relationships: k,
      bimInfos: Y
    };
  }
  /**
   * Like `reify` but with a synchronous return result.
   *
   * Usage requirements:
   *      - `info.childDataKeys` must be empty.
   *      - `info.externalModelInfo` must be `null`.
   */
  static reifySync(t, e, i, s, r, o) {
    console.assert(r.childDataKeys.length === 0), console.assert(r.externalModelInfo === null);
    const a = Ce(s), l = new Yt(
      null,
      t,
      e,
      i,
      s,
      o,
      r
    );
    return a.attachedInvisibly() && l.setVisibility(!1), l;
  }
  static async reify(t, e, i, s, r, o) {
    const a = ye(), l = new Yt(
      a,
      t,
      e,
      i,
      s,
      o,
      r
    );
    return await a, l;
  }
  static createDynamic(t, e, i, s, r, o, a = !1, l = null) {
    const c = Ne(e), h = t.massageAuthoredUserId(c, s), u = o ? We.InitiallyShown : 0, p = {
      nodeId: h,
      bits: u,
      name: i,
      localTransform: r,
      attributes: [],
      header: _n.dynamic,
      exchangeId: null,
      layerId: null,
      genericTypeId: null,
      genericId: null,
      userDatas: null
    }, m = a ? ne.OutOfHierarchy : 0, g = {
      nodeInfo: p,
      productBits: m,
      childDataKeys: [],
      prototypeDataKey: null,
      partDefinition: null,
      quickAccessPartDefinitionDataId: null,
      bodyInstanceInfos: [],
      externalModelInfo: null,
      cadViewInfos: [],
      pmiInfos: [],
      measurementUnit: l,
      simpleMaterial: null,
      layerInfos: [],
      filters: [],
      relationships: [],
      bimInfos: []
    }, _ = new hr();
    return _.attachInvisibly = !o, new Yt(
      null,
      _,
      null,
      t,
      c,
      e,
      g
    );
  }
  static createMissing(t, e) {
    const i = this.createDynamic(t, e, "Missing", null, null, !1);
    return i._bits |= ne.IsMissing, i;
  }
  isMissing() {
    return this._hasBits(ne.IsMissing);
  }
  static _amendInfo(t, e) {
    if (e.nodeInfo.name !== null)
      return e;
    let i = null;
    if (Ct(e.productBits, ne.NodeTypeProduct) ? i = t.generateProductName() : Ct(e.productBits, ne.NodeTypeGroup) ? i = t.generateGroupName() : Ct(e.productBits, ne.NodeTypeDrawingSheet) ? i = t.generateDrawingSheetName() : Ct(e.productBits, ne.NodeTypeDrawingView) && (i = t.generateDrawingViewName()), i === null)
      return e;
    const s = { ...e.nodeInfo, name: i };
    return { ...e, nodeInfo: s };
  }
  async _loadExternalModel(t, e, i) {
    if (Do(i))
      return t.attachByExternalModelInfo(i, this, e);
    const s = this.getAuthoredId();
    return gn(e).handleExternalModel(s, e, i.inclusionKey) ? t.attachByExternalModelInfo(i, this, e) : null;
  }
  async _loadAndAttachExternalModel(t, e, i) {
    const s = await this._loadExternalModel(
      t,
      e,
      i
    );
    return s !== null && this.addAttachContext(s), s;
  }
  async loadPendingExternalModels(t) {
    if (!this.hasPendingExternalModels())
      return [];
    const e = Ne(this), i = [];
    for (const r of se(this._pendingExternalModels)) {
      const o = this._loadAndAttachExternalModel(t, e, r);
      i.push(o);
    }
    delete this._pendingExternalModels;
    const s = [];
    for (const r of await Promise.all(i))
      r !== null && s.push(r);
    return s;
  }
  _lazyLoadPartDefinitionByInfo(t, e, i, s) {
    const r = s, o = Ei.reify(t, e, r, i);
    return xi.create(o);
  }
  _lazyLoadPartDefinitionById(t, e, i, s, r) {
    const o = t.getAbstractScEngine(), a = gn(e);
    let l = t.lookupPartDefinitionByDataId(
      a,
      i[0],
      i[1]
    );
    return l !== null ? xi.create(async () => {
      const c = await l;
      return c.addReferrer(this), c;
    }) : (l = xi.create(async () => {
      const c = i[0], h = i[1], u = await t.enqueue(() => o.safeGetMetaData(c, h));
      if (u !== null) {
        const p = new sr(s, u), m = new zo(p), g = Ei.parseBinary(t, m, r), _ = Ei.reify(t, e, c, g);
        return _.addReferrer(this), _;
      }
      return Ei.createMissing(t);
    }), t.registerPartDefinitionByDataId(
      a,
      i[0],
      i[1],
      l
    ), l);
  }
  static async _loadProductOccurrence(t, e, i, s, r, o) {
    const a = new zo(r), l = Yt.parseBinary(t, i, s, a);
    return Yt.reify(
      t,
      e,
      i,
      s,
      l,
      o
    );
  }
  _loadPrototypeContext(t, e, i, s, r, o) {
    const a = Ce(s), l = gn(a), h = a.getMasterModelKey(), u = {
      prototypeContext: null,
      sharedPrototypeContext: i.lookupPrototypeByDataId(
        l,
        h,
        r
      )
    };
    if (u.sharedPrototypeContext === null) {
      const p = xi.create(async () => {
        const m = i.getAbstractScEngine(), g = await i.enqueue(() => m.safeGetMetaData(h, r));
        if (g !== null) {
          const _ = new sr(o, g);
          return Yt._loadProductOccurrence(
            t,
            e,
            i,
            s,
            _,
            u.prototypeContext
          );
        }
        return Yt.createMissing(i, u.prototypeContext);
      });
      u.sharedPrototypeContext = new Ih(p), i.registerPrototypeByDataId(
        l,
        h,
        r,
        u.sharedPrototypeContext
      );
    }
    return u.prototypeContext = new Mr(u.sharedPrototypeContext, s), u.prototypeContext.addReferrer(this), u.prototypeContext;
  }
  async _loadProductOccurrences(t, e, i, s, r, o) {
    const c = Ce(s).getMasterModelKey(), h = i.getAbstractScEngine(), u = await i.enqueue(() => h.safeGetMetaDatas(c, r)), p = [];
    for (let m = 0; m < r.length; ++m) {
      let g;
      if (u !== null) {
        const _ = u[m];
        u[m] = new Uint8Array(0);
        const y = new sr(o, _);
        g = await Yt._loadProductOccurrence(
          t,
          e,
          i,
          s,
          y,
          this
        );
        const b = e.onLoadChildProductOccurrence();
        b && await b;
      } else
        g = Yt.createMissing(i, this);
      p.push(g);
    }
    return p;
  }
  _loadBodyInstances(t, e, i) {
    const s = [];
    for (const r of i) {
      const o = Ve.reify(t, e, this, r);
      s.push(o);
    }
    return s;
  }
  _loadCadViews(t, e, i) {
    const s = [];
    for (const r of i) {
      const o = Ni.reify(t, e, r, this);
      s.push(o), o.markLoaded();
    }
    return s;
  }
  _loadPmis(t, e, i) {
    const s = [];
    for (const r of i) {
      const o = gi.reify(t, e, r, this);
      s.push(o);
    }
    return s;
  }
  getParent() {
    return this._parent;
  }
  getRuntimeId() {
    return Ks(this._nodeId, this);
  }
  isAbsoluteRoot() {
    return this._nodeId === Vf;
  }
  getPrototype() {
    return this._prototypeContext !== void 0 ? this._prototypeContext : null;
  }
  isAConfigurationNode() {
    return this._hasBits(ne.IsAConfigurationNode);
  }
  isADefaultNode() {
    return this._hasBits(ne.IsADefaultNodeType);
  }
  isAProductNode() {
    return Ct(this._bits, ne.NodeTypeProduct);
  }
  isAGroupNode() {
    return Ct(this._bits, ne.NodeTypeGroup);
  }
  isADrawingSheetNode() {
    return Ct(this._bits, ne.NodeTypeDrawingSheet);
  }
  isADrawingViewNode() {
    return Ct(this._bits, ne.NodeTypeDrawingView);
  }
  addProductOccurrence(t) {
    console.assert(t.getParent() === this), this._children = Mi(this._children, t), this._itemWasAdded();
  }
  addBodyInstance(t) {
    console.assert(t.getParent() === this), this._bodyInstances = Mi(this._bodyInstances, t), this._itemWasAdded();
  }
  addCadView(t) {
    console.assert(t.getParent() === this), this._cadViews = Mi(this._cadViews, t), this._itemWasAdded();
  }
  addPmi(t) {
    console.assert(t.getParent() === this), this._pmis = Mi(this._pmis, t), this._itemWasAdded();
  }
  addLoadContext(t) {
    console.assert(t.getParent() === this), this._childContexts = Mi(this._childContexts, t), this._itemWasAdded();
  }
  addAttachContext(t) {
    console.assert(t.getParent() === this), this._childContexts = Mi(this._childContexts, t), this._itemWasAdded();
  }
  _followPrototypesWhileEmpty() {
    if (this._prototypeContext === void 0 || this._children !== void 0 || this._childContexts !== void 0)
      return this;
    const t = this._prototypeContext.getProductOccurrence();
    return t.isResolved() ? t.getResolved()._followPrototypesWhileEmpty() : this;
  }
  // Boxed because [[Promise.resolve<Thenable<T>>(x) => Promise<T>]], not [[Promise<<Thenable<T>>>]].
  getRawPartDefinition() {
    if (this._partDefinition !== void 0)
      return this._partDefinition;
    if (this._prototypeContext !== void 0) {
      const t = this._prototypeContext.getProductOccurrence();
      return t.isResolved() ? t.getResolved().getRawPartDefinition() : null;
    }
    return null;
  }
  // Boxed because [[Promise.resolve<Thenable<T>>(x) => Promise<T>]], not [[Promise<<Thenable<T>>>]].
  async getPartDefinition() {
    const t = this.getRawPartDefinition();
    return t instanceof xi ? wh.create(t) : t instanceof Promise ? t : null;
  }
  getPartDefinitionSync() {
    if (console.assert(this.isLoaded()), this._partDefinition !== void 0 && this._partDefinition.isResolved())
      return this._partDefinition.getResolved();
    if (this._prototypeContext !== void 0) {
      const t = this._prototypeContext.getProductOccurrence();
      if (t.isResolved())
        return t.getResolved().getPartDefinitionSync();
    }
    return null;
  }
  getChildContexts() {
    return se(this._childContexts);
  }
  _getChildren() {
    const t = se(this._children), e = se(this._childContexts);
    for (const i of e)
      t.push(...i.getChildren());
    return t;
  }
  async getChildren() {
    return (await this._followPrototypesWhileEmpty())._getChildren();
  }
  getChildrenSync() {
    console.assert(this.isLoaded());
    const t = this.tryGetChildrenSync();
    if (t === null)
      throw new re();
    return t;
  }
  tryGetChildrenSync() {
    const t = this._followPrototypesWhileEmpty();
    return t instanceof Promise ? null : t._getChildren();
  }
  async forEachChild(t) {
    const e = await this.getChildren();
    return wr(e, t);
  }
  forEachBodyInstance(t) {
    const e = this.getBodyInstances();
    return wr(e, t);
  }
  forEachPmi(t) {
    const e = this.getPmis();
    return wr(e, t);
  }
  forEachCadView(t) {
    const e = this.getCadViews();
    return wr(e, t);
  }
  hasBodyInstances() {
    return this._bodyInstances !== void 0;
  }
  getBodyInstances() {
    return se(this._bodyInstances);
  }
  getCadViews() {
    return se(this._cadViews);
  }
  getPmis() {
    return se(this._pmis);
  }
  setMeasurementUnit(t) {
    this._measurementUnit = t;
  }
  unsetMeasurementUnit() {
    this._measurementUnit = void 0;
  }
  hasMeasurementUnit() {
    return this._measurementUnit !== void 0;
  }
  getMeasurementUnit() {
    let t = this;
    do {
      if (t._measurementUnit !== void 0)
        return t._measurementUnit;
      t = Pn(t._parent);
    } while (t !== null);
    return 1;
  }
  async getPhysicalProperties(t) {
    const e = async () => {
      if (Array.isArray(this._children)) {
        const p = [];
        for (const w of this._children)
          await Ao(w), p.push(await w.getPhysicalProperties(t));
        if (!p.some((w) => w !== null))
          return null;
        let m = 0, g = 0;
        const _ = d.zero();
        let y = 0;
        if (p.forEach((w) => {
          w !== null && (y += 1, m += w.volume, g += w.surfaceArea, _.add(w.centerOfGravity));
        }), y === 0)
          return null;
        const b = d.scale(_, 1 / y);
        return Promise.resolve(new nr(g, m, b));
      }
      return this._children instanceof Yt ? (await Ao(this._children), this._children.getPhysicalProperties(t)) : null;
    }, i = await this.getPartDefinition();
    if (i === null)
      return t ? e() : null;
    const r = (await i.value).getRepresentationItems();
    if (r.length === 0)
      return t ? e() : null;
    let o = 0, a = 0;
    const l = d.zero();
    let c = 0;
    for (const p of r) {
      const m = p.getPhysicalProperties();
      m !== null && (o += m.volume, a += m.surfaceArea, l.add(m.centerOfGravity), c++);
    }
    c !== 0 && l.scale(1 / c);
    const h = new nr(a, o, l), u = await e();
    return u !== null ? new nr(
      h.surfaceArea + u.surfaceArea,
      h.volume + u.volume,
      d.add(h.centerOfGravity, u.centerOfGravity).scale(0.5)
    ) : h;
  }
  setPartDefinition(t) {
    console.assert(this._partDefinition === void 0), this._partDefinition = xi.create(t);
  }
  setPrototype(t) {
    console.assert(this._prototypeContext === void 0), this._prototypeContext = t, this._markBranchVisibilityDirty(!1);
  }
  removePrototype() {
    if (this._prototypeContext === void 0)
      throw new re();
    const t = this._prototypeContext;
    return delete this._prototypeContext, this._markBranchVisibilityDirty(!1), t;
  }
  getBranchVisibility() {
    return this._updateBranchVisibility(), this._getBranchVisibility();
  }
  _getBranchVisibility() {
    let t = this.isVisible() ? Pt.Shown : Pt.Hidden;
    return this._hasBits(ne.BranchVisibilityShown) && t !== Pt.Shown && (t = Pt.Mixed), this._hasBits(ne.BranchVisibilityHidden) && t !== Pt.Hidden && (t = Pt.Mixed), t;
  }
  _setBranchVisibility(t) {
    const e = this.isVisible();
    console.assert(e ? t !== Pt.Hidden : t === Pt.Hidden), this._bits &= ~(ne.BranchVisibilityHidden | ne.BranchVisibilityShown), (t === Pt.Hidden || t === Pt.Mixed) && (this._bits |= ne.BranchVisibilityHidden), (Ct(t, Pt.Shown) || t === Pt.Mixed) && (this._bits |= ne.BranchVisibilityShown);
  }
  _updateBranchVisibility() {
    if (!this._hasBits(ne.BranchVisibilityDirty))
      return;
    let t = this.isVisible() ? Pt.Shown : Pt.Hidden;
    const e = this._getSubBranchVisibilities();
    e !== null && e !== t && (t = Pt.Mixed), this._setBranchVisibility(t), this._bits &= ~ne.BranchVisibilityDirty;
  }
  _getSubBranchVisibilities() {
    return Pf(this);
  }
  _itemWasAdded() {
    this._getBranchVisibility() !== Pt.Mixed && this._markBranchVisibilityDirty(!0);
  }
  _onItemRemoved() {
    this._getBranchVisibility() !== Pt.Hidden && this._markBranchVisibilityDirty(!1);
  }
  markBranchVisibilityDirty() {
    this._markBranchVisibilityDirty(!1);
  }
  _markBranchVisibilityDirty(t) {
    if (!this._hasBits(ne.BranchVisibilityDirty) && !(t && this._getBranchVisibility() === Pt.Mixed))
      if (this._bits |= ne.BranchVisibilityDirty, this._parent instanceof Mr) {
        const e = this._parent.getReferrers();
        for (const i of e)
          i._markBranchVisibilityDirty(t);
      } else {
        const e = Pn(this._parent);
        if (e !== null)
          return e._markBranchVisibilityDirty(t);
      }
  }
  setVisibility(t) {
    this.isVisible() !== t && (this._setVisibility(t), this._markBranchVisibilityDirty(!1));
  }
  _removeDirectChild(t) {
    let e = se(this._children);
    const i = e.length;
    return e = e.filter((s) => s !== t), e.length === i ? !1 : (e.length === 0 ? delete this._children : this._children = zi(e), this._onItemRemoved(), !0);
  }
  _removeIndirectChild(t) {
    let e = !1, i = se(this._childContexts);
    for (const s of i)
      if (s.removeProductOccurrence(t)) {
        e = !0;
        break;
      }
    return e ? (i = i.filter((s) => s.hasChildren()), i.length === 0 ? delete this._childContexts : this._childContexts = zi(i), this._onItemRemoved(), !0) : !1;
  }
  removeProductOccurrence(t) {
    return this._removeDirectChild(t) ? !0 : this._removeIndirectChild(t);
  }
  removePmi(t) {
    let e = se(this._pmis);
    const i = e.length;
    return e = e.filter((s) => s !== t), e.length === i ? !1 : (e.length === 0 ? delete this._pmis : this._pmis = zi(e), this._onItemRemoved(), !0);
  }
  removeBodyInstance(t) {
    let e = se(this._bodyInstances);
    const i = e.length;
    return e = e.filter((s) => s !== t), e.length === i ? !1 : (e.length === 0 ? delete this._bodyInstances : this._bodyInstances = zi(e), this._onItemRemoved(), !0);
  }
  purgeContents() {
    this._markBranchVisibilityDirty(!1);
    const t = [];
    let e;
    this._partDefinition !== void 0 && (this._partDefinition.isUnforced() || (e = this._partDefinition.then((r) => {
      r.removeAllReferrers(), delete this._partDefinition;
    }), t.push(e))), this._prototypeContext !== void 0 && (e = this._prototypeContext.purgeContents(), t.push(e), this._prototypeContext.removeReferrer(this), delete this._prototypeContext);
    const i = se(this._children);
    e = wr(i, (r) => r.purgeContents()), t.push(e), delete this._children;
    const s = se(this._childContexts);
    return e = wr(s, (r) => r.purgeContents()), t.push(e), delete this._childContexts, delete this._bodyInstances, delete this._cadViews, delete this._pmis, delete this._measurementUnit, zt(t);
  }
  removePartDefinition() {
    if (this._partDefinition === void 0 || !this._partDefinition.isResolved())
      throw new re();
    const t = this._partDefinition;
    return delete this._partDefinition, t.getResolved();
  }
  isOutOfHierarchy() {
    return this._hasBits(ne.OutOfHierarchy);
  }
  markIsExternalModelRoot(t) {
    console.assert(!this._hasBits(ne.IsExternalModelRoot)), this._bits |= ne.IsExternalModelRoot, t.markSeenExternalModel();
  }
  isExternalModelRoot() {
    return this._hasBits(ne.IsExternalModelRoot);
  }
  addPendingExternalModel(t) {
    this._pendingExternalModels = Mi(this._pendingExternalModels, t);
  }
  hasPendingExternalModels() {
    return !Og(this._pendingExternalModels);
  }
}
class zd {
  constructor() {
    this._leftToRight = /* @__PURE__ */ new Map(), this._rightToLeft = /* @__PURE__ */ new Map();
  }
  set(t, e) {
    this._leftToRight.set(t, e), this._rightToLeft.set(e, t);
  }
  getLeft(t) {
    return this._rightToLeft.get(t);
  }
  getRight(t) {
    return this._leftToRight.get(t);
  }
}
class Jd {
  constructor() {
    this._bits1 = 0, this._bits2 = 0;
  }
  hasBits1(t) {
    return Ct(this._bits1, t);
  }
  hasBits2(t) {
    return Ct(this._bits2, t);
  }
  parseBits1(t) {
    this._bits1 = t.parseIndex_32();
  }
  parseBits2(t) {
    this.hasBits1(Qt.UseNodeParseBits2) && (this._bits2 = t.parseIndex_32());
  }
}
class Yf {
  constructor(t, e) {
    this.shown = t, this.removed = e;
  }
}
class zo {
  constructor(t) {
    this._bytes = t.bytes, this._header = t.header, this._dataView = new DataView(
      this._bytes.buffer,
      this._bytes.byteOffset,
      this._bytes.byteLength
    ), this._currentPos = 0;
  }
  hasNext() {
    return this._currentPos < this._bytes.length;
  }
  parseCount_32() {
    return this._parseUint_32();
  }
  parseIndex_32() {
    return this._parseUint_32();
  }
  parseAssemblyDataVersion(t) {
    const e = [];
    for (let i = 0; i < t; ++i)
      e.push(this._parseUint_32());
    return e;
  }
  parseAssemblyDataHeaderVersion() {
    return this._parseUint_32();
  }
  parseVisibility() {
    let t;
    ((r) => {
      r[r.Removed = 1] = "Removed", r[r.Shown = 2] = "Shown";
    })(t || (t = {}));
    const e = this._parseInt_8(), i = Ct(
      e,
      2
      /* Shown */
    ), s = Ct(
      e,
      1
      /* Removed */
    );
    return new Yf(i, s);
  }
  parseProductBits() {
    let t = this._parseUint_8();
    return this._header !== null && this._header.headerVersion >= 2 || !Ct(t, Zc.NodeTypeDrawingSheet) || (t &= ~Zc.NodeTypeDrawingSheet, t |= ne.NodeTypeDrawingSheet), t;
  }
  parseUnits() {
    const t = this.parseInt32(), e = [];
    for (let i = 0; i < t; i++) {
      const s = this.parseUInt32(), r = this.parseInt32(), o = this.parseFloat_64();
      e.push({
        basicUnit: s,
        exponent: r,
        factor: o
      });
    }
    return e;
  }
  parseCString() {
    const t = this._currentPos;
    let e = this._bytes[this._currentPos++];
    for (; e !== 0; )
      e = this._bytes[this._currentPos++];
    return Rg(this._bytes.subarray(t, this._currentPos - 1));
  }
  parseUInt32() {
    return this._parseUint_32();
  }
  parseInt32() {
    return this._parseInt_32();
  }
  parseBytes(t) {
    const e = this._currentPos;
    this._currentPos += t;
    const i = this._bytes.subarray(e, this._currentPos);
    return new Uint8Array(i);
  }
  parseNodeId() {
    const t = this._parseUint_32();
    return console.assert(t !== en), t;
  }
  parseLayerId() {
    const t = this._parseUint_32();
    return console.assert(t !== en), t;
  }
  parseGenericTypes() {
    const t = this._parseUint_32(), e = new zd();
    for (let i = 0; i < t; i++) {
      const s = this.parseCString(), r = this._parseUint_32();
      e.set(r, s);
    }
    return e;
  }
  parseGenericTypeId() {
    return this._parseUint_32();
  }
  parseGenericId() {
    return this.parseCString();
  }
  _parseScKey() {
    const t = this._parseUint_32();
    return console.assert(t !== ah.Invalid), t;
  }
  parseDataKey() {
    return this._parseScKey();
  }
  parseInstanceKey() {
    return this._parseScKey();
  }
  parseMeshKey() {
    return this._parseScKey();
  }
  parseModelKey(t) {
    const e = this._parseScKey();
    return t !== null ? t.getEffectiveModelKey(e) : e;
  }
  parseInclusionKey(t, e) {
    const i = this._parseScKey();
    return t !== null ? t.getEffectiveInclusionKey(i, e) : i;
  }
  parseMatrix() {
    const t = this._header !== null && this._header.doublePrecisionMatrices ? () => this.parseFloat_64() : () => this.parseFloat_32(), e = Xi.getIdentity();
    for (let i = 0; i < 4; ++i)
      for (let s = 0; s < 3; ++s)
        e[4 * i + s] = t();
    return e;
  }
  _parseInt_8() {
    return this._dataView.getInt8(this._currentPos++);
  }
  _parseUint_8() {
    return this._dataView.getUint8(this._currentPos++);
  }
  _parseUint_32() {
    const t = this._dataView.getUint32(this._currentPos, !0);
    return this._currentPos += 4, t;
  }
  _parseInt_32() {
    const t = this._dataView.getInt32(this._currentPos, !0);
    return this._currentPos += 4, t;
  }
  _parseFloat_32() {
    const t = this._dataView.getFloat32(this._currentPos, !0);
    return this._currentPos += 4, t;
  }
  _parseFloat_64() {
    const t = this._dataView.getFloat64(this._currentPos, !0);
    return this._currentPos += 8, t;
  }
  parseFloat_32() {
    return this._parseFloat_32();
  }
  parseFloat_64() {
    return this._parseFloat_64();
  }
  parseAttributeType() {
    return this._parseInt_8();
  }
  parseNodeParseBits() {
    const t = new Jd();
    return t.parseBits1(this), t.parseBits2(this), t;
  }
  parseViewParseBits() {
    return this._parseUint_32();
  }
  parsePmiParseBits() {
    return this._parseUint_32();
  }
  parseLayerParseBits() {
    return this._parseUint_32();
  }
  parseAttributeParseBits() {
    return this._parseUint_32();
  }
  parseRelationshipParseBits() {
    return this._parseUint_32();
  }
  parseBoolean() {
    return this._parseUint_8() !== 0;
  }
  parsePoint3_32() {
    return new d(this._parseFloat_32(), this._parseFloat_32(), this._parseFloat_32());
  }
  parsePoint3_64() {
    return new d(this._parseFloat_64(), this._parseFloat_64(), this._parseFloat_64());
  }
  parsePlane3_32() {
    return je.createFromCoefficients(
      this._parseFloat_32(),
      this._parseFloat_32(),
      this._parseFloat_32(),
      this._parseFloat_32()
    );
  }
  parsePmiType() {
    return this._parseUint_32();
  }
  parsePmiSubType() {
    return this._parseUint_32();
  }
  parsePmiTopoRef() {
    return this._parseInt_8();
  }
  parseBodyType() {
    return this._parseUint_8();
  }
  parseFaceType() {
    return this._parseInt_8();
  }
  parseEdgeType() {
    return this._parseInt_8();
  }
  parseUserDataIndex() {
    const t = this._parseUint_32(), e = this._parseUint_32();
    return e <= 2097151 ? 4294967296 * e + t : `${e.toString(16)}${Fg(t)}`.toUpperCase();
  }
  getHeader() {
    return this._header;
  }
}
function Gf(n, t) {
  const e = (s) => {
    t.push(s);
  }, i = {
    enterProductOccurrence: e,
    enterAnyBody: e,
    enterCadView: e,
    enterPmi: e,
    enterPartDefinition: e,
    enterRepresentationItem: e
  };
  return yi.walk(i, n, ft.None);
}
async function er(n) {
  const t = [], e = [];
  for (const i of n) {
    const s = Gf(i, e);
    t.push(s);
  }
  await zt(t);
  for (const i of e)
    i.markLoaded();
}
class Tf {
  constructor(t, e) {
    this.value = t, this.kids = e.slice();
  }
}
const xh = [24, 2, 0];
class Us {
  constructor(t) {
    this.referencedInfo = t;
  }
}
function sc(n) {
  return n instanceof Us ? n.referencedInfo : n;
}
function Ef(n, t) {
  let e = n.nodeInfo.localTransform;
  return e === null ? e = t : e = Xi.multiply(e, t), {
    ...n,
    nodeInfo: {
      ...n.nodeInfo,
      localTransform: e
    }
  };
}
class rc {
  /**
   * This is used to parse `ModelFileInfo` without adding it to the tree.
   */
  static parseXml(t, e, i, s, r) {
    console.assert(s.localName === "ModelFile");
    const o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), c = (m) => {
      let g = Yt.parseXml(
        t,
        e,
        i,
        m,
        r
      );
      const _ = g.nodeInfo.nodeId;
      if (l.has(g.nodeInfo.nodeId)) {
        const v = new Us(g);
        o.set(_, v);
      } else
        a.has(g.nodeInfo.nodeId) || (a.set(g.nodeInfo.nodeId, null), t.additionalMatrix !== null && (g = Ef(g, t.additionalMatrix.m))), o.set(_, g);
      const b = we.parseNodeIds(m, "Children") ?? [];
      for (const v of b)
        a.set(v, g);
      const w = we.parseNodeId(m, "InstanceRef");
      if (w !== null) {
        const v = l.get(w);
        v === void 0 ? l.set(w, [g]) : v.push(g);
      }
    };
    let h = s.firstElementChild;
    for (; h !== null; ) {
      if (h.localName !== "ProductOccurence")
        throw new ce(`Unexpected element "${h.localName}".`);
      if (we.parseNodeId(h, "Id") === null)
        throw new ce('Expected "Id" attribute.');
      c(h), h = h.nextElementSibling;
    }
    const u = this._parentMapToChildMap(o, a, l);
    return {
      treeInfos: this._childMapRoseTrees(u)
    };
  }
  static _parentMapToChildMap(t, e, i) {
    const s = /* @__PURE__ */ new Map(), r = (o, a) => {
      const l = s.get(o);
      l === void 0 ? s.set(o, [a]) : l.push(a);
    };
    return e.forEach((o, a) => {
      const l = t.get(a);
      if (l instanceof Us)
        throw new ce('Expected a referenced node for "InstanceRef".');
      r(o, l);
    }), i.forEach((o, a) => {
      console.assert(o.length > 0);
      const l = t.get(a);
      if (!(l instanceof Us))
        throw new ce(
          `Node is both an "InstanceRef" and contained in another node's "Children" list.`
        );
      for (const c of o)
        r(c, l);
    }), s;
  }
  static _childMapRoseTrees(t) {
    const e = (r) => {
      const o = [], a = sc(r), l = t.get(a);
      if (l !== void 0) {
        console.assert(l.length > 0);
        for (const c of l) {
          const h = e(c);
          o.push(h);
        }
      }
      return new Tf(r, o);
    }, i = t.get(null);
    if (i === void 0)
      return console.assert(t.size === 0), [];
    const s = [];
    for (const r of i) {
      if (r instanceof Us) {
        console.assert(!1);
        continue;
      }
      const o = e(r);
      s.push(o);
    }
    return s;
  }
  /**
   * Inserts `ModelFileInfo` into the assembly tree.
   */
  static async reify(t, e, i, s, r, o) {
    const a = [], l = [], c = [];
    for (const u of o.treeInfos) {
      if (u.value instanceof Us) {
        console.assert(!1);
        continue;
      }
      const p = this._reifyProductOccurrence(
        t,
        e,
        i,
        s,
        r,
        r,
        u,
        a
      );
      l.push(p), c.push(p.getRuntimeId());
    }
    const h = e.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      c,
      ps.LoadModel
    );
    return a.push(h), await zt(a), l;
  }
  static _rectifyExternalModelInfo(t, e) {
    let i = {
      ...e.referencedInfo.externalModelInfo,
      reservedNodeIdOffset: 0
    };
    if (i === null)
      throw new ce('"InstanceRef" node does not contain "ExternalModel".');
    if (!Do(i))
      throw new re();
    console.assert(i.reservedNodeIdOffset === 0);
    const s = t.newNodeIdOffset();
    return i = {
      ...i,
      reservedNodeIdOffset: s
    }, i;
  }
  static _reifyProductOccurrence(t, e, i, s, r, o, a, l) {
    const c = sc(a.value);
    if (c.childDataKeys.length !== 0)
      throw new re();
    if (c.externalModelInfo !== null)
      throw new ts('Unexpected "ExternalModel". Should be a child of an "InstanceRef".');
    const h = Yt.reifySync(
      t,
      i,
      s,
      r,
      c,
      o
    );
    o.addProductOccurrence(h), h.markLoaded();
    for (const u of a.kids)
      if (u.value instanceof Us) {
        console.assert(u.kids.length === 0);
        const p = this._rectifyExternalModelInfo(s, u.value);
        if (Dd(p)) {
          const m = i.attachByExternalModelInfo(p, h, r).then(async (g) => {
            if (g === null)
              return;
            await er([g]), h.addAttachContext(g);
            const _ = g.getChildren().map((y) => y.getRuntimeId());
            await e.promiseTrigger(
              "_subtreeLoaded",
              "subtreeLoaded",
              _,
              ps.LoadModel
            );
          });
          l.push(m);
        } else
          h.addPendingExternalModel(p);
      } else
        console.assert(u.value.externalModelInfo === null), this._reifyProductOccurrence(
          t,
          e,
          i,
          s,
          r,
          h,
          u,
          l
        );
    return h;
  }
  static _parseBounding(t, e) {
    const i = sc(t.value);
    let s = nn;
    i.measurementUnit !== null && (s = i.measurementUnit);
    let r = 1;
    s === nn ? s = e : e !== nn && (r = s / e);
    let o = new Q().setScaleComponent(r, r, r);
    const a = i.nodeInfo.localTransform;
    if (a !== null) {
      const h = Q.createFromArray(a);
      o = Q.multiply(h, o);
    }
    const l = ni.invalid();
    for (const h of t.kids) {
      let u = this._parseBounding(h, s);
      u = o.transformBox(u), l.addBox(u);
    }
    const c = i.externalModelInfo;
    if (c !== null) {
      if (!Do(c))
        throw new re();
      let h = c.bounding;
      if (h !== null && !h.isDegenerate()) {
        const u = c.measurementUnit || nn;
        if (e !== nn && u !== nn) {
          const p = u / s, m = new Q().setScaleComponent(
            p,
            p,
            p
          );
          o = Q.multiply(m, o);
        }
        h = o.transformBox(h), l.addBox(h);
      }
    }
    return l;
  }
  static parseBounding(t, e) {
    const i = ni.invalid();
    for (const s of t.treeInfos)
      for (const r of s.kids) {
        const o = this._parseBounding(r, e);
        i.addBox(o);
      }
    return i;
  }
  constructor() {
  }
}
const Jo = class {
  constructor(n, t, e, i, s, r, o) {
    this.headerVersion = n, this._rootAssemblyDataKey = t, this.isDrawing = e, this.isMeasurable = i, this.originalFileName = s, this.originalFileType = r, this.doublePrecisionMatrices = o;
  }
  supportsAttributeBits() {
    return this.headerVersion >= 5;
  }
  rootAssemblyDataKey() {
    return console.assert(this._rootAssemblyDataKey !== bl.Invalid), this._rootAssemblyDataKey;
  }
  // double precision matrices
  static parseBinary(n) {
    if (n.length === 0)
      return null;
    const t = new zo(new sr(null, n)), e = new Jd();
    if (e.parseBits1(t), !e.hasBits1(Qt.Header))
      return null;
    const i = t.parseAssemblyDataHeaderVersion();
    if (i > Jo._maxHeaderVersion)
      throw new ur(`Unknown header version: ${i}`);
    if (i >= 4) {
      const h = t.parseAssemblyDataVersion(3);
      if (!mh(xh, h))
        throw new ur(`Invalid version: ${yd(h)}`);
    }
    e.parseBits2(t);
    const s = t.parseDataKey(), r = t.parseBoolean();
    let o, a = "", l = oh.Unknown, c = !1;
    return i >= 1 ? o = t.parseBoolean() : o = !0, i >= 3 && (c = e.hasBits2(Un.DoublePrecisionMatrices), e.hasBits2(Un.OriginalName) && (a = t.parseCString()), l = t.parseIndex_32()), new Jo(
      i,
      s,
      r,
      o,
      a,
      l,
      c
    );
  }
};
let _n = Jo;
_n._maxHeaderVersion = 5;
_n.dynamic = new Jo(
  Jo._maxHeaderVersion,
  bl.Invalid,
  !1,
  // isDrawing
  !1,
  // isMeasurable
  "",
  // originalFileName
  oh.Unknown,
  !0
);
class sr {
  constructor(t, e) {
    this.header = t, this.bytes = e;
  }
}
class Si {
  constructor(t, e, i, s) {
    this._productOccurrences = null, this._relationship = [], this._bimNodeIdMap = /* @__PURE__ */ new Map(), this._bimInfos = [], console.assert(i !== void 0), console.assert(i === ve.Local == (s === Bi.Local)), this._attachContext = e, this._inclusionKey = i, this._modelKey = s;
    let r = e.getReservedNodeIdOffset();
    r !== null ? e.forgetReservedNodeIdOffset() : r = t.newNodeIdOffset(), this._nodeIdOffset = r, t.registerInclusionContext(this);
  }
  split(t, e) {
    return new Si(t, e, this._inclusionKey, this._modelKey);
  }
  getIdOffset() {
    return this._nodeIdOffset;
  }
  toRuntimeId(t) {
    return console.assert(Hr(t)), t + this._nodeIdOffset;
  }
  getInclusionKey() {
    return this._inclusionKey;
  }
  getModelKey() {
    return this._modelKey;
  }
  getParent() {
    return this._attachContext;
  }
  /** Naming clarity for when you know you want it as the attach-context */
  getAttachContext() {
    return this._attachContext;
  }
  addProductOccurrence(t) {
    console.assert(t.getParent() === this), this._productOccurrences = Mi(this._productOccurrences, t);
  }
  getChildren() {
    return console.assert(this._productOccurrences !== null), se(this._productOccurrences);
  }
  removeProductOccurrence(t) {
    let e = se(this._productOccurrences);
    const i = e.length;
    return e = e.filter((s) => s !== t), e.length === 0 ? this._productOccurrences = null : this._productOccurrences = zi(e), e.length < i;
  }
  purgeContents() {
    const t = [], e = se(this._productOccurrences);
    for (const i of e) {
      const s = i.purgeContents();
      t.push(s);
    }
    return this._productOccurrences = null, this._relationship.length = 0, zt(t);
  }
  hasChildren() {
    return this._productOccurrences !== null;
  }
  isLoaded() {
    if (this._productOccurrences instanceof Yt)
      return this._productOccurrences.isLoaded();
    if (this._productOccurrences === null)
      return !0;
    for (const t of this._productOccurrences)
      if (!t.isLoaded())
        return !1;
    return !0;
  }
  addRelationship(t) {
    this._relationship.push(t);
  }
  getRelationships() {
    return this._relationship;
  }
  addBimInfos(t) {
    this._bimInfos.push(t);
  }
  getBimInfos() {
    return this._bimInfos;
  }
  addBimIdToMap(t, e) {
    this._bimNodeIdMap.set(t, e);
  }
  getRuntimeNodeFromBimId(t) {
    const e = this._bimNodeIdMap.get(t);
    return e !== void 0 ? e : null;
  }
}
class hi {
  constructor(t, e, i, s, r) {
    this._reservedNodeIdOffset = null, this._inclusionContexts = null, this._originalFileName = "", this._originalFileType = Vo.Unknown, this._genericTypeMaps = null, console.assert(s !== Hn.Invalid), this._remapper = t, this._attachScope = e, this._attachedInvisibly = i, this._masterModelKey = s, this._parent = r;
  }
  async getRootNodeMetaData(t) {
    if (this._masterModelKey === Hn.Invalid)
      return null;
    const e = t.getAbstractScEngine(), i = this._masterModelKey, s = 1, r = await e.safeGetMetaData(i, s);
    if (r !== null) {
      const o = t.tryParseHeader(r);
      if (o === null)
        return new sr(null, r);
      const a = await o;
      this._originalFileName = a.originalFileName, this._originalFileType = a.originalFileType;
      const l = await e.safeGetMetaData(i, a.rootAssemblyDataKey());
      return l !== null ? new sr(a, l) : null;
    }
    return null;
  }
  getAttachScope() {
    return this._attachScope;
  }
  attachedInvisibly() {
    return this._attachedInvisibly;
  }
  getMasterModelKey() {
    return this._masterModelKey;
  }
  addInclusionContext(t) {
    console.assert(t.getParent() === this), this._inclusionContexts = Mi(this._inclusionContexts, t);
  }
  getRemapper() {
    return this._remapper;
  }
  getParent() {
    return this._parent;
  }
  getChildren() {
    const t = this._inclusionContexts;
    if (t === null)
      return [];
    if (Array.isArray(t)) {
      console.assert(t.length > 0);
      const e = t[0].getChildren();
      for (let i = 1; i < t.length; ++i) {
        const s = t[i];
        e.push(...s.getChildren());
      }
      return e;
    } else
      return t.getChildren();
  }
  getInclusionContexts() {
    return se(this._inclusionContexts);
  }
  split(t, e, i) {
    return new hi(
      this._remapper,
      t,
      e,
      this._masterModelKey,
      i
    );
  }
  hasChildren() {
    return this._inclusionContexts !== null;
  }
  removeProductOccurrence(t) {
    let e = null, i = se(this._inclusionContexts);
    for (const s of i)
      if (s.removeProductOccurrence(t)) {
        e = s;
        break;
      }
    return e === null ? !1 : (i = i.filter((s) => s.hasChildren()), i.length === 0 ? this._inclusionContexts = null : this._inclusionContexts = zi(i), !0);
  }
  purgeContents() {
    const t = [], e = se(this._inclusionContexts);
    for (const i of e) {
      const s = i.purgeContents();
      t.push(s);
    }
    return this._inclusionContexts = null, zt(t);
  }
  isLoaded() {
    if (this._inclusionContexts instanceof Si)
      return this._inclusionContexts.isLoaded();
    if (this._inclusionContexts === null)
      return !0;
    for (const t of this._inclusionContexts)
      if (!t.isLoaded())
        return !1;
    return !0;
  }
  setReservedNodeIdOffset(t) {
    console.assert(this._reservedNodeIdOffset === null), this._reservedNodeIdOffset = t;
  }
  getReservedNodeIdOffset() {
    return this._reservedNodeIdOffset;
  }
  forgetReservedNodeIdOffset() {
    console.assert(this._reservedNodeIdOffset !== null), this._reservedNodeIdOffset = null;
  }
  getOriginalFileName() {
    return this._originalFileName;
  }
  getOriginalFileType() {
    return this._originalFileType;
  }
  setGenericTypeMaps(t) {
    this._genericTypeMaps = t;
  }
  getGenericTypeMaps() {
    return this._genericTypeMaps;
  }
}
function Nf(n) {
  if (typeof n == "string")
    throw new re();
  return n;
}
class on {
  constructor(t, e, i) {
    this._handledExternalModels = null, this._attachContexts = null, this._registeredScsModelKeys = /* @__PURE__ */ new Map(), this._layerIdMap = new zd(), this._parent = t, this._scsBufferCache = i;
  }
  /**
   * Returns whether or not an authored external model should be handled or not.
   */
  handleExternalModel(t, e, i) {
    const s = e.getInclusionKey(), r = `${ic(i)} ${ic(
      s
    )} ${ic(t)}`;
    return this._handledExternalModels === null && (this._handledExternalModels = /* @__PURE__ */ new Set()), this._handledExternalModels.has(r) ? !1 : (this._handledExternalModels.add(r), !0);
  }
  getParent() {
    return this._parent;
  }
  addAttachContext(t) {
    this._attachContexts = Mi(this._attachContexts, t);
  }
  getChildren() {
    const t = this._attachContexts;
    if (t === null)
      return [];
    if (Array.isArray(t)) {
      console.assert(t.length > 0);
      const e = t[0].getChildren();
      for (let i = 1; i < t.length; ++i) {
        const s = t[i];
        e.push(...s.getChildren());
      }
      return e;
    } else
      return t.getChildren();
  }
  getAttachContexts() {
    return this._attachContexts === null ? [] : Array.isArray(this._attachContexts) ? this._attachContexts : [this._attachContexts];
  }
  hasChildren() {
    return this._attachContexts !== null;
  }
  removeProductOccurrence(t) {
    let e = null, i = se(this._attachContexts);
    for (const s of i)
      if (s.removeProductOccurrence(t)) {
        e = s;
        break;
      }
    return e === null ? !1 : (i = i.filter((s) => s.hasChildren()), i.length === 0 ? this._attachContexts = null : this._attachContexts = zi(i), !0);
  }
  purgeContents() {
    const t = [], e = se(this._attachContexts);
    for (const i of e) {
      const s = i.purgeContents();
      t.push(s);
    }
    return this._attachContexts = null, zt(t);
  }
  isLoaded() {
    if (this._attachContexts instanceof hi)
      return this._attachContexts.isLoaded();
    if (this._attachContexts === null)
      return !0;
    for (const t of this._attachContexts)
      if (!t.isLoaded())
        return !1;
    return !0;
  }
  /**
   * This should not be called more than once per `ExternalModelName` in a given `LoadContext`.
   */
  initializeScsModelKeysOf(t) {
    console.assert(this._registeredScsModelKeys.get(t) === void 0), this._registeredScsModelKeys.set(t, fh());
  }
  /**
   * Gets the model keys of an SCS model by its external name from a shattered XML file.
   *
   * Returns:
   *  - `null` if `initializeScsModelKeysOf` was not called for the given model.
   *  - `TrackedOpenPromise<null>` if the model has no attachment data.
   *  - `TrackedOpenPromise<ModelKey[]>` if the model has attachment data.
   */
  getScsModelKeysOf(t) {
    const e = this._registeredScsModelKeys.get(t);
    return e === void 0 ? null : e;
  }
  markAsFirstLoad() {
    console.assert(this._isFirstLoad === void 0), this._isFirstLoad = !0;
  }
  isFirstLoad() {
    return this._isFirstLoad === !0;
  }
  async toScsBuffer(t, e) {
    const i = xi.create(async () => {
      const s = await e(t);
      return Nf(s);
    });
    return this._scsBufferCache === null ? i : this._scsBufferCache.load(t, i);
  }
  // This gets called on both successful and erroneous loads.
  onLoadComplete() {
    this._scsBufferCache = null;
  }
  addLayerIdToMap(t, e) {
    this._layerIdMap.set(t, e);
  }
  getAuthoredLayerId(t) {
    const e = this._layerIdMap.getRight(t);
    return e !== void 0 ? e : null;
  }
  getRuntimeLayerId(t) {
    const e = this._layerIdMap.getLeft(t);
    return e !== void 0 ? e : null;
  }
  // Maps runtime layer IDs to authored layer IDs
}
function Bo(n) {
  let t = Xi.getIdentity(), e = n;
  for (; e !== null; )
    if (e instanceof Pi) {
      const i = e.getLocalTransform();
      i && (t = Xi.multiply(t, i)), e instanceof Ei ? e = null : e = e.getParent();
    } else if (e instanceof Si)
      e = e.getParent();
    else if (e instanceof hi)
      e = e.getParent();
    else if (e instanceof on)
      e = e.getParent();
    else
      return t;
  return t;
}
function Bd(n) {
  let t = n;
  for (; ; )
    if (t instanceof Pi)
      if (t instanceof Ur)
        t = t.getParent();
      else
        return t;
    else if (t instanceof on)
      t = t.getParent();
    else if (t instanceof Si)
      t = t.getParent();
    else if (t instanceof hi)
      t = t.getParent();
    else {
      if (t === null)
        return null;
      console.assert(!1), t = t.getInclusionContext();
    }
}
function ks(n) {
  return n instanceof Ur || n instanceof Yt ? n.isOutOfHierarchy() : !1;
}
function Rf(n) {
  return n instanceof Yt || n instanceof gi || n instanceof Ni ? n.getBranchVisibility() : n.isVisible() ? Pt.Shown : Pt.Hidden;
}
function Lf(n) {
  if (n instanceof Yt)
    return n.isADrawingSheetNode() ? At.DrawingSheet : n.hasBodyInstances() ? At.PartInstance : At.AssemblyNode;
  if (n instanceof Ei)
    return At.Part;
  if (n instanceof In)
    return At.PmiBody;
  if (n instanceof ms)
    return At.ViewFrame;
  if (n instanceof Ve)
    return At.BodyInstance;
  if (n instanceof Fe)
    switch (n.getBodyType()) {
      case xr.BRep:
        return At.BrepBody;
      case xr.Tessellation:
        return At.TessBody;
      case xr.Wireframe:
        return At.WireBody;
      case xr.PointCloud:
        return At.PointsBody;
      case xr.Unknown:
      default:
        return At.Body;
    }
  else
    return n instanceof gi ? At.Pmi : At.CadView;
}
function jo(n) {
  const t = n.getGenericTypeId();
  if (t !== null) {
    const i = Ce(n).getGenericTypeMaps();
    if (i !== null)
      return i.getRight(t) || null;
  }
  return null;
}
function Ne(n) {
  let t = n;
  for (; ; )
    if (t instanceof Pi)
      t = t.getParent();
    else {
      if (t instanceof Si)
        return t;
      if (t instanceof In)
        t = t.getParent();
      else if (t instanceof ms)
        t = t.getParent();
      else
        return t.getInclusionContext();
    }
}
function gn(n) {
  let t = n;
  for (; ; )
    if (t instanceof hi)
      t = t.getParent();
    else {
      if (t instanceof on)
        return t;
      t instanceof Pi || t instanceof Si ? t = t.getParent() : t = t.getInclusionContext();
    }
}
function Ce(n) {
  let t = n;
  for (; ; )
    if (t instanceof Si)
      t = t.getParent();
    else {
      if (t instanceof hi)
        return t;
      if (t instanceof Pi)
        t = t.getParent();
      else if (t instanceof on) {
        const e = t.getParent();
        if (e === null)
          throw new re();
        t = e;
      } else
        t = t.getInclusionContext();
    }
}
function hu(n) {
  let t = null, e = n;
  for (; ; )
    if (e instanceof Yt)
      t = e, e = e.getParent();
    else if (e instanceof Pi)
      e = e.getParent();
    else if (e instanceof Si) {
      if (t === null)
        throw new re();
      return t;
    } else
      e = e.getInclusionContext();
}
function Pn(n) {
  let t = n;
  for (; ; ) {
    if (t instanceof Yt)
      return t;
    if (t instanceof hi)
      t = t.getParent();
    else if (t instanceof Si)
      t = t.getParent();
    else if (t instanceof on) {
      const e = t.getParent();
      if (e === null)
        return null;
      t = e;
    } else if (t instanceof Ur)
      t = t.getParent();
    else if (t instanceof gi)
      t = t.getParent();
    else if (t instanceof Ni)
      t = t.getParent();
    else
      return console.assert(!1), null;
  }
}
const Xf = "IFCCOLUMN", Ff = "IFCCOVERING", Kf = "IFCCURTAINWALL", Of = "IFCDOOR", Af = "IFCRAMP", Df = "IFCROOF", zf = "IFCSLAB", Jf = "IFCSTAIR", Bf = "IFCSTAIRFLIGHT", jf = "IFCTRANSPORTELEMENT", Hf = "IFCWALL", Uf = "IFCWALLSTANDARDCASE", Qf = "IFCWINDOW";
function qf(n, t) {
  let e = n;
  for (; e !== null; ) {
    if (e.getName() === t || jo(e) === t)
      return !0;
    e = Pn(e.getParent());
  }
  return !1;
}
function $f(n) {
  switch (n) {
    case Xf:
    case Kf:
    case Jf:
    case Bf:
    case Hf:
    case Uf:
    case Qf:
      return ei.Wall | ei.Floor;
    case Ff:
    case Af:
    case Df:
    case zf:
      return ei.Floor;
    case Of:
    case jf:
      return ei.Door | ei.Floor;
  }
  return ei.None;
}
async function t_(n, t, e, i) {
  const s = await t.getNodeOrRepItem(e);
  if (s === null || s instanceof Fe || s instanceof Ei)
    return ei.None;
  let r = jo(s);
  if (r === null) {
    if (i === null)
      return ei.None;
    const a = await s.getAttributes();
    for (const l of a)
      if (l.getTitle() === i) {
        r = l.getValue();
        break;
      }
    if (r === null)
      return ei.None;
  }
  const o = n(r);
  return o !== ei.None ? o : ei.None;
}
async function e_(n) {
  const t = [], e = {
    enterAnyBody: (i) => {
      i instanceof Ve && t.push(i);
    }
  };
  return await yi.walk(e, n, ft.None), t;
}
async function i_(n) {
  const t = await e_(n), e = /* @__PURE__ */ new Set();
  for (const i of t) {
    const s = i.getParent();
    e.add(s);
  }
  return us(e);
}
async function n_(n, t, e, i) {
  const s = [];
  for (const c of e) {
    const h = t_(
      n,
      t,
      c,
      i
    );
    s.push(h);
  }
  const r = await Promise.all(s), o = [], a = [], l = [];
  for (let c = 0; c < e.length; ++c) {
    const h = e[c], u = r[c];
    u !== ei.None && (u & ei.Floor && o.push(h), u & ei.Wall && a.push(h), u & ei.Door && l.push(h));
  }
  return {
    floors: o,
    walls: a,
    doors: l
  };
}
function oc(n) {
  const t = [];
  for (const e of n) {
    const i = e.getBodyInstances();
    for (const s of i) {
      const r = s.getInstanceInc();
      t.push(r[0], r[1]);
    }
  }
  return t;
}
async function s_(n, t, e, i, s) {
  const r = await i_(i), o = await n_(
    n,
    e,
    r,
    s
  ), a = oc(o.floors);
  t.registerBimInstances(a, xo.Floor);
  const l = oc(o.walls);
  t.registerBimInstances(l, xo.Wall);
  const c = oc(o.doors);
  t.registerBimInstances(c, xo.Door);
}
async function r_(n, t, e) {
  const i = [], s = [], r = {
    enterAnyBody: (c) => {
      if (c instanceof Ve && !c.isOutOfHierarchy()) {
        i.push(c);
        const h = c.getInstanceInc();
        s.push(h[0], h[1]);
      }
    }
  };
  await yi.walk(r, n, ft.None);
  const o = /* @__PURE__ */ new Map(), a = await t.getPartColor(s, e), l = a.length;
  console.assert(l === i.length);
  for (let c = 0; c < l; ++c) {
    const h = a[c];
    h !== null && o.set(i[c].getRuntimeId(), h);
  }
  return o;
}
function Fr(n) {
  return [n.x, n.y, n.z];
}
function o_(n) {
  return [Math.abs(n[0]), Math.abs(n[1]), Math.abs(n[2])];
}
function a_(n, t) {
  return [n[0] * t[0], n[1] * t[1], n[2] * t[2]];
}
function l_(n, t) {
  return [n[0] + t[0], n[1] + t[1], n[2] + t[2]];
}
function c_(n, t) {
  return [n[0] - t[0], n[1] - t[1], n[2] - t[2]];
}
function h_(n, t) {
  return [n[0] + t[0], n[1] + t[1], n[2] + t[2], n[3] + t[3]];
}
function Cc(n, t) {
  return [n[0] - t[0], n[1] - t[1], n[2] - t[2], n[3] - t[3]];
}
function rs(n, t) {
  return n[0] * t[0] + n[1] * t[1] + n[2] * t[2];
}
function Sh(n) {
  const t = n[0], e = n[1], i = n[2];
  return t * t + e * e + i * i;
}
function uu(n) {
  return Math.sqrt(Sh(n));
}
function u_(n, t) {
  return [n * t[0], n * t[1], n * t[2]];
}
function ac(n) {
  return [n.x, n.y, n.z, n.w];
}
function uo(n, t) {
  const e = n.m, i = t;
  return [e[i], e[i + 4], e[i + 8], e[i + 12]];
}
function du(n) {
  const t = n[0], e = n[1], i = n[2], s = n[3];
  return t * t + e * e + i * i + s * s;
}
function lc(n, t) {
  return [n * t[0], n * t[1], n * t[2], n * t[3]];
}
function d_(n, t, e) {
  let i = rs(n, e) + e[3];
  return i *= i, i < 1e-5 && (i = 1e-5), t / i;
}
const Ri = 400, rr = "_empty", jd = en;
function Ca(n) {
  return n;
}
class Po {
  /** @hidden */
  constructor(t, e) {
    this._pmiColor = it.black(), this._pmiColorOverride = !1, this._viewAxes = new mu(), this._viewAxesSet = !1, this._engine = t, this._callbackManager = e, this._callbackManager.bind({
      _firstModelLoaded: async (i) => {
      },
      _resetAssemblyTreeBegin: async () => {
        this._viewAxes = new mu(), this._viewAxesSet = !1;
      }
    });
  }
  /** @hidden */
  _setModelStructure(t) {
    console.assert(this._modelStructure === void 0), this._modelStructure = t;
  }
  /**
   * Sets the up and front vectors for the model coordinate system.
   * Both the upVector and frontVector must be unique, cardinal axes.
   * @param frontVector
   * @param upVector
   */
  setViewAxes(t, e) {
    if (t.isAxis() && e.isAxis() && !t.equals(e))
      this._viewAxes.frontVector = t, this._viewAxes.upVector = e, this._callbackManager.trigger("viewAxes", t, e), this._viewAxesSet = !0;
    else
      throw new Mt("The upVector and frontVector must be unique, cardinal axes.");
  }
  /**
   * Gets whether there has been a successful call to setViewAxes.
   */
  viewAxesHaveBeenSet() {
    return this._viewAxesSet;
  }
  /**
   * @returns the up and front vectors for the model coordinate system.
   */
  getViewAxes() {
    return this._viewAxes;
  }
  /**
   * Gets the world space bounding box for the model.
   * @returns Promise that resolves with a Box representing the world space bounding box of the model.
   */
  async getModelBounding(t, e, i = !1) {
    let s = new ni();
    try {
      s = await this._engine.getModelBounding(
        t,
        e,
        i
      );
    } catch (r) {
      let o = !1;
      qs(r) && gd(r) === dh.Cancelled && (o = !0), console.assert(o);
    }
    return s;
  }
  /**
   * Gets the world space bounding box for the model. This does not take node visibility into account.
   * @returns Promise that resolves with a Box representing the world space bounding box of the model.
   */
  async getLooseBounding() {
    return this._engine.getLooseBounding();
  }
  /** @hidden */
  _allowNodeDeletion(t) {
    return this._modelStructure.allowNodeDeletion(t);
  }
  /** @hidden */
  _preventNodeDeletion(t) {
    return this._modelStructure.preventNodeDeletion(t);
  }
  /** @hidden */
  _preventMeshDeletion(t) {
    return console.assert(t[0] === Bi.Local), this._modelStructure.preventMeshDeletion(t[1]);
  }
  /** @hidden */
  _getNodeFromInstanceInc(t, e, i, s) {
    return this._modelStructure.getNodeFromInstanceInc(
      t,
      e,
      i,
      s
    );
  }
  /**
   * Gets the world space bounding box for a list of nodes.
   * @param nodeIds IDs of the nodes for which you wish to get the bounding box.
   * @param config Allows fine control of what body types to compute the bounding against. If not provided, all body types are considered.
   * @returns Promise that resolves with the world space bounding box for the given IDs.
   */
  getNodesBounding(t, e) {
    let i = bt.All, s = !1, r = !1;
    return e !== void 0 && (e.bodyInstance === !1 && (i &= ~bt.BodyInstance), e.pmiBody === !1 && (i &= ~bt.PmiBody), e.viewFrame === !1 && (i &= ~bt.ViewFrame), e.ignoreInvisible && (s = !0), e.tightBounding && (r = !0)), this._modelStructure.getBounding(t, i, s, r);
  }
  /**
   * Gets the world space bounding box for a node including any effects (explosion, camera suppression, etc).
   * Note: This function can have performance implications when used on nodes with many children.
   * @param nodeId ID of the node for which you wish to get the bounding box.
   * @returns Promise that resolves with the world space bounding box for the given ID.
   */
  async getNodeRealBounding(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      bt.All,
      ft.None
    );
    if (e.length === 0)
      throw new Mt("Cannot get bounding of node without geometry.");
    return this._engine.getDrawnPartsBounding(e);
  }
  /**
   * Sets the visibility for a given set of nodes.
   * @param mapping The mapping of node IDs to boolean value indicating the visibility setting for that node.
   * @param initiallyHiddenStayHidden Controls whether or not initially hidden geometries stay hidden. Default behavior is driven by [[setBehaviorInitiallyHidden]].
   * @param mode an optional walk mode to use while traversing the model tree
   * @returns Promise that resolves when the operation has completed.
   */
  setNodesVisibilities(t, e = null) {
    return t = nu(t), this._modelStructure.setVisibilitiesByMap(
      t,
      e !== null ? e : void 0
    );
  }
  /**
   * Sets visibility for a given list of nodes.
   * @param nodeIds The node IDs whose visibilities will be set.
   * @param visibility If true, nodes will be shown. If false, they will be hidden.
   * @param initiallyHiddenStayHidden Controls whether or not initially hidden geometries stay hidden. Default behavior is driven by [[setBehaviorInitiallyHidden]].
   * @param mode an optional walk mode to use while traversing the model tree
   * @returns Promise that resolves when the operation has completed.
   */
  setNodesVisibility(t, e, i = null) {
    return this._modelStructure.setVisibilitiesByValue(
      t,
      e,
      i
    );
  }
  setBodyNodesVisibility(t, e) {
    const i = this._modelStructure.lookupAnyTreeNode(t);
    if (i === null)
      throw new sn(t);
    const s = typeof e == "boolean" ? (r) => e : e;
    return this._modelStructure.setBodyNodesVisibility(
      i,
      (r) => s(r.getRuntimeId())
    );
  }
  /**
   * Resets visibility for all nodes in the model.
   * @returns Promise that resolves when the operation has completed.
   */
  resetNodesVisibility() {
    return this.isDrawing() ? this._callbackManager.promiseTrigger("_resetDrawing", null) : this._modelStructure.resetAllVisibilities();
  }
  /**
   * Returns a defaultVisibility boolean value and a visibilityException set of NodeIds.
   * defaultVisibility will be true if there are more nodes visible than hidden, and false otherwise.
   * If defaultVisibility is true, set of nodes that are hidden, if false, nodes that are visible.
   */
  async getVisibilityState(t) {
    const e = this._modelStructure.lookupAnyTreeNode(t);
    if (e === null)
      throw new sn(t);
    return Gd(e);
  }
  /**
   * Resets transform for all nodes in the model.
   * @returns Promise that resolves when the operation has completed.
   */
  resetNodesTransform() {
    return this._modelStructure.resetAllTransforms();
  }
  /**
   * Resets the state of the model to its default
   * @returns Promise that resolves when the operation has completed.
   */
  reset() {
    return this.resetModelOpacity(), this._modelStructure.reset();
  }
  /**
   * Remove all nodes, CAD views, configurations, and sheets from the model.
   *
   * If you intend to load additional models via the `loadSubtree` family
   * of methods, you should wait on the resolution of this promise before doing so.
   */
  clear() {
    return this._modelStructure.clear();
  }
  /**
   * Sets the color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesFaceColor(t, e) {
    return this._setNodesFaceColor(t, e), Promise.resolve();
  }
  /**
   * Sets the ambient color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   */
  setNodesAmbientColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.setPartAmbientColor(i, vt.Faces, e);
  }
  /**
   * Sets the ambient mix on the faces for a given list of nodes.
   * The mix is between the material ambient light and the global ambient light,
   * with 1.0 representing full material ambient mix and 0.0 representing full global
   * ambient light.
   * @param nodeIds IDs of nodes whose color to set
   * @param value the decimal value to set, between 0 and 1
   */
  setNodesAmbientMix(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.setPartAmbientMix(i, vt.Faces, e);
  }
  /**
   * Sets the emissive color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   */
  setNodesFaceEmissiveColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.setPartEmissiveColor(i, vt.Faces, e);
  }
  /**
   * Resets the emissive color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to reset
   */
  unsetNodesFaceEmissiveColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    e.length > 0 && this._engine.unsetPartEmissiveColor(e, vt.Faces);
  }
  /**
   * Sets the specular color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   */
  setNodesFaceSpecularColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.setPartSpecularColor(i, vt.Faces, e);
  }
  /**
   * Resets the specular color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to reset
   */
  unsetNodesFaceSpecularColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    e.length > 0 && this._engine.unsetPartSpecularColor(e, vt.Faces);
  }
  /**
   * Sets the specular intensity on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param value the value to set
   */
  setNodesFaceSpecularIntensity(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.setPartSpecularIntensity(i, vt.Faces, e);
  }
  /**
   * Resets the specular intensity on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   */
  unsetNodesFaceSpecularIntensity(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    e.length > 0 && this._engine.unsetPartSpecularIntensity(e, vt.Faces);
  }
  _setNodesFaceColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.setPartColor(i, vt.Faces, e);
  }
  _unsetNodesColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.unsetPartColor(i, e);
  }
  /**
   * Unsets the color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes to modify
   * @param color the color to set
   * @returns Promise that resolves when this operation has completed.
   */
  unsetNodesFaceColor(t) {
    return this._unsetNodesColor(t, vt.Faces), Promise.resolve();
  }
  /**
   * Sets the color on the lines/edges for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesLineColor(t, e) {
    return this._setNodesLineColor(t, e), Promise.resolve();
  }
  _setNodesLineColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.setPartColor(i, vt.Lines, e);
  }
  /**
   * Unsets the color on the lines for a given list of nodes.
   * @param nodeIds IDs of nodes to modify
   * @param color the color to set
   * @returns Promise that resolves when this operation has completed.
   */
  unsetNodesLineColor(t) {
    return this._unsetNodesColor(t, vt.Lines), Promise.resolve();
  }
  /**
   * Sets whether the supplied nodes should appear highlighted. When a node is highlighted,
   * the highlight color will override any color previously set on the model.
   *
   * *Tip:* An easy way to unhighlight the entire model is to call [[setNodesHighlighted]]
   * on the root node of the model:
   * ```
   * hwv.model.setNodesHighlighted([hwv.model.getAbsoluteRootNode()], false);
   * ```
   * (In this case, `hwv` is your instance of [[WebViewer]].)
   *
   * @param nodeIds array of IDs for this operation.
   * @param highlighted value indicating whether the supplied nodes should be highlighted.
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesHighlighted(t, e) {
    if (t.length === 0)
      return Promise.resolve();
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.LoadedNodesOnly
    );
    return i.length > 0 && this._engine.highlightParts(i, e), Promise.resolve();
  }
  /**
   * Returns whether the supplied nodes have been highlighted with [[setNodesHighlighted]].
   * @param nodeIds the list of nodes to be queried
   */
  getNodesHighlighted(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    return e.length > 0 ? this._engine.getPartHighlighted(e) : Promise.resolve([]);
  }
  /**
   * Sets colors for a given set of nodes.
   *
   * @param params object mapping node IDs to color to set for that node
   * @param alsoApplyToWireframe change or not lines color
   * @param alsoApplyToPoints change or not points color
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesColors(t, e = !1, i = !1) {
    const s = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Map(), o = (a, l) => {
      const c = this._modelStructure.lookupAnyTreeNode(a);
      if (c !== null) {
        const h = Oo(
          c,
          bt.All,
          !1,
          s,
          ft.None
        );
        if (h.length > 0) {
          const u = (l.r << 16) + (l.g << 8) + l.b, p = r.get(u);
          p ? r.set(u, p.concat(h)) : r.set(u, h);
        }
      }
    };
    if (t instanceof Map)
      t.forEach((a, l) => {
        o(l, a);
      });
    else {
      const a = Object.keys(t);
      for (const l of a) {
        const c = parseInt(l, 10);
        o(c, t[c]);
      }
    }
    return r.forEach((a, l) => {
      const c = new it(l >> 16, (l & 65280) >> 8, l & 255);
      this._engine.setPartColor(a, vt.Faces, c), e && this._engine.setPartColor(a, vt.Lines, c), i && this._engine.setPartColor(a, vt.Points, c);
    }), Promise.resolve();
  }
  /**
   * Gets an array of PMI topology references linking a PMI node to a body element, like a face or an edge.
   * @param pmiNodeId the ID of the PMI node.
   */
  getPmiTopologyReferences(t) {
    const e = [], i = (r, o, a) => {
      const l = new f_();
      return l.bodyId = r, l.subElementType = o, l.subElementIndex = a, l;
    }, s = this._modelStructure.getPmiTopologyReferences(t);
    if (s !== null)
      for (const r of s) {
        const o = r.body.getRuntimeId(), a = r.faceIds;
        for (const c of a)
          e.push(i(o, Uo.Face, c));
        const l = r.edgeIds;
        for (const c of l)
          e.push(i(o, Uo.Edge, c));
      }
    return e.length === 0 ? null : e;
  }
  /**
   * Returns names and ids of all the PMIs available in the scene
   * @returns a map associating PMI IDs to PMI names
   */
  getPmis() {
    return this._modelStructure.getPmis();
  }
  /**
   * Returns the type of a given PMI
   * @param idPMI ID of the PMI
   * @returns Type of the PMI (Dimension, Datum, GD&T...)
   */
  getPmiType(t) {
    return this._modelStructure.getPmiType(t);
  }
  /**
   * Returns the subtype of a given PMI
   * @param idPMI ID of the PMI
   * @returns Subtype of the PMI (Dimension distance, Datum target, GD&T fcf...)
   */
  getPmiSubtype(t) {
    return this._modelStructure.getPmiSubType(t);
  }
  /**
   * Saves a PMI override color
   * @param color the override color
   */
  setPmiColor(t) {
    this._pmiColor.assign(t);
  }
  /**
   * Returns the set PMI override color  (if none is set, defaults to black)
   * @returns color
   */
  getPmiColor() {
    return this._pmiColor.copy();
  }
  /**
   * Takes a boolean value and either enables the set PMI override color or resets all PMI colors to their default
   * @returns Promise that resolves when this operation has completed.
   */
  setPmiColorOverride(t, e) {
    return this._pmiColorOverride = t, t ? this._modelStructure.setPmiColor(this._pmiColor, e) : this._modelStructure.resetPmiColor(e), Promise.resolve();
  }
  /**
   * @returns a boolean value indicating the status of the PMI override color.
   */
  getPmiColorOverride() {
    return this._pmiColorOverride;
  }
  /**
   * Computes the distance between two bodies
   * @param partId1 id for the part which the first face belongs to
   * @param partId2 id for the part which the second face belongs to
   * @returns a promise that resolves with a Markup.Measure.FaceFaceDistanceItem when the operation completes
   */
  computeMinimumBodyBodyDistance(t, e) {
    const i = this._modelStructure.lookupAnyBody(t);
    if (i === null)
      throw new Gi(t, li.AnyBody);
    const s = this._modelStructure.lookupAnyBody(e);
    if (s === null)
      throw new Gi(e, li.AnyBody);
    const r = i.getInstanceInc(), o = s.getInstanceInc();
    return this._engine.computeMinimumBodyBodyDistance(r, o);
  }
  /**
   * Computes the distance between two faces
   * @param partId1 id for the part which the first face belongs to
   * @param faceId1 id for the face in the first part
   * @param partId2 id for the part which the second face belongs to
   * @param faceId2 id for the face in the second part
   * @returns a promise that resolves with a Markup.Measure.FaceFaceDistanceItem when the operation completes
   */
  computeMinimumFaceFaceDistance(t, e, i, s) {
    const r = this._modelStructure.lookupAnyBody(t);
    if (r === null)
      throw new Gi(t, li.AnyBody);
    const o = this._modelStructure.lookupAnyBody(i);
    if (o === null)
      throw new Gi(i, li.AnyBody);
    const a = r.getInstanceInc(), l = o.getInstanceInc();
    return this._engine.computeMininimumFaceFaceDistance(
      [a[0], a[1]],
      e,
      [l[0], l[1]],
      s
    );
  }
  /**
   * Computers the minimum distance between a face and a ray.
   * @param nodeId id of the node the face belongs to
   * @param faceId id of the face in the node
   * @param ray the ray to test against
   * @returns a promise that resolves with a Markup.Measure.FaceFaceDistanceItem when the operation completes
   */
  computeMinimumFaceRayDistance(t, e, i) {
    const s = this._modelStructure.lookupAnyBody(t);
    if (s === null)
      throw new Gi(t, li.AnyBody);
    const r = s.getInstanceInc();
    return this._engine.computeMinimumFaceRayDistance(r, e, i);
  }
  /**
   * Computers the minimum distance between a face and an infinite line.
   * @param nodeId id of the node the face belongs to
   * @param faceId id of the face in the node
   * @param ray the line (in the form of a ray) to test against
   * @returns a promise that resolves with a Markup.Measure.FaceFaceDistanceItem when the operation completes
   */
  computeMinimumFaceLineDistance(t, e, i) {
    const s = this._modelStructure.lookupAnyBody(t);
    if (s === null)
      throw new Gi(t, li.AnyBody);
    const r = s.getInstanceInc();
    return this._engine.computeMinimumFaceLineDistance(r, e, i);
  }
  /**
   * Sets the color for a face element. This color will take precedence over any currently set color on the node
   * @param nodeId the Id of the node containing the face
   * @param faceId the Id of the face in the node that will have its color set
   * @param color the color to set
   */
  setNodeFaceColor(t, e, i) {
    return this._setNodeFaceColor(t, e, i), Promise.resolve();
  }
  _setNodeFaceColor(t, e, i) {
    const s = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      bt.All,
      ft.None
    );
    if (s.length === 2) {
      const r = s;
      this._engine.setElementColor(r, vt.Faces, e, 1, i);
    }
  }
  /**
   * Sets the visibility for a face element. This visibility setting will take precedence over other element visibility settings
   * @param partId the Id of the part containing the face
   * @param faceId the Id of the face in the node that will have its visibility set
   * @param visibility visibility state to be set
   */
  setNodeFaceVisibility(t, e, i) {
    this._setNodeElementVisibility(t, e, i, vt.Faces);
  }
  /**
   * Clears the visibility for a node's face elements, resetting them to default.
   * @param partId the Id of the part to be reset
   */
  clearNodeFaceVisibility(t) {
    this._clearNodeElementVisibility(t, vt.Faces);
  }
  _setNodeElementVisibility(t, e, i, s) {
    const r = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      bt.All,
      ft.None
    );
    if (r.length === 2) {
      const o = r;
      this._engine.setElementVisibility(o, s, e, 1, i);
    }
  }
  _clearNodeElementVisibility(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      bt.All,
      ft.None
    );
    if (i.length === 2) {
      const s = i;
      this._engine.clearElementVisibility(s, e);
    }
  }
  _unsetElementColor(t, e, i) {
    if (i < 0)
      return;
    const s = this._getInstanceIncFromSingleLeafNode(t);
    this._engine.unsetElementColor(s, e, i, 1);
  }
  /**
   * Unsets the color for a face element. This will return the face's color to its default state.
   * @param nodeId the Id of the node containing the face
   * @param faceId the Id of the face in the node that will have its color unset
   */
  unsetNodeFaceColor(t, e) {
    return this._unsetElementColor(t, vt.Faces, e), Promise.resolve();
  }
  /**
   * Sets whether the face element for a given node should appear highlighted.
   * When a face element is highlighted, the highlight color will override
   * any color previously set on the element.
   * @param nodeId the id for the node containing the face element.
   * @param faceId the face Id that is the target of this operation.
   * @param highlighted value indicating whether the supplied face element should be highlighted.
   */
  setNodeFaceHighlighted(t, e, i) {
    return this._setNodeFaceHighlighted(t, e, i), Promise.resolve();
  }
  _setNodeFaceHighlighted(t, e, i) {
    const s = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      bt.All,
      ft.LoadedNodesOnly
    );
    s.length > 0 && this._engine.highlightElements(s, vt.Faces, e, 1, i);
  }
  async _getElementHighlighted(t, e, i) {
    const s = this._getInstanceIncFromSingleLeafNode(t), [r] = await this._engine.getElementHighlighted(s, e, i);
    return r;
  }
  /**
   * Returns whether the supplied face element has been highlighted with [[setNodeFaceHighlighted]].
   * @param nodeId the ID of the node containing the face element
   * @param faceIndex the index of the face within the node
   */
  getNodeFaceHighlighted(t, e) {
    return this._getElementHighlighted(t, vt.Faces, e);
  }
  /**
   * Gets the color set via [[setNodePointColor]] on a point element.
   * If no color has been set, `null` will be returned.
   * <br><br> See also: [[getNodeEffectivePointColor]]
   * @param nodeId the ID of the node containing the point
   * @param pointIndex the index of the point in the node
   */
  getNodePointColor(t, e) {
    return this._getNodeElementColor(t, vt.Points, e);
  }
  /**
   * Gets the color set via [[setNodePointColor]] on a point element. If no color has been set,
   * the node's point color will be returned. If the node's point color has not been set,
   * the color specified when the model was authored will be returned.
   * @param nodeId the ID of the node containing the point
   * @param pointIndex the index of the point in the node
   */
  getNodeEffectivePointColor(t, e) {
    return this._getNodeEffectiveElementColor(t, vt.Points, e);
  }
  /**
   * Sets the color for a point element.
   * @param partId the Id of the node containing the point.
   * @param pointId the Id of the point in the node that will have its color set.
   * @param color the color to set.
   */
  setNodePointColor(t, e, i) {
    const s = this._modelStructure.lookupAnyBody(t);
    if (s === null)
      throw new Gi(t, li.AnyBody);
    const r = s.getInstanceInc();
    this._engine.setElementColor(r, vt.Points, e, 1, i);
  }
  /**
   * Unsets the color for a point element. This will return the point's color to its default state.
   * @param partId the Id of the node containing the point
   * @param pointId the Id of the point in the node that will have its color unset
   */
  unsetNodePointColor(t, e) {
    this._unsetElementColor(t, vt.Points, e);
  }
  /**
   * Gets the color set via [[setNodesPointColor]] on the points of a list of leaf nodes.
   * If no color has been explicitly set for a particular node, `null` will appear at the corresponding
   * position in the returned array.
   * <br><br> See also: [[getNodesEffectivePointColor]]
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesPointColor(t) {
    return this._getNodesColor(t, vt.Points);
  }
  /**
   * Gets the color set on the points of a list of leaf nodes. If no color has been set,
   * the color specified when the model was authored will be returned.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesEffectivePointColor(t) {
    return this._getNodesEffectiveColor(t, vt.Points);
  }
  /**
   * Sets the color on the points for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesPointColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.setPartColor(i, vt.Points, e);
  }
  /**
   * Unsets the color on the points for a given list of nodes.
   * @param nodeIds IDs of nodes to modify
   */
  unsetNodesPointColor(t) {
    this._unsetNodesColor(t, vt.Points);
  }
  /**
   * Sets the color for a line element.
   * @param nodeId the Id of the node containing the line.
   * @param lineId the Id of the line in the node that will have its color set.
   * @param color the color to set.
   */
  setNodeLineColor(t, e, i) {
    return this._setNodeLineColor(t, e, i), Promise.resolve();
  }
  _setNodeLineColor(t, e, i) {
    const s = this._modelStructure.lookupAnyBody(t);
    if (s === null)
      throw new Gi(t, li.AnyBody);
    const r = s.getInstanceInc();
    this._engine.setElementColor(r, vt.Lines, e, 1, i);
  }
  /**
   * Unsets the color for a line element. This will return the line's color to its default state.
   * @param nodeId the Id of the node containing the line
   * @param lineId the Id of the line in the node that will have its color unset
   */
  unsetNodeLineColor(t, e) {
    return this._unsetElementColor(t, vt.Lines, e), Promise.resolve();
  }
  /**
   * Sets the visibility for a line element. This visibility setting will take precedence over other element visibility settings
   * @param partId the Id of the part containing the line
   * @param lineId the Id of the line in the node that will have its visibility set
   * @param visibility visibility state to be set
   */
  setNodeLineVisibility(t, e, i) {
    this._setNodeElementVisibility(t, e, i, vt.Lines);
  }
  /**
   * Clears the visibility for a node's line elements, resetting them to default.
   * @param partId the Id of the part to clear visibilities from
   */
  clearNodeLineVisibility(t) {
    this._clearNodeElementVisibility(t, vt.Lines);
  }
  /**
   * Sets whether the line element for a given node should appear highlighted. When a line element is highlighted, the highlight color will override any color previously set on the element.
   * @param nodeId the id for the node containing the line element.
   * @param lineId the line Id that is the target of this operation.
   * @param highlighted value indicating whether the supplied line element should be highlighted.
   */
  setNodeLineHighlighted(t, e, i) {
    return this._setNodeLineHighlighted(t, e, i), Promise.resolve();
  }
  _setNodeLineHighlighted(t, e, i) {
    const s = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      bt.All,
      ft.LoadedNodesOnly
    );
    s.length > 0 && this._engine.highlightElements(s, vt.Lines, e, 1, i);
  }
  /**
   * Returns whether the supplied line element has been highlighted with [[setNodeLineHighlighted]].
   * @param nodeId the ID of the node containing the line element
   * @param lineIndex the index of the line within the node
   */
  getNodeLineHighlighted(t, e) {
    return this._getElementHighlighted(t, vt.Lines, e);
  }
  /**
   * Sets the visibility for a point element. This visibility setting will take precedence over other element visibility settings
   * @param partId the Id of the part containing the point
   * @param pointId the Id of the point in the node that will have its visibility set
   * @param visibility visibility state to be set
   */
  setNodePointVisibility(t, e, i) {
    this._setNodeElementVisibility(t, e, i, vt.Points);
  }
  /**
   * Clears the visibility for a node's point elements, resetting it to default.
   * @param partId the Id of the part to clear visibilities from
   */
  clearNodePointVisibility(t) {
    this._clearNodeElementVisibility(t, vt.Points);
  }
  /**
   * Sets whether the point element for a given node should appear highlighted. When a point element is highlighted, the highlight color will override any color previously set on the element.
   * @param nodeId the id for the node containing the point element.
   * @param pointId the point Id that is the target of this operation.
   * @param highlighted value indicating whether the supplied point element should be highlighted.
   */
  setNodePointHighlighted(t, e, i) {
    return this._setNodePointHighlighted(t, e, i), Promise.resolve();
  }
  _setNodePointHighlighted(t, e, i) {
    const s = this._modelStructure.lookupAnyBody(t);
    if (s === null)
      throw new Gi(t, li.AnyBody);
    const r = s.getInstanceInc();
    this._engine.highlightElements(r, vt.Points, e, 1, i);
  }
  /**
   * Returns whether the supplied point element has been highlighted with [[setNodePointHighlighted]].
   * @param nodeId the ID of the node containing the point element
   * @param pointIndex the index of the point within the node
   */
  getNodePointHighlighted(t, e) {
    return this._getElementHighlighted(t, vt.Points, e);
  }
  /**
   * Resets color for all nodes in the model.
   * @returns Promise that resolves when this operation has completed.
   */
  resetNodesColor() {
    return this._engine.resetColors(), Promise.resolve();
  }
  /**
   * Sets opacity for a given list of nodes.
   * @param nodeIds IDs of nodes whose opacity will be set
   * @param opacity opacity value to apply to each node. The value should be between the range of 0.0 and 1.0. 0.0 indicates fully transparent, while 1.0 is fully opaque.
   */
  setNodesOpacity(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.setPartOpacity(i, e);
  }
  /**
   * Returns whether nodes with the given NodeIds have an opacity value that is not fully opaque.
   * @param nodeIds IDs of nodes to query.
   * @returns array of boolean values corresponding to the id array passed into the function.  A value of true indicates that the node contains transparency and is not fully opaque.
   */
  getNodesHaveTransparency(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    return e.length > 0 ? this._engine.getPartHasTransparency(e) : Promise.resolve([]);
  }
  /**
   * Sets opacity for a given set of nodes.
   * @param params object mapping node IDs to opacity to set for that NodeId. The opacity value should be between the range of 0.0 and 1.0. 0.0 indicates fully transparent, while 1.0 is fully opaque.
   */
  setNodesOpacities(t) {
    t = nu(t);
    const e = /* @__PURE__ */ new Set();
    t.forEach((i, s) => {
      const r = this._modelStructure.lookupAnyTreeNode(s);
      if (r !== null) {
        const o = Oo(
          r,
          bt.BodyInstance,
          !1,
          e,
          ft.None
        );
        o.length > 0 && this._engine.setPartOpacity(o, i);
      }
    });
  }
  /**
   * Resets opacity for all nodes in the model.
   * @returns Promise that resolves when this operation has completed.
   */
  resetModelOpacity() {
    this._engine.resetOpacity(), this._callbackManager.trigger("_resetOpacity");
  }
  /**
   * Resets highlight for all nodes in the model.
   * @returns Promise that resolves when this operation has completed.
   */
  resetModelHighlight() {
    return this._engine.clearHighlight(), Promise.resolve();
  }
  /**
   * Resets opacity for a given list of nodes.
   * @param nodeIds IDs of nodes whose opacity will be reset to their default values
   */
  resetNodesOpacity(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    e.length > 0 && this._engine.unsetPartOpacity(e);
  }
  _getNodesColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    return i.length > 0 ? this._engine.getPartColor(i, e) : Promise.resolve([]);
  }
  _getNodesEffectiveColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    return i.length > 0 ? this._engine.getEffectivePartColor(i, e) : Promise.resolve([]);
  }
  /**
   * Gets the color set via [[setNodesFaceColor]] on the faces of a list of leaf nodes.
   * If no color has been explicitly set for a particular node, `null` will appear at the corresponding
   * position in the returned array.
   * <br><br> See also: [[getNodesEffectiveFaceColor]]
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesFaceColor(t) {
    return this._getNodesColor(t, vt.Faces);
  }
  /**
   * Gets the color set on the faces of a list of leaf nodes. If no color has been set,
   * the color specified when the model was authored will be returned.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesEffectiveFaceColor(t) {
    return this._getNodesEffectiveColor(t, vt.Faces);
  }
  /**
   * Gets the color set via [[setNodesLineColor]] on the lines of a list of leaf nodes.
   * If no color has been set for a particular node, `null` will appear at the corresponding
   * position in the returned array.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesLineColor(t) {
    return this._getNodesColor(t, vt.Lines);
  }
  /**
   * Gets the color set on the lines of a list of leaf nodes. If no color has been set,
   * the color specified when the model was authored will be returned.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesEffectiveLineColor(t) {
    return this._getNodesEffectiveColor(t, vt.Lines);
  }
  /**
   * Gets a map associating NodeIds to colors that are set on those nodes.
   * Only NodeIds of nodes that have a color set will be included.
   * @param startNodeId The start node to walk when building the color map.
   * @param elementType Returned colors are of this element type.
   */
  async getNodeColorMap(t, e) {
    const i = this._modelStructure.lookupAnyTreeNode(t);
    if (i !== null)
      return r_(i, this._engine, e);
    throw new sn(t);
  }
  /**
   * Gets the opacity set via [[setNodesOpacity]] on a list of leaf nodes.
   * If no value has been set for a particular node, `null` will appear at the corresponding
   * position in the returned array.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesOpacity(t) {
    return Promise.resolve(this._getNodesOpacity(t));
  }
  _getNodesOpacity(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    return e.length > 0 ? this._engine.getPartOpacity(e) : [];
  }
  /**
   * Gets the opacity set on a list of leaf nodes multiplied by the opacity
   * specified when the model was authored. If no opacity has been set,
   * the opacity specified when the model was authored will be returned directly.
   * @param nodeIds IDs of the nodes to be queried
   * @param elementType the type of element (faces, lines or points) to query
   */
  getNodesEffectiveOpacity(t, e) {
    const i = this._getInstanceIncsFromLeafNodes(t);
    return i && i.length > 0 ? this._engine.getEffectivePartOpacity(i, e) : Promise.resolve([]);
  }
  async _getNodeElementColor(t, e, i) {
    const s = this._getInstanceIncFromSingleLeafNode(t), [r] = await this._engine.getElementColor(s, e, i);
    return r;
  }
  async _getNodeEffectiveElementColor(t, e, i) {
    const s = this._getInstanceIncFromSingleLeafNode(t), [r] = await this._engine.getEffectiveElementColor(s, e, i);
    return r;
  }
  /**
   * Gets the color set via [[setNodeFaceColor]] on a face element.
   * If no color has been set, `null` will be returned.
   * <br><br> See also: [[getNodeEffectiveFaceColor]]
   * @param nodeId the ID of the node containing the face
   * @param faceIndex the index of the face in the node
   */
  getNodeFaceColor(t, e) {
    return this._getNodeElementColor(t, vt.Faces, e);
  }
  /**
   * Gets the color set via [[setNodeFaceColor]] on a face element. If no color has been set,
   * the node's face color will be returned. If the node's face color has not been set,
   * the color specified when the model was authored will be returned.
   * @param nodeId the ID of the node containing the face
   * @param faceIndex the index of the face in the node
   */
  getNodeEffectiveFaceColor(t, e) {
    return this._getNodeEffectiveElementColor(t, vt.Faces, e);
  }
  /**
   * Gets the color set via [[setNodeLineColor]] on a line element.
   * If no color has been set, `null` will be returned.
   * @param nodeId the ID of the node containing the line
   * @param lineIndex the index of the line in the node
   */
  getNodeLineColor(t, e) {
    return this._getNodeElementColor(t, vt.Lines, e);
  }
  /**
   * Gets the color set via [[setNodeLineColor]] on a line element. If no color has been set,
   * the node's line color will be returned. If the node's line color has not been set,
   * the color specified when the model was authored will be returned.
   * @param nodeId the ID of the node containing the line
   * @param lineIndex the index of the line in the node
   */
  getNodeEffectiveLineColor(t, e) {
    return this._getNodeEffectiveElementColor(t, vt.Lines, e);
  }
  /**
   * Returns "Out Of Hierarchy" status for child node for the given Id.
   * @param id Node id to get children of
   * @returns false if node is Out Of Hierarchy, true if it is
   */
  getOutOfHierarchy(t) {
    return this._modelStructure.isOutOfHierarchy(t);
  }
  /**
   * Returns the absolute root node of the assembly tree.
   * @returns Id for the model tree root node or null if the model structure is not loaded.
   */
  getAbsoluteRootNode() {
    return this._modelStructure.getAbsoluteRootNodeId();
  }
  /**
   * Returns IDs for child nodes for the given Id.
   * @param id Node id to get children of
   * @param includeOutOfHierarchy true to include Out Of Hierarchy node, false or null to exclude them
   * @returns ID for the children of this node, or null if the ID is invalid
   */
  getNodeChildren(t, e) {
    return this._modelStructure.getChildIds(t, e || !1);
  }
  /**
   * Returns IDs of nodes who instance the same part as the supplied node.
   * This method should be called on nodes whose type is `PartInstance`.
   * @param id ID of a `PartInstance` node.
   * @returns Array containing `PartInstance` node IDs. These nodes all instance the same part as the supplied node.  If this method is called on a node which is not of type `PartInstance` then `null` will be returned.
   */
  getNodesInstancingSamePart(t) {
    return this._modelStructure.getPartReferrers(t);
  }
  /**
   * Returns the unit multiplier affecting the supplied node.
   * This number is a multiplier of millimeters (for example inches will be `25.4`).
   * The default value is `1.0`.
   * @returns The unit multiplier for the model (in mm)
   */
  getNodeUnitMultiplier(t) {
    return this._modelStructure.getUnit(t);
  }
  /**
   * Creates a CAD view. This method will trigger a "cadViewCreated" callback if the creation is successful.
   * @param id Node id to attach the created view to
   * @param viewName Name of the view
   * @param camera Camera that will be set when the view gets activated
   * @param pmiIds (optional, pass null or empty array if none to send) Node IDs of the PMI to show for the view
   * @param nodesToShow (optional, pass null or empty array if none to send) Node IDs of the elements to force visibility on
   * @param nodesToHide (optional, pass null or empty array if none to send) Node IDs of the elements to force visibility off
   * @param nodeIdsAndLocalTransforms (optional, pass null or empty array if none to send) array of node ID and matrix pair, defining specific local transform to apply
   * @param cuttingPlane (optional, pass null if none to send) Cutting plane to set when the view gets activated. Distance of the planes must be in the same unit as the model.
   * @param meshInstanceData (optional, pass null if none to send) object that specifies the data for the mesh instance of the rectangular frame (mostly found on capture views)
   * @returns id of the view, null is returned if the function fails
   */
  createCadView(t, e, i, s, r, o, a, l, c) {
    s || (s = []), r || (r = []), o || (o = []), a || (a = []), l === void 0 && (l = null), c === void 0 && (c = null);
    const h = this._modelStructure.createCadView(
      t,
      e,
      i,
      s,
      r,
      o,
      a,
      l,
      c
    );
    return h !== null && this._callbackManager.trigger("cadViewCreated", h, e), h;
  }
  /**
   * Gets CAD View information for this model.
   * @returns a map mapping associating CAD View ID to name
   */
  getCadViewMap() {
    return this._modelStructure.getCadViewMap();
  }
  /**
   * Activates a CAD View
   * @param id ID of the CAD View to activate.
   * @param duration camera transition time in milliseconds.
   * @param massageCamera If true, undesirable authored cameras may be modified into a camera with more reasonable values
   * @returns None.
   */
  activateCadView(t, e = Ri, i = !0) {
    return this.resetModelOpacity(), this._modelStructure.activateCadView(t, e, i);
  }
  /**
   * Get PMI IDs for a CAD View
   * @param id ID of the CAD View
   * @returns IDs of visible PMIs for the view
   */
  getCadViewPmis(t) {
    return this._modelStructure.getCadViewPmis(t);
  }
  /**
   * Gets whether or not cad configurations are enabled
   * @returns Boolean indicating whether or not cad configurations are enabled
   */
  cadConfigurationsEnabled() {
    return this._modelStructure.cadConfigurationsEnabled();
  }
  /**
   * Gets CAD configurations
   * @returns an object mapping CAD configuration ID to config name
   */
  getCadConfigurations() {
    return this._modelStructure.getCadConfigurations();
  }
  /**
   * Gets CAD default configuration
   * @returns ID of default CAD Configuration
   */
  getDefaultCadConfiguration() {
    return this._modelStructure.getDefaultCadConfiguration();
  }
  /**
   * Gets CAD default view
   * @returns ID of default CAD Configuration
   */
  getDefaultCadView() {
    return this._modelStructure.getDefaultCadView();
  }
  /**
   * Activate the default CAD view
   * @param duration Duration of the camera animation
   * @param massageCamera If true, undesirable authored cameras may be modified into a camera with more reasonable values
   * @returns None.
   */
  activateDefaultCadView(t = Ri, e = !0) {
    return this._modelStructure.activateDefaultCadView(t, e);
  }
  /**
   * Gets Active CAD configuration
   * @returns ID of activated CAD Configuration
   */
  getActiveCadConfiguration() {
    return this._modelStructure.getActiveCadConfiguration();
  }
  /**
   * Get the configuration in which the view is defined
   * @returns ID of CAD Configuration of the view
   */
  getCadViewConfiguration(t) {
    return this._modelStructure.getCadViewConfiguration(t);
  }
  /**
   * Activates a CAD configuration
   * @param id ID of the CAD Configuration to activate
   * @returns None.
   */
  activateCadConfiguration(t) {
    return this._modelStructure.activateCadConfiguration(t, !0);
  }
  /**
   * Activates Default CAD configuration
   * @param fitNodes Fit view to visible nodes if possible (default true)
   * @returns None.
   */
  activateDefaultCadConfiguration(t = !0) {
    return this._modelStructure.activateDefaultCadConfiguration(t);
  }
  /**
   * Returns point attributes for a node of the given node and point.
   * @param nodeId Node to retrieve point properties from
   * @param pointIndex Index of point for which to retrieve point attributes
   * @returns Promise for the requested point attributes. Properties returned will be null if none associated with the point.
   */
  getPointAttributes(t, e) {
    return this._modelStructure.getPointAttributes(t, e);
  }
  /**
   * Returns edge count for a node of the given node.
   * @param nodeId Node to retrieve edge count from
   * @returns Promise providing the number of edges
   */
  getEdgeCount(t) {
    return this._modelStructure.getEdgeCount(t);
  }
  /**
   * Returns edge attributes for a node of the given node and edge.
   * @param nodeId Node to retrieve edge properties from
   * @param edgeIndex Index of edge for which to retrieve edge attributes
   * @returns Promise for the requested edge attributes. Properties returned will be null if none associated with the edge.
   */
  getEdgeAttributes(t, e) {
    return this._modelStructure.getEdgeAttributes(t, e);
  }
  /**
   * Returns edge properties for a node of the given node and edge.
   * @param nodeId Node to retrieve edge properties from
   * @param edgeid ID of edge for which to retrieve edge properties
   * @returns Promise for the requested edge properties. Properties returned will be null if none associated with the edge.
   */
  getEdgeProperty(t, e) {
    return this._modelStructure.getEdgeProperty(t, e);
  }
  /**
   * Returns face count for a node of the given node and face.
   * @param nodeId Node to retrieve face count from
   * @returns Promise providing the number of faces
   */
  getFaceCount(t) {
    return this._modelStructure.getFaceCount(t);
  }
  /**
   * Returns face attributes for a node of the given node and face.
   * @param nodeId Node to retrieve edge properties from
   * @param faceIndex Index of face for which to retrieve face attributes
   * @returns Promise for the requested face attributes. Properties returned will be null if none associated with the edge.
   */
  getFaceAttributes(t, e) {
    return this._modelStructure.getFaceAttributes(t, e);
  }
  /**
   * Returns Face properties for a node of the given node and face.
   * @param nodeId Node to retrieve face properties from
   * @param faceid ID of face for which to retrieve face properties
   * @returns Promise for the requested face properties. Properties returned will be null if none associated with the face.
   */
  getFaceProperty(t, e) {
    return this._modelStructure.getFaceProperty(t, e);
  }
  /**
   * Set edge property for a node of the given node and edge.
   * @param id Node to set edge properties to
   * @param edgeid ID of edge
   * @param prop property (CircleElement, LineElement...)
   */
  setEdgeProperty(t, e, i) {
    this._modelStructure.setEdgeProperty(t, e, i);
  }
  /**
   * Set face property for a node of the given node and face.
   * @param id Node to set edge properties to
   * @param faceid ID of face
   * @param prop property (CylinderElement, PlaneElement...)
   */
  setFaceProperty(t, e, i) {
    this._modelStructure.setFaceProperty(t, e, i);
  }
  /**
   * Fetch the mesh data for a particular node
   * @param nodeId the node's ID
   */
  async getNodeMeshData(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      bt.All,
      ft.None
    );
    if (e.length === 0)
      throw new Mt("Node does not refer to a mesh instance");
    if (e.length > 2)
      throw new Mt("Node refers to multiple mesh instances");
    const i = e, s = await this._engine.getInstancesMeshData(i);
    if (s[1] === vo.Invalid)
      throw new Mt("Node has instance, but no mesh data");
    return this._engine.getMeshData(s);
  }
  /**
   * Fetch the mesh data for any capping geometry on a particular node
   * @param nodeIds the node IDs to get capping data from.
   */
  async getNodeCappingMeshData(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      bt.All,
      ft.None
    );
    if (e.length === 0)
      throw new Mt("Node does not refer to a mesh instance");
    if (e.length > 2)
      throw new Mt("Node refers to multiple mesh instances");
    const i = e, s = await this._engine.getInstancesCappingMeshData(i);
    return s[1] === vo.Invalid ? null : this._engine.getMeshData(s);
  }
  /**
   * Fetch the mesh data for any capping geometry on a list of nodes and their children
   * @param nodeIds the node IDs to get capping data from.
   */
  async getNodesCappingMeshData(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    ), i = await this._engine.getInstancesCappingMeshData(e), s = [];
    for (let r = 1; r < i.length; r += 2)
      if (i[r] !== vo.Invalid) {
        const o = [i[r - 1], i[r]], a = await this._engine.getMeshData(o);
        s.push(a);
      }
    return s;
  }
  /**
   * Returns a copy of the Matrix for a node of the given ID
   * @param id Node to retrieve matrix from
   * @returns Copy of the Matrix of the node
   */
  getNodeMatrix(t) {
    return this._modelStructure.getMatrix(t);
  }
  /**
   * Sets Matrix for a node of the given ID
   * @param id Node to set matrix on
   * @param Matrix of the Node
   * @param setAsInitial tells if you want to change the node initial matrix or not
   */
  setNodeMatrix(t, e, i = !1) {
    return this._modelStructure.setMatrix(t, e, i);
  }
  /**
   * Used by Animation system to efficiently update the matrix of many nodes at once.
   * Currently not part of public API due to difference in signature with other bulk operations which use Map based parameter.
   * @hidden
   */
  _setNodesMatrices(t, e, i = !1) {
    return this._modelStructure.setMatrices(t, e, i);
  }
  /**
   * Reset node matrix to the one set as the initial one
   * @param id Node to set matrix on
   */
  resetNodeMatrixToInitial(t) {
    return this._modelStructure.resetToInitialMatrix(t);
  }
  /**
   * Returns net matrix for a node of the given ID
   * @param id Node to retrieve net matrix from
   * @returns Net Matrix of the Node
   */
  getNodeNetMatrix(t) {
    return Q.createFromArray(this._modelStructure.getNetMatrix(t));
  }
  /**
   * Returns the parent Id for the given node id.
   * @param id node id to get the parent of
   * @returns ID of the parent node for the supplied ID. If the ID is invalid or the root ID, null is returned.
   */
  getNodeParent(t) {
    return this._modelStructure.getParentId(t);
  }
  /**
   * Returns the type of the node with the given ID.
   * @param id The ID of the node to get the type for.
   * @returns The type of the node.
   */
  getNodeType(t) {
    return this._modelStructure.getType(t);
  }
  /**
   * Returns the properties for the given node ID.
   * @param id Node ID to get the parent of
   * @param computeFromChildren If true physical properties will be computed from child nodes.
   * @returns object properties for the supplied ID, or null if the ID was invalid
   */
  getNodeProperties(t, e = !0) {
    return this._modelStructure.getProperties(t, e);
  }
  /**
   * Purpose: Adds a property to the node
   * @Param nodeId node id to set the property on
   * @Param property name
   * @Param property value
   * @returns true if all went right, false otherwise
   */
  addPropertyToNode(t, e, i, s) {
    return this._modelStructure.addProperty(t, e, i, s);
  }
  /**
   * Purpose: Sets physical properties
   * @Param nodeId node id to set the property on, the node id has to be a body node
   * @Param gravityCenter gravity center in local coordinates
   * @Param surfaceArea surface area, in squared current unit
   * @Param volume volume, in cubed current unit
   * @returns true if all went right, false otherwise
   */
  setPhysicalProperties(t, e, i, s) {
    return this._modelStructure.setPhysicalProperties(t, e, i, s);
  }
  /**
   * Specifies nodes for the system to load. This method is useful when the viewer was created with the <code>streamOnDemand</code> option set to true.
   * @param nodeIds array of unique IDs for the system to load
   */
  requestNodes(t) {
    return this._modelStructure.requestNodes(t);
  }
  /**
   * Returns the name for a node in the assembly tree.
   * @param nodeId The node ID to get the name of.
   * @returns The name of the node with the given nodeId or null if no name is found.
   */
  getNodeName(t) {
    return this._modelStructure.getName(t) || null;
  }
  /**
   * Returns the Exchange ID of a node in the assembly tree.
   * @param nodeId The node ID to get the Exchange ID from.
   * @returns The Exchange ID of the node with the given nodeId or null if no Exchange ID is found.
   */
  getNodeExchangeId(t) {
    return this._modelStructure.getNodeExchangeId(t);
  }
  /**
   * Returns names and ids of all filters available in the scene
   * @returns a map associating Filter IDs to filter names
   */
  getFilters() {
    return this._modelStructure.getFilters();
  }
  /**
   * @returns The name of a filter for the given filter ID index or null if filter was not found
   */
  getFilterName(t) {
    return this._modelStructure.getFilterName(t);
  }
  /**
   * @param nodeId The ID of the node to query.
   * @returns Filters which retain or remove the given node.
   */
  getFiltersWithNode(t) {
    return this._modelStructure.getFiltersWithNode(t);
  }
  /**
   * @param filtersId array of filters indexes to take in account
   * @returns nodesId of nodes retained by the given filter indices and the type of filter (inclusive or not). Returns null if no filter is found.
   */
  getNodesFromFiltersId(t) {
    return this._modelStructure.getNodesFromFilterIds(t);
  }
  /**
   * Returns names and ids of all layers available in the scene
   * @returns a map associating Layer IDs to Layer names
   */
  getLayers() {
    return this._modelStructure.getLayers();
  }
  /**
   * Return names of layers. Different layers can have the same name. Some layers can be unnamed.
   * @returns Names of layers
   */
  getUniqueLayerNames() {
    return this._modelStructure.getUniqueLayerNames();
  }
  /**
   * @returns The name of a layer for the given filter ID or null if layer was not found
   */
  getLayerName(t) {
    return this._modelStructure.getLayerName(t);
  }
  /**
   * @returns Id of layers for the given filter name or null if no layers are found
   */
  getLayerIdsFromName(t) {
    return this._modelStructure.getLayerIdsFromName(t);
  }
  /**
   * Returns the layer ID of a node in the assembly tree.
   * @param nodeId The node ID to get the Exchange ID from.
   * @returns The layer ID of the node with the given nodeId or null if no layer is found.
   */
  getNodeLayerId(t) {
    return this._modelStructure.getNodeLayerId(t);
  }
  /**
   * Returns IDs of nodes in the given layer.
   * @param layerId The layer ID to get nodes from.
   * @param onlyTreeNodes if true return only nodes present in model Tree
   * @returns An array of nodes Id of nodes with the given layerId or null if no layers are found.
   */
  getNodesFromLayer(t, e) {
    return this._modelStructure.getRuntimeNodesFromLayer(t, e);
  }
  /**
   * Returns IDs of nodes in given layers.
   * @param layersId Array of layers Id to get nodes from.
   * @param onlyTreeNodes if true return only nodes present in model Tree
   * @returns An array of nodes Id of nodes with one of the given layerId or null if no layers are found.
   */
  getNodesFromLayers(t, e) {
    return this._modelStructure.getRuntimeNodesFromLayers(t, e);
  }
  /**
   * Returns IDs of nodes in the given layer.
   * @param layer name the name of layer to get nodes from.
   * @param onlyTreeNodes if true return only nodes present in model Tree
   * @returns An array of nodes Id of nodes with the given layerName or null if no layers are found.
   */
  getNodesFromLayerName(t, e) {
    return this._modelStructure.getRuntimeNodesFromLayerName(t, e);
  }
  /**
   * Returns the current visibility for a node.
   * @param nodeId ID of the node to get visibility for.
   * @returns true if the current node's visibility state is on or false if it is not.
   */
  getNodeVisibility(t) {
    return this._modelStructure.isVisible(t);
  }
  /**
   * Branch visibility indicates the visibility state for all of a node's children.
   * @param nodeId ID of the node at the root of the branch.
   * @returns Shown/Hidden if all children have the same visibility state, Mixed otherwise.
   */
  getBranchVisibility(t) {
    const e = this._modelStructure.getBranchVisibility(t);
    return e === Pt.Shown ? Pt.Shown : e === Pt.Hidden ? Pt.Hidden : (console.assert(e === Pt.Mixed), Pt.Mixed);
  }
  /**
   * Returns a data object. During the authoring phase, a user can store general data within a model. (This is how
   * properties are stored, for example.) This function allows you to retrieve the data from the client application.
   *
   * @see {@link https://docs.techsoft3d.com/communicator/latest/api_ref/data_import/libsc/classSC_1_1Store_1_1Model.html#_CPPv4N2SC5Store5Model6InsertE8uint32_tPK7uint8_t8uint32_t Model::Insert}
   *
   * @param an Array of ModelKey-DataKey pairs ([ModelKey, DataKey, ModelKey, DataKey, ModelKey, DataKey...]
   * @returns promise that resolves when this operation has completed returning an array of 8bits int arrays for each ModelKey-DataKey pairs
   */
  getDataFromIds(t) {
    return this._engine.getDataFromIds(t);
  }
  /**
   * @param meshData [[MeshData]] object containing data to insert into the scene.
   * @returns Promise that resolves with a [[MeshId]] when the mesh has been created. The [[MeshId]] can be used to create instances of the mesh using [[createMeshInstance]].
   */
  async createMesh(t, e) {
    const i = await this._engine.createMesh(t);
    return e && e.doNotDelete && this._preventMeshDeletion(i), i;
  }
  static _flatArrayToPairArray(t) {
    const e = [];
    for (let i = 0; i < t.length; i += 2)
      e.push([t[i], t[i + 1]]);
    return e;
  }
  static _pairArrayToFlatArray(t) {
    const e = [];
    for (const i of t)
      e.push(i[0], i[1]);
    return e;
  }
  /**
   * Retrieve the [[MeshId]] associated with the mesh data attached to the given nodes.
   */
  async getMeshIds(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    ), i = await this._engine.getInstancesMeshData(e);
    return Po._flatArrayToPairArray(i);
  }
  /**
   * Replace a mesh's data. This will affect all instances of that mesh.
   * @param key the [[MeshId]] identifying the mesh
   * @param data the new data
   */
  replaceMesh(t, e) {
    return this._engine.replaceMesh(t, e);
  }
  /**
   * Creates an instance of a mesh that has been created using [[createMesh]] or retrieved using [[getMeshIds]].
   * @param data object that specifies the data for this mesh instance
   * @param parentNodeId the ID of the desired parent node
   * @param preventFromResetting if set to true, then the visibility and positioning won't be reset when resetxxx() functions gets called.
   * @param isOutOfHierarchy True if the node created shouldn't appear in the model structure.
   * @returns Promise that resolves with a node ID that can be used to perform operations on this instance.
   */
  createMeshInstance(t, e, i, s) {
    return e === void 0 && (e = null), i || (i = !1), s || (s = !1), this._createMeshInstance(t, e, i, s);
  }
  async _createMeshInstance(t, e, i, s) {
    const r = t.getMatrix(), o = r !== null || e !== null;
    let a = t.getCreationFlags();
    i && (a |= xt.DoNotReset), console.assert(
      !e || !s,
      "Out of hierarchy instances should not have a parent node."
    );
    const l = e === null || this.getNodeVisibility(e);
    let c = t;
    (o || !l) && (c = t.copy(), c.setCreationFlags(a | xt.Invisible));
    const h = await this._engine.createMeshInstance(c), u = this._modelStructure.createMeshInstance(
      h[0],
      h[1],
      t.getInstanceName(),
      e,
      i,
      s,
      !1
    );
    if (o || !l) {
      const g = r || new Q();
      await this.setNodeMatrix(u, g, !0), !(a & xt.Invisible) && l && this._engine.setPartVisibility(h, !0, !0);
    }
    let p = l;
    a & xt.Invisible && (p = !1);
    const m = this._modelStructure.lookupAnyTreeNode(u);
    return m !== null && m.setVisibility(p), e !== null && await this._callbackManager.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      [u],
      ps.CreateInstance
    ), u;
  }
  /**
   * Creates a PMI Instance from a mesh that has been created using the createMesh method.
   * @param data object that specifies the data for the PMI graphic representation
   * @param pmiType see PmiType enum (Datum, Gdt, Dimension...)
   * @param pmiSubType see PmiSubType enum (DatumTarget, GdtFcf, DimensionDistance...)
   * @param refOnTopoItems see RefOnTopoItem. It defines the PMI links to a body element, like a face or an edge
   * @param parentNodeId the ID of the desired parent node
   * @returns Promise that resolves with a node ID that can be used to perform operations on this instance. You can use deleteMeshInstances() to delete the PMI
   */
  async createPmiInstance(t, e, i, s, r) {
    r === void 0 && (r = null);
    const o = [];
    for (const c of s) {
      const h = this._modelStructure.lookupBodyInstance(c.bodyId);
      if (h === null)
        throw new sn(c.bodyId);
      const u = Xr.fromBodyInstance(
        h,
        c.subElementType,
        c.subElementIndex
      );
      o.push(u);
    }
    const a = await this._engine.createMeshInstance(t), l = this._modelStructure.createPmiInstance(
      a[0],
      a[1],
      e,
      i,
      o,
      t.getInstanceName(),
      r
    );
    return r !== null && await this._callbackManager.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      [l],
      ps.CreatePmi
    ), l;
  }
  /**
   * Creates an image that can be applied as a texture via [[setNodesTexture]].
   * See [[deleteImages]].
   * @param primaryImage The image data and associated options
   * @param thumbnailImage If specified, an uncompressed image that will be used as a
   *                       placeholder for the primary image until it is fully loaded.
   *                       Only useful when `primaryImage` is a compressed image.
   */
  createImage(t, e) {
    return this._engine.createImage(t, e);
  }
  /**
   * Deletes images created with [[createImage]].
   * @param imageIds The IDs of the images to be deleted
   */
  deleteImages(t) {
    return this._engine.destroyImages(Po._pairArrayToFlatArray(t));
  }
  /**
   * Apply an image to a node as a texture map. See [[createImage]] and [[unsetNodesTexture]].
   * @param nodeIds The nodes on which to apply the texture
   * @param options Options specifying how the texture is applied
   */
  setNodesTexture(t, e) {
    const i = this._getInstanceIncsFromLeafNodes(t);
    return this._engine.setTexture(i, e);
  }
  /**
   * Remove one or more textures applied via [[setNodesTexture]].
   * @param nodeIds The nodes from which to remove the texture or textures
   */
  unsetNodesTexture(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    this._engine.unsetTexture(e);
  }
  /**
   * Deletes meshes that have been created at run time.
   *
   * In order for this method to succeed, all mesh instances created for the given IDs
   * must have also been destroyed with [[deleteMeshInstances]].
   *
   * @param meshIds The IDs of meshes that should be deleted
   * @returns Promise that resolves when this operation has completed.
   */
  deleteMeshes(t) {
    return this._engine.destroyMeshes(Po._pairArrayToFlatArray(t));
  }
  /**
   * Deletes mesh instances that have been created at run time
   * @param nodeIds array of IDs for mesh instances created at run time that should be destroyed
   * @returns Promise that resolves when this operation has completed.
   */
  deleteMeshInstances(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    ), i = [];
    if (e.length > 0) {
      for (const s of t)
        i.push(this._modelStructure.deleteNode(s));
      i.push(this._engine.destroyLocalInstances(e));
    }
    return zt(i);
  }
  _obtainLoadSubtreeConfig(t) {
    if (t[0] instanceof hr)
      return t[0].copy();
    {
      const e = new hr();
      return e.additionalMatrix = t[0] || null, e.allowMissingExternalModels = !!t[1], e.copy();
    }
  }
  loadSubtreeFromXmlFile(t, e, i, ...s) {
    const r = this._obtainLoadSubtreeConfig(s);
    return i || (i = Ca), this._modelStructure.loadSubtreeFromXmlFile(
      t,
      e,
      i,
      r
    );
  }
  loadSubtreeFromXmlBuffer(t, e, i, ...s) {
    const r = this._obtainLoadSubtreeConfig(s);
    return i || (i = Ca), this._modelStructure.loadSubtreeFromXmlDoc(t, e, i, r);
  }
  loadSubtreeFromScsXmlFile(t, e, i, ...s) {
    const r = this._obtainLoadSubtreeConfig(s);
    return i || (i = Ca), this._modelStructure.loadSubtreeFromScsXmlFile(
      t,
      e,
      i,
      r
    );
  }
  loadSubtreeFromScsXmlBuffer(t, e, i, ...s) {
    const r = this._obtainLoadSubtreeConfig(s);
    return i || (i = Ca), this._modelStructure.loadSubtreeFromScsXmlDoc(t, e, i, r);
  }
  loadSubtreeFromModel(t, e, ...i) {
    const s = this._obtainLoadSubtreeConfig(i);
    return this._modelStructure.loadSubtreeFromStream(t, e, s);
  }
  loadSubtreeFromScsFile(t, e, ...i) {
    const s = this._obtainLoadSubtreeConfig(i);
    return this._modelStructure.loadSubtreeFromScsFile(t, e, s);
  }
  loadSubtreeFromScsBuffer(t, e, ...i) {
    const s = this._obtainLoadSubtreeConfig(i);
    return this._modelStructure.loadSubtreeFromScsBuffer(t, e, s);
  }
  /**
   * Loads measurement data from a JSON object
   * @param json JSON object containing measurement data
   */
  loadMeasurementFromJson(t) {
    return this._modelStructure.loadMeasurementFromJson(t);
  }
  /**
   * Loads measurement data from a JSON string
   * @param str JSON string containing measurement data
   */
  loadMeasurementFromString(t) {
    return this._modelStructure.loadMeasurementFromString(t);
  }
  /**
   * Loads measurement data from a ZIP file
   * @param filename Name of a file containing ZIP measurement data
   */
  loadMeasurementFromFile(t) {
    return this._modelStructure.loadMeasurementFromFile(t);
  }
  /**
   * Delete all the current scene and load the specified model instead. Also triggers a "modelSwitched" when finished.
   * @param newModelFilename Name of the model file to load after the existing scene gets deleted
   * @returns A `Promise` of the newly loaded model's root nodes IDs.
   */
  switchToModel(t) {
    return this._callbackManager.trigger("modelLoadBegin"), this._modelStructure.switchToModel(t);
  }
  /**
   * Creates a node
   * @param parentNodeId ID of the node to link the child node to. This ID should not have a type of Body or BodyInstance. If this parameter is `undefined`, the child node will be linked to the root.
   * @param name of the node to create
   * @param nodeID (optional) ID you want the node to have, if not specified the nodeID will be set automatically. Be aware that if the specified node ID is already used by another node, then it will be ignored a new one will be set automatically.
   * @param localMatrix (optional) Initial local matrix of the node (identity if none set)
   * @param visibility (optional) Initial visibility of the node (visible if nothing set)
   * @param measurmentUnit (optional) Specifies optional measurement units for this node. When set to null (the default), the node will inheret the unit setting of the parent node. If set, a scaling matrix will be computed
   *    that scales appropriately based on the unit scaling and applied to the newly created node. If a non-null localMatrix has been specified, that matrix will be combined with the computed scaling matrix.
   * @returns child node ID
   */
  createNode(t, e, i, s, r, o) {
    t === void 0 && (t = null), i === void 0 && (i = null), s === void 0 && (s = null), r == null && (r = !0);
    const a = this._modelStructure.createNode(
      t,
      e,
      i,
      s,
      r,
      o
    );
    return a !== null && this._callbackManager.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      [a],
      ps.CreateNode
    ), a;
  }
  /**
   * Delete a node and all its children
   * @param ID of the node
   */
  async deleteNode(t) {
    const e = this._modelStructure.gatherInclusionKeysFromNodeIds([t]);
    await this._modelStructure.deleteNode(t), await this._engine.detachInclusions(e), this._callbackManager.trigger("subtreeDeleted", [t]);
  }
  /**
   * Creates an part node
   * @param nodeID (optional) ID you want the node to have, if not specified the nodeID will be set automatically. Be aware that if the specified node ID is already used by another node, then it will be ignored and new one will be set automatically.
   * @returns a node ID to access the created part node
   */
  createPart(t) {
    return t === void 0 && (t = null), this._modelStructure.createPart(t);
  }
  /**
   * Set a part on an assembly node
   * @param assemblyNodeID ID of the assembly node
   * @param partNodeID ID of the part node
   * @returns true if all went right, false otherwise
   */
  setPart(t, e) {
    return t == null || e == null ? !1 : this._modelStructure.setPart(t, e);
  }
  /**
   * Creates a representation item on a part
   * @param partNodeId ID of the part node
   * @param repItemId (optional) Id you want the node to have, if not specified the nodeId will be set automatically. Be aware that if the specified node Id is already used by another node, then it will be ignored and a new one will be set automatically.
   * @returns node ID to access the created representation item, null is returned if something went wrong
   */
  createAndAddRepresentationItem(t, e) {
    return t == null ? null : (e === void 0 && (e = null), this._modelStructure.createAndAddRepItem(t, e));
  }
  /**
   * Returns the lowest available node ID
   */
  getLowestAvailableNodeId() {
    return this._modelStructure.getLowestAvailableNodeId();
  }
  /**
   * Allows changing the behavior in the viewer
   * @param instanceModifier InstanceModifier
   * @param nodeIds Array of node ids
   * @param value boolean
   */
  setInstanceModifier(t, e, i) {
    return this._setInstanceModifier(t, e, i, bt.All), Promise.resolve();
  }
  /** @hidden */
  _setInstanceModifier(t, e, i, s) {
    const r = this._modelStructure.gatherInstanceIncsFromNodeIds(
      e,
      s,
      ft.None
    );
    r.length > 0 && this._engine.setInstanceModifier(t, r, i);
  }
  getAssociatedModelKey(t) {
    const e = this._modelStructure.getAssociatedModelKey(t);
    return Promise.resolve(e);
  }
  hasDepthRange(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    return this._engine.hasDepthRange(e);
  }
  /**
   * Remaps the depth values used for z-ordering of pixels to the given
   * range, which must be a subset of `[0,1]`. The depth value at the
   * near plane (normally `0`) is mapped to `min` and the value at
   * the far plane (normally `1`) is mapped to `max`.
   *
   * The smaller the range, the more z-fighting you will see among
   * objects set to that range.
   *
   * @param nodeIds the node IDs to operate on
   * @param min the depth value at the near plane
   * @param max the depth value at the far plane
   */
  setDepthRange(t, e, i) {
    return this._setDepthRange(t, e, i), Promise.resolve();
  }
  _setDepthRange(t, e, i) {
    const s = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    this._engine.setDepthRange(s, e, i);
  }
  /**
   * Unsets the depth range set by [[setDepthRange]].
   * @param nodeIds the node IDs to operate on
   */
  unsetDepthRange(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    this._engine.unsetDepthRange(e);
  }
  /** @hidden */
  _gatherInstanceIncsFromNodeIds(t, e = bt.All) {
    return this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      e,
      ft.None
    );
  }
  _getInstanceIncsFromLeafNodes(t) {
    const e = [];
    for (const i of t) {
      const s = this._modelStructure.gatherInstanceIncsFromNodeIds(
        [i],
        bt.All,
        ft.None
      );
      if (s.length === 2) {
        const r = s;
        e.push(r[0], r[1]);
      } else
        throw new Mt("Non-leaf node encountered");
    }
    return e;
  }
  _getInstanceIncFromSingleLeafNode(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      bt.All,
      ft.None
    );
    if (e.length === 2)
      return e;
    throw new Mt("Non-leaf node encountered");
  }
  /**
   * Sets the desired mesh level
   * @param nodeIds IDs of nodes in the assembly on which mesh level will be set
   * @param meshLevel 0 standard, 1 low, 2 extra low
   * @returns Promise that resolves when the operation has completed.
   */
  setMeshLevel(t, e) {
    return this._modelStructure.setMeshLevel(t, e), Promise.resolve();
  }
  /**
   * Sets the metallic and roughness factors for the supplied nodes materials.
   * Materials that are not currently set to use the Metallic Roughness shading model will be upgraded to use this mode.
   * @param nodeIds List of nodes to set material properties for
   * @param metallicFactor The metalness of the material
   * @param roughnessFactor The roughness of the material
   */
  setMetallicRoughness(t, e, i) {
    const s = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    this._engine.setMetallicRoughness(s, e, i);
  }
  /**
   * Gets the metallic and roughness factors for the supplied nodes materials.
   * Materials that are not currently set to use the Metallic Roughness shading model will have a null entry
   * @param nodeIds List of nodes to get material properties for
   */
  getMetallicRoughness(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    return this._engine.getMetallicRoughness(e);
  }
  /**
   * Unsets the metallic and roughness values set with [[setMetallicRoughness]]
   * These materials will no longer use the Metallic Roughness shading model.
   * @param nodeIds List of nodes to unset material properties for
   */
  unsetMetallicRoughness(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    this._engine.unsetMetallicRoughness(e);
  }
  /**
   * If enabled then models loaded into an existing scene with a different unit value will be scaled to the unit value of the current scene.
   * @param enabled value indicating if automatic unit scaling will be active
   */
  setEnableAutomaticUnitScaling(t) {
    return this._modelStructure.setEnableAutomaticUnitScaling(t);
  }
  /**
   * By default, objects that are initially hidden stays hidden unless specifically set to be shown. This function allows this behavior to be disabled.
   * @param enabled value indicating if initially hidden objects stay hidden
   */
  setBehaviorInitiallyHidden(t) {
    return this._modelStructure.setBehaviorInitiallyHidden(t);
  }
  /**
   * Tells if the model is a CAD drawing or not
   * @returns true if the model is a CAD drawing
   */
  isDrawing() {
    return this._modelStructure.isACadDrawing();
  }
  /**
   * @returns true if the model contains measurement data.
   */
  isMeasurable() {
    return this._modelStructure.isMeasurable();
  }
  /**
   * @param bodyId ID of the body node containing the line
   * @param lineIndex Index of the line ot be checked
   * @returns true if the line has associated measurement data
   */
  isLineMeasurable(t, e) {
    return this._modelStructure.isLineMeasurable(t, e);
  }
  isFaceMeasurable(t, e) {
    return this._modelStructure.isFaceMeasurable(t, e);
  }
  /**
   * @returns the original file name of the model which contain the given node or null if the node is not found.
   */
  getModelFileNameFromNode(t) {
    return this._modelStructure.getModelFileNameFromNode(t);
  }
  /**
   * @returns the original file type of the model which contain the given node or null if the node is not found.
   */
  getModelFileTypeFromNode(t) {
    return this._modelStructure.getModelFileTypeFromNode(t);
  }
  /**
   * @returns the generic type of the given node or null if the node is not found.
   */
  getNodeGenericType(t) {
    return this._modelStructure.getNodeGenericType(t);
  }
  /**
   * @returns the generic id of the given node or null if the node is not found.
   */
  getNodeGenericId(t) {
    return this._modelStructure.getNodeGenericId(t);
  }
  /**
   * This function recursively discovers BIM nodes in the supplied subtree and registers them.
   * @param startNodeId The root of the subtree to walk for registration.
   * @param attributeToMask The callback used to obtain a node's [[BimMask]] from its attributes.
   * @returns Promise that resolves when the operation has completed.
   */
  async registerBimNodes(t, e, i = null) {
    const s = this._modelStructure.lookupAnyTreeNode(t);
    if (s !== null)
      return typeof i == "boolean" && (i = i ? "TYPE" : null), s_(
        e,
        this._engine,
        this._modelStructure,
        s,
        i
      );
  }
  /**
   * Gets all generic types and NodeIds with that type.
   * @returns Map containing generic types and NodeIds
   */
  getGenericTypeIdMap() {
    return this._modelStructure.getGenericTypeIdMap();
  }
  /**
   * This function returns all NodeIds with an IFC type.
   * @param genericType
   * @returns All NodeIds with an IFC type
   */
  getNodesByGenericType(t) {
    return this._modelStructure.getNodesByGenericType(t);
  }
  /**
   * This function gets all generic types contained in the model.
   * @returns All generic types.
   */
  getGenericTypes() {
    return this._modelStructure.getGenericTypes();
  }
  /**
   * Checks if a [[NodeId]] is a generic type.
   * @param nodeId
   * @param genericType
   */
  hasEffectiveGenericType(t, e) {
    return this._modelStructure.hasEffectiveGenericType(t, e);
  }
  /**
   * This function recursively discovers IFC nodes in the supplied subtree and registers them.
   * @param startNodeId The root of the subtree to walk for registration.
   * @returns Promise that resolves when the operation has completed.
   */
  registerIfcNodes(t, e = null) {
    return this.registerBimNodes(t, $f, e);
  }
  /**
   * Tells if the view is an annotation view or not
   * @param cadViewNodeId Node ID of the CAD view
   * @returns true if the view is an annotation view
   */
  isAnnotationView(t) {
    return this._modelStructure.isAnnotationView(t);
  }
  /**
   * Tells if the view is a combine state view or not
   * @param cadViewNodeId Node ID of the CAD view
   * @returns true if the view is a combine state view
   */
  isCombineStateView(t) {
    return this._modelStructure.isCombineStateView(t);
  }
  /**
   * Sets a vector and angle used to determine an object's visibility based on camera orientation.
   * @param space The space in which the culling vector is defined.
   * @param vector A vector that will be compared with the view vector.
   * @param toleranceDegrees The maximum angle between the culling vector and the view vector within which the object will be visible.
   */
  setNodesCullingVector(t, e, i, s) {
    return this._setNodesCullingVector(t, e, i, s), Promise.resolve();
  }
  _setNodesCullingVector(t, e, i, s) {
    const r = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    return this._engine.setCullingVector(r, e, i, s);
  }
  /**
   * Unsets the vector and angle used to determine an object's visibility based on camera orientation.
   * @param nodeIds The nodes to unset culling vectors on.
   */
  unsetNodesCullingVectors(t) {
    return this._unsetNodesCullingVectors(t), Promise.resolve();
  }
  _unsetNodesCullingVectors(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    this._engine.unsetCullingVector(e);
  }
  /**
   * Retrieves the vector and angle used to determine an object's visibility based on camera orientation.
   * If unset, `null` will appear at the corresponding array index.
   * @param nodeIds The nodes to query culling vectors from.
   * @returns A promise of culling vectors.
   */
  getNodesCullingVectors(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    return this._engine.getCullingVector(e);
  }
  /**
   * Retrieves the node ID offset for a given node.
   * @param nodeId The node to obtain the node ID offset from.
   * @returns The node ID offset for the supplied node.
   */
  getNodeIdOffset(t) {
    return this._modelStructure.getIdOffset(t);
  }
  /**
   * Queries if a node is fully loaded or not.
   * @param nodeId The node to query.
   * @returns True if the node is fully loaded; false otherwise.
   */
  isNodeLoaded(t) {
    return this._modelStructure.isNodeLoaded(t);
  }
  /**
   * Triangulates the supplied polygon.
   * @param polygonPoints An array of point data for the polygon. Points are stored [XYZXYZXYZ...] format.
   * @param normal The normal of the polygon to triangulate.
   * @returns An array containing the point data for the generated triangles. Points are stored [XYZXYZXYZ...] format.
   *          This returned list is always divisible by 9 (3 points per triangle; 3 floats per point).
   */
  triangulatePolygon(t, e) {
    const i = Fr(e);
    return this._engine.triangulatePolygon(t, i);
  }
  /**
   * Applies the given line pattern to the specified nodes. See also [[unsetNodesLinePattern]].
   * @param nodeIds The IDs of the nodes.
   * @param pattern The line pattern. See [[LinePattern]] for details.
   * @param patternLength The length of a single repetition of the line pattern.
   * @param patternLengthUnit The unit in which the length of the pattern is measured. See [[LinePatternLengthUnit]] for details.
   */
  setNodesLinePattern(t, e, i, s) {
    const r = this._gatherInstanceIncsFromNodeIds(t);
    this._engine.setLinePattern(r, e, i, s);
  }
  /**
   * Removes the line pattern applied by [[setNodesLinePattern]].
   * @param nodeIds The IDs of the nodes.
   */
  unsetNodesLinePattern(t) {
    const e = this._gatherInstanceIncsFromNodeIds(t);
    this._engine.unsetLinePattern(e);
  }
  /** @hidden */
  async _hwfAwaitAssemblyTreeReady() {
    const t = this.getAbsoluteRootNode(), e = this._modelStructure.lookupAnyTreeNode(t);
    if (e === null)
      throw new re();
    const i = gn(e);
    await yi.forceLazyPromises(i), await er([i]);
  }
  /**
   * Returns all the `UserDataIndex` items associated with the input node.
   * @param nodeId The ID of the node to query.
   * @returns A list of `UserDataIndex`, possibly empty.
   * @throws `InvalidNodeIdError`
   */
  getNodeUserDataIndices(t) {
    return this._modelStructure.getUserDataIndices(t);
  }
  /**
   * Returns the user data for a given node and index.
   * @param nodeId The ID of the node to query.
   * @param index The index of the data.
   * @returns The user data.
   * @throws `InvalidNodeIdError` `InvalidIndexError`
   */
  getNodeUserData(t, e) {
    return this._modelStructure.getUserData(t, e);
  }
  /**
   * Returns a list of node IDs given a list of generic IDs. Note that the
   * returned list of node IDs may be longer than the provided list of generic
   * IDs since one ID can be used by more than one node.
   * @param genericIds Array of generic IDs to find nodes fore
   * @returns Array of node ids corresponding to the provided generic IDs
   */
  getNodeIdsByGenericIds(t) {
    const e = [];
    for (const i of t) {
      const s = this._modelStructure.getNodesByGenericId(i);
      s !== null && s.forEach((r) => {
        e.push(r);
      });
    }
    return e;
  }
  /** @hidden */
  _getModelStructure() {
    return this._modelStructure;
  }
  /**
   * Returns true if the node is within an external model.
   * @param nodeId
   */
  isWithinExternalModel(t) {
    return this._modelStructure.isWithinExternalModel(t);
  }
  /** @hidden */
  _firstAssemblyDataHeader() {
    return this._modelStructure.firstAssemblyDataHeader();
  }
  /**
   * Retrieves the bim id of the corresponding node id.
   * @param node the id of the node for which you want its bim id.
   * @returns the bim id corresponding to the node or null if none.
   */
  getBimIdFromNode(t) {
    return this._modelStructure.getBimIdFromNode(t);
  }
  /**
   * Retrieves the bim ids of the corresponding generic id.
   * @param ifcGuid the generic id for which you want its bim id.
   * @returns the bim id corresponding to the ifcGuid or null if none.
   */
  getBimIdsFromGenericId(t) {
    const e = [], i = this._modelStructure.getNodesByGenericId(t);
    return i !== null && i.forEach((s) => {
      const r = this.getBimIdFromNode(s);
      r !== null && e.push(r);
    }), e;
  }
  /**
   * Retrieves the node id of the corresponding bim id.
   * @param node any known node id of the working model.
   * @param bimID bim id for which you want its node id.
   * @returns the node id corresponding to the BimId or null if none.
   */
  getNodeIdFromBimId(t, e) {
    return this._modelStructure.getRuntimeNodeFromBimId(t, e);
  }
  /**
   * Retrieves the generic id of the corresponding bim id.
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its generic id.
   * @returns the generic id corresponding to the BimId or null if none.
   */
  getGenericIdFromBimId(t, e) {
    const i = this._modelStructure.getRuntimeNodeFromBimId(t, e);
    return i !== null ? this._modelStructure.getNodeGenericId(i) : null;
  }
  /**
   * Retrieves all type of relationships that a bim id has.
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its types of relationships.
   * @returns array of type of relationship corresponding to the BimId.
   */
  getRelationshipTypesFromBimId(t, e) {
    const i = [], s = this._modelStructure.getBimIdRelationshipTypes(t, e);
    for (const r of s)
      i.push(r.type);
    return i;
  }
  /**
   * Retrieve all related relationships that a bim id have.
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its related relationships.
   * @returns array of bim id which are the related relationship of the BimId.
   */
  getBimIdRelatedElements(t, e, i) {
    const s = this._modelStructure.getBimIdRelationshipTypes(t, e);
    for (const r of s)
      if (r.type === i)
        return r.relateds;
    return [];
  }
  /**
   * Retrieve all relating relationships that a bim id have.
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its relating relationships.
   * @returns array of bim id which are the relating relationship of the BimId.
   */
  getBimIdRelatingElements(t, e, i) {
    const s = this._modelStructure.getBimIdRelationshipTypes(t, e);
    for (const r of s)
      if (r.type === i)
        return r.relatings;
    return [];
  }
  /**
   * Retrieve all relationships that a bim id have, sorted in 2 arrays (relateds and relatings)
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its relationships.
   * @returns double array of bim id of relationship of the BimId sorted by its relateds and its relatings.
   */
  getBimIdConnectedElements(t, e, i) {
    const s = this._modelStructure.getBimIdRelationshipTypes(t, e);
    for (const r of s)
      if (r.type === i)
        return { relateds: r.relateds, relatings: r.relatings };
    return { relateds: [], relatings: [] };
  }
  /**
   * Retrieve the name of the bim element
   * @param bimId bim id for which you want the bim element name.
   * @param node any known node id of the working model.
   * @returns the name and the info regarding the connection to a node of the bim element.
   */
  getBimInfoFromBimId(t, e) {
    return this._modelStructure.getInfoOfBimId(t, e);
  }
}
var L0 = /* @__PURE__ */ ((n) => {
})(), X0 = /* @__PURE__ */ ((n) => {
})(), ps = /* @__PURE__ */ ((n) => (n[n.LoadModel = 0] = "LoadModel", n[n.CreateNode = 1] = "CreateNode", n[n.CreateInstance = 2] = "CreateInstance", n[n.CreatePmi = 3] = "CreatePmi", n))(ps || {}), m_ = /* @__PURE__ */ ((n) => (n[n.Desktop = 0] = "Desktop", n[n.Mobile = 1] = "Mobile", n))(m_ || {}), vt = /* @__PURE__ */ ((n) => (n[n.Faces = 0] = "Faces", n[n.Lines = 1] = "Lines", n[n.Points = 2] = "Points", n))(vt || {}), te = /* @__PURE__ */ ((n) => (n[n.Perspective = 0] = "Perspective", n[n.Orthographic = 1] = "Orthographic", n))(te || {}), et = /* @__PURE__ */ ((n) => (n[n.Top = 0] = "Top", n[n.Bottom = 1] = "Bottom", n[n.Left = 2] = "Left", n[n.Right = 3] = "Right", n[n.Front = 4] = "Front", n[n.Back = 5] = "Back", n[n.Iso = 6] = "Iso", n[n.TopRightFront = 7] = "TopRightFront", n[n.TopLeftFront = 8] = "TopLeftFront", n[n.TopLeftBack = 9] = "TopLeftBack", n[n.TopRightBack = 10] = "TopRightBack", n[n.TopBack = 11] = "TopBack", n[n.TopFront = 12] = "TopFront", n[n.TopLeft = 13] = "TopLeft", n[n.TopRight = 14] = "TopRight", n[n.BottomRightBack = 15] = "BottomRightBack", n[n.BottomLeftBack = 16] = "BottomLeftBack", n[n.BottomLeftFront = 17] = "BottomLeftFront", n[n.BottomRightFront = 18] = "BottomRightFront", n[n.BottomFront = 19] = "BottomFront", n[n.BottomBack = 20] = "BottomBack", n[n.BottomLeft = 21] = "BottomLeft", n[n.BottomRight = 22] = "BottomRight", n[n.RightBottomBack = 23] = "RightBottomBack", n[n.RightBottomFront = 24] = "RightBottomFront", n[n.RightTopFront = 25] = "RightTopFront", n[n.RightTopBack = 26] = "RightTopBack", n[n.RightTop = 27] = "RightTop", n[n.RightBottom = 28] = "RightBottom", n[n.RightFront = 29] = "RightFront", n[n.RightBack = 30] = "RightBack", n[n.LeftBottomFront = 31] = "LeftBottomFront", n[n.LeftBottomBack = 32] = "LeftBottomBack", n[n.LeftTopBack = 33] = "LeftTopBack", n[n.LeftTopFront = 34] = "LeftTopFront", n[n.LeftTop = 35] = "LeftTop", n[n.LeftBottom = 36] = "LeftBottom", n[n.LeftBack = 37] = "LeftBack", n[n.LeftFront = 38] = "LeftFront", n[n.FrontBottomRight = 39] = "FrontBottomRight", n[n.FrontTopRight = 40] = "FrontTopRight", n[n.FrontTopLeft = 41] = "FrontTopLeft", n[n.FrontBottomLeft = 42] = "FrontBottomLeft", n[n.FrontRight = 43] = "FrontRight", n[n.FrontLeft = 44] = "FrontLeft", n[n.FrontTop = 45] = "FrontTop", n[n.FrontBottom = 46] = "FrontBottom", n[n.BackTopRight = 47] = "BackTopRight", n[n.BackBottomRight = 48] = "BackBottomRight", n[n.BackBottomLeft = 49] = "BackBottomLeft", n[n.BackTopLeft = 50] = "BackTopLeft", n[n.BackLeft = 51] = "BackLeft", n[n.BackRight = 52] = "BackRight", n[n.BackBottom = 53] = "BackBottom", n[n.BackTop = 54] = "BackTop", n))(et || {}), Ht = /* @__PURE__ */ ((n) => (n[n.X = 0] = "X", n[n.Y = 1] = "Y", n[n.Z = 2] = "Z", n))(Ht || {}), Kt = /* @__PURE__ */ ((n) => (n[n.None = -1] = "None", n[n.Left = 0] = "Left", n[n.Middle = 1] = "Middle", n[n.Right = 2] = "Right", n))(Kt || {}), Ai = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Left = 1] = "Left", n[n.Right = 2] = "Right", n[n.Middle = 4] = "Middle", n))(Ai || {}), Jn = /* @__PURE__ */ ((n) => (n[n.Axis = 0] = "Axis", n[n.Plane = 1] = "Plane", n[n.ViewPlane = 2] = "ViewPlane", n[n.Rotate = 3] = "Rotate", n))(Jn || {}), ws = /* @__PURE__ */ ((n) => (n[n.Translate = 0] = "Translate", n[n.Rotate = 1] = "Rotate", n))(ws || {}), Et = /* @__PURE__ */ ((n) => (n[n.Invalid = -1] = "Invalid", n[n.None = 0] = "None", n[n.Navigate = 1] = "Navigate", n[n.Orbit = 2] = "Orbit", n[n.Pan = 3] = "Pan", n[n.Zoom = 4] = "Zoom", n[n.WindowZoom = 5] = "WindowZoom", n[n.Walk = 6] = "Walk", n[n.KeyboardWalk = 7] = "KeyboardWalk", n[n.WalkMode = 8] = "WalkMode", n[n.Turntable = 9] = "Turntable", n[n.Select = 10] = "Select", n[n.AreaSelect = 11] = "AreaSelect", n[n.RayDrillSelect = 12] = "RayDrillSelect", n[n.RedlineCircle = 13] = "RedlineCircle", n[n.RedlineText = 14] = "RedlineText", n[n.RedlineRectangle = 15] = "RedlineRectangle", n[n.RedlinePolyline = 16] = "RedlinePolyline", n[n.MeasureEdgeLength = 17] = "MeasureEdgeLength", n[n.MeasureFaceFaceDistance = 18] = "MeasureFaceFaceDistance", n[n.MeasureLineLineAngle = 19] = "MeasureLineLineAngle", n[n.MeasurePointPointDistance = 20] = "MeasurePointPointDistance", n[n.MeasureBodyBodyDistance = 21] = "MeasureBodyBodyDistance", n[n.MeasureFaceFaceAngle = 22] = "MeasureFaceFaceAngle", n[n.MeasurePolylineDistance = 23] = "MeasurePolylineDistance", n[n.MeasurePolygonArea = 24] = "MeasurePolygonArea", n[n.Note = 25] = "Note", n[n.Cutting = 26] = "Cutting", n[n.Handle = 27] = "Handle", n[n.NavCube = 28] = "NavCube", n[n.AxisTriad = 29] = "AxisTriad", n[n.Floorplan = 30] = "Floorplan", n[n.SpaceMouse = 31] = "SpaceMouse", n))(Et || {}), kt = /* @__PURE__ */ ((n) => (n[n.MouseDown = 0] = "MouseDown", n[n.MouseMove = 1] = "MouseMove", n[n.MouseUp = 2] = "MouseUp", n[n.Mousewheel = 3] = "Mousewheel", n[n.TouchStart = 4] = "TouchStart", n[n.TouchMove = 5] = "TouchMove", n[n.TouchEnd = 6] = "TouchEnd", n[n.KeyDown = 7] = "KeyDown", n[n.KeyUp = 8] = "KeyUp", n[n.ViewOrientationChange = 9] = "ViewOrientationChange", n))(kt || {}), _e = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Shift = 2] = "Shift", n[n.Alt = 4] = "Alt", n[n.Control = 8] = "Control", n[n.Command = 16] = "Command", n))(_e || {}), Vn = /* @__PURE__ */ ((n) => (n[n.Down = 0] = "Down", n[n.Up = 1] = "Up", n[n.Move = 2] = "Move", n[n.Wheel = 3] = "Wheel", n))(Vn || {}), La = /* @__PURE__ */ ((n) => (n[n.Start = 0] = "Start", n[n.Move = 1] = "Move", n[n.End = 2] = "End", n))(La || {}), kc = /* @__PURE__ */ ((n) => (n[n.Down = 0] = "Down", n[n.Up = 1] = "Up", n))(kc || {}), Ot = /* @__PURE__ */ ((n) => (n[n.Forward = 0] = "Forward", n[n.Backward = 1] = "Backward", n[n.Left = 2] = "Left", n[n.Right = 3] = "Right", n[n.Up = 4] = "Up", n[n.Down = 5] = "Down", n[n.RotateRight = 6] = "RotateRight", n[n.RotateLeft = 7] = "RotateLeft", n[n.TiltUp = 8] = "TiltUp", n[n.TiltDown = 9] = "TiltDown", n))(Ot || {}), Ut = /* @__PURE__ */ ((n) => (n[n.Backspace = 8] = "Backspace", n[n.Shift = 16] = "Shift", n[n.Escape = 27] = "Escape", n[n.PgUp = 33] = "PgUp", n[n.PgDown = 34] = "PgDown", n[n.LeftArrow = 37] = "LeftArrow", n[n.UpArrow = 38] = "UpArrow", n[n.RightArrow = 39] = "RightArrow", n[n.DownArrow = 40] = "DownArrow", n[n.Delete = 46] = "Delete", n[n.a = 65] = "a", n[n.b = 66] = "b", n[n.c = 67] = "c", n[n.d = 68] = "d", n[n.e = 69] = "e", n[n.f = 70] = "f", n[n.g = 71] = "g", n[n.h = 72] = "h", n[n.i = 73] = "i", n[n.j = 74] = "j", n[n.k = 75] = "k", n[n.l = 76] = "l", n[n.m = 77] = "m", n[n.n = 78] = "n", n[n.o = 79] = "o", n[n.p = 80] = "p", n[n.q = 81] = "q", n[n.r = 82] = "r", n[n.s = 83] = "s", n[n.t = 84] = "t", n[n.u = 85] = "u", n[n.v = 86] = "v", n[n.w = 87] = "w", n[n.x = 88] = "x", n[n.y = 89] = "y", n[n.z = 90] = "z", n[n._0 = 48] = "_0", n[n._1 = 49] = "_1", n[n._2 = 50] = "_2", n[n._3 = 51] = "_3", n[n._4 = 52] = "_4", n[n._5 = 53] = "_5", n[n._6 = 54] = "_6", n[n._7 = 55] = "_7", n[n._8 = 56] = "_8", n[n._9 = 57] = "_9", n[n.NumPad_0 = 96] = "NumPad_0", n[n.NumPad_1 = 97] = "NumPad_1", n[n.NumPad_2 = 98] = "NumPad_2", n[n.NumPad_3 = 99] = "NumPad_3", n[n.NumPad_4 = 100] = "NumPad_4", n[n.NumPad_5 = 101] = "NumPad_5", n[n.NumPad_6 = 102] = "NumPad_6", n[n.NumPad_7 = 103] = "NumPad_7", n[n.NumPad_8 = 104] = "NumPad_8", n[n.NumPad_9 = 105] = "NumPad_9", n))(Ut || {}), Xt = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Face = 1] = "Face", n[n.Line = 2] = "Line", n[n.Point = 4] = "Point", n[n.All = 7] = "All", n))(Xt || {}), pi = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Face = 1] = "Face", n[n.Line = 2] = "Line", n[n.Point = 3] = "Point", n[n.Part = 4] = "Part", n))(pi || {}), ai = /* @__PURE__ */ ((n) => (n[n.Set = 0] = "Set", n[n.Add = 1] = "Add", n[n.Toggle = 2] = "Toggle", n))(ai || {}), Ln = /* @__PURE__ */ ((n) => (n[n.HighlightOnly = 0] = "HighlightOnly", n[n.OutlineOnly = 1] = "OutlineOnly", n[n.HighlightAndOutline = 2] = "HighlightAndOutline", n))(Ln || {}), p_ = /* @__PURE__ */ ((n) => (n[n.Info = 0] = "Info", n[n.Warning = 1] = "Warning", n[n.Error = 2] = "Error", n))(p_ || {}), Ps = /* @__PURE__ */ ((n) => (n[n.Interactive = 1] = "Interactive", n[n.All = 2] = "All", n[n.OnDemand = 4] = "OnDemand", n[
  n.Default = 1
  /* Interactive */
] = "Default", n))(Ps || {}), Ho = /* @__PURE__ */ ((n) => (n[n.Client = 0] = "Client", n[n.Server = 1] = "Server", n))(Ho || {}), Sn = /* @__PURE__ */ ((n) => (n[n.Wireframe = 0] = "Wireframe", n[n.Shaded = 1] = "Shaded", n[n.WireframeOnShaded = 2] = "WireframeOnShaded", n[n.HiddenLine = 3] = "HiddenLine", n[n.XRay = 4] = "XRay", n[n.Gooch = 5] = "Gooch", n[n.Toon = 6] = "Toon", n))(Sn || {}), g_ = /* @__PURE__ */ ((n) => (n[n.Unsorted = 0] = "Unsorted", n[n.SingleLayer = 1] = "SingleLayer", n))(g_ || {}), Hd = /* @__PURE__ */ ((n) => (n[n.SMAA = 0] = "SMAA", n[n.None = 1] = "None", n))(Hd || {}), Xe = /* @__PURE__ */ ((n) => (n[n.DoNotExplode = 0] = "DoNotExplode", n[n.DoNotCut = 1] = "DoNotCut", n[n.DoNotSelect = 2] = "DoNotSelect", n[n.SuppressCameraScale = 3] = "SuppressCameraScale", n[n.OverrideSceneVisibility = 4] = "OverrideSceneVisibility", n[n.DoNotLight = 5] = "DoNotLight", n[n.DoNotOutlineHighlight = 6] = "DoNotOutlineHighlight", n[n.ExcludeBounding = 7] = "ExcludeBounding", n[n.DoNotUseVertexColors = 8] = "DoNotUseVertexColors", n[n.AlwaysDraw = 9] = "AlwaysDraw", n[n.DoNotXRay = 10] = "DoNotXRay", n[n.ScreenOriented = 11] = "ScreenOriented", n[n.ScreenSpace = 12] = "ScreenSpace", n[n.ScreenSpaceStretched = 13] = "ScreenSpaceStretched", n[n.DoNotReset = 14] = "DoNotReset", n))(Xe || {}), xt = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.SuppressCameraScale = 1] = "SuppressCameraScale", n[n.ScreenOriented = 2] = "ScreenOriented", n[n.DoNotCut = 4] = "DoNotCut", n[n.DoNotExplode = 8] = "DoNotExplode", n[n.DoNotSelect = 16] = "DoNotSelect", n[n.DoNotLight = 32] = "DoNotLight", n[n.DoNotOutlineHighlight = 64] = "DoNotOutlineHighlight", n[n.ExcludeBounding = 128] = "ExcludeBounding", n[n.DoNotUseVertexColors = 256] = "DoNotUseVertexColors", n[n.Invisible = 512] = "Invisible", n[n.DoNotXRay = 1024] = "DoNotXRay", n[n.AlwaysDraw = 2048] = "AlwaysDraw", n[n.OverrideSceneVisibility = 4096] = "OverrideSceneVisibility", n[n.ScreenSpace = 8192] = "ScreenSpace", n[n.ScreenSpaceStretched = 16384] = "ScreenSpaceStretched", n[n.DoNotReset = 32768] = "DoNotReset", n))(xt || {}), vs = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Model = 1] = "Model", n[n.Instance = 2] = "Instance", n[n.Ejected = 4] = "Ejected", n[n.All = 7] = "All", n))(vs || {}), mo = /* @__PURE__ */ ((n) => (n[n.CameraTarget = 0] = "CameraTarget", n[n.ModelCenter = 1] = "ModelCenter", n[n.OrbitTarget = 2] = "OrbitTarget", n))(mo || {}), po = /* @__PURE__ */ ((n) => (n[n.Mouse = 0] = "Mouse", n[n.Keyboard = 1] = "Keyboard", n))(po || {}), At = /* @__PURE__ */ ((n) => (n[n.AssemblyNode = 0] = "AssemblyNode", n[n.PartInstance = 1] = "PartInstance", n[n.Part = 2] = "Part", n[n.BodyInstance = 3] = "BodyInstance", n[n.PmiBody = 4] = "PmiBody", n[n.ViewFrame = 5] = "ViewFrame", n[n.Body = 6] = "Body", n[n.BrepBody = 7] = "BrepBody", n[n.TessBody = 8] = "TessBody", n[n.WireBody = 9] = "WireBody", n[n.PointsBody = 10] = "PointsBody", n[n.Pmi = 11] = "Pmi", n[n.CadView = 12] = "CadView", n[n.DrawingSheet = 13] = "DrawingSheet", n[n.Unknown = 14] = "Unknown", n))(At || {}), Ud = /* @__PURE__ */ ((n) => (n[n.Unknown = 0] = "Unknown", n[n.Text = 1] = "Text", n[n.Dimension = 2] = "Dimension", n[n.Arrow = 3] = "Arrow", n[n.Balloon = 4] = "Balloon", n[n.CircleCenter = 5] = "CircleCenter", n[n.Coordinate = 6] = "Coordinate", n[n.Datum = 7] = "Datum", n[n.Fastener = 8] = "Fastener", n[n.Gdt = 9] = "Gdt", n[n.Locator = 10] = "Locator", n[n.MeasurementPoint = 11] = "MeasurementPoint", n[n.Roughness = 12] = "Roughness", n[n.Welding = 13] = "Welding", n[n.Table = 14] = "Table", n[n.Other = 15] = "Other", n[n.GeometricalTolerance = 16] = "GeometricalTolerance", n))(Ud || {}), Qd = /* @__PURE__ */ ((n) => (n[n.Unknown = 0] = "Unknown", n[n.DatumIdent = 1] = "DatumIdent", n[n.DatumTarget = 2] = "DatumTarget", n[n.DimensionDistance = 1] = "DimensionDistance", n[n.DimensionDistanceOffset = 2] = "DimensionDistanceOffset", n[n.DimensionDistanceCumulate = 3] = "DimensionDistanceCumulate", n[n.DimensionChamfer = 4] = "DimensionChamfer", n[n.DimensionSlope = 5] = "DimensionSlope", n[n.DimensionOrdinate = 6] = "DimensionOrdinate", n[n.DimensionRadius = 7] = "DimensionRadius", n[n.DimensionRadiusTangent = 8] = "DimensionRadiusTangent", n[n.DimensionRadiusCylinder = 9] = "DimensionRadiusCylinder", n[n.DimensionRadiusEdge = 10] = "DimensionRadiusEdge", n[n.DimensionDiameter = 11] = "DimensionDiameter", n[n.DimensionDiameterTangent = 12] = "DimensionDiameterTangent", n[n.DimensionDiameterCylinder = 13] = "DimensionDiameterCylinder", n[n.DimensionDiameterEdge = 14] = "DimensionDiameterEdge", n[n.DimensionDiameterCone = 15] = "DimensionDiameterCone", n[n.DimensionLength = 16] = "DimensionLength", n[n.DimensionLengthCurvilinear = 17] = "DimensionLengthCurvilinear", n[n.DimensionLengthCircular = 18] = "DimensionLengthCircular", n[n.DimensionAngle = 19] = "DimensionAngle", n[n.GdtFcf = 1] = "GdtFcf", n[n.WeldingLine = 1] = "WeldingLine", n[n.WeldingSpot = 2] = "WeldingSpot", n[n.OtherSymbolUser = 1] = "OtherSymbolUser", n[n.OtherSymbolUtility = 2] = "OtherSymbolUtility", n[n.OtherSymbolCustom = 3] = "OtherSymbolCustom", n[n.OtherGeometricReference = 4] = "OtherGeometricReference", n[n.OtherRegion = 5] = "OtherRegion", n))(Qd || {}), Uo = /* @__PURE__ */ ((n) => (n[n.Unknown = -1] = "Unknown", n[n.Context = 1] = "Context", n[n.Item = 2] = "Item", n[n.MultipleVertex = 3] = "MultipleVertex", n[n.UniqueVertex = 4] = "UniqueVertex", n[n.WireEdge = 5] = "WireEdge", n[n.Edge = 6] = "Edge", n[n.CoEdge = 7] = "CoEdge", n[n.Loop = 8] = "Loop", n[n.Face = 9] = "Face", n[n.Shell = 10] = "Shell", n[n.Connex = 11] = "Connex", n[n.Body = 12] = "Body", n[n.SingleWireBody = 13] = "SingleWireBody", n[n.BrepData = 14] = "BrepData", n[n.WireBody = 17] = "WireBody", n))(Uo || {}), yn = /* @__PURE__ */ ((n) => (n[n.Unknown = 0] = "Unknown", n[n.Clockwise = 1] = "Clockwise", n[n.CounterClockwise = 2] = "CounterClockwise", n))(yn || {}), Jt = /* @__PURE__ */ ((n) => (n[n.UpperLeftCorner = 0] = "UpperLeftCorner", n[n.LowerLeftCorner = 1] = "LowerLeftCorner", n[n.LowerRightCorner = 2] = "LowerRightCorner", n[n.UpperRightCorner = 3] = "UpperRightCorner", n[n.TopCenter = 4] = "TopCenter", n[n.LeftCenter = 5] = "LeftCenter", n[n.RightCenter = 6] = "RightCenter", n[n.BottomCenter = 7] = "BottomCenter", n[n.Center = 8] = "Center", n))(Jt || {}), Bt = /* @__PURE__ */ ((n) => (n[n.Pixels = 0] = "Pixels", n[n.ProportionOfCanvas = 1] = "ProportionOfCanvas", n[n.ProportionOfOtherDimension = 2] = "ProportionOfOtherDimension", n))(Bt || {}), Mc = /* @__PURE__ */ ((n) => (n[n.ScreenPixels = 0] = "ScreenPixels", n[n.CSSPixels = 1] = "CSSPixels", n[n.World = 2] = "World", n[n.ProportionOfScreenWidth = 3] = "ProportionOfScreenWidth", n[n.ProportionOfScreenHeight = 4] = "ProportionOfScreenHeight", n[n.ProportionOfBoundingDiagonal = 5] = "ProportionOfBoundingDiagonal", n))(Mc || {}), Wc = /* @__PURE__ */ ((n) => (n[n.Square = 0] = "Square", n[n.Disk = 1] = "Disk", n[n.Sphere = 2] = "Sphere", n))(Wc || {});
class f_ {
  constructor() {
    this.bodyId = jd, this.subElementType = -1, this.subElementIndex = -1;
  }
}
var Pt = /* @__PURE__ */ ((n) => (n[n.Hidden = 0] = "Hidden", n[n.Shown = 1] = "Shown", n[n.Mixed = 2] = "Mixed", n))(Pt || {}), __ = /* @__PURE__ */ ((n) => (n[n.Object = 0] = "Object", n[n.World = 1] = "World", n))(__ || {}), Gt = /* @__PURE__ */ ((n) => (n[n.First = 8] = "First", n[
  n.Handles = 8
  /* First */
] = "Handles", n[n.AxisTriad = 9] = "AxisTriad", n[n.NavCube = 10] = "NavCube", n[n.Floorplan = 11] = "Floorplan", n[n.TestFramework = 12] = "TestFramework", n))(Gt || {});
class y_ {
  constructor() {
    this.pos1 = d.zero(), this.pos2 = d.zero(), this.distance = 0;
  }
}
class mu {
  constructor() {
    this.frontVector = new d(-1, 0, 0), this.upVector = new d(0, 0, 1);
  }
}
var b_ = /* @__PURE__ */ ((n) => (n[n.Object = 0] = "Object", n[n.World = 1] = "World", n[n.ProportionOfScreenWidth = 2] = "ProportionOfScreenWidth", n[n.ProportionOfScreenHeight = 3] = "ProportionOfScreenHeight", n))(b_ || {}), Qo = /* @__PURE__ */ ((n) => (n[n.Selected = 0] = "Selected", n[n.Unselected = 1] = "Unselected", n))(Qo || {}), mn = /* @__PURE__ */ ((n) => (n[n.Pixels = 0] = "Pixels", n[n.ProportionOfWidth = 1] = "ProportionOfWidth", n[n.ProportionOfHeight = 2] = "ProportionOfHeight", n))(mn || {}), Bn = /* @__PURE__ */ ((n) => (n[n.Undefined = 0] = "Undefined", n[n.Int = 1] = "Int", n[n.Float = 2] = "Float", n[n.Time = 3] = "Time", n[n.String = 4] = "String", n[n.Ignored = 5] = "Ignored", n))(Bn || {});
class pu {
  constructor(t, e) {
    this.isInclusive = t, this.nodeIds = e;
  }
}
class I_ {
  constructor(t, e) {
    this.defaultVisibility = t, this.visibilityExceptions = e;
  }
}
class hr {
  constructor() {
    this.additionalMatrix = null, this.allowMissingExternalModels = !1, this.attachInvisibly = !1, this.implicitlyLoadXmlExternalModels = !0, this.ignoreCadViews = !1, this.ignoreFilters = !1, this.ignoreLayers = !1, this.ignoreGenericTypes = !1, this.ignoreBimRelationships = !1, this._allowSubtreeLoadedCallback = !0;
  }
  copy() {
    const t = new hr();
    return t.additionalMatrix = this.additionalMatrix, t.additionalMatrix !== null && (t.additionalMatrix = t.additionalMatrix.copy()), t.allowMissingExternalModels = this.allowMissingExternalModels, t.attachInvisibly = this.attachInvisibly, t.implicitlyLoadXmlExternalModels = this.implicitlyLoadXmlExternalModels, t.ignoreCadViews = this.ignoreCadViews, t.ignoreFilters = this.ignoreFilters, t.ignoreLayers = this.ignoreLayers, t.ignoreGenericTypes = this.ignoreGenericTypes, t.ignoreBimRelationships = this.ignoreBimRelationships, t._allowSubtreeLoadedCallback = this._allowSubtreeLoadedCallback, t;
  }
}
var Vo = /* @__PURE__ */ ((n) => (n[n.Unknown = 0] = "Unknown", n[n.Catia = 2] = "Catia", n[n.CatiaV5 = 3] = "CatiaV5", n[n.Cadds = 4] = "Cadds", n[n.Unigraphics = 5] = "Unigraphics", n[n.Parasolid = 6] = "Parasolid", n[n.Euclid = 7] = "Euclid", n[n.Iges = 9] = "Iges", n[n.Unisurf = 10] = "Unisurf", n[n.Vda = 11] = "Vda", n[n.Stl = 12] = "Stl", n[n.Wrl = 13] = "Wrl", n[n.Dxf = 14] = "Dxf", n[n.Acis = 15] = "Acis", n[n.ProE = 16] = "ProE", n[n.Step = 18] = "Step", n[n.Ideas = 19] = "Ideas", n[n.Jt = 20] = "Jt", n[n.Slw = 22] = "Slw", n[n.Cgr = 23] = "Cgr", n[n.Prc = 24] = "Prc", n[n.Xvl = 25] = "Xvl", n[n.Hpgl = 26] = "Hpgl", n[n.TopSolid = 27] = "TopSolid", n[n.OneSpaceDesigner = 28] = "OneSpaceDesigner", n[n._3dxml = 29] = "_3dxml", n[n.Inventor = 30] = "Inventor", n[n.PostScript = 31] = "PostScript", n[n.Pdp = 32] = "Pdp", n[n.U3d = 33] = "U3d", n[n.Ifc = 34] = "Ifc", n[n.Dwg = 35] = "Dwg", n[n.Dwf = 36] = "Dwf", n[n.Se = 37] = "Se", n[n.Obj = 38] = "Obj", n[n.Kmz = 39] = "Kmz", n[n.Dae = 40] = "Dae", n[n._3ds = 41] = "_3ds", n[n.Rhino = 43] = "Rhino", n[n.Xml = 44] = "Xml", n[n._3mf = 45] = "_3mf", n[n.Scs = 46] = "Scs", n[n._3dHtml = 47] = "_3dHtml", n[n.Hsf = 48] = "Hsf", n[n.Gltf = 49] = "Gltf", n[n.Revit = 50] = "Revit", n[n.Fbx = 51] = "Fbx", n))(Vo || {}), Pc = /* @__PURE__ */ ((n) => (n[n.World = 0] = "World", n[n.ProportionOfBoundingHeight = 1] = "ProportionOfBoundingHeight", n))(Pc || {}), w_ = /* @__PURE__ */ ((n) => (n[n.Default = 0] = "Default", n[n.PerNode = 1] = "PerNode", n))(w_ || {}), Wr = /* @__PURE__ */ ((n) => (n[n.NorthUp = 0] = "NorthUp", n[n.AvatarUp = 1] = "AvatarUp", n))(Wr || {}), qd = /* @__PURE__ */ ((n) => (n[n.ContainedInSpatialStructure = 0] = "ContainedInSpatialStructure", n[n.Aggregates = 1] = "Aggregates", n[n.VoidsElement = 2] = "VoidsElement", n[n.FillsElement = 3] = "FillsElement", n[n.SpaceBoundary = 4] = "SpaceBoundary", n[n.ConnectsPathElements = 5] = "ConnectsPathElements", n[n.Undefined = 6] = "Undefined", n))(qd || {}), $d = /* @__PURE__ */ ((n) => (n[n.FixedFramerate = 0] = "FixedFramerate", n[n.OcclusionCulling = 1] = "OcclusionCulling", n))($d || {}), Oi = /* @__PURE__ */ ((n) => (n[n.Rgba32 = 0] = "Rgba32", n[n.Rgb24 = 1] = "Rgb24", n[n.Gray8 = 2] = "Gray8", n[n.GrayAlpha16 = 3] = "GrayAlpha16", n[n.Jpeg = 4] = "Jpeg", n[n.Png = 5] = "Png", n))(Oi || {}), Vc = /* @__PURE__ */ ((n) => (n[n.Clamp = 0] = "Clamp", n[n.Repeat = 1] = "Repeat", n[n.Trim = 2] = "Trim", n))(Vc || {}), v_ = /* @__PURE__ */ ((n) => (n[n.UV = 0] = "UV", n))(v_ || {}), x_ = /* @__PURE__ */ ((n) => (n[n.Decal = 1] = "Decal", n))(x_ || {}), Yo = /* @__PURE__ */ ((n) => (n[n.Model = 1] = "Model", n[n.Svg = 2] = "Svg", n[n.Html = 4] = "Html", n[n.All = 7] = "All", n))(Yo || {});
class Mt extends Error {
  /**
   * Creates a new CommunicatorError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, Mt.prototype);
  }
}
class Zh extends Mt {
  /**
   * Creates a new InvalidIndexError
   */
  constructor(t) {
    super(`Invalid index (${t}).`), Object.setPrototypeOf(this, Zh.prototype);
  }
}
class Ms extends Mt {
  /**
   * Creates a new PickOutsideCanvasError
   */
  constructor() {
    super("Cannot pick from outside the canvas area."), Object.setPrototypeOf(this, Ms.prototype);
  }
}
class as extends Mt {
  /**
   * Creates a new SelectionInvalidatedError
   */
  constructor() {
    super("Selection invalidated."), Object.setPrototypeOf(this, as.prototype);
  }
}
class re extends Mt {
  /**
   * Creates a new InternalLogicError
   */
  constructor() {
    super("Internal logic error."), Object.setPrototypeOf(this, re.prototype);
  }
}
class sn extends Mt {
  /**
   * Creates a new InvalidNodeIdError
   */
  constructor(t) {
    super(`Invalid node (${t}).`), Object.setPrototypeOf(this, sn.prototype), this.nodeId = t;
  }
}
class Gi extends Mt {
  /**
   * Creates a new InvalidNodeTypeError
   */
  constructor(t, e, ...i) {
    i.push(e);
    const s = [];
    for (const a of i)
      switch (a) {
        case li.ProductOccurrence:
          s.push(At.DrawingSheet, At.PartInstance, At.AssemblyNode);
          break;
        case li.AnyBody:
          s.push(At.BodyInstance), s.push(At.PmiBody), s.push(At.ViewFrame);
          break;
        case li.BodyInstance:
          s.push(At.BodyInstance);
          break;
        case li.CadView:
          s.push(At.CadView);
          break;
        default:
          $n();
      }
    s.sort();
    const r = [];
    for (const a of s)
      r.push(At[a]);
    const o = r.length === 1 ? `type (${r[0]})` : `types ${r}`;
    super(`Expected node (${t}) to be of ${o}.`), Object.setPrototypeOf(this, Gi.prototype), this.nodeId = t, this.expectedTypes = s;
  }
}
class ts extends Mt {
  /**
   * Creates a new LoadError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, ts.prototype);
  }
}
class Rl extends ts {
  /**
   * Creates a new LoadCancelledError
   */
  constructor() {
    super("Load cancelled."), Object.setPrototypeOf(this, Rl.prototype);
  }
}
class Ll extends ts {
  /**
   * Creates a new MissingModelError
   */
  constructor(t) {
    super(`Missing model: '${t}'.`), Object.setPrototypeOf(this, Ll.prototype);
  }
}
class fn extends Mt {
  /**
   * Creates a new ParseError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, fn.prototype);
  }
}
class ur extends fn {
  /**
   * Creates a new AssemblyDataParseError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, ur.prototype);
  }
}
class ce extends fn {
  /**
   * Creates a new XmlParseError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, ce.prototype);
  }
}
function S_(n) {
  return Z_(n);
}
function Z_(n) {
  const t = new tm();
  for (const i of n)
    i._gatherForExport(t);
  const e = {};
  if (!t.buffers.isEmpty()) {
    e.buffers = [];
    for (const i of t.buffers.toArray())
      e.buffers.push(i._export());
  }
  if (!t.samplers.isEmpty()) {
    e.samplers = [];
    for (const i of t.samplers.toArray())
      e.samplers.push(i._export(t));
  }
  if (!t.colorMaps.isEmpty()) {
    e.colorMaps = [];
    for (const i of t.colorMaps.toArray())
      e.colorMaps.push(k_(i));
  }
  if (n.length !== 0) {
    e.animations = [];
    for (const i of n)
      e.animations.push(i._export(t));
  }
  return {
    ...e
  };
}
function C_(n) {
  const t = n, e = new em();
  if (t.buffers !== void 0)
    for (const s of t.buffers)
      e.buffers.push(ca._import(s));
  if (t.samplers !== void 0)
    for (const s of t.samplers)
      e.samplers.push(ln._import(e, s));
  if (t.colorMaps !== void 0)
    for (const s of t.colorMaps)
      e.colorMaps.push(M_(s));
  const i = [];
  if (t.animations !== void 0)
    for (const s of t.animations)
      i.push(yl._import(e, s));
  return i;
}
function k_(n) {
  const t = [];
  for (const e of n)
    t.push([e.position, e.color.r, e.color.g, e.color.b]);
  return t;
}
function M_(n) {
  const t = [];
  for (const e of n)
    t.push({
      position: e[0],
      color: new it(e[1], e[2], e[3])
    });
  return t;
}
class tm {
  constructor() {
    this.buffers = new Xa(), this.samplers = new Xa(), this.colorMaps = new Xa();
  }
}
class em {
  constructor() {
    this.buffers = [], this.samplers = [], this.colorMaps = [];
  }
}
class Xa {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  add(t) {
    this.map.has(t) || this.map.set(t, this.map.size);
  }
  getIndex(t) {
    const e = this.map.get(t);
    if (e === void 0)
      throw new re();
    return e;
  }
  /**
   * Returns an array containing each element of the set placed at its
   * assigned index.
   */
  toArray() {
    const t = [];
    return this.map.forEach((e, i) => {
      t[e] = i;
    }), t;
  }
  isEmpty() {
    return this.map.size === 0;
  }
}
var im = /* @__PURE__ */ ((n) => (n[n.Stopped = 0] = "Stopped", n[n.Playing = 1] = "Playing", n[n.Paused = 2] = "Paused", n[n.Complete = 3] = "Complete", n))(im || {});
class Ch {
  /** @hidden Do not use.  Create via Animation.Manager API instead. */
  constructor(t, e) {
    this._viewer = t, this.animation = e, this._nodeValues = /* @__PURE__ */ new Map(), this._disabledChannels = /* @__PURE__ */ new Set(), this._currentTime = 0, this._lastUpdate = 0, this.speed = 1, this._animationTime = 0, this._state = 0, this.loop = 0, this._loopCount = 0, this.onComplete = null, this.nodeIdOffset = 0, this.reload();
  }
  /** Sets the enabled state for a channel in this players animation.
   * All channels are enabled by default when a player is created.
   * A channel that has been disabled will not have its value interpolated by the system until it is re-enabled
   * @param channel a channel from the underlying animation
   * @param enabled boolean value indicating whether the channel should be enabled.
   */
  setChannelEnabled(t, e) {
    e ? this._disabledChannels.delete(t) : this._disabledChannels.add(t);
  }
  /**
   * Updates internal state of animation player.
   *
   * Call this method after any part of the underlying animation has been updated.
   * */
  reload() {
    this._nodeValues.clear(), this._animationTime = 0;
    for (const t of this.animation.nodeChannels) {
      const e = t.sampler.buffer.times.length;
      if (e !== 0) {
        if (!this._nodeValues.has(t.nodeId)) {
          const i = new Qu(t.nodeId);
          i.pivotPoint = this.animation.pivotPoints.get(t.nodeId), this._nodeValues.set(t.nodeId, i);
        }
        this._animationTime = Math.max(this._animationTime, t.sampler.buffer.times[e - 1]);
      }
    }
    for (const t of this.animation.cameraChannels) {
      const e = t.sampler.buffer.times.length;
      e !== 0 && (this._animationTime = Math.max(this._animationTime, t.sampler.buffer.times[e - 1]));
    }
  }
  /**
   * Called automatically by the Animation.Manager when it is updating all animations.
   * @returns True if values were modified.
   * @hidden
   */
  _tick(t, e) {
    if (this._state !== 1)
      return !1;
    const i = (t - this._lastUpdate) / 1e3;
    return this._tickTime(i, e), this._lastUpdate = t, !0;
  }
  /**
   * Updates the animation using the supplied delta time specified in seconds.
   * @returns True if values were modified.
   * @hidden
   */
  _tickTime(t, e) {
    if (this._state !== 1)
      return !1;
    this._currentTime += t * this.speed;
    const i = this._currentTime < 0, s = this._currentTime > this._animationTime;
    return i || s ? this.loop < 0 || this.loop > this._loopCount ? (this._loopCount += 1, this._currentTime = i ? this._animationTime : 0, this.evaluate(this._currentTime, e)) : (this._currentTime = this._animationTime, this.evaluate(this._currentTime, e), this._state = 3, this._loopCount = 0, this.onComplete && this.onComplete()) : this.evaluate(this._currentTime, e), !0;
  }
  /** Starts playing the animation. */
  play() {
    this._state !== 1 && (this._state === 3 && (this._currentTime = 0), this._lastUpdate = performance.now(), this._state = 1);
  }
  /** Pauses animation playback. */
  pause() {
    this._state === 1 && (this._state = 2);
  }
  /** Stops animation playback and resets the current time to 0. */
  stop() {
    this._state = 0, this.setTime(0);
  }
  /**
   * Sets the current animation time.
   * @param time time in milliseconds
   */
  setTime(t) {
    const e = new Ua();
    this._currentTime = Math.min(t, this._animationTime), this.evaluate(this._currentTime, e), e.apply(this._viewer);
  }
  /**
   * Calculate the values for each channel of the associated [[Animation]]
   * at the given time.
   *
   * @param time The time at which to evaluate the animation.
   * @param out Storage for the evaluated values. If supplied, this object
   * will be returned instead of a new [[BatchedValues]] object. This
   * allows values gathered from multiple players to be combined into one
   * batch.
   */
  evaluate(t, e) {
    e === void 0 && (e = new Ua());
    for (const i of this.animation.nodeChannels) {
      const s = this._nodeValues.get(i.nodeId);
      s !== void 0 && !this._disabledChannels.has(i) && i._getValue(t, s);
    }
    this._nodeValues.forEach((i) => {
      if (e === void 0)
        throw new re();
      const s = i.nodeId + this.nodeIdOffset;
      (i.flags & di.Transform) === di.Transform && (i.updateMatrix(), e.node.matrixNodeIds.push(s), e.node.matrices.push(i.matrix)), (i.flags & di.Opacity) === di.Opacity && e.node.opacities.set(s, i.opacity), (i.flags & di.Visibility) === di.Visibility && (i.visibility !== 0 ? e.node.visibilityOn.push(s) : e.node.visibilityOff.push(s)), (i.flags & di.Color) === di.Color && e.node.colors.set(
        s,
        new it(i.color.x, i.color.y, i.color.z)
      ), i.flags = di.None;
    });
    for (const i of this.animation.cameraChannels)
      i.sampler.buffer.times.length > 0 && !this._disabledChannels.has(i) && i._getValue(t, e.camera);
    return e;
  }
  /** Gets the current animation state. */
  getState() {
    return this._state;
  }
  /** Gets the current time in seconds that the animation has been playing. */
  getCurrentTime() {
    return this._currentTime;
  }
  /** Gets the current time in seconds of the entire animation. */
  getAnimationTime() {
    return this._animationTime;
  }
}
Ch.LoopIndefinitely = -1;
class nm {
  /** @hidden Created during WebViewer Initialization. */
  constructor(t) {
    this._viewer = t, this._players = [], this._intervalHandle = null, this._batch = new Ua(), this._viewer.setCallbacks({
      assemblyTreeReady: () => {
        this.setTickInterval(50);
      }
    });
  }
  /** Creates a new animation player for the supplied animation. */
  createPlayer(t) {
    const e = new Ch(this._viewer, t);
    return this._players.push(e), e;
  }
  /** Removes the player at the provided index from control of the manager. Returns `true` if a player was removed */
  removePlayerByIndex(t) {
    return t >= this._players.length ? !1 : (this._players.splice(t, 1), !0);
  }
  /** Removes the provided player from control of the manager. Returns `true` is a player was removed */
  removePlayer(t) {
    for (let e = 0; e < this._players.length; e++)
      if (this._players[e] === t)
        return this._players.splice(e, 1), !0;
    return !1;
  }
  /** Removes all players from control of the manager. */
  clear() {
    this._players = [];
  }
  _tick() {
    if (this._players.length === 0)
      return;
    this._batch.clear();
    let t = !1;
    const e = performance.now();
    for (const i of this._players)
      i._tick(e, this._batch) && (t = !0);
    t && (this._viewer.pauseRendering(), this._batch.apply(this._viewer), this._viewer.resumeRendering());
  }
  /** @hidden  Called by the web viewer only*/
  _shutdown() {
    this._intervalHandle !== null && clearInterval(this._intervalHandle);
  }
  /**
   * Sets the interval at which animations are updated.
   * @param milliseconds number of milliseconds between update intervals
   */
  setTickInterval(t) {
    this._intervalHandle && clearInterval(this._intervalHandle), this._intervalHandle = setInterval(() => {
      this._tick();
    }, t);
  }
}
function io(n, t, e, i) {
  const s = e === Mn.Width || e === Mn.Height ? rn.Scalar : rn.Vec3, r = new ca(s), o = new ln(r, i);
  return n.createCameraChannel(t, e, o);
}
function W_(n, t, e) {
  const i = [];
  return i.push(
    io(
      n,
      `${t}-Position`,
      Mn.Position,
      e
    )
  ), i.push(
    io(
      n,
      `${t}-Target`,
      Mn.Target,
      e
    )
  ), i.push(
    io(n, `${t}-Up`, Mn.Up, e)
  ), i.push(
    io(n, `${t}-Width`, Mn.Width, e)
  ), i.push(
    io(
      n,
      `${t}-Height`,
      Mn.Height,
      e
    )
  ), i;
}
function P_(n, t, e) {
  const i = t.getPosition();
  e.cameraChannels[0].sampler.buffer.insertVec3Keyframe(
    n,
    i.x,
    i.y,
    i.z
  );
  const s = t.getTarget();
  e.cameraChannels[1].sampler.buffer.insertVec3Keyframe(n, s.x, s.y, s.z);
  const r = t.getUp();
  e.cameraChannels[2].sampler.buffer.insertVec3Keyframe(n, r.x, r.y, r.z), e.cameraChannels[3].sampler.buffer.insertScalarKeyframe(n, t.getWidth()), e.cameraChannels[4].sampler.buffer.insertScalarKeyframe(n, t.getHeight());
}
const F0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Animation: yl,
  BatchedCameraValues: qu,
  BatchedNodeValues: $u,
  BatchedValues: Ua,
  CameraChannel: Eo,
  CameraProperty: Mn,
  ExportContext: tm,
  ImportContext: em,
  IndexedSet: Xa,
  InterpolationType: qa,
  KeyType: rn,
  KeyframeBuffer: ca,
  Manager: nm,
  NodeChannel: To,
  NodeProperty: Qa,
  NodeValues: Qu,
  NodeValuesFlags: di,
  Player: Ch,
  PlayerState: im,
  Sampler: ln,
  createCameraChannels: W_,
  exportAnimations: S_,
  importAnimations: C_,
  keyframeCamera: P_
}, Symbol.toStringTag, { value: "Module" }));
var pn = /* @__PURE__ */ ((n) => (n[n.Unknown = 0] = "Unknown", n[n.v1_0 = 1] = "v1_0", n[n.v2_0 = 2] = "v2_0", n[n.v2_1 = 3] = "v2_1", n))(pn || {}), Ci = /* @__PURE__ */ ((n) => (n[n.Unknown = 0] = "Unknown", n[n.TopicFolder = 1] = "TopicFolder", n[n.Version = 2] = "Version", n[n.Markup = 3] = "Markup", n[n.Snapshot = 4] = "Snapshot", n[n.Viewpoint = 5] = "Viewpoint", n[n.Schema = 6] = "Schema", n[n.Project = 7] = "Project", n))(Ci || {});
const Xn = "HOOPS Communicator";
function go(n) {
  return n ? "true" : "false";
}
function Fa(n, t) {
  const e = n.createElement("Component");
  return t.ifcGuid !== void 0 && e.setAttribute("IfcGuid", t.ifcGuid), t.originatingSystem !== void 0 && e.setAttribute("OriginatingSystem", t.originatingSystem), t.authoringToolId !== void 0 && e.setAttribute("AuthoringToolId", t.authoringToolId.toString()), e;
}
function ka(n) {
  return n.length === 1 ? `0${n}` : n;
}
function sm(n, t) {
  const e = t ? ka(Math.round(t).toString(16)) : "", i = ka(Math.round(n.r).toString(16)), s = ka(Math.round(n.g).toString(16)), r = ka(Math.round(n.b).toString(16));
  return `${e}${i}${s}${r}`;
}
function Zn(n, t, e) {
  const i = n.createElement("X"), s = n.createElement("Y"), r = n.createElement("Z");
  i.innerHTML = e.x.toString(), s.innerHTML = e.y.toString(), r.innerHTML = e.z.toString(), t.appendChild(i), t.appendChild(s), t.appendChild(r);
}
function Fn(n, t, e) {
  e != null && n.setAttribute(t, e);
}
function On(n, t, e, i) {
  const s = n.createElement(e);
  s.innerHTML = i, t.appendChild(s);
}
function ze(n, t, e, i) {
  i != null && On(n, t, e, i);
}
function fo(n) {
  return n == null ? null : n.toISOString();
}
function Yc(n) {
  return n == null ? null : n.toString();
}
function Ka(n) {
  return n == null ? null : n ? "true" : "false";
}
function Ma(n) {
  throw new Error('Could not dynamically require "' + n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var rm = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(n, t) {
  (function(e) {
    n.exports = e();
  })(function() {
    return function e(i, s, r) {
      function o(c, h) {
        if (!s[c]) {
          if (!i[c]) {
            var u = typeof Ma == "function" && Ma;
            if (!h && u)
              return u(c, !0);
            if (a)
              return a(c, !0);
            var p = new Error("Cannot find module '" + c + "'");
            throw p.code = "MODULE_NOT_FOUND", p;
          }
          var m = s[c] = { exports: {} };
          i[c][0].call(m.exports, function(g) {
            var _ = i[c][1][g];
            return o(_ || g);
          }, m, m.exports, e, i, s, r);
        }
        return s[c].exports;
      }
      for (var a = typeof Ma == "function" && Ma, l = 0; l < r.length; l++)
        o(r[l]);
      return o;
    }({ 1: [function(e, i, s) {
      var r = e("./utils"), o = e("./support"), a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      s.encode = function(l) {
        for (var c, h, u, p, m, g, _, y = [], b = 0, w = l.length, v = w, C = r.getTypeOf(l) !== "string"; b < l.length; )
          v = w - b, u = C ? (c = l[b++], h = b < w ? l[b++] : 0, b < w ? l[b++] : 0) : (c = l.charCodeAt(b++), h = b < w ? l.charCodeAt(b++) : 0, b < w ? l.charCodeAt(b++) : 0), p = c >> 2, m = (3 & c) << 4 | h >> 4, g = 1 < v ? (15 & h) << 2 | u >> 6 : 64, _ = 2 < v ? 63 & u : 64, y.push(a.charAt(p) + a.charAt(m) + a.charAt(g) + a.charAt(_));
        return y.join("");
      }, s.decode = function(l) {
        var c, h, u, p, m, g, _ = 0, y = 0, b = "data:";
        if (l.substr(0, b.length) === b)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var w, v = 3 * (l = l.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (l.charAt(l.length - 1) === a.charAt(64) && v--, l.charAt(l.length - 2) === a.charAt(64) && v--, v % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (w = o.uint8array ? new Uint8Array(0 | v) : new Array(0 | v); _ < l.length; )
          c = a.indexOf(l.charAt(_++)) << 2 | (p = a.indexOf(l.charAt(_++))) >> 4, h = (15 & p) << 4 | (m = a.indexOf(l.charAt(_++))) >> 2, u = (3 & m) << 6 | (g = a.indexOf(l.charAt(_++))), w[y++] = c, m !== 64 && (w[y++] = h), g !== 64 && (w[y++] = u);
        return w;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(e, i, s) {
      var r = e("./external"), o = e("./stream/DataWorker"), a = e("./stream/Crc32Probe"), l = e("./stream/DataLengthProbe");
      function c(h, u, p, m, g) {
        this.compressedSize = h, this.uncompressedSize = u, this.crc32 = p, this.compression = m, this.compressedContent = g;
      }
      c.prototype = { getContentWorker: function() {
        var h = new o(r.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length")), u = this;
        return h.on("end", function() {
          if (this.streamInfo.data_length !== u.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), h;
      }, getCompressedWorker: function() {
        return new o(r.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, c.createWorkerFrom = function(h, u, p) {
        return h.pipe(new a()).pipe(new l("uncompressedSize")).pipe(u.compressWorker(p)).pipe(new l("compressedSize")).withStreamInfo("compression", u);
      }, i.exports = c;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, i, s) {
      var r = e("./stream/GenericWorker");
      s.STORE = { magic: "\0\0", compressWorker: function() {
        return new r("STORE compression");
      }, uncompressWorker: function() {
        return new r("STORE decompression");
      } }, s.DEFLATE = e("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, i, s) {
      var r = e("./utils"), o = function() {
        for (var a, l = [], c = 0; c < 256; c++) {
          a = c;
          for (var h = 0; h < 8; h++)
            a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
          l[c] = a;
        }
        return l;
      }();
      i.exports = function(a, l) {
        return a !== void 0 && a.length ? r.getTypeOf(a) !== "string" ? function(c, h, u, p) {
          var m = o, g = p + u;
          c ^= -1;
          for (var _ = p; _ < g; _++)
            c = c >>> 8 ^ m[255 & (c ^ h[_])];
          return -1 ^ c;
        }(0 | l, a, a.length, 0) : function(c, h, u, p) {
          var m = o, g = p + u;
          c ^= -1;
          for (var _ = p; _ < g; _++)
            c = c >>> 8 ^ m[255 & (c ^ h.charCodeAt(_))];
          return -1 ^ c;
        }(0 | l, a, a.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(e, i, s) {
      s.base64 = !1, s.binary = !1, s.dir = !1, s.createFolders = !0, s.date = null, s.compression = null, s.compressionOptions = null, s.comment = null, s.unixPermissions = null, s.dosPermissions = null;
    }, {}], 6: [function(e, i, s) {
      var r = null;
      r = typeof Promise < "u" ? Promise : e("lie"), i.exports = { Promise: r };
    }, { lie: 37 }], 7: [function(e, i, s) {
      var r = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", o = e("pako"), a = e("./utils"), l = e("./stream/GenericWorker"), c = r ? "uint8array" : "array";
      function h(u, p) {
        l.call(this, "FlateWorker/" + u), this._pako = null, this._pakoAction = u, this._pakoOptions = p, this.meta = {};
      }
      s.magic = "\b\0", a.inherits(h, l), h.prototype.processChunk = function(u) {
        this.meta = u.meta, this._pako === null && this._createPako(), this._pako.push(a.transformTo(c, u.data), !1);
      }, h.prototype.flush = function() {
        l.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, h.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this._pako = null;
      }, h.prototype._createPako = function() {
        this._pako = new o[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var u = this;
        this._pako.onData = function(p) {
          u.push({ data: p, meta: u.meta });
        };
      }, s.compressWorker = function(u) {
        return new h("Deflate", u);
      }, s.uncompressWorker = function() {
        return new h("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, i, s) {
      function r(m, g) {
        var _, y = "";
        for (_ = 0; _ < g; _++)
          y += String.fromCharCode(255 & m), m >>>= 8;
        return y;
      }
      function o(m, g, _, y, b, w) {
        var v, C, k = m.file, Y = m.compression, P = w !== c.utf8encode, L = a.transformTo("string", w(k.name)), N = a.transformTo("string", c.utf8encode(k.name)), D = k.comment, B = a.transformTo("string", w(D)), V = a.transformTo("string", c.utf8encode(D)), X = N.length !== k.name.length, Z = V.length !== D.length, W = "", st = "", j = "", gt = k.dir, U = k.date, ht = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        g && !_ || (ht.crc32 = m.crc32, ht.compressedSize = m.compressedSize, ht.uncompressedSize = m.uncompressedSize);
        var z = 0;
        g && (z |= 8), P || !X && !Z || (z |= 2048);
        var O = 0, _t = 0;
        gt && (O |= 16), b === "UNIX" ? (_t = 798, O |= function(ut, oe) {
          var Re = ut;
          return ut || (Re = oe ? 16893 : 33204), (65535 & Re) << 16;
        }(k.unixPermissions, gt)) : (_t = 20, O |= function(ut) {
          return 63 & (ut || 0);
        }(k.dosPermissions)), v = U.getUTCHours(), v <<= 6, v |= U.getUTCMinutes(), v <<= 5, v |= U.getUTCSeconds() / 2, C = U.getUTCFullYear() - 1980, C <<= 4, C |= U.getUTCMonth() + 1, C <<= 5, C |= U.getUTCDate(), X && (st = r(1, 1) + r(h(L), 4) + N, W += "up" + r(st.length, 2) + st), Z && (j = r(1, 1) + r(h(B), 4) + V, W += "uc" + r(j.length, 2) + j);
        var rt = "";
        return rt += `
\0`, rt += r(z, 2), rt += Y.magic, rt += r(v, 2), rt += r(C, 2), rt += r(ht.crc32, 4), rt += r(ht.compressedSize, 4), rt += r(ht.uncompressedSize, 4), rt += r(L.length, 2), rt += r(W.length, 2), { fileRecord: u.LOCAL_FILE_HEADER + rt + L + W, dirRecord: u.CENTRAL_FILE_HEADER + r(_t, 2) + rt + r(B.length, 2) + "\0\0\0\0" + r(O, 4) + r(y, 4) + L + W + B };
      }
      var a = e("../utils"), l = e("../stream/GenericWorker"), c = e("../utf8"), h = e("../crc32"), u = e("../signature");
      function p(m, g, _, y) {
        l.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = g, this.zipPlatform = _, this.encodeFileName = y, this.streamFiles = m, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      a.inherits(p, l), p.prototype.push = function(m) {
        var g = m.meta.percent || 0, _ = this.entriesCount, y = this._sources.length;
        this.accumulate ? this.contentBuffer.push(m) : (this.bytesWritten += m.data.length, l.prototype.push.call(this, { data: m.data, meta: { currentFile: this.currentFile, percent: _ ? (g + 100 * (_ - y - 1)) / _ : 100 } }));
      }, p.prototype.openedSource = function(m) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = m.file.name;
        var g = this.streamFiles && !m.file.dir;
        if (g) {
          var _ = o(m, g, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: _.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = !0;
      }, p.prototype.closedSource = function(m) {
        this.accumulate = !1;
        var g = this.streamFiles && !m.file.dir, _ = o(m, g, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(_.dirRecord), g)
          this.push({ data: function(y) {
            return u.DATA_DESCRIPTOR + r(y.crc32, 4) + r(y.compressedSize, 4) + r(y.uncompressedSize, 4);
          }(m), meta: { percent: 100 } });
        else
          for (this.push({ data: _.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, p.prototype.flush = function() {
        for (var m = this.bytesWritten, g = 0; g < this.dirRecords.length; g++)
          this.push({ data: this.dirRecords[g], meta: { percent: 100 } });
        var _ = this.bytesWritten - m, y = function(b, w, v, C, k) {
          var Y = a.transformTo("string", k(C));
          return u.CENTRAL_DIRECTORY_END + "\0\0\0\0" + r(b, 2) + r(b, 2) + r(w, 4) + r(v, 4) + r(Y.length, 2) + Y;
        }(this.dirRecords.length, _, m, this.zipComment, this.encodeFileName);
        this.push({ data: y, meta: { percent: 100 } });
      }, p.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, p.prototype.registerPrevious = function(m) {
        this._sources.push(m);
        var g = this;
        return m.on("data", function(_) {
          g.processChunk(_);
        }), m.on("end", function() {
          g.closedSource(g.previous.streamInfo), g._sources.length ? g.prepareNextSource() : g.end();
        }), m.on("error", function(_) {
          g.error(_);
        }), this;
      }, p.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, p.prototype.error = function(m) {
        var g = this._sources;
        if (!l.prototype.error.call(this, m))
          return !1;
        for (var _ = 0; _ < g.length; _++)
          try {
            g[_].error(m);
          } catch {
          }
        return !0;
      }, p.prototype.lock = function() {
        l.prototype.lock.call(this);
        for (var m = this._sources, g = 0; g < m.length; g++)
          m[g].lock();
      }, i.exports = p;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, i, s) {
      var r = e("../compressions"), o = e("./ZipFileWorker");
      s.generateWorker = function(a, l, c) {
        var h = new o(l.streamFiles, c, l.platform, l.encodeFileName), u = 0;
        try {
          a.forEach(function(p, m) {
            u++;
            var g = function(w, v) {
              var C = w || v, k = r[C];
              if (!k)
                throw new Error(C + " is not a valid compression method !");
              return k;
            }(m.options.compression, l.compression), _ = m.options.compressionOptions || l.compressionOptions || {}, y = m.dir, b = m.date;
            m._compressWorker(g, _).withStreamInfo("file", { name: p, dir: y, date: b, comment: m.comment || "", unixPermissions: m.unixPermissions, dosPermissions: m.dosPermissions }).pipe(h);
          }), h.entriesCount = u;
        } catch (p) {
          h.error(p);
        }
        return h;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, i, s) {
      function r() {
        if (!(this instanceof r))
          return new r();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var o = new r();
          for (var a in this)
            typeof this[a] != "function" && (o[a] = this[a]);
          return o;
        };
      }
      (r.prototype = e("./object")).loadAsync = e("./load"), r.support = e("./support"), r.defaults = e("./defaults"), r.version = "3.10.1", r.loadAsync = function(o, a) {
        return new r().loadAsync(o, a);
      }, r.external = e("./external"), i.exports = r;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, i, s) {
      var r = e("./utils"), o = e("./external"), a = e("./utf8"), l = e("./zipEntries"), c = e("./stream/Crc32Probe"), h = e("./nodejsUtils");
      function u(p) {
        return new o.Promise(function(m, g) {
          var _ = p.decompressed.getContentWorker().pipe(new c());
          _.on("error", function(y) {
            g(y);
          }).on("end", function() {
            _.streamInfo.crc32 !== p.decompressed.crc32 ? g(new Error("Corrupted zip : CRC32 mismatch")) : m();
          }).resume();
        });
      }
      i.exports = function(p, m) {
        var g = this;
        return m = r.extend(m || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: a.utf8decode }), h.isNode && h.isStream(p) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : r.prepareContent("the loaded zip file", p, !0, m.optimizedBinaryString, m.base64).then(function(_) {
          var y = new l(m);
          return y.load(_), y;
        }).then(function(_) {
          var y = [o.Promise.resolve(_)], b = _.files;
          if (m.checkCRC32)
            for (var w = 0; w < b.length; w++)
              y.push(u(b[w]));
          return o.Promise.all(y);
        }).then(function(_) {
          for (var y = _.shift(), b = y.files, w = 0; w < b.length; w++) {
            var v = b[w], C = v.fileNameStr, k = r.resolve(v.fileNameStr);
            g.file(k, v.decompressed, { binary: !0, optimizedBinaryString: !0, date: v.date, dir: v.dir, comment: v.fileCommentStr.length ? v.fileCommentStr : null, unixPermissions: v.unixPermissions, dosPermissions: v.dosPermissions, createFolders: m.createFolders }), v.dir || (g.file(k).unsafeOriginalName = C);
          }
          return y.zipComment.length && (g.comment = y.zipComment), g;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, i, s) {
      var r = e("../utils"), o = e("../stream/GenericWorker");
      function a(l, c) {
        o.call(this, "Nodejs stream input adapter for " + l), this._upstreamEnded = !1, this._bindStream(c);
      }
      r.inherits(a, o), a.prototype._bindStream = function(l) {
        var c = this;
        (this._stream = l).pause(), l.on("data", function(h) {
          c.push({ data: h, meta: { percent: 0 } });
        }).on("error", function(h) {
          c.isPaused ? this.generatedError = h : c.error(h);
        }).on("end", function() {
          c.isPaused ? c._upstreamEnded = !0 : c.end();
        });
      }, a.prototype.pause = function() {
        return !!o.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, a.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, i.exports = a;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, i, s) {
      var r = e("readable-stream").Readable;
      function o(a, l, c) {
        r.call(this, l), this._helper = a;
        var h = this;
        a.on("data", function(u, p) {
          h.push(u) || h._helper.pause(), c && c(p);
        }).on("error", function(u) {
          h.emit("error", u);
        }).on("end", function() {
          h.push(null);
        });
      }
      e("../utils").inherits(o, r), o.prototype._read = function() {
        this._helper.resume();
      }, i.exports = o;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, i, s) {
      i.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(r, o) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(r, o);
        if (typeof r == "number")
          throw new Error('The "data" argument must not be a number');
        return new Buffer(r, o);
      }, allocBuffer: function(r) {
        if (Buffer.alloc)
          return Buffer.alloc(r);
        var o = new Buffer(r);
        return o.fill(0), o;
      }, isBuffer: function(r) {
        return Buffer.isBuffer(r);
      }, isStream: function(r) {
        return r && typeof r.on == "function" && typeof r.pause == "function" && typeof r.resume == "function";
      } };
    }, {}], 15: [function(e, i, s) {
      function r(k, Y, P) {
        var L, N = a.getTypeOf(Y), D = a.extend(P || {}, h);
        D.date = D.date || /* @__PURE__ */ new Date(), D.compression !== null && (D.compression = D.compression.toUpperCase()), typeof D.unixPermissions == "string" && (D.unixPermissions = parseInt(D.unixPermissions, 8)), D.unixPermissions && 16384 & D.unixPermissions && (D.dir = !0), D.dosPermissions && 16 & D.dosPermissions && (D.dir = !0), D.dir && (k = b(k)), D.createFolders && (L = y(k)) && w.call(this, L, !0);
        var B = N === "string" && D.binary === !1 && D.base64 === !1;
        P && P.binary !== void 0 || (D.binary = !B), (Y instanceof u && Y.uncompressedSize === 0 || D.dir || !Y || Y.length === 0) && (D.base64 = !1, D.binary = !0, Y = "", D.compression = "STORE", N = "string");
        var V = null;
        V = Y instanceof u || Y instanceof l ? Y : g.isNode && g.isStream(Y) ? new _(k, Y) : a.prepareContent(k, Y, D.binary, D.optimizedBinaryString, D.base64);
        var X = new p(k, V, D);
        this.files[k] = X;
      }
      var o = e("./utf8"), a = e("./utils"), l = e("./stream/GenericWorker"), c = e("./stream/StreamHelper"), h = e("./defaults"), u = e("./compressedObject"), p = e("./zipObject"), m = e("./generate"), g = e("./nodejsUtils"), _ = e("./nodejs/NodejsStreamInputAdapter"), y = function(k) {
        k.slice(-1) === "/" && (k = k.substring(0, k.length - 1));
        var Y = k.lastIndexOf("/");
        return 0 < Y ? k.substring(0, Y) : "";
      }, b = function(k) {
        return k.slice(-1) !== "/" && (k += "/"), k;
      }, w = function(k, Y) {
        return Y = Y !== void 0 ? Y : h.createFolders, k = b(k), this.files[k] || r.call(this, k, null, { dir: !0, createFolders: Y }), this.files[k];
      };
      function v(k) {
        return Object.prototype.toString.call(k) === "[object RegExp]";
      }
      var C = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(k) {
        var Y, P, L;
        for (Y in this.files)
          L = this.files[Y], (P = Y.slice(this.root.length, Y.length)) && Y.slice(0, this.root.length) === this.root && k(P, L);
      }, filter: function(k) {
        var Y = [];
        return this.forEach(function(P, L) {
          k(P, L) && Y.push(L);
        }), Y;
      }, file: function(k, Y, P) {
        if (arguments.length !== 1)
          return k = this.root + k, r.call(this, k, Y, P), this;
        if (v(k)) {
          var L = k;
          return this.filter(function(D, B) {
            return !B.dir && L.test(D);
          });
        }
        var N = this.files[this.root + k];
        return N && !N.dir ? N : null;
      }, folder: function(k) {
        if (!k)
          return this;
        if (v(k))
          return this.filter(function(N, D) {
            return D.dir && k.test(N);
          });
        var Y = this.root + k, P = w.call(this, Y), L = this.clone();
        return L.root = P.name, L;
      }, remove: function(k) {
        k = this.root + k;
        var Y = this.files[k];
        if (Y || (k.slice(-1) !== "/" && (k += "/"), Y = this.files[k]), Y && !Y.dir)
          delete this.files[k];
        else
          for (var P = this.filter(function(N, D) {
            return D.name.slice(0, k.length) === k;
          }), L = 0; L < P.length; L++)
            delete this.files[P[L].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(k) {
        var Y, P = {};
        try {
          if ((P = a.extend(k || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: o.utf8encode })).type = P.type.toLowerCase(), P.compression = P.compression.toUpperCase(), P.type === "binarystring" && (P.type = "string"), !P.type)
            throw new Error("No output type specified.");
          a.checkSupport(P.type), P.platform !== "darwin" && P.platform !== "freebsd" && P.platform !== "linux" && P.platform !== "sunos" || (P.platform = "UNIX"), P.platform === "win32" && (P.platform = "DOS");
          var L = P.comment || this.comment || "";
          Y = m.generateWorker(this, P, L);
        } catch (N) {
          (Y = new l("error")).error(N);
        }
        return new c(Y, P.type || "string", P.mimeType);
      }, generateAsync: function(k, Y) {
        return this.generateInternalStream(k).accumulate(Y);
      }, generateNodeStream: function(k, Y) {
        return (k = k || {}).type || (k.type = "nodebuffer"), this.generateInternalStream(k).toNodejsStream(Y);
      } };
      i.exports = C;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, i, s) {
      i.exports = e("stream");
    }, { stream: void 0 }], 17: [function(e, i, s) {
      var r = e("./DataReader");
      function o(a) {
        r.call(this, a);
        for (var l = 0; l < this.data.length; l++)
          a[l] = 255 & a[l];
      }
      e("../utils").inherits(o, r), o.prototype.byteAt = function(a) {
        return this.data[this.zero + a];
      }, o.prototype.lastIndexOfSignature = function(a) {
        for (var l = a.charCodeAt(0), c = a.charCodeAt(1), h = a.charCodeAt(2), u = a.charCodeAt(3), p = this.length - 4; 0 <= p; --p)
          if (this.data[p] === l && this.data[p + 1] === c && this.data[p + 2] === h && this.data[p + 3] === u)
            return p - this.zero;
        return -1;
      }, o.prototype.readAndCheckSignature = function(a) {
        var l = a.charCodeAt(0), c = a.charCodeAt(1), h = a.charCodeAt(2), u = a.charCodeAt(3), p = this.readData(4);
        return l === p[0] && c === p[1] && h === p[2] && u === p[3];
      }, o.prototype.readData = function(a) {
        if (this.checkOffset(a), a === 0)
          return [];
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, i, s) {
      var r = e("../utils");
      function o(a) {
        this.data = a, this.length = a.length, this.index = 0, this.zero = 0;
      }
      o.prototype = { checkOffset: function(a) {
        this.checkIndex(this.index + a);
      }, checkIndex: function(a) {
        if (this.length < this.zero + a || a < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + a + "). Corrupted zip ?");
      }, setIndex: function(a) {
        this.checkIndex(a), this.index = a;
      }, skip: function(a) {
        this.setIndex(this.index + a);
      }, byteAt: function() {
      }, readInt: function(a) {
        var l, c = 0;
        for (this.checkOffset(a), l = this.index + a - 1; l >= this.index; l--)
          c = (c << 8) + this.byteAt(l);
        return this.index += a, c;
      }, readString: function(a) {
        return r.transformTo("string", this.readData(a));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var a = this.readInt(4);
        return new Date(Date.UTC(1980 + (a >> 25 & 127), (a >> 21 & 15) - 1, a >> 16 & 31, a >> 11 & 31, a >> 5 & 63, (31 & a) << 1));
      } }, i.exports = o;
    }, { "../utils": 32 }], 19: [function(e, i, s) {
      var r = e("./Uint8ArrayReader");
      function o(a) {
        r.call(this, a);
      }
      e("../utils").inherits(o, r), o.prototype.readData = function(a) {
        this.checkOffset(a);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, i, s) {
      var r = e("./DataReader");
      function o(a) {
        r.call(this, a);
      }
      e("../utils").inherits(o, r), o.prototype.byteAt = function(a) {
        return this.data.charCodeAt(this.zero + a);
      }, o.prototype.lastIndexOfSignature = function(a) {
        return this.data.lastIndexOf(a) - this.zero;
      }, o.prototype.readAndCheckSignature = function(a) {
        return a === this.readData(4);
      }, o.prototype.readData = function(a) {
        this.checkOffset(a);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, i, s) {
      var r = e("./ArrayReader");
      function o(a) {
        r.call(this, a);
      }
      e("../utils").inherits(o, r), o.prototype.readData = function(a) {
        if (this.checkOffset(a), a === 0)
          return new Uint8Array(0);
        var l = this.data.subarray(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, i, s) {
      var r = e("../utils"), o = e("../support"), a = e("./ArrayReader"), l = e("./StringReader"), c = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
      i.exports = function(u) {
        var p = r.getTypeOf(u);
        return r.checkSupport(p), p !== "string" || o.uint8array ? p === "nodebuffer" ? new c(u) : o.uint8array ? new h(r.transformTo("uint8array", u)) : new a(r.transformTo("array", u)) : new l(u);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, i, s) {
      s.LOCAL_FILE_HEADER = "PK", s.CENTRAL_FILE_HEADER = "PK", s.CENTRAL_DIRECTORY_END = "PK", s.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", s.ZIP64_CENTRAL_DIRECTORY_END = "PK", s.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(e, i, s) {
      var r = e("./GenericWorker"), o = e("../utils");
      function a(l) {
        r.call(this, "ConvertWorker to " + l), this.destType = l;
      }
      o.inherits(a, r), a.prototype.processChunk = function(l) {
        this.push({ data: o.transformTo(this.destType, l.data), meta: l.meta });
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, i, s) {
      var r = e("./GenericWorker"), o = e("../crc32");
      function a() {
        r.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      e("../utils").inherits(a, r), a.prototype.processChunk = function(l) {
        this.streamInfo.crc32 = o(l.data, this.streamInfo.crc32 || 0), this.push(l);
      }, i.exports = a;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, i, s) {
      var r = e("../utils"), o = e("./GenericWorker");
      function a(l) {
        o.call(this, "DataLengthProbe for " + l), this.propName = l, this.withStreamInfo(l, 0);
      }
      r.inherits(a, o), a.prototype.processChunk = function(l) {
        if (l) {
          var c = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = c + l.data.length;
        }
        o.prototype.processChunk.call(this, l);
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, i, s) {
      var r = e("../utils"), o = e("./GenericWorker");
      function a(l) {
        o.call(this, "DataWorker");
        var c = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, l.then(function(h) {
          c.dataIsReady = !0, c.data = h, c.max = h && h.length || 0, c.type = r.getTypeOf(h), c.isPaused || c._tickAndRepeat();
        }, function(h) {
          c.error(h);
        });
      }
      r.inherits(a, o), a.prototype.cleanUp = function() {
        o.prototype.cleanUp.call(this), this.data = null;
      }, a.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, r.delay(this._tickAndRepeat, [], this)), !0);
      }, a.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (r.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, a.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return !1;
        var l = null, c = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            l = this.data.substring(this.index, c);
            break;
          case "uint8array":
            l = this.data.subarray(this.index, c);
            break;
          case "array":
          case "nodebuffer":
            l = this.data.slice(this.index, c);
        }
        return this.index = c, this.push({ data: l, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, i, s) {
      function r(o) {
        this.name = o || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      r.prototype = { push: function(o) {
        this.emit("data", o);
      }, end: function() {
        if (this.isFinished)
          return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (o) {
          this.emit("error", o);
        }
        return !0;
      }, error: function(o) {
        return !this.isFinished && (this.isPaused ? this.generatedError = o : (this.isFinished = !0, this.emit("error", o), this.previous && this.previous.error(o), this.cleanUp()), !0);
      }, on: function(o, a) {
        return this._listeners[o].push(a), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(o, a) {
        if (this._listeners[o])
          for (var l = 0; l < this._listeners[o].length; l++)
            this._listeners[o][l].call(this, a);
      }, pipe: function(o) {
        return o.registerPrevious(this);
      }, registerPrevious: function(o) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = o.streamInfo, this.mergeStreamInfo(), this.previous = o;
        var a = this;
        return o.on("data", function(l) {
          a.processChunk(l);
        }), o.on("end", function() {
          a.end();
        }), o.on("error", function(l) {
          a.error(l);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return !1;
        var o = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), o = !0), this.previous && this.previous.resume(), !o;
      }, flush: function() {
      }, processChunk: function(o) {
        this.push(o);
      }, withStreamInfo: function(o, a) {
        return this.extraStreamInfo[o] = a, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var o in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) && (this.streamInfo[o] = this.extraStreamInfo[o]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var o = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + o : o;
      } }, i.exports = r;
    }, {}], 29: [function(e, i, s) {
      var r = e("../utils"), o = e("./ConvertWorker"), a = e("./GenericWorker"), l = e("../base64"), c = e("../support"), h = e("../external"), u = null;
      if (c.nodestream)
        try {
          u = e("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
      function p(g, _) {
        return new h.Promise(function(y, b) {
          var w = [], v = g._internalType, C = g._outputType, k = g._mimeType;
          g.on("data", function(Y, P) {
            w.push(Y), _ && _(P);
          }).on("error", function(Y) {
            w = [], b(Y);
          }).on("end", function() {
            try {
              var Y = function(P, L, N) {
                switch (P) {
                  case "blob":
                    return r.newBlob(r.transformTo("arraybuffer", L), N);
                  case "base64":
                    return l.encode(L);
                  default:
                    return r.transformTo(P, L);
                }
              }(C, function(P, L) {
                var N, D = 0, B = null, V = 0;
                for (N = 0; N < L.length; N++)
                  V += L[N].length;
                switch (P) {
                  case "string":
                    return L.join("");
                  case "array":
                    return Array.prototype.concat.apply([], L);
                  case "uint8array":
                    for (B = new Uint8Array(V), N = 0; N < L.length; N++)
                      B.set(L[N], D), D += L[N].length;
                    return B;
                  case "nodebuffer":
                    return Buffer.concat(L);
                  default:
                    throw new Error("concat : unsupported type '" + P + "'");
                }
              }(v, w), k);
              y(Y);
            } catch (P) {
              b(P);
            }
            w = [];
          }).resume();
        });
      }
      function m(g, _, y) {
        var b = _;
        switch (_) {
          case "blob":
          case "arraybuffer":
            b = "uint8array";
            break;
          case "base64":
            b = "string";
        }
        try {
          this._internalType = b, this._outputType = _, this._mimeType = y, r.checkSupport(b), this._worker = g.pipe(new o(b)), g.lock();
        } catch (w) {
          this._worker = new a("error"), this._worker.error(w);
        }
      }
      m.prototype = { accumulate: function(g) {
        return p(this, g);
      }, on: function(g, _) {
        var y = this;
        return g === "data" ? this._worker.on(g, function(b) {
          _.call(y, b.data, b.meta);
        }) : this._worker.on(g, function() {
          r.delay(_, arguments, y);
        }), this;
      }, resume: function() {
        return r.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(g) {
        if (r.checkSupport("nodestream"), this._outputType !== "nodebuffer")
          throw new Error(this._outputType + " is not supported by this method");
        return new u(this, { objectMode: this._outputType !== "nodebuffer" }, g);
      } }, i.exports = m;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, i, s) {
      if (s.base64 = !0, s.array = !0, s.string = !0, s.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", s.nodebuffer = typeof Buffer < "u", s.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
        s.blob = !1;
      else {
        var r = new ArrayBuffer(0);
        try {
          s.blob = new Blob([r], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var o = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            o.append(r), s.blob = o.getBlob("application/zip").size === 0;
          } catch {
            s.blob = !1;
          }
        }
      }
      try {
        s.nodestream = !!e("readable-stream").Readable;
      } catch {
        s.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(e, i, s) {
      for (var r = e("./utils"), o = e("./support"), a = e("./nodejsUtils"), l = e("./stream/GenericWorker"), c = new Array(256), h = 0; h < 256; h++)
        c[h] = 252 <= h ? 6 : 248 <= h ? 5 : 240 <= h ? 4 : 224 <= h ? 3 : 192 <= h ? 2 : 1;
      c[254] = c[254] = 1;
      function u() {
        l.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function p() {
        l.call(this, "utf-8 encode");
      }
      s.utf8encode = function(m) {
        return o.nodebuffer ? a.newBufferFrom(m, "utf-8") : function(g) {
          var _, y, b, w, v, C = g.length, k = 0;
          for (w = 0; w < C; w++)
            (64512 & (y = g.charCodeAt(w))) == 55296 && w + 1 < C && (64512 & (b = g.charCodeAt(w + 1))) == 56320 && (y = 65536 + (y - 55296 << 10) + (b - 56320), w++), k += y < 128 ? 1 : y < 2048 ? 2 : y < 65536 ? 3 : 4;
          for (_ = o.uint8array ? new Uint8Array(k) : new Array(k), w = v = 0; v < k; w++)
            (64512 & (y = g.charCodeAt(w))) == 55296 && w + 1 < C && (64512 & (b = g.charCodeAt(w + 1))) == 56320 && (y = 65536 + (y - 55296 << 10) + (b - 56320), w++), y < 128 ? _[v++] = y : (y < 2048 ? _[v++] = 192 | y >>> 6 : (y < 65536 ? _[v++] = 224 | y >>> 12 : (_[v++] = 240 | y >>> 18, _[v++] = 128 | y >>> 12 & 63), _[v++] = 128 | y >>> 6 & 63), _[v++] = 128 | 63 & y);
          return _;
        }(m);
      }, s.utf8decode = function(m) {
        return o.nodebuffer ? r.transformTo("nodebuffer", m).toString("utf-8") : function(g) {
          var _, y, b, w, v = g.length, C = new Array(2 * v);
          for (_ = y = 0; _ < v; )
            if ((b = g[_++]) < 128)
              C[y++] = b;
            else if (4 < (w = c[b]))
              C[y++] = 65533, _ += w - 1;
            else {
              for (b &= w === 2 ? 31 : w === 3 ? 15 : 7; 1 < w && _ < v; )
                b = b << 6 | 63 & g[_++], w--;
              1 < w ? C[y++] = 65533 : b < 65536 ? C[y++] = b : (b -= 65536, C[y++] = 55296 | b >> 10 & 1023, C[y++] = 56320 | 1023 & b);
            }
          return C.length !== y && (C.subarray ? C = C.subarray(0, y) : C.length = y), r.applyFromCharCode(C);
        }(m = r.transformTo(o.uint8array ? "uint8array" : "array", m));
      }, r.inherits(u, l), u.prototype.processChunk = function(m) {
        var g = r.transformTo(o.uint8array ? "uint8array" : "array", m.data);
        if (this.leftOver && this.leftOver.length) {
          if (o.uint8array) {
            var _ = g;
            (g = new Uint8Array(_.length + this.leftOver.length)).set(this.leftOver, 0), g.set(_, this.leftOver.length);
          } else
            g = this.leftOver.concat(g);
          this.leftOver = null;
        }
        var y = function(w, v) {
          var C;
          for ((v = v || w.length) > w.length && (v = w.length), C = v - 1; 0 <= C && (192 & w[C]) == 128; )
            C--;
          return C < 0 || C === 0 ? v : C + c[w[C]] > v ? C : v;
        }(g), b = g;
        y !== g.length && (o.uint8array ? (b = g.subarray(0, y), this.leftOver = g.subarray(y, g.length)) : (b = g.slice(0, y), this.leftOver = g.slice(y, g.length))), this.push({ data: s.utf8decode(b), meta: m.meta });
      }, u.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, s.Utf8DecodeWorker = u, r.inherits(p, l), p.prototype.processChunk = function(m) {
        this.push({ data: s.utf8encode(m.data), meta: m.meta });
      }, s.Utf8EncodeWorker = p;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, i, s) {
      var r = e("./support"), o = e("./base64"), a = e("./nodejsUtils"), l = e("./external");
      function c(_) {
        return _;
      }
      function h(_, y) {
        for (var b = 0; b < _.length; ++b)
          y[b] = 255 & _.charCodeAt(b);
        return y;
      }
      e("setimmediate"), s.newBlob = function(_, y) {
        s.checkSupport("blob");
        try {
          return new Blob([_], { type: y });
        } catch {
          try {
            var b = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return b.append(_), b.getBlob(y);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var u = { stringifyByChunk: function(_, y, b) {
        var w = [], v = 0, C = _.length;
        if (C <= b)
          return String.fromCharCode.apply(null, _);
        for (; v < C; )
          y === "array" || y === "nodebuffer" ? w.push(String.fromCharCode.apply(null, _.slice(v, Math.min(v + b, C)))) : w.push(String.fromCharCode.apply(null, _.subarray(v, Math.min(v + b, C)))), v += b;
        return w.join("");
      }, stringifyByChar: function(_) {
        for (var y = "", b = 0; b < _.length; b++)
          y += String.fromCharCode(_[b]);
        return y;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return r.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return r.nodebuffer && String.fromCharCode.apply(null, a.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function p(_) {
        var y = 65536, b = s.getTypeOf(_), w = !0;
        if (b === "uint8array" ? w = u.applyCanBeUsed.uint8array : b === "nodebuffer" && (w = u.applyCanBeUsed.nodebuffer), w)
          for (; 1 < y; )
            try {
              return u.stringifyByChunk(_, b, y);
            } catch {
              y = Math.floor(y / 2);
            }
        return u.stringifyByChar(_);
      }
      function m(_, y) {
        for (var b = 0; b < _.length; b++)
          y[b] = _[b];
        return y;
      }
      s.applyFromCharCode = p;
      var g = {};
      g.string = { string: c, array: function(_) {
        return h(_, new Array(_.length));
      }, arraybuffer: function(_) {
        return g.string.uint8array(_).buffer;
      }, uint8array: function(_) {
        return h(_, new Uint8Array(_.length));
      }, nodebuffer: function(_) {
        return h(_, a.allocBuffer(_.length));
      } }, g.array = { string: p, array: c, arraybuffer: function(_) {
        return new Uint8Array(_).buffer;
      }, uint8array: function(_) {
        return new Uint8Array(_);
      }, nodebuffer: function(_) {
        return a.newBufferFrom(_);
      } }, g.arraybuffer = { string: function(_) {
        return p(new Uint8Array(_));
      }, array: function(_) {
        return m(new Uint8Array(_), new Array(_.byteLength));
      }, arraybuffer: c, uint8array: function(_) {
        return new Uint8Array(_);
      }, nodebuffer: function(_) {
        return a.newBufferFrom(new Uint8Array(_));
      } }, g.uint8array = { string: p, array: function(_) {
        return m(_, new Array(_.length));
      }, arraybuffer: function(_) {
        return _.buffer;
      }, uint8array: c, nodebuffer: function(_) {
        return a.newBufferFrom(_);
      } }, g.nodebuffer = { string: p, array: function(_) {
        return m(_, new Array(_.length));
      }, arraybuffer: function(_) {
        return g.nodebuffer.uint8array(_).buffer;
      }, uint8array: function(_) {
        return m(_, new Uint8Array(_.length));
      }, nodebuffer: c }, s.transformTo = function(_, y) {
        if (y = y || "", !_)
          return y;
        s.checkSupport(_);
        var b = s.getTypeOf(y);
        return g[b][_](y);
      }, s.resolve = function(_) {
        for (var y = _.split("/"), b = [], w = 0; w < y.length; w++) {
          var v = y[w];
          v === "." || v === "" && w !== 0 && w !== y.length - 1 || (v === ".." ? b.pop() : b.push(v));
        }
        return b.join("/");
      }, s.getTypeOf = function(_) {
        return typeof _ == "string" ? "string" : Object.prototype.toString.call(_) === "[object Array]" ? "array" : r.nodebuffer && a.isBuffer(_) ? "nodebuffer" : r.uint8array && _ instanceof Uint8Array ? "uint8array" : r.arraybuffer && _ instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, s.checkSupport = function(_) {
        if (!r[_.toLowerCase()])
          throw new Error(_ + " is not supported by this platform");
      }, s.MAX_VALUE_16BITS = 65535, s.MAX_VALUE_32BITS = -1, s.pretty = function(_) {
        var y, b, w = "";
        for (b = 0; b < (_ || "").length; b++)
          w += "\\x" + ((y = _.charCodeAt(b)) < 16 ? "0" : "") + y.toString(16).toUpperCase();
        return w;
      }, s.delay = function(_, y, b) {
        setImmediate(function() {
          _.apply(b || null, y || []);
        });
      }, s.inherits = function(_, y) {
        function b() {
        }
        b.prototype = y.prototype, _.prototype = new b();
      }, s.extend = function() {
        var _, y, b = {};
        for (_ = 0; _ < arguments.length; _++)
          for (y in arguments[_])
            Object.prototype.hasOwnProperty.call(arguments[_], y) && b[y] === void 0 && (b[y] = arguments[_][y]);
        return b;
      }, s.prepareContent = function(_, y, b, w, v) {
        return l.Promise.resolve(y).then(function(C) {
          return r.blob && (C instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(C)) !== -1) && typeof FileReader < "u" ? new l.Promise(function(k, Y) {
            var P = new FileReader();
            P.onload = function(L) {
              k(L.target.result);
            }, P.onerror = function(L) {
              Y(L.target.error);
            }, P.readAsArrayBuffer(C);
          }) : C;
        }).then(function(C) {
          var k = s.getTypeOf(C);
          return k ? (k === "arraybuffer" ? C = s.transformTo("uint8array", C) : k === "string" && (v ? C = o.decode(C) : b && w !== !0 && (C = function(Y) {
            return h(Y, r.uint8array ? new Uint8Array(Y.length) : new Array(Y.length));
          }(C))), C) : l.Promise.reject(new Error("Can't read the data of '" + _ + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, i, s) {
      var r = e("./reader/readerFor"), o = e("./utils"), a = e("./signature"), l = e("./zipEntry"), c = e("./support");
      function h(u) {
        this.files = [], this.loadOptions = u;
      }
      h.prototype = { checkSignature: function(u) {
        if (!this.reader.readAndCheckSignature(u)) {
          this.reader.index -= 4;
          var p = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(p) + ", expected " + o.pretty(u) + ")");
        }
      }, isSignature: function(u, p) {
        var m = this.reader.index;
        this.reader.setIndex(u);
        var g = this.reader.readString(4) === p;
        return this.reader.setIndex(m), g;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var u = this.reader.readData(this.zipCommentLength), p = c.uint8array ? "uint8array" : "array", m = o.transformTo(p, u);
        this.zipComment = this.loadOptions.decodeFileName(m);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var u, p, m, g = this.zip64EndOfCentralSize - 44; 0 < g; )
          u = this.reader.readInt(2), p = this.reader.readInt(4), m = this.reader.readData(p), this.zip64ExtensibleData[u] = { id: u, length: p, value: m };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var u, p;
        for (u = 0; u < this.files.length; u++)
          p = this.files[u], this.reader.setIndex(p.localHeaderOffset), this.checkSignature(a.LOCAL_FILE_HEADER), p.readLocalPart(this.reader), p.handleUTF8(), p.processAttributes();
      }, readCentralDir: function() {
        var u;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(a.CENTRAL_FILE_HEADER); )
          (u = new l({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(u);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var u = this.reader.lastIndexOfSignature(a.CENTRAL_DIRECTORY_END);
        if (u < 0)
          throw this.isSignature(0, a.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(u);
        var p = u;
        if (this.checkSignature(a.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (u = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(u), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, a.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var m = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (m += 20, m += 12 + this.zip64EndOfCentralSize);
        var g = p - m;
        if (0 < g)
          this.isSignature(p, a.CENTRAL_FILE_HEADER) || (this.reader.zero = g);
        else if (g < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(g) + " bytes.");
      }, prepareReader: function(u) {
        this.reader = r(u);
      }, load: function(u) {
        this.prepareReader(u), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, i.exports = h;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, i, s) {
      var r = e("./reader/readerFor"), o = e("./utils"), a = e("./compressedObject"), l = e("./crc32"), c = e("./utf8"), h = e("./compressions"), u = e("./support");
      function p(m, g) {
        this.options = m, this.loadOptions = g;
      }
      p.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(m) {
        var g, _;
        if (m.skip(22), this.fileNameLength = m.readInt(2), _ = m.readInt(2), this.fileName = m.readData(this.fileNameLength), m.skip(_), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((g = function(y) {
          for (var b in h)
            if (Object.prototype.hasOwnProperty.call(h, b) && h[b].magic === y)
              return h[b];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
        this.decompressed = new a(this.compressedSize, this.uncompressedSize, this.crc32, g, m.readData(this.compressedSize));
      }, readCentralPart: function(m) {
        this.versionMadeBy = m.readInt(2), m.skip(2), this.bitFlag = m.readInt(2), this.compressionMethod = m.readString(2), this.date = m.readDate(), this.crc32 = m.readInt(4), this.compressedSize = m.readInt(4), this.uncompressedSize = m.readInt(4);
        var g = m.readInt(2);
        if (this.extraFieldsLength = m.readInt(2), this.fileCommentLength = m.readInt(2), this.diskNumberStart = m.readInt(2), this.internalFileAttributes = m.readInt(2), this.externalFileAttributes = m.readInt(4), this.localHeaderOffset = m.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        m.skip(g), this.readExtraFields(m), this.parseZIP64ExtraField(m), this.fileComment = m.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var m = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), m == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), m == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var m = r(this.extraFields[1].value);
          this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = m.readInt(8)), this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = m.readInt(8)), this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = m.readInt(8)), this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = m.readInt(4));
        }
      }, readExtraFields: function(m) {
        var g, _, y, b = m.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); m.index + 4 < b; )
          g = m.readInt(2), _ = m.readInt(2), y = m.readData(_), this.extraFields[g] = { id: g, length: _, value: y };
        m.setIndex(b);
      }, handleUTF8: function() {
        var m = u.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = c.utf8decode(this.fileName), this.fileCommentStr = c.utf8decode(this.fileComment);
        else {
          var g = this.findExtraFieldUnicodePath();
          if (g !== null)
            this.fileNameStr = g;
          else {
            var _ = o.transformTo(m, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(_);
          }
          var y = this.findExtraFieldUnicodeComment();
          if (y !== null)
            this.fileCommentStr = y;
          else {
            var b = o.transformTo(m, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(b);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var m = this.extraFields[28789];
        if (m) {
          var g = r(m.value);
          return g.readInt(1) !== 1 || l(this.fileName) !== g.readInt(4) ? null : c.utf8decode(g.readData(m.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var m = this.extraFields[25461];
        if (m) {
          var g = r(m.value);
          return g.readInt(1) !== 1 || l(this.fileComment) !== g.readInt(4) ? null : c.utf8decode(g.readData(m.length - 5));
        }
        return null;
      } }, i.exports = p;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, i, s) {
      function r(g, _, y) {
        this.name = g, this.dir = y.dir, this.date = y.date, this.comment = y.comment, this.unixPermissions = y.unixPermissions, this.dosPermissions = y.dosPermissions, this._data = _, this._dataBinary = y.binary, this.options = { compression: y.compression, compressionOptions: y.compressionOptions };
      }
      var o = e("./stream/StreamHelper"), a = e("./stream/DataWorker"), l = e("./utf8"), c = e("./compressedObject"), h = e("./stream/GenericWorker");
      r.prototype = { internalStream: function(g) {
        var _ = null, y = "string";
        try {
          if (!g)
            throw new Error("No output type specified.");
          var b = (y = g.toLowerCase()) === "string" || y === "text";
          y !== "binarystring" && y !== "text" || (y = "string"), _ = this._decompressWorker();
          var w = !this._dataBinary;
          w && !b && (_ = _.pipe(new l.Utf8EncodeWorker())), !w && b && (_ = _.pipe(new l.Utf8DecodeWorker()));
        } catch (v) {
          (_ = new h("error")).error(v);
        }
        return new o(_, y, "");
      }, async: function(g, _) {
        return this.internalStream(g).accumulate(_);
      }, nodeStream: function(g, _) {
        return this.internalStream(g || "nodebuffer").toNodejsStream(_);
      }, _compressWorker: function(g, _) {
        if (this._data instanceof c && this._data.compression.magic === g.magic)
          return this._data.getCompressedWorker();
        var y = this._decompressWorker();
        return this._dataBinary || (y = y.pipe(new l.Utf8EncodeWorker())), c.createWorkerFrom(y, g, _);
      }, _decompressWorker: function() {
        return this._data instanceof c ? this._data.getContentWorker() : this._data instanceof h ? this._data : new a(this._data);
      } };
      for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], p = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, m = 0; m < u.length; m++)
        r.prototype[u[m]] = p;
      i.exports = r;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, i, s) {
      (function(r) {
        var o, a, l = r.MutationObserver || r.WebKitMutationObserver;
        if (l) {
          var c = 0, h = new l(g), u = r.document.createTextNode("");
          h.observe(u, { characterData: !0 }), o = function() {
            u.data = c = ++c % 2;
          };
        } else if (r.setImmediate || r.MessageChannel === void 0)
          o = "document" in r && "onreadystatechange" in r.document.createElement("script") ? function() {
            var _ = r.document.createElement("script");
            _.onreadystatechange = function() {
              g(), _.onreadystatechange = null, _.parentNode.removeChild(_), _ = null;
            }, r.document.documentElement.appendChild(_);
          } : function() {
            setTimeout(g, 0);
          };
        else {
          var p = new r.MessageChannel();
          p.port1.onmessage = g, o = function() {
            p.port2.postMessage(0);
          };
        }
        var m = [];
        function g() {
          var _, y;
          a = !0;
          for (var b = m.length; b; ) {
            for (y = m, m = [], _ = -1; ++_ < b; )
              y[_]();
            b = m.length;
          }
          a = !1;
        }
        i.exports = function(_) {
          m.push(_) !== 1 || a || o();
        };
      }).call(this, typeof $s < "u" ? $s : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(e, i, s) {
      var r = e("immediate");
      function o() {
      }
      var a = {}, l = ["REJECTED"], c = ["FULFILLED"], h = ["PENDING"];
      function u(b) {
        if (typeof b != "function")
          throw new TypeError("resolver must be a function");
        this.state = h, this.queue = [], this.outcome = void 0, b !== o && _(this, b);
      }
      function p(b, w, v) {
        this.promise = b, typeof w == "function" && (this.onFulfilled = w, this.callFulfilled = this.otherCallFulfilled), typeof v == "function" && (this.onRejected = v, this.callRejected = this.otherCallRejected);
      }
      function m(b, w, v) {
        r(function() {
          var C;
          try {
            C = w(v);
          } catch (k) {
            return a.reject(b, k);
          }
          C === b ? a.reject(b, new TypeError("Cannot resolve promise with itself")) : a.resolve(b, C);
        });
      }
      function g(b) {
        var w = b && b.then;
        if (b && (typeof b == "object" || typeof b == "function") && typeof w == "function")
          return function() {
            w.apply(b, arguments);
          };
      }
      function _(b, w) {
        var v = !1;
        function C(P) {
          v || (v = !0, a.reject(b, P));
        }
        function k(P) {
          v || (v = !0, a.resolve(b, P));
        }
        var Y = y(function() {
          w(k, C);
        });
        Y.status === "error" && C(Y.value);
      }
      function y(b, w) {
        var v = {};
        try {
          v.value = b(w), v.status = "success";
        } catch (C) {
          v.status = "error", v.value = C;
        }
        return v;
      }
      (i.exports = u).prototype.finally = function(b) {
        if (typeof b != "function")
          return this;
        var w = this.constructor;
        return this.then(function(v) {
          return w.resolve(b()).then(function() {
            return v;
          });
        }, function(v) {
          return w.resolve(b()).then(function() {
            throw v;
          });
        });
      }, u.prototype.catch = function(b) {
        return this.then(null, b);
      }, u.prototype.then = function(b, w) {
        if (typeof b != "function" && this.state === c || typeof w != "function" && this.state === l)
          return this;
        var v = new this.constructor(o);
        return this.state !== h ? m(v, this.state === c ? b : w, this.outcome) : this.queue.push(new p(v, b, w)), v;
      }, p.prototype.callFulfilled = function(b) {
        a.resolve(this.promise, b);
      }, p.prototype.otherCallFulfilled = function(b) {
        m(this.promise, this.onFulfilled, b);
      }, p.prototype.callRejected = function(b) {
        a.reject(this.promise, b);
      }, p.prototype.otherCallRejected = function(b) {
        m(this.promise, this.onRejected, b);
      }, a.resolve = function(b, w) {
        var v = y(g, w);
        if (v.status === "error")
          return a.reject(b, v.value);
        var C = v.value;
        if (C)
          _(b, C);
        else {
          b.state = c, b.outcome = w;
          for (var k = -1, Y = b.queue.length; ++k < Y; )
            b.queue[k].callFulfilled(w);
        }
        return b;
      }, a.reject = function(b, w) {
        b.state = l, b.outcome = w;
        for (var v = -1, C = b.queue.length; ++v < C; )
          b.queue[v].callRejected(w);
        return b;
      }, u.resolve = function(b) {
        return b instanceof this ? b : a.resolve(new this(o), b);
      }, u.reject = function(b) {
        var w = new this(o);
        return a.reject(w, b);
      }, u.all = function(b) {
        var w = this;
        if (Object.prototype.toString.call(b) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var v = b.length, C = !1;
        if (!v)
          return this.resolve([]);
        for (var k = new Array(v), Y = 0, P = -1, L = new this(o); ++P < v; )
          N(b[P], P);
        return L;
        function N(D, B) {
          w.resolve(D).then(function(V) {
            k[B] = V, ++Y !== v || C || (C = !0, a.resolve(L, k));
          }, function(V) {
            C || (C = !0, a.reject(L, V));
          });
        }
      }, u.race = function(b) {
        var w = this;
        if (Object.prototype.toString.call(b) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var v = b.length, C = !1;
        if (!v)
          return this.resolve([]);
        for (var k = -1, Y = new this(o); ++k < v; )
          P = b[k], w.resolve(P).then(function(L) {
            C || (C = !0, a.resolve(Y, L));
          }, function(L) {
            C || (C = !0, a.reject(Y, L));
          });
        var P;
        return Y;
      };
    }, { immediate: 36 }], 38: [function(e, i, s) {
      var r = {};
      (0, e("./lib/utils/common").assign)(r, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), i.exports = r;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, i, s) {
      var r = e("./zlib/deflate"), o = e("./utils/common"), a = e("./utils/strings"), l = e("./zlib/messages"), c = e("./zlib/zstream"), h = Object.prototype.toString, u = 0, p = -1, m = 0, g = 8;
      function _(b) {
        if (!(this instanceof _))
          return new _(b);
        this.options = o.assign({ level: p, method: g, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: m, to: "" }, b || {});
        var w = this.options;
        w.raw && 0 < w.windowBits ? w.windowBits = -w.windowBits : w.gzip && 0 < w.windowBits && w.windowBits < 16 && (w.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
        var v = r.deflateInit2(this.strm, w.level, w.method, w.windowBits, w.memLevel, w.strategy);
        if (v !== u)
          throw new Error(l[v]);
        if (w.header && r.deflateSetHeader(this.strm, w.header), w.dictionary) {
          var C;
          if (C = typeof w.dictionary == "string" ? a.string2buf(w.dictionary) : h.call(w.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(w.dictionary) : w.dictionary, (v = r.deflateSetDictionary(this.strm, C)) !== u)
            throw new Error(l[v]);
          this._dict_set = !0;
        }
      }
      function y(b, w) {
        var v = new _(w);
        if (v.push(b, !0), v.err)
          throw v.msg || l[v.err];
        return v.result;
      }
      _.prototype.push = function(b, w) {
        var v, C, k = this.strm, Y = this.options.chunkSize;
        if (this.ended)
          return !1;
        C = w === ~~w ? w : w === !0 ? 4 : 0, typeof b == "string" ? k.input = a.string2buf(b) : h.call(b) === "[object ArrayBuffer]" ? k.input = new Uint8Array(b) : k.input = b, k.next_in = 0, k.avail_in = k.input.length;
        do {
          if (k.avail_out === 0 && (k.output = new o.Buf8(Y), k.next_out = 0, k.avail_out = Y), (v = r.deflate(k, C)) !== 1 && v !== u)
            return this.onEnd(v), !(this.ended = !0);
          k.avail_out !== 0 && (k.avail_in !== 0 || C !== 4 && C !== 2) || (this.options.to === "string" ? this.onData(a.buf2binstring(o.shrinkBuf(k.output, k.next_out))) : this.onData(o.shrinkBuf(k.output, k.next_out)));
        } while ((0 < k.avail_in || k.avail_out === 0) && v !== 1);
        return C === 4 ? (v = r.deflateEnd(this.strm), this.onEnd(v), this.ended = !0, v === u) : C !== 2 || (this.onEnd(u), !(k.avail_out = 0));
      }, _.prototype.onData = function(b) {
        this.chunks.push(b);
      }, _.prototype.onEnd = function(b) {
        b === u && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = b, this.msg = this.strm.msg;
      }, s.Deflate = _, s.deflate = y, s.deflateRaw = function(b, w) {
        return (w = w || {}).raw = !0, y(b, w);
      }, s.gzip = function(b, w) {
        return (w = w || {}).gzip = !0, y(b, w);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, i, s) {
      var r = e("./zlib/inflate"), o = e("./utils/common"), a = e("./utils/strings"), l = e("./zlib/constants"), c = e("./zlib/messages"), h = e("./zlib/zstream"), u = e("./zlib/gzheader"), p = Object.prototype.toString;
      function m(_) {
        if (!(this instanceof m))
          return new m(_);
        this.options = o.assign({ chunkSize: 16384, windowBits: 0, to: "" }, _ || {});
        var y = this.options;
        y.raw && 0 <= y.windowBits && y.windowBits < 16 && (y.windowBits = -y.windowBits, y.windowBits === 0 && (y.windowBits = -15)), !(0 <= y.windowBits && y.windowBits < 16) || _ && _.windowBits || (y.windowBits += 32), 15 < y.windowBits && y.windowBits < 48 && !(15 & y.windowBits) && (y.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
        var b = r.inflateInit2(this.strm, y.windowBits);
        if (b !== l.Z_OK)
          throw new Error(c[b]);
        this.header = new u(), r.inflateGetHeader(this.strm, this.header);
      }
      function g(_, y) {
        var b = new m(y);
        if (b.push(_, !0), b.err)
          throw b.msg || c[b.err];
        return b.result;
      }
      m.prototype.push = function(_, y) {
        var b, w, v, C, k, Y, P = this.strm, L = this.options.chunkSize, N = this.options.dictionary, D = !1;
        if (this.ended)
          return !1;
        w = y === ~~y ? y : y === !0 ? l.Z_FINISH : l.Z_NO_FLUSH, typeof _ == "string" ? P.input = a.binstring2buf(_) : p.call(_) === "[object ArrayBuffer]" ? P.input = new Uint8Array(_) : P.input = _, P.next_in = 0, P.avail_in = P.input.length;
        do {
          if (P.avail_out === 0 && (P.output = new o.Buf8(L), P.next_out = 0, P.avail_out = L), (b = r.inflate(P, l.Z_NO_FLUSH)) === l.Z_NEED_DICT && N && (Y = typeof N == "string" ? a.string2buf(N) : p.call(N) === "[object ArrayBuffer]" ? new Uint8Array(N) : N, b = r.inflateSetDictionary(this.strm, Y)), b === l.Z_BUF_ERROR && D === !0 && (b = l.Z_OK, D = !1), b !== l.Z_STREAM_END && b !== l.Z_OK)
            return this.onEnd(b), !(this.ended = !0);
          P.next_out && (P.avail_out !== 0 && b !== l.Z_STREAM_END && (P.avail_in !== 0 || w !== l.Z_FINISH && w !== l.Z_SYNC_FLUSH) || (this.options.to === "string" ? (v = a.utf8border(P.output, P.next_out), C = P.next_out - v, k = a.buf2string(P.output, v), P.next_out = C, P.avail_out = L - C, C && o.arraySet(P.output, P.output, v, C, 0), this.onData(k)) : this.onData(o.shrinkBuf(P.output, P.next_out)))), P.avail_in === 0 && P.avail_out === 0 && (D = !0);
        } while ((0 < P.avail_in || P.avail_out === 0) && b !== l.Z_STREAM_END);
        return b === l.Z_STREAM_END && (w = l.Z_FINISH), w === l.Z_FINISH ? (b = r.inflateEnd(this.strm), this.onEnd(b), this.ended = !0, b === l.Z_OK) : w !== l.Z_SYNC_FLUSH || (this.onEnd(l.Z_OK), !(P.avail_out = 0));
      }, m.prototype.onData = function(_) {
        this.chunks.push(_);
      }, m.prototype.onEnd = function(_) {
        _ === l.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = _, this.msg = this.strm.msg;
      }, s.Inflate = m, s.inflate = g, s.inflateRaw = function(_, y) {
        return (y = y || {}).raw = !0, g(_, y);
      }, s.ungzip = g;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, i, s) {
      var r = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      s.assign = function(l) {
        for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
          var h = c.shift();
          if (h) {
            if (typeof h != "object")
              throw new TypeError(h + "must be non-object");
            for (var u in h)
              h.hasOwnProperty(u) && (l[u] = h[u]);
          }
        }
        return l;
      }, s.shrinkBuf = function(l, c) {
        return l.length === c ? l : l.subarray ? l.subarray(0, c) : (l.length = c, l);
      };
      var o = { arraySet: function(l, c, h, u, p) {
        if (c.subarray && l.subarray)
          l.set(c.subarray(h, h + u), p);
        else
          for (var m = 0; m < u; m++)
            l[p + m] = c[h + m];
      }, flattenChunks: function(l) {
        var c, h, u, p, m, g;
        for (c = u = 0, h = l.length; c < h; c++)
          u += l[c].length;
        for (g = new Uint8Array(u), c = p = 0, h = l.length; c < h; c++)
          m = l[c], g.set(m, p), p += m.length;
        return g;
      } }, a = { arraySet: function(l, c, h, u, p) {
        for (var m = 0; m < u; m++)
          l[p + m] = c[h + m];
      }, flattenChunks: function(l) {
        return [].concat.apply([], l);
      } };
      s.setTyped = function(l) {
        l ? (s.Buf8 = Uint8Array, s.Buf16 = Uint16Array, s.Buf32 = Int32Array, s.assign(s, o)) : (s.Buf8 = Array, s.Buf16 = Array, s.Buf32 = Array, s.assign(s, a));
      }, s.setTyped(r);
    }, {}], 42: [function(e, i, s) {
      var r = e("./common"), o = !0, a = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        o = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        a = !1;
      }
      for (var l = new r.Buf8(256), c = 0; c < 256; c++)
        l[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
      function h(u, p) {
        if (p < 65537 && (u.subarray && a || !u.subarray && o))
          return String.fromCharCode.apply(null, r.shrinkBuf(u, p));
        for (var m = "", g = 0; g < p; g++)
          m += String.fromCharCode(u[g]);
        return m;
      }
      l[254] = l[254] = 1, s.string2buf = function(u) {
        var p, m, g, _, y, b = u.length, w = 0;
        for (_ = 0; _ < b; _++)
          (64512 & (m = u.charCodeAt(_))) == 55296 && _ + 1 < b && (64512 & (g = u.charCodeAt(_ + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (g - 56320), _++), w += m < 128 ? 1 : m < 2048 ? 2 : m < 65536 ? 3 : 4;
        for (p = new r.Buf8(w), _ = y = 0; y < w; _++)
          (64512 & (m = u.charCodeAt(_))) == 55296 && _ + 1 < b && (64512 & (g = u.charCodeAt(_ + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (g - 56320), _++), m < 128 ? p[y++] = m : (m < 2048 ? p[y++] = 192 | m >>> 6 : (m < 65536 ? p[y++] = 224 | m >>> 12 : (p[y++] = 240 | m >>> 18, p[y++] = 128 | m >>> 12 & 63), p[y++] = 128 | m >>> 6 & 63), p[y++] = 128 | 63 & m);
        return p;
      }, s.buf2binstring = function(u) {
        return h(u, u.length);
      }, s.binstring2buf = function(u) {
        for (var p = new r.Buf8(u.length), m = 0, g = p.length; m < g; m++)
          p[m] = u.charCodeAt(m);
        return p;
      }, s.buf2string = function(u, p) {
        var m, g, _, y, b = p || u.length, w = new Array(2 * b);
        for (m = g = 0; m < b; )
          if ((_ = u[m++]) < 128)
            w[g++] = _;
          else if (4 < (y = l[_]))
            w[g++] = 65533, m += y - 1;
          else {
            for (_ &= y === 2 ? 31 : y === 3 ? 15 : 7; 1 < y && m < b; )
              _ = _ << 6 | 63 & u[m++], y--;
            1 < y ? w[g++] = 65533 : _ < 65536 ? w[g++] = _ : (_ -= 65536, w[g++] = 55296 | _ >> 10 & 1023, w[g++] = 56320 | 1023 & _);
          }
        return h(w, g);
      }, s.utf8border = function(u, p) {
        var m;
        for ((p = p || u.length) > u.length && (p = u.length), m = p - 1; 0 <= m && (192 & u[m]) == 128; )
          m--;
        return m < 0 || m === 0 ? p : m + l[u[m]] > p ? m : p;
      };
    }, { "./common": 41 }], 43: [function(e, i, s) {
      i.exports = function(r, o, a, l) {
        for (var c = 65535 & r | 0, h = r >>> 16 & 65535 | 0, u = 0; a !== 0; ) {
          for (a -= u = 2e3 < a ? 2e3 : a; h = h + (c = c + o[l++] | 0) | 0, --u; )
            ;
          c %= 65521, h %= 65521;
        }
        return c | h << 16 | 0;
      };
    }, {}], 44: [function(e, i, s) {
      i.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(e, i, s) {
      var r = function() {
        for (var o, a = [], l = 0; l < 256; l++) {
          o = l;
          for (var c = 0; c < 8; c++)
            o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          a[l] = o;
        }
        return a;
      }();
      i.exports = function(o, a, l, c) {
        var h = r, u = c + l;
        o ^= -1;
        for (var p = c; p < u; p++)
          o = o >>> 8 ^ h[255 & (o ^ a[p])];
        return -1 ^ o;
      };
    }, {}], 46: [function(e, i, s) {
      var r, o = e("../utils/common"), a = e("./trees"), l = e("./adler32"), c = e("./crc32"), h = e("./messages"), u = 0, p = 4, m = 0, g = -2, _ = -1, y = 4, b = 2, w = 8, v = 9, C = 286, k = 30, Y = 19, P = 2 * C + 1, L = 15, N = 3, D = 258, B = D + N + 1, V = 42, X = 113, Z = 1, W = 2, st = 3, j = 4;
      function gt(S, $) {
        return S.msg = h[$], $;
      }
      function U(S) {
        return (S << 1) - (4 < S ? 9 : 0);
      }
      function ht(S) {
        for (var $ = S.length; 0 <= --$; )
          S[$] = 0;
      }
      function z(S) {
        var $ = S.state, H = $.pending;
        H > S.avail_out && (H = S.avail_out), H !== 0 && (o.arraySet(S.output, $.pending_buf, $.pending_out, H, S.next_out), S.next_out += H, $.pending_out += H, S.total_out += H, S.avail_out -= H, $.pending -= H, $.pending === 0 && ($.pending_out = 0));
      }
      function O(S, $) {
        a._tr_flush_block(S, 0 <= S.block_start ? S.block_start : -1, S.strstart - S.block_start, $), S.block_start = S.strstart, z(S.strm);
      }
      function _t(S, $) {
        S.pending_buf[S.pending++] = $;
      }
      function rt(S, $) {
        S.pending_buf[S.pending++] = $ >>> 8 & 255, S.pending_buf[S.pending++] = 255 & $;
      }
      function ut(S, $) {
        var H, T, G = S.max_chain_length, K = S.strstart, tt = S.prev_length, nt = S.nice_match, A = S.strstart > S.w_size - B ? S.strstart - (S.w_size - B) : 0, lt = S.window, dt = S.w_mask, ct = S.prev, It = S.strstart + D, jt = lt[K + tt - 1], Ft = lt[K + tt];
        S.prev_length >= S.good_match && (G >>= 2), nt > S.lookahead && (nt = S.lookahead);
        do
          if (lt[(H = $) + tt] === Ft && lt[H + tt - 1] === jt && lt[H] === lt[K] && lt[++H] === lt[K + 1]) {
            K += 2, H++;
            do
              ;
            while (lt[++K] === lt[++H] && lt[++K] === lt[++H] && lt[++K] === lt[++H] && lt[++K] === lt[++H] && lt[++K] === lt[++H] && lt[++K] === lt[++H] && lt[++K] === lt[++H] && lt[++K] === lt[++H] && K < It);
            if (T = D - (It - K), K = It - D, tt < T) {
              if (S.match_start = $, nt <= (tt = T))
                break;
              jt = lt[K + tt - 1], Ft = lt[K + tt];
            }
          }
        while (($ = ct[$ & dt]) > A && --G != 0);
        return tt <= S.lookahead ? tt : S.lookahead;
      }
      function oe(S) {
        var $, H, T, G, K, tt, nt, A, lt, dt, ct = S.w_size;
        do {
          if (G = S.window_size - S.lookahead - S.strstart, S.strstart >= ct + (ct - B)) {
            for (o.arraySet(S.window, S.window, ct, ct, 0), S.match_start -= ct, S.strstart -= ct, S.block_start -= ct, $ = H = S.hash_size; T = S.head[--$], S.head[$] = ct <= T ? T - ct : 0, --H; )
              ;
            for ($ = H = ct; T = S.prev[--$], S.prev[$] = ct <= T ? T - ct : 0, --H; )
              ;
            G += ct;
          }
          if (S.strm.avail_in === 0)
            break;
          if (tt = S.strm, nt = S.window, A = S.strstart + S.lookahead, lt = G, dt = void 0, dt = tt.avail_in, lt < dt && (dt = lt), H = dt === 0 ? 0 : (tt.avail_in -= dt, o.arraySet(nt, tt.input, tt.next_in, dt, A), tt.state.wrap === 1 ? tt.adler = l(tt.adler, nt, dt, A) : tt.state.wrap === 2 && (tt.adler = c(tt.adler, nt, dt, A)), tt.next_in += dt, tt.total_in += dt, dt), S.lookahead += H, S.lookahead + S.insert >= N)
            for (K = S.strstart - S.insert, S.ins_h = S.window[K], S.ins_h = (S.ins_h << S.hash_shift ^ S.window[K + 1]) & S.hash_mask; S.insert && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[K + N - 1]) & S.hash_mask, S.prev[K & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = K, K++, S.insert--, !(S.lookahead + S.insert < N)); )
              ;
        } while (S.lookahead < B && S.strm.avail_in !== 0);
      }
      function Re(S, $) {
        for (var H, T; ; ) {
          if (S.lookahead < B) {
            if (oe(S), S.lookahead < B && $ === u)
              return Z;
            if (S.lookahead === 0)
              break;
          }
          if (H = 0, S.lookahead >= N && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + N - 1]) & S.hash_mask, H = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart), H !== 0 && S.strstart - H <= S.w_size - B && (S.match_length = ut(S, H)), S.match_length >= N)
            if (T = a._tr_tally(S, S.strstart - S.match_start, S.match_length - N), S.lookahead -= S.match_length, S.match_length <= S.max_lazy_match && S.lookahead >= N) {
              for (S.match_length--; S.strstart++, S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + N - 1]) & S.hash_mask, H = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart, --S.match_length != 0; )
                ;
              S.strstart++;
            } else
              S.strstart += S.match_length, S.match_length = 0, S.ins_h = S.window[S.strstart], S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + 1]) & S.hash_mask;
          else
            T = a._tr_tally(S, 0, S.window[S.strstart]), S.lookahead--, S.strstart++;
          if (T && (O(S, !1), S.strm.avail_out === 0))
            return Z;
        }
        return S.insert = S.strstart < N - 1 ? S.strstart : N - 1, $ === p ? (O(S, !0), S.strm.avail_out === 0 ? st : j) : S.last_lit && (O(S, !1), S.strm.avail_out === 0) ? Z : W;
      }
      function Wt(S, $) {
        for (var H, T, G; ; ) {
          if (S.lookahead < B) {
            if (oe(S), S.lookahead < B && $ === u)
              return Z;
            if (S.lookahead === 0)
              break;
          }
          if (H = 0, S.lookahead >= N && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + N - 1]) & S.hash_mask, H = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart), S.prev_length = S.match_length, S.prev_match = S.match_start, S.match_length = N - 1, H !== 0 && S.prev_length < S.max_lazy_match && S.strstart - H <= S.w_size - B && (S.match_length = ut(S, H), S.match_length <= 5 && (S.strategy === 1 || S.match_length === N && 4096 < S.strstart - S.match_start) && (S.match_length = N - 1)), S.prev_length >= N && S.match_length <= S.prev_length) {
            for (G = S.strstart + S.lookahead - N, T = a._tr_tally(S, S.strstart - 1 - S.prev_match, S.prev_length - N), S.lookahead -= S.prev_length - 1, S.prev_length -= 2; ++S.strstart <= G && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + N - 1]) & S.hash_mask, H = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart), --S.prev_length != 0; )
              ;
            if (S.match_available = 0, S.match_length = N - 1, S.strstart++, T && (O(S, !1), S.strm.avail_out === 0))
              return Z;
          } else if (S.match_available) {
            if ((T = a._tr_tally(S, 0, S.window[S.strstart - 1])) && O(S, !1), S.strstart++, S.lookahead--, S.strm.avail_out === 0)
              return Z;
          } else
            S.match_available = 1, S.strstart++, S.lookahead--;
        }
        return S.match_available && (T = a._tr_tally(S, 0, S.window[S.strstart - 1]), S.match_available = 0), S.insert = S.strstart < N - 1 ? S.strstart : N - 1, $ === p ? (O(S, !0), S.strm.avail_out === 0 ? st : j) : S.last_lit && (O(S, !1), S.strm.avail_out === 0) ? Z : W;
      }
      function Dt(S, $, H, T, G) {
        this.good_length = S, this.max_lazy = $, this.nice_length = H, this.max_chain = T, this.func = G;
      }
      function ee() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = w, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new o.Buf16(2 * P), this.dyn_dtree = new o.Buf16(2 * (2 * k + 1)), this.bl_tree = new o.Buf16(2 * (2 * Y + 1)), ht(this.dyn_ltree), ht(this.dyn_dtree), ht(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new o.Buf16(L + 1), this.heap = new o.Buf16(2 * C + 1), ht(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new o.Buf16(2 * C + 1), ht(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function ie(S) {
        var $;
        return S && S.state ? (S.total_in = S.total_out = 0, S.data_type = b, ($ = S.state).pending = 0, $.pending_out = 0, $.wrap < 0 && ($.wrap = -$.wrap), $.status = $.wrap ? V : X, S.adler = $.wrap === 2 ? 0 : 1, $.last_flush = u, a._tr_init($), m) : gt(S, g);
      }
      function Ye(S) {
        var $ = ie(S);
        return $ === m && function(H) {
          H.window_size = 2 * H.w_size, ht(H.head), H.max_lazy_match = r[H.level].max_lazy, H.good_match = r[H.level].good_length, H.nice_match = r[H.level].nice_length, H.max_chain_length = r[H.level].max_chain, H.strstart = 0, H.block_start = 0, H.lookahead = 0, H.insert = 0, H.match_length = H.prev_length = N - 1, H.match_available = 0, H.ins_h = 0;
        }(S.state), $;
      }
      function bi(S, $, H, T, G, K) {
        if (!S)
          return g;
        var tt = 1;
        if ($ === _ && ($ = 6), T < 0 ? (tt = 0, T = -T) : 15 < T && (tt = 2, T -= 16), G < 1 || v < G || H !== w || T < 8 || 15 < T || $ < 0 || 9 < $ || K < 0 || y < K)
          return gt(S, g);
        T === 8 && (T = 9);
        var nt = new ee();
        return (S.state = nt).strm = S, nt.wrap = tt, nt.gzhead = null, nt.w_bits = T, nt.w_size = 1 << nt.w_bits, nt.w_mask = nt.w_size - 1, nt.hash_bits = G + 7, nt.hash_size = 1 << nt.hash_bits, nt.hash_mask = nt.hash_size - 1, nt.hash_shift = ~~((nt.hash_bits + N - 1) / N), nt.window = new o.Buf8(2 * nt.w_size), nt.head = new o.Buf16(nt.hash_size), nt.prev = new o.Buf16(nt.w_size), nt.lit_bufsize = 1 << G + 6, nt.pending_buf_size = 4 * nt.lit_bufsize, nt.pending_buf = new o.Buf8(nt.pending_buf_size), nt.d_buf = 1 * nt.lit_bufsize, nt.l_buf = 3 * nt.lit_bufsize, nt.level = $, nt.strategy = K, nt.method = H, Ye(S);
      }
      r = [new Dt(0, 0, 0, 0, function(S, $) {
        var H = 65535;
        for (H > S.pending_buf_size - 5 && (H = S.pending_buf_size - 5); ; ) {
          if (S.lookahead <= 1) {
            if (oe(S), S.lookahead === 0 && $ === u)
              return Z;
            if (S.lookahead === 0)
              break;
          }
          S.strstart += S.lookahead, S.lookahead = 0;
          var T = S.block_start + H;
          if ((S.strstart === 0 || S.strstart >= T) && (S.lookahead = S.strstart - T, S.strstart = T, O(S, !1), S.strm.avail_out === 0) || S.strstart - S.block_start >= S.w_size - B && (O(S, !1), S.strm.avail_out === 0))
            return Z;
        }
        return S.insert = 0, $ === p ? (O(S, !0), S.strm.avail_out === 0 ? st : j) : (S.strstart > S.block_start && (O(S, !1), S.strm.avail_out), Z);
      }), new Dt(4, 4, 8, 4, Re), new Dt(4, 5, 16, 8, Re), new Dt(4, 6, 32, 32, Re), new Dt(4, 4, 16, 16, Wt), new Dt(8, 16, 32, 32, Wt), new Dt(8, 16, 128, 128, Wt), new Dt(8, 32, 128, 256, Wt), new Dt(32, 128, 258, 1024, Wt), new Dt(32, 258, 258, 4096, Wt)], s.deflateInit = function(S, $) {
        return bi(S, $, w, 15, 8, 0);
      }, s.deflateInit2 = bi, s.deflateReset = Ye, s.deflateResetKeep = ie, s.deflateSetHeader = function(S, $) {
        return S && S.state ? S.state.wrap !== 2 ? g : (S.state.gzhead = $, m) : g;
      }, s.deflate = function(S, $) {
        var H, T, G, K;
        if (!S || !S.state || 5 < $ || $ < 0)
          return S ? gt(S, g) : g;
        if (T = S.state, !S.output || !S.input && S.avail_in !== 0 || T.status === 666 && $ !== p)
          return gt(S, S.avail_out === 0 ? -5 : g);
        if (T.strm = S, H = T.last_flush, T.last_flush = $, T.status === V)
          if (T.wrap === 2)
            S.adler = 0, _t(T, 31), _t(T, 139), _t(T, 8), T.gzhead ? (_t(T, (T.gzhead.text ? 1 : 0) + (T.gzhead.hcrc ? 2 : 0) + (T.gzhead.extra ? 4 : 0) + (T.gzhead.name ? 8 : 0) + (T.gzhead.comment ? 16 : 0)), _t(T, 255 & T.gzhead.time), _t(T, T.gzhead.time >> 8 & 255), _t(T, T.gzhead.time >> 16 & 255), _t(T, T.gzhead.time >> 24 & 255), _t(T, T.level === 9 ? 2 : 2 <= T.strategy || T.level < 2 ? 4 : 0), _t(T, 255 & T.gzhead.os), T.gzhead.extra && T.gzhead.extra.length && (_t(T, 255 & T.gzhead.extra.length), _t(T, T.gzhead.extra.length >> 8 & 255)), T.gzhead.hcrc && (S.adler = c(S.adler, T.pending_buf, T.pending, 0)), T.gzindex = 0, T.status = 69) : (_t(T, 0), _t(T, 0), _t(T, 0), _t(T, 0), _t(T, 0), _t(T, T.level === 9 ? 2 : 2 <= T.strategy || T.level < 2 ? 4 : 0), _t(T, 3), T.status = X);
          else {
            var tt = w + (T.w_bits - 8 << 4) << 8;
            tt |= (2 <= T.strategy || T.level < 2 ? 0 : T.level < 6 ? 1 : T.level === 6 ? 2 : 3) << 6, T.strstart !== 0 && (tt |= 32), tt += 31 - tt % 31, T.status = X, rt(T, tt), T.strstart !== 0 && (rt(T, S.adler >>> 16), rt(T, 65535 & S.adler)), S.adler = 1;
          }
        if (T.status === 69)
          if (T.gzhead.extra) {
            for (G = T.pending; T.gzindex < (65535 & T.gzhead.extra.length) && (T.pending !== T.pending_buf_size || (T.gzhead.hcrc && T.pending > G && (S.adler = c(S.adler, T.pending_buf, T.pending - G, G)), z(S), G = T.pending, T.pending !== T.pending_buf_size)); )
              _t(T, 255 & T.gzhead.extra[T.gzindex]), T.gzindex++;
            T.gzhead.hcrc && T.pending > G && (S.adler = c(S.adler, T.pending_buf, T.pending - G, G)), T.gzindex === T.gzhead.extra.length && (T.gzindex = 0, T.status = 73);
          } else
            T.status = 73;
        if (T.status === 73)
          if (T.gzhead.name) {
            G = T.pending;
            do {
              if (T.pending === T.pending_buf_size && (T.gzhead.hcrc && T.pending > G && (S.adler = c(S.adler, T.pending_buf, T.pending - G, G)), z(S), G = T.pending, T.pending === T.pending_buf_size)) {
                K = 1;
                break;
              }
              K = T.gzindex < T.gzhead.name.length ? 255 & T.gzhead.name.charCodeAt(T.gzindex++) : 0, _t(T, K);
            } while (K !== 0);
            T.gzhead.hcrc && T.pending > G && (S.adler = c(S.adler, T.pending_buf, T.pending - G, G)), K === 0 && (T.gzindex = 0, T.status = 91);
          } else
            T.status = 91;
        if (T.status === 91)
          if (T.gzhead.comment) {
            G = T.pending;
            do {
              if (T.pending === T.pending_buf_size && (T.gzhead.hcrc && T.pending > G && (S.adler = c(S.adler, T.pending_buf, T.pending - G, G)), z(S), G = T.pending, T.pending === T.pending_buf_size)) {
                K = 1;
                break;
              }
              K = T.gzindex < T.gzhead.comment.length ? 255 & T.gzhead.comment.charCodeAt(T.gzindex++) : 0, _t(T, K);
            } while (K !== 0);
            T.gzhead.hcrc && T.pending > G && (S.adler = c(S.adler, T.pending_buf, T.pending - G, G)), K === 0 && (T.status = 103);
          } else
            T.status = 103;
        if (T.status === 103 && (T.gzhead.hcrc ? (T.pending + 2 > T.pending_buf_size && z(S), T.pending + 2 <= T.pending_buf_size && (_t(T, 255 & S.adler), _t(T, S.adler >> 8 & 255), S.adler = 0, T.status = X)) : T.status = X), T.pending !== 0) {
          if (z(S), S.avail_out === 0)
            return T.last_flush = -1, m;
        } else if (S.avail_in === 0 && U($) <= U(H) && $ !== p)
          return gt(S, -5);
        if (T.status === 666 && S.avail_in !== 0)
          return gt(S, -5);
        if (S.avail_in !== 0 || T.lookahead !== 0 || $ !== u && T.status !== 666) {
          var nt = T.strategy === 2 ? function(A, lt) {
            for (var dt; ; ) {
              if (A.lookahead === 0 && (oe(A), A.lookahead === 0)) {
                if (lt === u)
                  return Z;
                break;
              }
              if (A.match_length = 0, dt = a._tr_tally(A, 0, A.window[A.strstart]), A.lookahead--, A.strstart++, dt && (O(A, !1), A.strm.avail_out === 0))
                return Z;
            }
            return A.insert = 0, lt === p ? (O(A, !0), A.strm.avail_out === 0 ? st : j) : A.last_lit && (O(A, !1), A.strm.avail_out === 0) ? Z : W;
          }(T, $) : T.strategy === 3 ? function(A, lt) {
            for (var dt, ct, It, jt, Ft = A.window; ; ) {
              if (A.lookahead <= D) {
                if (oe(A), A.lookahead <= D && lt === u)
                  return Z;
                if (A.lookahead === 0)
                  break;
              }
              if (A.match_length = 0, A.lookahead >= N && 0 < A.strstart && (ct = Ft[It = A.strstart - 1]) === Ft[++It] && ct === Ft[++It] && ct === Ft[++It]) {
                jt = A.strstart + D;
                do
                  ;
                while (ct === Ft[++It] && ct === Ft[++It] && ct === Ft[++It] && ct === Ft[++It] && ct === Ft[++It] && ct === Ft[++It] && ct === Ft[++It] && ct === Ft[++It] && It < jt);
                A.match_length = D - (jt - It), A.match_length > A.lookahead && (A.match_length = A.lookahead);
              }
              if (A.match_length >= N ? (dt = a._tr_tally(A, 1, A.match_length - N), A.lookahead -= A.match_length, A.strstart += A.match_length, A.match_length = 0) : (dt = a._tr_tally(A, 0, A.window[A.strstart]), A.lookahead--, A.strstart++), dt && (O(A, !1), A.strm.avail_out === 0))
                return Z;
            }
            return A.insert = 0, lt === p ? (O(A, !0), A.strm.avail_out === 0 ? st : j) : A.last_lit && (O(A, !1), A.strm.avail_out === 0) ? Z : W;
          }(T, $) : r[T.level].func(T, $);
          if (nt !== st && nt !== j || (T.status = 666), nt === Z || nt === st)
            return S.avail_out === 0 && (T.last_flush = -1), m;
          if (nt === W && ($ === 1 ? a._tr_align(T) : $ !== 5 && (a._tr_stored_block(T, 0, 0, !1), $ === 3 && (ht(T.head), T.lookahead === 0 && (T.strstart = 0, T.block_start = 0, T.insert = 0))), z(S), S.avail_out === 0))
            return T.last_flush = -1, m;
        }
        return $ !== p ? m : T.wrap <= 0 ? 1 : (T.wrap === 2 ? (_t(T, 255 & S.adler), _t(T, S.adler >> 8 & 255), _t(T, S.adler >> 16 & 255), _t(T, S.adler >> 24 & 255), _t(T, 255 & S.total_in), _t(T, S.total_in >> 8 & 255), _t(T, S.total_in >> 16 & 255), _t(T, S.total_in >> 24 & 255)) : (rt(T, S.adler >>> 16), rt(T, 65535 & S.adler)), z(S), 0 < T.wrap && (T.wrap = -T.wrap), T.pending !== 0 ? m : 1);
      }, s.deflateEnd = function(S) {
        var $;
        return S && S.state ? ($ = S.state.status) !== V && $ !== 69 && $ !== 73 && $ !== 91 && $ !== 103 && $ !== X && $ !== 666 ? gt(S, g) : (S.state = null, $ === X ? gt(S, -3) : m) : g;
      }, s.deflateSetDictionary = function(S, $) {
        var H, T, G, K, tt, nt, A, lt, dt = $.length;
        if (!S || !S.state || (K = (H = S.state).wrap) === 2 || K === 1 && H.status !== V || H.lookahead)
          return g;
        for (K === 1 && (S.adler = l(S.adler, $, dt, 0)), H.wrap = 0, dt >= H.w_size && (K === 0 && (ht(H.head), H.strstart = 0, H.block_start = 0, H.insert = 0), lt = new o.Buf8(H.w_size), o.arraySet(lt, $, dt - H.w_size, H.w_size, 0), $ = lt, dt = H.w_size), tt = S.avail_in, nt = S.next_in, A = S.input, S.avail_in = dt, S.next_in = 0, S.input = $, oe(H); H.lookahead >= N; ) {
          for (T = H.strstart, G = H.lookahead - (N - 1); H.ins_h = (H.ins_h << H.hash_shift ^ H.window[T + N - 1]) & H.hash_mask, H.prev[T & H.w_mask] = H.head[H.ins_h], H.head[H.ins_h] = T, T++, --G; )
            ;
          H.strstart = T, H.lookahead = N - 1, oe(H);
        }
        return H.strstart += H.lookahead, H.block_start = H.strstart, H.insert = H.lookahead, H.lookahead = 0, H.match_length = H.prev_length = N - 1, H.match_available = 0, S.next_in = nt, S.input = A, S.avail_in = tt, H.wrap = K, m;
      }, s.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, i, s) {
      i.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(e, i, s) {
      i.exports = function(r, o) {
        var a, l, c, h, u, p, m, g, _, y, b, w, v, C, k, Y, P, L, N, D, B, V, X, Z, W;
        a = r.state, l = r.next_in, Z = r.input, c = l + (r.avail_in - 5), h = r.next_out, W = r.output, u = h - (o - r.avail_out), p = h + (r.avail_out - 257), m = a.dmax, g = a.wsize, _ = a.whave, y = a.wnext, b = a.window, w = a.hold, v = a.bits, C = a.lencode, k = a.distcode, Y = (1 << a.lenbits) - 1, P = (1 << a.distbits) - 1;
        t:
          do {
            v < 15 && (w += Z[l++] << v, v += 8, w += Z[l++] << v, v += 8), L = C[w & Y];
            e:
              for (; ; ) {
                if (w >>>= N = L >>> 24, v -= N, (N = L >>> 16 & 255) === 0)
                  W[h++] = 65535 & L;
                else {
                  if (!(16 & N)) {
                    if (!(64 & N)) {
                      L = C[(65535 & L) + (w & (1 << N) - 1)];
                      continue e;
                    }
                    if (32 & N) {
                      a.mode = 12;
                      break t;
                    }
                    r.msg = "invalid literal/length code", a.mode = 30;
                    break t;
                  }
                  D = 65535 & L, (N &= 15) && (v < N && (w += Z[l++] << v, v += 8), D += w & (1 << N) - 1, w >>>= N, v -= N), v < 15 && (w += Z[l++] << v, v += 8, w += Z[l++] << v, v += 8), L = k[w & P];
                  i:
                    for (; ; ) {
                      if (w >>>= N = L >>> 24, v -= N, !(16 & (N = L >>> 16 & 255))) {
                        if (!(64 & N)) {
                          L = k[(65535 & L) + (w & (1 << N) - 1)];
                          continue i;
                        }
                        r.msg = "invalid distance code", a.mode = 30;
                        break t;
                      }
                      if (B = 65535 & L, v < (N &= 15) && (w += Z[l++] << v, (v += 8) < N && (w += Z[l++] << v, v += 8)), m < (B += w & (1 << N) - 1)) {
                        r.msg = "invalid distance too far back", a.mode = 30;
                        break t;
                      }
                      if (w >>>= N, v -= N, (N = h - u) < B) {
                        if (_ < (N = B - N) && a.sane) {
                          r.msg = "invalid distance too far back", a.mode = 30;
                          break t;
                        }
                        if (X = b, (V = 0) === y) {
                          if (V += g - N, N < D) {
                            for (D -= N; W[h++] = b[V++], --N; )
                              ;
                            V = h - B, X = W;
                          }
                        } else if (y < N) {
                          if (V += g + y - N, (N -= y) < D) {
                            for (D -= N; W[h++] = b[V++], --N; )
                              ;
                            if (V = 0, y < D) {
                              for (D -= N = y; W[h++] = b[V++], --N; )
                                ;
                              V = h - B, X = W;
                            }
                          }
                        } else if (V += y - N, N < D) {
                          for (D -= N; W[h++] = b[V++], --N; )
                            ;
                          V = h - B, X = W;
                        }
                        for (; 2 < D; )
                          W[h++] = X[V++], W[h++] = X[V++], W[h++] = X[V++], D -= 3;
                        D && (W[h++] = X[V++], 1 < D && (W[h++] = X[V++]));
                      } else {
                        for (V = h - B; W[h++] = W[V++], W[h++] = W[V++], W[h++] = W[V++], 2 < (D -= 3); )
                          ;
                        D && (W[h++] = W[V++], 1 < D && (W[h++] = W[V++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (l < c && h < p);
        l -= D = v >> 3, w &= (1 << (v -= D << 3)) - 1, r.next_in = l, r.next_out = h, r.avail_in = l < c ? c - l + 5 : 5 - (l - c), r.avail_out = h < p ? p - h + 257 : 257 - (h - p), a.hold = w, a.bits = v;
      };
    }, {}], 49: [function(e, i, s) {
      var r = e("../utils/common"), o = e("./adler32"), a = e("./crc32"), l = e("./inffast"), c = e("./inftrees"), h = 1, u = 2, p = 0, m = -2, g = 1, _ = 852, y = 592;
      function b(V) {
        return (V >>> 24 & 255) + (V >>> 8 & 65280) + ((65280 & V) << 8) + ((255 & V) << 24);
      }
      function w() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new r.Buf16(320), this.work = new r.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function v(V) {
        var X;
        return V && V.state ? (X = V.state, V.total_in = V.total_out = X.total = 0, V.msg = "", X.wrap && (V.adler = 1 & X.wrap), X.mode = g, X.last = 0, X.havedict = 0, X.dmax = 32768, X.head = null, X.hold = 0, X.bits = 0, X.lencode = X.lendyn = new r.Buf32(_), X.distcode = X.distdyn = new r.Buf32(y), X.sane = 1, X.back = -1, p) : m;
      }
      function C(V) {
        var X;
        return V && V.state ? ((X = V.state).wsize = 0, X.whave = 0, X.wnext = 0, v(V)) : m;
      }
      function k(V, X) {
        var Z, W;
        return V && V.state ? (W = V.state, X < 0 ? (Z = 0, X = -X) : (Z = 1 + (X >> 4), X < 48 && (X &= 15)), X && (X < 8 || 15 < X) ? m : (W.window !== null && W.wbits !== X && (W.window = null), W.wrap = Z, W.wbits = X, C(V))) : m;
      }
      function Y(V, X) {
        var Z, W;
        return V ? (W = new w(), (V.state = W).window = null, (Z = k(V, X)) !== p && (V.state = null), Z) : m;
      }
      var P, L, N = !0;
      function D(V) {
        if (N) {
          var X;
          for (P = new r.Buf32(512), L = new r.Buf32(32), X = 0; X < 144; )
            V.lens[X++] = 8;
          for (; X < 256; )
            V.lens[X++] = 9;
          for (; X < 280; )
            V.lens[X++] = 7;
          for (; X < 288; )
            V.lens[X++] = 8;
          for (c(h, V.lens, 0, 288, P, 0, V.work, { bits: 9 }), X = 0; X < 32; )
            V.lens[X++] = 5;
          c(u, V.lens, 0, 32, L, 0, V.work, { bits: 5 }), N = !1;
        }
        V.lencode = P, V.lenbits = 9, V.distcode = L, V.distbits = 5;
      }
      function B(V, X, Z, W) {
        var st, j = V.state;
        return j.window === null && (j.wsize = 1 << j.wbits, j.wnext = 0, j.whave = 0, j.window = new r.Buf8(j.wsize)), W >= j.wsize ? (r.arraySet(j.window, X, Z - j.wsize, j.wsize, 0), j.wnext = 0, j.whave = j.wsize) : (W < (st = j.wsize - j.wnext) && (st = W), r.arraySet(j.window, X, Z - W, st, j.wnext), (W -= st) ? (r.arraySet(j.window, X, Z - W, W, 0), j.wnext = W, j.whave = j.wsize) : (j.wnext += st, j.wnext === j.wsize && (j.wnext = 0), j.whave < j.wsize && (j.whave += st))), 0;
      }
      s.inflateReset = C, s.inflateReset2 = k, s.inflateResetKeep = v, s.inflateInit = function(V) {
        return Y(V, 15);
      }, s.inflateInit2 = Y, s.inflate = function(V, X) {
        var Z, W, st, j, gt, U, ht, z, O, _t, rt, ut, oe, Re, Wt, Dt, ee, ie, Ye, bi, S, $, H, T, G = 0, K = new r.Buf8(4), tt = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!V || !V.state || !V.output || !V.input && V.avail_in !== 0)
          return m;
        (Z = V.state).mode === 12 && (Z.mode = 13), gt = V.next_out, st = V.output, ht = V.avail_out, j = V.next_in, W = V.input, U = V.avail_in, z = Z.hold, O = Z.bits, _t = U, rt = ht, $ = p;
        t:
          for (; ; )
            switch (Z.mode) {
              case g:
                if (Z.wrap === 0) {
                  Z.mode = 13;
                  break;
                }
                for (; O < 16; ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                if (2 & Z.wrap && z === 35615) {
                  K[Z.check = 0] = 255 & z, K[1] = z >>> 8 & 255, Z.check = a(Z.check, K, 2, 0), O = z = 0, Z.mode = 2;
                  break;
                }
                if (Z.flags = 0, Z.head && (Z.head.done = !1), !(1 & Z.wrap) || (((255 & z) << 8) + (z >> 8)) % 31) {
                  V.msg = "incorrect header check", Z.mode = 30;
                  break;
                }
                if ((15 & z) != 8) {
                  V.msg = "unknown compression method", Z.mode = 30;
                  break;
                }
                if (O -= 4, S = 8 + (15 & (z >>>= 4)), Z.wbits === 0)
                  Z.wbits = S;
                else if (S > Z.wbits) {
                  V.msg = "invalid window size", Z.mode = 30;
                  break;
                }
                Z.dmax = 1 << S, V.adler = Z.check = 1, Z.mode = 512 & z ? 10 : 12, O = z = 0;
                break;
              case 2:
                for (; O < 16; ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                if (Z.flags = z, (255 & Z.flags) != 8) {
                  V.msg = "unknown compression method", Z.mode = 30;
                  break;
                }
                if (57344 & Z.flags) {
                  V.msg = "unknown header flags set", Z.mode = 30;
                  break;
                }
                Z.head && (Z.head.text = z >> 8 & 1), 512 & Z.flags && (K[0] = 255 & z, K[1] = z >>> 8 & 255, Z.check = a(Z.check, K, 2, 0)), O = z = 0, Z.mode = 3;
              case 3:
                for (; O < 32; ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                Z.head && (Z.head.time = z), 512 & Z.flags && (K[0] = 255 & z, K[1] = z >>> 8 & 255, K[2] = z >>> 16 & 255, K[3] = z >>> 24 & 255, Z.check = a(Z.check, K, 4, 0)), O = z = 0, Z.mode = 4;
              case 4:
                for (; O < 16; ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                Z.head && (Z.head.xflags = 255 & z, Z.head.os = z >> 8), 512 & Z.flags && (K[0] = 255 & z, K[1] = z >>> 8 & 255, Z.check = a(Z.check, K, 2, 0)), O = z = 0, Z.mode = 5;
              case 5:
                if (1024 & Z.flags) {
                  for (; O < 16; ) {
                    if (U === 0)
                      break t;
                    U--, z += W[j++] << O, O += 8;
                  }
                  Z.length = z, Z.head && (Z.head.extra_len = z), 512 & Z.flags && (K[0] = 255 & z, K[1] = z >>> 8 & 255, Z.check = a(Z.check, K, 2, 0)), O = z = 0;
                } else
                  Z.head && (Z.head.extra = null);
                Z.mode = 6;
              case 6:
                if (1024 & Z.flags && (U < (ut = Z.length) && (ut = U), ut && (Z.head && (S = Z.head.extra_len - Z.length, Z.head.extra || (Z.head.extra = new Array(Z.head.extra_len)), r.arraySet(Z.head.extra, W, j, ut, S)), 512 & Z.flags && (Z.check = a(Z.check, W, ut, j)), U -= ut, j += ut, Z.length -= ut), Z.length))
                  break t;
                Z.length = 0, Z.mode = 7;
              case 7:
                if (2048 & Z.flags) {
                  if (U === 0)
                    break t;
                  for (ut = 0; S = W[j + ut++], Z.head && S && Z.length < 65536 && (Z.head.name += String.fromCharCode(S)), S && ut < U; )
                    ;
                  if (512 & Z.flags && (Z.check = a(Z.check, W, ut, j)), U -= ut, j += ut, S)
                    break t;
                } else
                  Z.head && (Z.head.name = null);
                Z.length = 0, Z.mode = 8;
              case 8:
                if (4096 & Z.flags) {
                  if (U === 0)
                    break t;
                  for (ut = 0; S = W[j + ut++], Z.head && S && Z.length < 65536 && (Z.head.comment += String.fromCharCode(S)), S && ut < U; )
                    ;
                  if (512 & Z.flags && (Z.check = a(Z.check, W, ut, j)), U -= ut, j += ut, S)
                    break t;
                } else
                  Z.head && (Z.head.comment = null);
                Z.mode = 9;
              case 9:
                if (512 & Z.flags) {
                  for (; O < 16; ) {
                    if (U === 0)
                      break t;
                    U--, z += W[j++] << O, O += 8;
                  }
                  if (z !== (65535 & Z.check)) {
                    V.msg = "header crc mismatch", Z.mode = 30;
                    break;
                  }
                  O = z = 0;
                }
                Z.head && (Z.head.hcrc = Z.flags >> 9 & 1, Z.head.done = !0), V.adler = Z.check = 0, Z.mode = 12;
                break;
              case 10:
                for (; O < 32; ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                V.adler = Z.check = b(z), O = z = 0, Z.mode = 11;
              case 11:
                if (Z.havedict === 0)
                  return V.next_out = gt, V.avail_out = ht, V.next_in = j, V.avail_in = U, Z.hold = z, Z.bits = O, 2;
                V.adler = Z.check = 1, Z.mode = 12;
              case 12:
                if (X === 5 || X === 6)
                  break t;
              case 13:
                if (Z.last) {
                  z >>>= 7 & O, O -= 7 & O, Z.mode = 27;
                  break;
                }
                for (; O < 3; ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                switch (Z.last = 1 & z, O -= 1, 3 & (z >>>= 1)) {
                  case 0:
                    Z.mode = 14;
                    break;
                  case 1:
                    if (D(Z), Z.mode = 20, X !== 6)
                      break;
                    z >>>= 2, O -= 2;
                    break t;
                  case 2:
                    Z.mode = 17;
                    break;
                  case 3:
                    V.msg = "invalid block type", Z.mode = 30;
                }
                z >>>= 2, O -= 2;
                break;
              case 14:
                for (z >>>= 7 & O, O -= 7 & O; O < 32; ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                if ((65535 & z) != (z >>> 16 ^ 65535)) {
                  V.msg = "invalid stored block lengths", Z.mode = 30;
                  break;
                }
                if (Z.length = 65535 & z, O = z = 0, Z.mode = 15, X === 6)
                  break t;
              case 15:
                Z.mode = 16;
              case 16:
                if (ut = Z.length) {
                  if (U < ut && (ut = U), ht < ut && (ut = ht), ut === 0)
                    break t;
                  r.arraySet(st, W, j, ut, gt), U -= ut, j += ut, ht -= ut, gt += ut, Z.length -= ut;
                  break;
                }
                Z.mode = 12;
                break;
              case 17:
                for (; O < 14; ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                if (Z.nlen = 257 + (31 & z), z >>>= 5, O -= 5, Z.ndist = 1 + (31 & z), z >>>= 5, O -= 5, Z.ncode = 4 + (15 & z), z >>>= 4, O -= 4, 286 < Z.nlen || 30 < Z.ndist) {
                  V.msg = "too many length or distance symbols", Z.mode = 30;
                  break;
                }
                Z.have = 0, Z.mode = 18;
              case 18:
                for (; Z.have < Z.ncode; ) {
                  for (; O < 3; ) {
                    if (U === 0)
                      break t;
                    U--, z += W[j++] << O, O += 8;
                  }
                  Z.lens[tt[Z.have++]] = 7 & z, z >>>= 3, O -= 3;
                }
                for (; Z.have < 19; )
                  Z.lens[tt[Z.have++]] = 0;
                if (Z.lencode = Z.lendyn, Z.lenbits = 7, H = { bits: Z.lenbits }, $ = c(0, Z.lens, 0, 19, Z.lencode, 0, Z.work, H), Z.lenbits = H.bits, $) {
                  V.msg = "invalid code lengths set", Z.mode = 30;
                  break;
                }
                Z.have = 0, Z.mode = 19;
              case 19:
                for (; Z.have < Z.nlen + Z.ndist; ) {
                  for (; Dt = (G = Z.lencode[z & (1 << Z.lenbits) - 1]) >>> 16 & 255, ee = 65535 & G, !((Wt = G >>> 24) <= O); ) {
                    if (U === 0)
                      break t;
                    U--, z += W[j++] << O, O += 8;
                  }
                  if (ee < 16)
                    z >>>= Wt, O -= Wt, Z.lens[Z.have++] = ee;
                  else {
                    if (ee === 16) {
                      for (T = Wt + 2; O < T; ) {
                        if (U === 0)
                          break t;
                        U--, z += W[j++] << O, O += 8;
                      }
                      if (z >>>= Wt, O -= Wt, Z.have === 0) {
                        V.msg = "invalid bit length repeat", Z.mode = 30;
                        break;
                      }
                      S = Z.lens[Z.have - 1], ut = 3 + (3 & z), z >>>= 2, O -= 2;
                    } else if (ee === 17) {
                      for (T = Wt + 3; O < T; ) {
                        if (U === 0)
                          break t;
                        U--, z += W[j++] << O, O += 8;
                      }
                      O -= Wt, S = 0, ut = 3 + (7 & (z >>>= Wt)), z >>>= 3, O -= 3;
                    } else {
                      for (T = Wt + 7; O < T; ) {
                        if (U === 0)
                          break t;
                        U--, z += W[j++] << O, O += 8;
                      }
                      O -= Wt, S = 0, ut = 11 + (127 & (z >>>= Wt)), z >>>= 7, O -= 7;
                    }
                    if (Z.have + ut > Z.nlen + Z.ndist) {
                      V.msg = "invalid bit length repeat", Z.mode = 30;
                      break;
                    }
                    for (; ut--; )
                      Z.lens[Z.have++] = S;
                  }
                }
                if (Z.mode === 30)
                  break;
                if (Z.lens[256] === 0) {
                  V.msg = "invalid code -- missing end-of-block", Z.mode = 30;
                  break;
                }
                if (Z.lenbits = 9, H = { bits: Z.lenbits }, $ = c(h, Z.lens, 0, Z.nlen, Z.lencode, 0, Z.work, H), Z.lenbits = H.bits, $) {
                  V.msg = "invalid literal/lengths set", Z.mode = 30;
                  break;
                }
                if (Z.distbits = 6, Z.distcode = Z.distdyn, H = { bits: Z.distbits }, $ = c(u, Z.lens, Z.nlen, Z.ndist, Z.distcode, 0, Z.work, H), Z.distbits = H.bits, $) {
                  V.msg = "invalid distances set", Z.mode = 30;
                  break;
                }
                if (Z.mode = 20, X === 6)
                  break t;
              case 20:
                Z.mode = 21;
              case 21:
                if (6 <= U && 258 <= ht) {
                  V.next_out = gt, V.avail_out = ht, V.next_in = j, V.avail_in = U, Z.hold = z, Z.bits = O, l(V, rt), gt = V.next_out, st = V.output, ht = V.avail_out, j = V.next_in, W = V.input, U = V.avail_in, z = Z.hold, O = Z.bits, Z.mode === 12 && (Z.back = -1);
                  break;
                }
                for (Z.back = 0; Dt = (G = Z.lencode[z & (1 << Z.lenbits) - 1]) >>> 16 & 255, ee = 65535 & G, !((Wt = G >>> 24) <= O); ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                if (Dt && !(240 & Dt)) {
                  for (ie = Wt, Ye = Dt, bi = ee; Dt = (G = Z.lencode[bi + ((z & (1 << ie + Ye) - 1) >> ie)]) >>> 16 & 255, ee = 65535 & G, !(ie + (Wt = G >>> 24) <= O); ) {
                    if (U === 0)
                      break t;
                    U--, z += W[j++] << O, O += 8;
                  }
                  z >>>= ie, O -= ie, Z.back += ie;
                }
                if (z >>>= Wt, O -= Wt, Z.back += Wt, Z.length = ee, Dt === 0) {
                  Z.mode = 26;
                  break;
                }
                if (32 & Dt) {
                  Z.back = -1, Z.mode = 12;
                  break;
                }
                if (64 & Dt) {
                  V.msg = "invalid literal/length code", Z.mode = 30;
                  break;
                }
                Z.extra = 15 & Dt, Z.mode = 22;
              case 22:
                if (Z.extra) {
                  for (T = Z.extra; O < T; ) {
                    if (U === 0)
                      break t;
                    U--, z += W[j++] << O, O += 8;
                  }
                  Z.length += z & (1 << Z.extra) - 1, z >>>= Z.extra, O -= Z.extra, Z.back += Z.extra;
                }
                Z.was = Z.length, Z.mode = 23;
              case 23:
                for (; Dt = (G = Z.distcode[z & (1 << Z.distbits) - 1]) >>> 16 & 255, ee = 65535 & G, !((Wt = G >>> 24) <= O); ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                if (!(240 & Dt)) {
                  for (ie = Wt, Ye = Dt, bi = ee; Dt = (G = Z.distcode[bi + ((z & (1 << ie + Ye) - 1) >> ie)]) >>> 16 & 255, ee = 65535 & G, !(ie + (Wt = G >>> 24) <= O); ) {
                    if (U === 0)
                      break t;
                    U--, z += W[j++] << O, O += 8;
                  }
                  z >>>= ie, O -= ie, Z.back += ie;
                }
                if (z >>>= Wt, O -= Wt, Z.back += Wt, 64 & Dt) {
                  V.msg = "invalid distance code", Z.mode = 30;
                  break;
                }
                Z.offset = ee, Z.extra = 15 & Dt, Z.mode = 24;
              case 24:
                if (Z.extra) {
                  for (T = Z.extra; O < T; ) {
                    if (U === 0)
                      break t;
                    U--, z += W[j++] << O, O += 8;
                  }
                  Z.offset += z & (1 << Z.extra) - 1, z >>>= Z.extra, O -= Z.extra, Z.back += Z.extra;
                }
                if (Z.offset > Z.dmax) {
                  V.msg = "invalid distance too far back", Z.mode = 30;
                  break;
                }
                Z.mode = 25;
              case 25:
                if (ht === 0)
                  break t;
                if (ut = rt - ht, Z.offset > ut) {
                  if ((ut = Z.offset - ut) > Z.whave && Z.sane) {
                    V.msg = "invalid distance too far back", Z.mode = 30;
                    break;
                  }
                  oe = ut > Z.wnext ? (ut -= Z.wnext, Z.wsize - ut) : Z.wnext - ut, ut > Z.length && (ut = Z.length), Re = Z.window;
                } else
                  Re = st, oe = gt - Z.offset, ut = Z.length;
                for (ht < ut && (ut = ht), ht -= ut, Z.length -= ut; st[gt++] = Re[oe++], --ut; )
                  ;
                Z.length === 0 && (Z.mode = 21);
                break;
              case 26:
                if (ht === 0)
                  break t;
                st[gt++] = Z.length, ht--, Z.mode = 21;
                break;
              case 27:
                if (Z.wrap) {
                  for (; O < 32; ) {
                    if (U === 0)
                      break t;
                    U--, z |= W[j++] << O, O += 8;
                  }
                  if (rt -= ht, V.total_out += rt, Z.total += rt, rt && (V.adler = Z.check = Z.flags ? a(Z.check, st, rt, gt - rt) : o(Z.check, st, rt, gt - rt)), rt = ht, (Z.flags ? z : b(z)) !== Z.check) {
                    V.msg = "incorrect data check", Z.mode = 30;
                    break;
                  }
                  O = z = 0;
                }
                Z.mode = 28;
              case 28:
                if (Z.wrap && Z.flags) {
                  for (; O < 32; ) {
                    if (U === 0)
                      break t;
                    U--, z += W[j++] << O, O += 8;
                  }
                  if (z !== (4294967295 & Z.total)) {
                    V.msg = "incorrect length check", Z.mode = 30;
                    break;
                  }
                  O = z = 0;
                }
                Z.mode = 29;
              case 29:
                $ = 1;
                break t;
              case 30:
                $ = -3;
                break t;
              case 31:
                return -4;
              case 32:
              default:
                return m;
            }
        return V.next_out = gt, V.avail_out = ht, V.next_in = j, V.avail_in = U, Z.hold = z, Z.bits = O, (Z.wsize || rt !== V.avail_out && Z.mode < 30 && (Z.mode < 27 || X !== 4)) && B(V, V.output, V.next_out, rt - V.avail_out) ? (Z.mode = 31, -4) : (_t -= V.avail_in, rt -= V.avail_out, V.total_in += _t, V.total_out += rt, Z.total += rt, Z.wrap && rt && (V.adler = Z.check = Z.flags ? a(Z.check, st, rt, V.next_out - rt) : o(Z.check, st, rt, V.next_out - rt)), V.data_type = Z.bits + (Z.last ? 64 : 0) + (Z.mode === 12 ? 128 : 0) + (Z.mode === 20 || Z.mode === 15 ? 256 : 0), (_t == 0 && rt === 0 || X === 4) && $ === p && ($ = -5), $);
      }, s.inflateEnd = function(V) {
        if (!V || !V.state)
          return m;
        var X = V.state;
        return X.window && (X.window = null), V.state = null, p;
      }, s.inflateGetHeader = function(V, X) {
        var Z;
        return V && V.state && 2 & (Z = V.state).wrap ? ((Z.head = X).done = !1, p) : m;
      }, s.inflateSetDictionary = function(V, X) {
        var Z, W = X.length;
        return V && V.state ? (Z = V.state).wrap !== 0 && Z.mode !== 11 ? m : Z.mode === 11 && o(1, X, W, 0) !== Z.check ? -3 : B(V, X, W, W) ? (Z.mode = 31, -4) : (Z.havedict = 1, p) : m;
      }, s.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, i, s) {
      var r = e("../utils/common"), o = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], a = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], l = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], c = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      i.exports = function(h, u, p, m, g, _, y, b) {
        var w, v, C, k, Y, P, L, N, D, B = b.bits, V = 0, X = 0, Z = 0, W = 0, st = 0, j = 0, gt = 0, U = 0, ht = 0, z = 0, O = null, _t = 0, rt = new r.Buf16(16), ut = new r.Buf16(16), oe = null, Re = 0;
        for (V = 0; V <= 15; V++)
          rt[V] = 0;
        for (X = 0; X < m; X++)
          rt[u[p + X]]++;
        for (st = B, W = 15; 1 <= W && rt[W] === 0; W--)
          ;
        if (W < st && (st = W), W === 0)
          return g[_++] = 20971520, g[_++] = 20971520, b.bits = 1, 0;
        for (Z = 1; Z < W && rt[Z] === 0; Z++)
          ;
        for (st < Z && (st = Z), V = U = 1; V <= 15; V++)
          if (U <<= 1, (U -= rt[V]) < 0)
            return -1;
        if (0 < U && (h === 0 || W !== 1))
          return -1;
        for (ut[1] = 0, V = 1; V < 15; V++)
          ut[V + 1] = ut[V] + rt[V];
        for (X = 0; X < m; X++)
          u[p + X] !== 0 && (y[ut[u[p + X]]++] = X);
        if (P = h === 0 ? (O = oe = y, 19) : h === 1 ? (O = o, _t -= 257, oe = a, Re -= 257, 256) : (O = l, oe = c, -1), V = Z, Y = _, gt = X = z = 0, C = -1, k = (ht = 1 << (j = st)) - 1, h === 1 && 852 < ht || h === 2 && 592 < ht)
          return 1;
        for (; ; ) {
          for (L = V - gt, D = y[X] < P ? (N = 0, y[X]) : y[X] > P ? (N = oe[Re + y[X]], O[_t + y[X]]) : (N = 96, 0), w = 1 << V - gt, Z = v = 1 << j; g[Y + (z >> gt) + (v -= w)] = L << 24 | N << 16 | D | 0, v !== 0; )
            ;
          for (w = 1 << V - 1; z & w; )
            w >>= 1;
          if (w !== 0 ? (z &= w - 1, z += w) : z = 0, X++, --rt[V] == 0) {
            if (V === W)
              break;
            V = u[p + y[X]];
          }
          if (st < V && (z & k) !== C) {
            for (gt === 0 && (gt = st), Y += Z, U = 1 << (j = V - gt); j + gt < W && !((U -= rt[j + gt]) <= 0); )
              j++, U <<= 1;
            if (ht += 1 << j, h === 1 && 852 < ht || h === 2 && 592 < ht)
              return 1;
            g[C = z & k] = st << 24 | j << 16 | Y - _ | 0;
          }
        }
        return z !== 0 && (g[Y + z] = V - gt << 24 | 64 << 16 | 0), b.bits = st, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(e, i, s) {
      i.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(e, i, s) {
      var r = e("../utils/common"), o = 0, a = 1;
      function l(G) {
        for (var K = G.length; 0 <= --K; )
          G[K] = 0;
      }
      var c = 0, h = 29, u = 256, p = u + 1 + h, m = 30, g = 19, _ = 2 * p + 1, y = 15, b = 16, w = 7, v = 256, C = 16, k = 17, Y = 18, P = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], L = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], N = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], D = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], B = new Array(2 * (p + 2));
      l(B);
      var V = new Array(2 * m);
      l(V);
      var X = new Array(512);
      l(X);
      var Z = new Array(256);
      l(Z);
      var W = new Array(h);
      l(W);
      var st, j, gt, U = new Array(m);
      function ht(G, K, tt, nt, A) {
        this.static_tree = G, this.extra_bits = K, this.extra_base = tt, this.elems = nt, this.max_length = A, this.has_stree = G && G.length;
      }
      function z(G, K) {
        this.dyn_tree = G, this.max_code = 0, this.stat_desc = K;
      }
      function O(G) {
        return G < 256 ? X[G] : X[256 + (G >>> 7)];
      }
      function _t(G, K) {
        G.pending_buf[G.pending++] = 255 & K, G.pending_buf[G.pending++] = K >>> 8 & 255;
      }
      function rt(G, K, tt) {
        G.bi_valid > b - tt ? (G.bi_buf |= K << G.bi_valid & 65535, _t(G, G.bi_buf), G.bi_buf = K >> b - G.bi_valid, G.bi_valid += tt - b) : (G.bi_buf |= K << G.bi_valid & 65535, G.bi_valid += tt);
      }
      function ut(G, K, tt) {
        rt(G, tt[2 * K], tt[2 * K + 1]);
      }
      function oe(G, K) {
        for (var tt = 0; tt |= 1 & G, G >>>= 1, tt <<= 1, 0 < --K; )
          ;
        return tt >>> 1;
      }
      function Re(G, K, tt) {
        var nt, A, lt = new Array(y + 1), dt = 0;
        for (nt = 1; nt <= y; nt++)
          lt[nt] = dt = dt + tt[nt - 1] << 1;
        for (A = 0; A <= K; A++) {
          var ct = G[2 * A + 1];
          ct !== 0 && (G[2 * A] = oe(lt[ct]++, ct));
        }
      }
      function Wt(G) {
        var K;
        for (K = 0; K < p; K++)
          G.dyn_ltree[2 * K] = 0;
        for (K = 0; K < m; K++)
          G.dyn_dtree[2 * K] = 0;
        for (K = 0; K < g; K++)
          G.bl_tree[2 * K] = 0;
        G.dyn_ltree[2 * v] = 1, G.opt_len = G.static_len = 0, G.last_lit = G.matches = 0;
      }
      function Dt(G) {
        8 < G.bi_valid ? _t(G, G.bi_buf) : 0 < G.bi_valid && (G.pending_buf[G.pending++] = G.bi_buf), G.bi_buf = 0, G.bi_valid = 0;
      }
      function ee(G, K, tt, nt) {
        var A = 2 * K, lt = 2 * tt;
        return G[A] < G[lt] || G[A] === G[lt] && nt[K] <= nt[tt];
      }
      function ie(G, K, tt) {
        for (var nt = G.heap[tt], A = tt << 1; A <= G.heap_len && (A < G.heap_len && ee(K, G.heap[A + 1], G.heap[A], G.depth) && A++, !ee(K, nt, G.heap[A], G.depth)); )
          G.heap[tt] = G.heap[A], tt = A, A <<= 1;
        G.heap[tt] = nt;
      }
      function Ye(G, K, tt) {
        var nt, A, lt, dt, ct = 0;
        if (G.last_lit !== 0)
          for (; nt = G.pending_buf[G.d_buf + 2 * ct] << 8 | G.pending_buf[G.d_buf + 2 * ct + 1], A = G.pending_buf[G.l_buf + ct], ct++, nt === 0 ? ut(G, A, K) : (ut(G, (lt = Z[A]) + u + 1, K), (dt = P[lt]) !== 0 && rt(G, A -= W[lt], dt), ut(G, lt = O(--nt), tt), (dt = L[lt]) !== 0 && rt(G, nt -= U[lt], dt)), ct < G.last_lit; )
            ;
        ut(G, v, K);
      }
      function bi(G, K) {
        var tt, nt, A, lt = K.dyn_tree, dt = K.stat_desc.static_tree, ct = K.stat_desc.has_stree, It = K.stat_desc.elems, jt = -1;
        for (G.heap_len = 0, G.heap_max = _, tt = 0; tt < It; tt++)
          lt[2 * tt] !== 0 ? (G.heap[++G.heap_len] = jt = tt, G.depth[tt] = 0) : lt[2 * tt + 1] = 0;
        for (; G.heap_len < 2; )
          lt[2 * (A = G.heap[++G.heap_len] = jt < 2 ? ++jt : 0)] = 1, G.depth[A] = 0, G.opt_len--, ct && (G.static_len -= dt[2 * A + 1]);
        for (K.max_code = jt, tt = G.heap_len >> 1; 1 <= tt; tt--)
          ie(G, lt, tt);
        for (A = It; tt = G.heap[1], G.heap[1] = G.heap[G.heap_len--], ie(G, lt, 1), nt = G.heap[1], G.heap[--G.heap_max] = tt, G.heap[--G.heap_max] = nt, lt[2 * A] = lt[2 * tt] + lt[2 * nt], G.depth[A] = (G.depth[tt] >= G.depth[nt] ? G.depth[tt] : G.depth[nt]) + 1, lt[2 * tt + 1] = lt[2 * nt + 1] = A, G.heap[1] = A++, ie(G, lt, 1), 2 <= G.heap_len; )
          ;
        G.heap[--G.heap_max] = G.heap[1], function(Ft, si) {
          var cn, Ii, hn, pe, En, Nn, Vi = si.dyn_tree, He = si.max_code, Yi = si.stat_desc.static_tree, qi = si.stat_desc.has_stree, wn = si.stat_desc.extra_bits, Zi = si.stat_desc.extra_base, Ge = si.stat_desc.max_length, Ds = 0;
          for (pe = 0; pe <= y; pe++)
            Ft.bl_count[pe] = 0;
          for (Vi[2 * Ft.heap[Ft.heap_max] + 1] = 0, cn = Ft.heap_max + 1; cn < _; cn++)
            Ge < (pe = Vi[2 * Vi[2 * (Ii = Ft.heap[cn]) + 1] + 1] + 1) && (pe = Ge, Ds++), Vi[2 * Ii + 1] = pe, He < Ii || (Ft.bl_count[pe]++, En = 0, Zi <= Ii && (En = wn[Ii - Zi]), Nn = Vi[2 * Ii], Ft.opt_len += Nn * (pe + En), qi && (Ft.static_len += Nn * (Yi[2 * Ii + 1] + En)));
          if (Ds !== 0) {
            do {
              for (pe = Ge - 1; Ft.bl_count[pe] === 0; )
                pe--;
              Ft.bl_count[pe]--, Ft.bl_count[pe + 1] += 2, Ft.bl_count[Ge]--, Ds -= 2;
            } while (0 < Ds);
            for (pe = Ge; pe !== 0; pe--)
              for (Ii = Ft.bl_count[pe]; Ii !== 0; )
                He < (hn = Ft.heap[--cn]) || (Vi[2 * hn + 1] !== pe && (Ft.opt_len += (pe - Vi[2 * hn + 1]) * Vi[2 * hn], Vi[2 * hn + 1] = pe), Ii--);
          }
        }(G, K), Re(lt, jt, G.bl_count);
      }
      function S(G, K, tt) {
        var nt, A, lt = -1, dt = K[1], ct = 0, It = 7, jt = 4;
        for (dt === 0 && (It = 138, jt = 3), K[2 * (tt + 1) + 1] = 65535, nt = 0; nt <= tt; nt++)
          A = dt, dt = K[2 * (nt + 1) + 1], ++ct < It && A === dt || (ct < jt ? G.bl_tree[2 * A] += ct : A !== 0 ? (A !== lt && G.bl_tree[2 * A]++, G.bl_tree[2 * C]++) : ct <= 10 ? G.bl_tree[2 * k]++ : G.bl_tree[2 * Y]++, lt = A, jt = (ct = 0) === dt ? (It = 138, 3) : A === dt ? (It = 6, 3) : (It = 7, 4));
      }
      function $(G, K, tt) {
        var nt, A, lt = -1, dt = K[1], ct = 0, It = 7, jt = 4;
        for (dt === 0 && (It = 138, jt = 3), nt = 0; nt <= tt; nt++)
          if (A = dt, dt = K[2 * (nt + 1) + 1], !(++ct < It && A === dt)) {
            if (ct < jt)
              for (; ut(G, A, G.bl_tree), --ct != 0; )
                ;
            else
              A !== 0 ? (A !== lt && (ut(G, A, G.bl_tree), ct--), ut(G, C, G.bl_tree), rt(G, ct - 3, 2)) : ct <= 10 ? (ut(G, k, G.bl_tree), rt(G, ct - 3, 3)) : (ut(G, Y, G.bl_tree), rt(G, ct - 11, 7));
            lt = A, jt = (ct = 0) === dt ? (It = 138, 3) : A === dt ? (It = 6, 3) : (It = 7, 4);
          }
      }
      l(U);
      var H = !1;
      function T(G, K, tt, nt) {
        rt(G, (c << 1) + (nt ? 1 : 0), 3), function(A, lt, dt, ct) {
          Dt(A), ct && (_t(A, dt), _t(A, ~dt)), r.arraySet(A.pending_buf, A.window, lt, dt, A.pending), A.pending += dt;
        }(G, K, tt, !0);
      }
      s._tr_init = function(G) {
        H || (function() {
          var K, tt, nt, A, lt, dt = new Array(y + 1);
          for (A = nt = 0; A < h - 1; A++)
            for (W[A] = nt, K = 0; K < 1 << P[A]; K++)
              Z[nt++] = A;
          for (Z[nt - 1] = A, A = lt = 0; A < 16; A++)
            for (U[A] = lt, K = 0; K < 1 << L[A]; K++)
              X[lt++] = A;
          for (lt >>= 7; A < m; A++)
            for (U[A] = lt << 7, K = 0; K < 1 << L[A] - 7; K++)
              X[256 + lt++] = A;
          for (tt = 0; tt <= y; tt++)
            dt[tt] = 0;
          for (K = 0; K <= 143; )
            B[2 * K + 1] = 8, K++, dt[8]++;
          for (; K <= 255; )
            B[2 * K + 1] = 9, K++, dt[9]++;
          for (; K <= 279; )
            B[2 * K + 1] = 7, K++, dt[7]++;
          for (; K <= 287; )
            B[2 * K + 1] = 8, K++, dt[8]++;
          for (Re(B, p + 1, dt), K = 0; K < m; K++)
            V[2 * K + 1] = 5, V[2 * K] = oe(K, 5);
          st = new ht(B, P, u + 1, p, y), j = new ht(V, L, 0, m, y), gt = new ht(new Array(0), N, 0, g, w);
        }(), H = !0), G.l_desc = new z(G.dyn_ltree, st), G.d_desc = new z(G.dyn_dtree, j), G.bl_desc = new z(G.bl_tree, gt), G.bi_buf = 0, G.bi_valid = 0, Wt(G);
      }, s._tr_stored_block = T, s._tr_flush_block = function(G, K, tt, nt) {
        var A, lt, dt = 0;
        0 < G.level ? (G.strm.data_type === 2 && (G.strm.data_type = function(ct) {
          var It, jt = 4093624447;
          for (It = 0; It <= 31; It++, jt >>>= 1)
            if (1 & jt && ct.dyn_ltree[2 * It] !== 0)
              return o;
          if (ct.dyn_ltree[18] !== 0 || ct.dyn_ltree[20] !== 0 || ct.dyn_ltree[26] !== 0)
            return a;
          for (It = 32; It < u; It++)
            if (ct.dyn_ltree[2 * It] !== 0)
              return a;
          return o;
        }(G)), bi(G, G.l_desc), bi(G, G.d_desc), dt = function(ct) {
          var It;
          for (S(ct, ct.dyn_ltree, ct.l_desc.max_code), S(ct, ct.dyn_dtree, ct.d_desc.max_code), bi(ct, ct.bl_desc), It = g - 1; 3 <= It && ct.bl_tree[2 * D[It] + 1] === 0; It--)
            ;
          return ct.opt_len += 3 * (It + 1) + 5 + 5 + 4, It;
        }(G), A = G.opt_len + 3 + 7 >>> 3, (lt = G.static_len + 3 + 7 >>> 3) <= A && (A = lt)) : A = lt = tt + 5, tt + 4 <= A && K !== -1 ? T(G, K, tt, nt) : G.strategy === 4 || lt === A ? (rt(G, 2 + (nt ? 1 : 0), 3), Ye(G, B, V)) : (rt(G, 4 + (nt ? 1 : 0), 3), function(ct, It, jt, Ft) {
          var si;
          for (rt(ct, It - 257, 5), rt(ct, jt - 1, 5), rt(ct, Ft - 4, 4), si = 0; si < Ft; si++)
            rt(ct, ct.bl_tree[2 * D[si] + 1], 3);
          $(ct, ct.dyn_ltree, It - 1), $(ct, ct.dyn_dtree, jt - 1);
        }(G, G.l_desc.max_code + 1, G.d_desc.max_code + 1, dt + 1), Ye(G, G.dyn_ltree, G.dyn_dtree)), Wt(G), nt && Dt(G);
      }, s._tr_tally = function(G, K, tt) {
        return G.pending_buf[G.d_buf + 2 * G.last_lit] = K >>> 8 & 255, G.pending_buf[G.d_buf + 2 * G.last_lit + 1] = 255 & K, G.pending_buf[G.l_buf + G.last_lit] = 255 & tt, G.last_lit++, K === 0 ? G.dyn_ltree[2 * tt]++ : (G.matches++, K--, G.dyn_ltree[2 * (Z[tt] + u + 1)]++, G.dyn_dtree[2 * O(K)]++), G.last_lit === G.lit_bufsize - 1;
      }, s._tr_align = function(G) {
        rt(G, 2, 3), ut(G, v, B), function(K) {
          K.bi_valid === 16 ? (_t(K, K.bi_buf), K.bi_buf = 0, K.bi_valid = 0) : 8 <= K.bi_valid && (K.pending_buf[K.pending++] = 255 & K.bi_buf, K.bi_buf >>= 8, K.bi_valid -= 8);
        }(G);
      };
    }, { "../utils/common": 41 }], 53: [function(e, i, s) {
      i.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(e, i, s) {
      (function(r) {
        (function(o, a) {
          if (!o.setImmediate) {
            var l, c, h, u, p = 1, m = {}, g = !1, _ = o.document, y = Object.getPrototypeOf && Object.getPrototypeOf(o);
            y = y && y.setTimeout ? y : o, l = {}.toString.call(o.process) === "[object process]" ? function(C) {
              process.nextTick(function() {
                w(C);
              });
            } : function() {
              if (o.postMessage && !o.importScripts) {
                var C = !0, k = o.onmessage;
                return o.onmessage = function() {
                  C = !1;
                }, o.postMessage("", "*"), o.onmessage = k, C;
              }
            }() ? (u = "setImmediate$" + Math.random() + "$", o.addEventListener ? o.addEventListener("message", v, !1) : o.attachEvent("onmessage", v), function(C) {
              o.postMessage(u + C, "*");
            }) : o.MessageChannel ? ((h = new MessageChannel()).port1.onmessage = function(C) {
              w(C.data);
            }, function(C) {
              h.port2.postMessage(C);
            }) : _ && "onreadystatechange" in _.createElement("script") ? (c = _.documentElement, function(C) {
              var k = _.createElement("script");
              k.onreadystatechange = function() {
                w(C), k.onreadystatechange = null, c.removeChild(k), k = null;
              }, c.appendChild(k);
            }) : function(C) {
              setTimeout(w, 0, C);
            }, y.setImmediate = function(C) {
              typeof C != "function" && (C = new Function("" + C));
              for (var k = new Array(arguments.length - 1), Y = 0; Y < k.length; Y++)
                k[Y] = arguments[Y + 1];
              var P = { callback: C, args: k };
              return m[p] = P, l(p), p++;
            }, y.clearImmediate = b;
          }
          function b(C) {
            delete m[C];
          }
          function w(C) {
            if (g)
              setTimeout(w, 0, C);
            else {
              var k = m[C];
              if (k) {
                g = !0;
                try {
                  (function(Y) {
                    var P = Y.callback, L = Y.args;
                    switch (L.length) {
                      case 0:
                        P();
                        break;
                      case 1:
                        P(L[0]);
                        break;
                      case 2:
                        P(L[0], L[1]);
                        break;
                      case 3:
                        P(L[0], L[1], L[2]);
                        break;
                      default:
                        P.apply(a, L);
                    }
                  })(k);
                } finally {
                  b(C), g = !1;
                }
              }
            }
          }
          function v(C) {
            C.source === o && typeof C.data == "string" && C.data.indexOf(u) === 0 && w(+C.data.slice(u.length));
          }
        })(typeof self > "u" ? r === void 0 ? this : r : self);
      }).call(this, typeof $s < "u" ? $s : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(rm);
var Xl = rm.exports;
const V_ = /* @__PURE__ */ Il(Xl);
class Oa {
  constructor(t, e) {
    this._version = pn.Unknown, this._topicsMap = /* @__PURE__ */ new Map(), this._bcfFileName = t, this._id = e;
  }
  /**
   * Exports BCF data to a file. Prompts the user to save it on their device.
   * @param filename Filename BCF data will be exported as
   */
  async exportBCF(t) {
    await this.toBcfZipBlob().then((e) => {
      const i = document.createElement("a"), s = URL.createObjectURL(e);
      i.href = s, i.download = `${t}.bcf`, document.body.appendChild(i), i.click(), setTimeout(() => {
        document.body.removeChild(i), URL.revokeObjectURL(s);
      }, 0);
    });
  }
  /**
   * Creates a BCFZIP blob. The resulting blob is importable using `BcfManager.addBCFFromBuffer`.
   */
  toBcfZipBlob() {
    const t = new XMLSerializer(), e = '<?xml version="1.0" encoding="UTF-8"?><Version VersionId="2.1" xsi:noNamespaceSchemaLocation="version.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><DetailedVersion>2.1</DetailedVersion></Version>', i = Xl.file("bcf.version", e);
    return this._topicsMap.forEach((s, r) => {
      const o = i.folder(r);
      if (o === null) {
        console.error("Failed to create folder for BCF topic");
        return;
      }
      const a = t.serializeToString(s.getMarkup().export());
      o.file("markup.bcf", a), s.getViewpointMap().forEach((h, u) => {
        const p = t.serializeToString(h.export());
        o.file(u, p);
      }), s.getSnapshotMap().forEach((h, u) => {
        o.file(u, h.getData());
      });
    }), i.generateAsync({ type: "blob" });
  }
  /**
   * Adds a BCF topic.
   * @param topicId
   * @param topic
   */
  addTopic(t, e) {
    this._topicsMap.set(t, e);
  }
  /**
   * @returns A map associating BCF topic ids to BCF topic data.
   */
  getTopics() {
    return this._topicsMap;
  }
  /**
   * Gets a BCF topic.
   * @param topicId
   */
  getTopic(t) {
    return this._topicsMap.get(t) || null;
  }
  /**
   * Gets the BCF version.
   */
  getVersion() {
    return this._version;
  }
  /**
   * Sets the BCF version.
   * @param version
   */
  setVersion(t) {
    this._version = t;
  }
  /**
   * Gets the BCF filename.
   */
  getFilename() {
    return this._bcfFileName;
  }
  /**
   * Identifier used to keep track of loaded BCF data.
   */
  getId() {
    return this._id;
  }
}
function Qi() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(n) {
    const t = new Uint32Array(1);
    yg().getRandomValues(t);
    const e = t[0] / 4294967295 * 16 | 0;
    return (n === "x" ? e : e & 3 | 8).toString(16);
  });
}
class om {
  constructor(t, e, i, s, r, o) {
    this._ifcProject = t, this._ifcSpatialStructureElement = e, this._isExternal = i, this._filename = s, this._date = r, this._reference = o;
  }
  /**
   * [[GenericId]] Reference to the project to which this topic is related in the IFC file
   */
  getIfcProject() {
    return this._ifcProject || null;
  }
  /**
   * [[GenericId]] Reference to the spatial structure element, e.g. IfcBuildingStorey, to which this topic is related.
   */
  getIfcSpacialStructureElement() {
    return this._ifcSpatialStructureElement || null;
  }
  /**
   * Is the IFC file external or within the bcfzip
   */
  getIsExternal() {
    return this._isExternal || null;
  }
  /**
   * The BIM file related to this topic.
   */
  getBimFilename() {
    return this._filename || null;
  }
  /**
   * Date of the BIM file.
   */
  getBimDate() {
    return this._date || null;
  }
  /**
   * URI to IfcFile.
   * IsExternal=false "..\example.ifc" (within bcfzip)
   * IsExternal=true "https://.../example.ifc"
   */
  getReference() {
    return this._reference || null;
  }
}
class am {
  constructor(t, e, i, s) {
    this._viewpointFilename = void 0, this._snapshotFilename = void 0, this._index = void 0, this._guid = t, this._viewpointFilename = e, this._snapshotFilename = i, s !== void 0 && (this._index = parseInt(s, 10));
  }
  getGuid() {
    return this._guid;
  }
  getViewpointFilename() {
    return this._viewpointFilename || null;
  }
  getSnapshotFilename() {
    return this._snapshotFilename || null;
  }
  getIndex() {
    return this._index || null;
  }
}
class Gc {
  constructor(t, e, i, s, r, o, a) {
    this._guid = t, this._date = e, this._author = i, this._text = s, this._viewpointGuid = r, this._modifiedDate = o, this._modifiedAuthor = a;
  }
  getId() {
    return this._guid;
  }
  getDate() {
    return this._date;
  }
  setDate(t) {
    this._date = t;
  }
  getAuthor() {
    return this._author;
  }
  setAuthor(t) {
    this._author = t;
  }
  getText() {
    return this._text;
  }
  setText(t) {
    this._text = t;
  }
  getViewpointGuid() {
    return this._viewpointGuid || null;
  }
  setViewpointGuid(t) {
    this._viewpointGuid = t !== null ? t : void 0;
  }
  getModifiedDate() {
    return this._modifiedDate || null;
  }
  setModifiedDate(t) {
    this._modifiedDate = t !== null ? t : void 0;
  }
  getModifiedAuthor() {
    return this._modifiedAuthor || null;
  }
  setModifiedAuthor(t) {
    this._modifiedAuthor = t !== null ? t : void 0;
  }
}
class lm {
  constructor(t, e, i) {
    this._markupHeaderFiles = [], this._topic = {
      guid: "",
      title: "",
      creationDate: /* @__PURE__ */ new Date(),
      creationAuthor: ""
    }, this._comments = /* @__PURE__ */ new Map(), this._viewpoints = /* @__PURE__ */ new Map(), this._filename = t, this._bcfTopic = i, this._parseDocument(e);
  }
  _parseDocument(t) {
    if (t === null)
      return;
    let i = t.documentElement.firstElementChild;
    for (; i !== null; ) {
      const s = i.localName;
      if (s === null)
        break;
      switch (s) {
        case "Header":
          this._parseHeader(i);
          break;
        case "Topic":
          this._parseTopic(i);
          break;
        case "Comment":
          this._parseComment(i);
          break;
        case "Viewpoints":
          this._parseViewpoint(i);
          break;
      }
      i = i.nextElementSibling;
    }
  }
  _exportHeader(t) {
    const e = t.createElement("Header");
    return Fn(e, "ProjectGuid", this._projectGuid), this._markupHeaderFiles.forEach((i) => {
      const s = t.createElement("File");
      Fn(s, "IfcProject", i.getIfcProject()), Fn(
        s,
        "IfcSpatialStructureElement",
        i.getIfcSpacialStructureElement()
      ), Fn(
        s,
        "isExternal",
        Ka(i.getIsExternal())
      ), ze(t, s, "Filename", i.getBimFilename()), ze(t, s, "Date", fo(i.getBimDate())), ze(t, s, "Reference", i.getReference()), e.appendChild(s);
    }), e;
  }
  _exportTopicData(t) {
    const e = t.createElement("Topic");
    if (e.setAttribute("Guid", this._topic.guid), Fn(e, "TopicType", this._topic.topicType), Fn(e, "TopicStatus", this._topic.topicStatus), On(t, e, "Title", this._topic.title), On(t, e, "CreationDate", this._topic.creationDate.toISOString()), On(t, e, "CreationAuthor", this._topic.creationAuthor), ze(t, e, "ReferenceLink", this._topic.referenceLink), ze(t, e, "Priority", this._topic.priority), ze(t, e, "Index", Yc(this._topic.index)), ze(
      t,
      e,
      "ModifiedDate",
      fo(this._topic.modifiedDate)
    ), ze(t, e, "ModifiedAuthor", this._topic.modifiedAuthor), ze(t, e, "DueDate", fo(this._topic.dueDate)), ze(t, e, "AssignedTo", this._topic.assignedTo), ze(t, e, "Description", this._topic.description), ze(t, e, "Stage", this._topic.stage), this._topic.labels) {
      const i = t.createElement("Labels");
      this._topic.labels.forEach((s) => {
        On(t, i, "Label", s);
      }), e.appendChild(i);
    }
    return e;
  }
  _exportBimSnippet(t, e) {
    const i = t.createElement("BimSnippet");
    return i.setAttribute("SnippetType", e.snippetType), Fn(
      i,
      "isExternal",
      Ka(e.isExternal)
    ), On(t, i, "Reference", e.reference), ze(t, i, "ReferenceSchema", e.referenceSchema), i;
  }
  _exportDocumentReference(t, e) {
    const i = t.createElement("DocumentReference");
    return Fn(i, "Guid", e.guid), Fn(
      i,
      "isExternal",
      Ka(e.isExternal)
    ), ze(
      t,
      i,
      "ReferencedDocument",
      e.referencedDocument
    ), ze(t, i, "Description", e.description), i;
  }
  _exportRelatedTopic(t, e) {
    const i = t.createElement("RelatedTopic");
    return i.setAttribute("Guid", e.guid), i;
  }
  _exportTopic(t) {
    const e = this._exportTopicData(t);
    return this._topic.bimSnippets && this._topic.bimSnippets.forEach((i) => {
      e.appendChild(this._exportBimSnippet(t, i));
    }), this._topic.documentReferences && this._topic.documentReferences.forEach((i) => {
      e.appendChild(this._exportDocumentReference(t, i));
    }), this._topic.relatedTopics && this._topic.relatedTopics.forEach((i) => {
      e.appendChild(this._exportRelatedTopic(t, i));
    }), e;
  }
  _exportComment(t, e) {
    const i = t.createElement("Comment");
    i.setAttribute("Guid", e.getId()), On(t, i, "Date", e.getDate().toISOString()), On(t, i, "Author", e.getAuthor()), On(t, i, "Comment", e.getText()), ze(
      t,
      i,
      "ModifiedDate",
      fo(e.getModifiedDate())
    ), ze(t, i, "ModifiedAuthor", e.getModifiedAuthor());
    const s = e.getViewpointGuid();
    if (s) {
      const r = t.createElement("Viewpoint");
      r.setAttribute("Guid", s), i.appendChild(r);
    }
    return i;
  }
  _exportViewpoint(t, e) {
    const i = t.createElement("Viewpoints");
    return i.setAttribute("Guid", e.getGuid()), ze(t, i, "Viewpoint", e.getViewpointFilename()), ze(t, i, "Snapshot", e.getSnapshotFilename()), ze(
      t,
      i,
      "Index",
      Yc(e.getIndex())
    ), i;
  }
  /**
   * @returns XML document containing the markup data.
   */
  export() {
    const t = document.implementation.createDocument("", "", null), e = t.createElement("Markup");
    return e.appendChild(this._exportHeader(t)), e.appendChild(this._exportTopic(t)), this._comments.forEach((i) => {
      e.appendChild(this._exportComment(t, i));
    }), this._viewpoints.forEach((i) => {
      e.appendChild(this._exportViewpoint(t, i));
    }), t.appendChild(e), t;
  }
  /**
   * @returns the project GUID.
   */
  getProjectGuid() {
    return this._projectGuid || null;
  }
  /**
   * @returns a list of [[BCFMarkupHeaderFile]] containing data related to IFC files.
   */
  getMarkupHeaderFiles() {
    return this._markupHeaderFiles;
  }
  /**
   * Gets the Markup filename.
   */
  getFilename() {
    return this._filename;
  }
  /**
   * Gets the topic id.
   */
  getTopicId() {
    return this._topic.guid;
  }
  /**
   * Sets the topic id.
   * @param guid
   */
  setTopicId(t) {
    this._topic.guid = t;
  }
  /**
   * Gets the topic type.
   */
  getTopicType() {
    return this._topic.topicType || null;
  }
  /**
   * Sets the topic type.
   * @param topicType
   */
  setTopicType(t) {
    this._topic.topicType = t !== null ? t : void 0;
  }
  /**
   * Gets the topic status.
   */
  getTopicStatus() {
    return this._topic.topicStatus || null;
  }
  /**
   * Sets the topic status.
   * @param topicStatus
   */
  setTopicStatus(t) {
    this._topic.topicStatus = t !== null ? t : void 0;
  }
  /**
   * Gets the title of the markup topic.
   */
  getTopicTitle() {
    return this._topic.title;
  }
  /**
   * Sets the title of the markup topic.
   * @param title
   */
  setTopicTitle(t) {
    this._topic.title = t;
  }
  /**
   * Gets the creation date of the markup topic.
   */
  getTopicCreationDate() {
    return this._topic.creationDate;
  }
  /**
   * Sets the creation date of the markup topic;
   * @param date
   */
  setTopicCreationDate(t) {
    this._topic.creationDate = t;
  }
  /**
   * Gets the name of the user that created the markup topic.
   */
  getTopicCreationAuthor() {
    return this._topic.creationAuthor;
  }
  /**
   * Sets the name of the user that created the markup topic.
   * @param author
   */
  setTopicCreationAuthor(t) {
    this._topic.creationAuthor = t;
  }
  /**
   * List of references to the topic, for example, a work request management system or an URI to a model.
   */
  getTopicReferenceLink() {
    return this._topic.referenceLink || null;
  }
  /**
   * Sets the ReferenceLink.
   * @param referenceLink
   */
  setTopicReferenceLink(t) {
    this._topic.referenceLink = t === null ? void 0 : t;
  }
  /**
   * Gets the topic priority.
   */
  getTopicPriority() {
    return this._topic.priority || null;
  }
  /**
   * Sets the topic priority.
   * @param priority
   */
  setTopicPriority(t) {
    this._topic.priority = t === null ? void 0 : t;
  }
  /**
   * Number to maintain the order of the topics.
   */
  getTopicIndex() {
    return this._topic.index || null;
  }
  /**
   * Sets the topic index.
   * @param index
   */
  setTopicIndex(t) {
    this._topic.index = t === null ? void 0 : t;
  }
  /**
   * Tags for grouping Topics.
   */
  getTopicLabels() {
    return this._topic.labels === void 0 ? [] : this._topic.labels.slice();
  }
  /**
   * Sets the topic labels.
   * @param labels
   */
  setTopicLabels(t) {
    this._topic.labels = t.slice();
  }
  /**
   * Date when the topic was last modified. Exists only when Topic has been modified after creation.
   */
  getTopicModifiedDate() {
    return this._topic.modifiedDate || null;
  }
  /**
   * Sets the topic modified date.
   * @param date
   */
  setTopicModifiedDate(t) {
    this._topic.modifiedDate = t === null ? void 0 : t;
  }
  /**
   * User who modified the topic. Exists only when Topic has been modified after creation.
   */
  getTopicModifiedAuthor() {
    return this._topic.modifiedAuthor || null;
  }
  /**
   * Sets the author that last modified the topic.
   * @param modifiedAuthor
   */
  setTopicModifiedAuthor(t) {
    this._topic.modifiedAuthor = t === null ? void 0 : t;
  }
  /**
   * Date when the issue needs to be resolved by.
   */
  getTopicDueDate() {
    return this._topic.dueDate || null;
  }
  /**
   * Sets the topic due date.
   * @param date
   */
  setTopicDueDate(t) {
    this._topic.dueDate = t === null ? void 0 : t;
  }
  /**
   * The user to whom this topic is assigned to. Recommended to be in email format. The list of possible values are defined in the extension schema.
   */
  getTopicAssignedTo() {
    return this._topic.assignedTo || null;
  }
  /**
   * Sets the user that the topic is assigned to.
   */
  setTopicAssignedTo(t) {
    this._topic.assignedTo = t === null ? void 0 : t;
  }
  /**
   * Description of the topic.
   */
  getTopicDescription() {
    return this._topic.description || null;
  }
  /**
   * Sets the topic description;
   * @param description
   */
  setTopicDescription(t) {
    this._topic.description = t === null ? void 0 : t;
  }
  /**
   * Stage this topic is part of.
   */
  getTopicStage() {
    return this._topic.stage || null;
  }
  /**
   * Sets the topic stage;
   * @param stage
   */
  setTopicState(t) {
    this._topic.stage = t === null ? void 0 : t;
  }
  /**
   * Gets a map of GUIDs and corresponding comments.
   */
  getComments() {
    return this._comments;
  }
  /**
   * Adds a comment to the topic.
   * @param date
   * @param author
   * @param text
   * @param viewpointGuid
   * @param modifiedDate
   * @param modifiedAuthor
   */
  addComment(t, e, i, s, r, o) {
    const a = Qi(), l = new Gc(
      a,
      t,
      e,
      i,
      s,
      r,
      o
    );
    return this._comments.set(a, l), l;
  }
  /**
   * Updates a topic comment.
   * @param comment
   */
  updateComment(t) {
    const e = t.getId();
    this._comments.set(e, t);
  }
  /**
   * Deletes a comment from the topic..
   * @param guid
   */
  deleteComment(t) {
    this._comments.delete(t);
  }
  /**
   * Gets a map of GUIDs and corresponding viewpoints.
   */
  getViewpoints() {
    return this._viewpoints;
  }
  _addFile(t) {
    const e = this._getElementAttributes(t), i = this._getChildData(t), s = i.get("Date"), r = {
      date: s === void 0 ? void 0 : new Date(s),
      filename: i.get("Filename"),
      reference: i.get("Reference"),
      ifcProject: e.get("IfcProject"),
      ifcSpatialStructureElement: e.get("IfcSpatialStructureElement"),
      isExternal: e.get("isExternal") === "true"
    };
    this._markupHeaderFiles.push(
      new om(
        r.ifcProject,
        r.ifcSpatialStructureElement,
        r.isExternal,
        r.filename,
        r.date,
        r.reference
      )
    );
  }
  _parseHeader(t) {
    const i = this._getElementAttributes(t).get("ProjectGuid");
    i !== void 0 && (this._projectGuid = i);
    let s = t.firstElementChild;
    s !== null && (this._addFile(s), s = s.nextElementSibling);
  }
  _parseTopic(t) {
    const e = this._getElementAttributes(t), i = e.get("Guid");
    if (i === void 0)
      return;
    this._topic.guid = i, this._topic.topicType = e.get("TopicType") || e.get("Status"), this._topic.topicStatus = e.get("TopicStatus") || e.get("VerbalStatus");
    let s = t.firstElementChild;
    if (s !== null)
      for (; s !== null; ) {
        const r = s.localName;
        if (r === null)
          break;
        const o = this._getChildData(s), a = this._getElementAttributes(s);
        switch (r) {
          case "BimSnippet":
            {
              this._topic.bimSnippets === void 0 && (this._topic.bimSnippets = []);
              const l = o.get("Reference"), c = a.get("SnippetType");
              if (l !== void 0 && c !== void 0) {
                const h = {
                  snippetType: c,
                  reference: l
                };
                a.get("isExternal") && (h.isExternal = a.get("isExternal") === "true"), o.get("ReferenceSchema") && (h.referenceSchema = o.get("ReferenceSchema")), this._topic.bimSnippets.push(h);
              }
            }
            break;
          case "DocumentReference":
            {
              this._topic.documentReferences === void 0 && (this._topic.documentReferences = []);
              const l = {};
              o.get("Guid") && (l.guid = o.get("Guid")), o.get("isExternal") && (l.isExternal = o.get("isExternal") === "true"), o.get("Description") && (l.description = o.get("Description")), o.get("ReferencedDocument") && (l.referencedDocument = o.get("ReferencedDocument")), this._topic.documentReferences.push(l);
            }
            break;
          case "RelatedTopic":
            {
              this._topic.relatedTopics === void 0 && (this._topic.relatedTopics = []);
              const l = o.get("Guid");
              if (l !== void 0) {
                const c = {
                  guid: l
                };
                this._topic.relatedTopics.push(c);
              }
            }
            break;
          case "ReferenceLink":
            s.textContent && (this._topic.referenceLink = s.textContent);
            break;
          case "Title":
            s.textContent && (this._topic.title = s.textContent);
            break;
          case "Priority":
            s.textContent && (this._topic.priority = s.textContent);
            break;
          case "Index":
            s.textContent && (this._topic.index = parseInt(s.textContent, 10));
            break;
          case "Labels":
            {
              let l = s.firstChild;
              if (!l)
                break;
              for (this._topic.labels === void 0 && (this._topic.labels = []); l; )
                l.textContent && this._topic.labels.push(l.textContent), l = l.nextSibling;
            }
            break;
          case "CreationDate":
            s.textContent && (this._topic.creationDate = new Date(s.textContent));
            break;
          case "CreationAuthor":
            s.textContent && (this._topic.creationAuthor = s.textContent);
            break;
          case "ModifiedDate":
            s.textContent && (this._topic.modifiedDate = new Date(s.textContent));
            break;
          case "ModifiedAuthor":
            s.textContent && (this._topic.modifiedAuthor = s.textContent);
            break;
          case "DueDate":
            s.textContent && (this._topic.dueDate = new Date(s.textContent));
            break;
          case "AssignedTo":
            s.textContent && (this._topic.assignedTo = s.textContent);
            break;
          case "Description":
            s.textContent && (this._topic.description = s.textContent);
            break;
          case "Stage":
            s.textContent && (this._topic.stage = s.textContent);
            break;
        }
        s = s.nextElementSibling;
      }
  }
  _parseComment(t) {
    let e = "", i = /* @__PURE__ */ new Date(), s = "", r = "", o, a, l;
    const h = this._getElementAttributes(t).get("Guid");
    if (h)
      e = h;
    else
      return;
    let u = t.firstElementChild;
    if (u !== null)
      for (; u !== null; ) {
        const m = u.localName;
        if (m === null)
          break;
        switch (m) {
          case "Date":
            u.textContent && (i = new Date(u.textContent));
            break;
          case "Author":
            u.textContent && (s = u.textContent);
            break;
          case "Comment":
            u.textContent && (r = u.textContent);
            break;
          case "Viewpoint":
            o = this._getElementAttributes(u).get("Guid");
            break;
          case "ModifiedDate":
            u.textContent && (a = new Date(u.textContent));
            break;
          case "ModifiedAuthor":
            u.textContent && (l = u.textContent);
            break;
        }
        u = u.nextElementSibling;
      }
    const p = new Gc(
      e,
      i,
      s,
      r,
      o,
      a,
      l
    );
    this._comments.set(e, p);
  }
  _parseViewpoint(t) {
    const i = this._getElementAttributes(t).get("Guid");
    if (i !== void 0) {
      const s = this._getChildData(t), r = s.get("Viewpoint"), o = s.get("Snapshot"), a = s.get("Index");
      this.addViewpoint(i, r, o, a);
    }
  }
  addViewpoint(t, e, i, s) {
    this._viewpoints.set(
      t,
      new am(t, e, i, s)
    );
  }
  _getChildData(t) {
    const e = /* @__PURE__ */ new Map();
    let i = t.firstElementChild;
    for (; i !== null; ) {
      const s = i.localName;
      let r = null;
      i.firstElementChild === null && (r = i.textContent), s !== null && r !== null && e.set(s, r), i = i.nextElementSibling;
    }
    return e;
  }
  _getElementAttributes(t) {
    const e = t.attributes, i = /* @__PURE__ */ new Map();
    for (let s = 0; s < e.length; ++s) {
      const r = e[s], o = r.name, a = r.value;
      i.set(o, a);
    }
    return i;
  }
}
class or {
  constructor(t, e) {
    this._filename = t, this._data = e;
  }
  /**
   * Creates a BCF Snapshot from an HTMLImageElement.
   * @param filename
   * @param image
   */
  static createFromImage(t, e) {
    const i = or.snapshotDataFromImage(e);
    return new or(t, i);
  }
  /**
   * Gets the filename.
   */
  getFilename() {
    return this._filename;
  }
  /**
   * Gets png data.
   */
  getData() {
    return this._data;
  }
  /**
   * Gets a url for images corresponding to viewpoints.
   */
  getUrl() {
    const t = new Blob([this._data], { type: "image/png" });
    return URL.createObjectURL(t, { oneTimeOnly: !0 });
  }
  /**
   * Gets image data as a Uint8Array from an HTMLImageElement.
   * @param img
   */
  static snapshotDataFromImage(t) {
    const e = t.src;
    return or._convertDataURIToBinary(e);
  }
  static _convertDataURIToBinary(t) {
    const e = ";base64,", i = t.indexOf(e) + e.length, s = window.atob(t.substring(i)), r = new Uint8Array(s.length);
    for (let o = 0; o < s.length; o++) {
      const a = s[o].charCodeAt(0);
      r[o] = a;
    }
    return r;
  }
}
class _s {
  constructor() {
    this._behindView = !1;
  }
  /**
   * Called when the MarkupItem is removed from the system.
   * Any cleanup that needs to be done should be performed in this method.
   */
  remove() {
  }
  // XXX: This should probably have a `Promise<void>` return type. See `NoteText.prototype.remove` for an example.
  /**
   * Called when the markup item should be redrawn on the screen. This most typically happens when the scene is rendered.
   */
  draw() {
  }
  /**
   * Called when a hit test is performed on this markup item.
   * @param point position in window where the hit test is being performed.
   * @returns boolean value indicating whether this item was picked
   */
  hit(t) {
    return !1;
  }
  /**
   * Called when a hit test is performed on this markup item.
   * @param point position in window where the hit test is being performed.
   * @param pickTolerance amount of tolerance allowed for a hit in pixels.
   * @returns boolean value indicating whether this item was picked
   */
  hitWithTolerance(t, e) {
    return !1;
  }
  /**
   * Called when this markup item is selected by the system.
   */
  onSelect() {
  }
  /**
   * Called when this markup item is deselected by the system
   */
  onDeselect() {
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {};
  }
  /**
   * Gets the fully qualified class name for this markup item. E.g. "Communicator.Markup.Redline.RedlineCircle"
   * @returns fully qualified class name
   */
  getClassName() {
    return "Communicator.Markup.MarkupItem";
  }
}
class Qr extends _s {
  constructor(t) {
    super(), this._viewer = t;
  }
  onDragStart(t) {
    return !1;
  }
  onDragMove(t) {
    return !1;
  }
  onDragEnd(t) {
    return !1;
  }
  remove() {
    this._viewer.trigger("redlineDeleted", this), this._viewer.markupManager.refreshMarkup();
  }
}
class kh {
  constructor() {
    this._strokeWidth = 1, this._strokeColor = it.black();
  }
  /** @hidden */
  _assign(t) {
    this._strokeWidth = t._strokeWidth, this._strokeColor.assign(t._strokeColor);
  }
  /**
   * Sets the stroke color for this shape
   * @param color the stroke color
   */
  setStrokeColor(t) {
    this._strokeColor.assign(t);
  }
  /**
   * Gets the stroke color for this shape
   * @returns the stroke color
   */
  getStrokeColor() {
    return this._strokeColor.copy();
  }
  /**
   * Sets the stroke width for this shape in pixels
   * @param strokeWidth the stroke width in pixels
   */
  setStrokeWidth(t) {
    this._strokeWidth = t;
  }
  /**
   * Gets the stroke width for this shape in pixels
   * @returns the stroke width in pixels
   */
  getStrokeWidth() {
    return this._strokeWidth;
  }
}
class gr extends kh {
  constructor() {
    super(...arguments), this._fillColor = it.black(), this._fillOpacity = 1;
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._fillColor.assign(t._fillColor), this._fillOpacity = t._fillOpacity;
  }
  /**
   * Gets the fill opacity for this shape
   * @returns the fill opacity
   */
  getFillOpacity() {
    return this._fillOpacity;
  }
  /**
   * Sets the fill opacity for this shape
   * @param fillOpacity the fill opacity
   */
  setFillOpacity(t) {
    this._fillOpacity = t;
  }
  /**
   * Sets the fill color for this shape
   * @param color the fill color
   */
  setFillColor(t) {
    this._fillColor.assign(t);
  }
  /**
   * Gets the fill color for this shape
   * @returns the fill color
   */
  getFillColor() {
    return this._fillColor.copy();
  }
}
var ii = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Arrowhead = 1] = "Arrowhead", n[n.Circle = 2] = "Circle", n))(ii || {});
const gu = 9;
class da extends kh {
  constructor() {
    super(...arguments), this._startEndcapType = 0, this._startEndcapColor = it.black(), this._startEndcapSize = gu, this._endEndcapType = 0, this._endEndcapColor = it.black(), this._endEndcapSize = gu, this._endcapsInverted = !1;
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._startEndcapType = t._startEndcapType, this._startEndcapColor.assign(t._startEndcapColor), this._startEndcapSize = t._startEndcapSize, this._endEndcapType = t._endEndcapType, this._endEndcapColor.assign(t._endEndcapColor), this._endEndcapSize = t._endEndcapSize, this._endcapsInverted = t._endcapsInverted;
  }
  /**
   * Gets the start endcap type for this shape. The default Value is none.
   * @returns the start endcap type
   */
  getStartEndcapType() {
    return this._startEndcapType;
  }
  /**
   * Sets the start endcap type for this shape
   * @param endcapType the new endcap type
   */
  setStartEndcapType(t) {
    this._startEndcapType = t;
  }
  /**
   * Gets the color of the start endcap. Default value is black.
   * @returns color for the start endcap.
   */
  getStartEndcapColor() {
    return this._startEndcapColor.copy();
  }
  /**
   * Sets the color for the start endcap.
   * @param color the start endcap color value.
   */
  setStartEndcapColor(t) {
    this._startEndcapColor.assign(t);
  }
  /**
   * Gets the size of the start endcap in pixels. Default value is 9.
   * @returns size of the start endcap.
   */
  getStartEndcapSize() {
    return this._startEndcapSize;
  }
  /**
   * Sets the size of the start endcap in pixels.
   * @param size the start endcap.
   */
  setStartEndcapSize(t) {
    this._startEndcapSize = t;
  }
  /**
   * Gets the end endcap type for this shape. The default value is none.
   * @returns the end endcap type
   */
  getEndEndcapType() {
    return this._endEndcapType;
  }
  /**
   * Sets the end endcap type for this shape
   * @param endcapType the new endcap type
   */
  setEndEndcapType(t) {
    this._endEndcapType = t;
  }
  /**
   * Convenience for setting the start and eend endcap type for this shape
   * @param endcapType the new endcap type
   */
  setEndcapType(t) {
    this._startEndcapType = t, this._endEndcapType = t;
  }
  /**
   * Gets the size of the end endcap in pixels. Default value is 9.
   * @returns size of the end endcap.
   */
  getEndEndcapSize() {
    return this._endEndcapSize;
  }
  /**
   * Sets the size of the end endcap in pixels.
   * @param size the end endcap.
   */
  setEndEndcapSize(t) {
    this._endEndcapSize = t;
  }
  /**
   * Gets the color of the end endcap. Default value is black.
   * @returns color for the end endcap.
   */
  getEndEndcapColor() {
    return this._endEndcapColor.copy();
  }
  /**
   * Sets the color for the end endcap.
   * @param color the end endcap color value.
   */
  setEndEndcapColor(t) {
    this._endEndcapColor.assign(t);
  }
  /**
   * Gets whether endcaps are inverted for this shape. The default value is false.
   * @returns value indicating whether endcaps are inverted
   */
  getEndcapsInverted() {
    return this._endcapsInverted;
  }
  /**
   * Sets whether endcapsare inverted for this shape.
   * @param inverted value indicated whether endcaps should be inverted
   */
  setEndcapsInverted(t) {
    this._endcapsInverted = t;
  }
}
class qn extends gr {
  constructor() {
    super(...arguments), this._center = E.zero(), this._radius = 1;
  }
  /**
   * Sets the values for the circle
   * @param center the center point of the circle.
   * @radius the circle radius.
   */
  set(t, e) {
    this._center.assign(t), this.setRadius(e);
  }
  /**
   * Gets the center of the circle
   * @returns the circle center
   */
  getCenter() {
    return this._center.copy();
  }
  /**
   * Sets the center of the circle
   * @param the circle center
   */
  setCenter(t) {
    this._center.assign(t);
  }
  /**
   * Gets the radius of the circle
   * @returns the circle radius
   */
  getRadius() {
    return this._radius;
  }
  /**
   * Sets the radius of the circle
   * @param radius the circle radius
   */
  setRadius(t) {
    this._radius = t;
  }
}
class cm {
  constructor(t, e) {
    this.center = t.copy(), this.radius = e;
  }
}
class Mh extends gr {
  constructor() {
    super(...arguments), this._circles = [];
  }
  /**
   * Removes all circles from this collection
   */
  clear() {
    this._circles = [];
  }
  /**
   * Adds a circle to the collection
   * @param center circle center
   * @param radius the circle radius
   */
  addCircle(t, e) {
    this._circles.push(new cm(t, e));
  }
  /**
   * Updates a circle in the collection
   * @param index the index of the circle to update
   * @param center circle center
   * @param radius the circle radius
   */
  setCircle(t, e, i) {
    const s = this._circles[t];
    s.center.assign(e), s.radius = i;
  }
  /**
   * Gets the circles in the collection
   */
  getCircles() {
    return this._circles;
  }
}
const Aa = class extends Qr {
  constructor(n) {
    super(n), this._uniqueId = Qi(), this._centerPt = d.zero(), this._radiusPt = d.zero(), this._circleShape = new qn(), this._previousDragPlanePosition = d.zero(), this._circleShape.setFillOpacity(0), this._circleShape.setStrokeColor(it.red()), this._circleShape.setStrokeWidth(2);
  }
  setCenter(n) {
    this._centerPt.assign(n);
  }
  getCenter() {
    return this._centerPt.copy();
  }
  setRadiusPoint(n) {
    this._radiusPt.assign(n);
  }
  getRadiusPoint() {
    return this._radiusPt.copy();
  }
  getUniqueId() {
    return this._uniqueId;
  }
  _update() {
    const n = this._viewer.view, t = E.fromPoint3(n.projectPoint(this._centerPt)), e = E.fromPoint3(n.projectPoint(this._radiusPt)), i = E.distance(t, e);
    this._circleShape.set(t, i);
  }
  draw() {
    this._update(), this._viewer.markupManager.getRenderer().drawCircle(this._circleShape);
  }
  hit(n) {
    return this.hitWithTolerance(n, 0);
  }
  hitWithTolerance(n, t) {
    this._update();
    const e = this._circleShape.getStrokeWidth() + t, i = E.distance(this._circleShape.getCenter(), n) - this._circleShape.getRadius();
    return Math.abs(i) <= e;
  }
  onSelect() {
    this._circleShape.setStrokeWidth(4);
  }
  onDeselect() {
    this._circleShape.setStrokeWidth(2);
  }
  isValid() {
    return this._circleShape.getRadius() > Aa._validRadiusTolerance;
  }
  // dragging methods
  onDragStart(n) {
    const t = this._viewer.view, e = t.getCamera().getCameraPlaneIntersectionPoint(n, t);
    return e !== null && this._previousDragPlanePosition.assign(e), !1;
  }
  onDragMove(n) {
    const t = this._viewer.view, e = t.getCamera().getCameraPlaneIntersectionPoint(n, t);
    if (e !== null) {
      const i = d.subtract(e, this._previousDragPlanePosition);
      this._centerPt.add(i), this._radiusPt.add(i), this._previousDragPlanePosition.assign(e);
    }
    return !0;
  }
  // Serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      uniqueId: this._uniqueId,
      centerPoint: this._centerPt.toJson(),
      radiusPoint: this._radiusPt.toJson(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[RedlineCircle]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new Aa(t);
    return i._uniqueId = e.uniqueId, i.setCenter(d.fromJson(e.centerPoint)), i.setRadiusPoint(d.fromJson(e.radiusPoint)), i;
  }
  getClassName() {
    return Aa.className;
  }
};
let dr = Aa;
dr.className = "Communicator.Markup.Redline.RedlineCircle";
dr._validRadiusTolerance = 1;
Ui(dr.className, dr.fromJson);
class fr extends da {
  constructor() {
    super(...arguments), this._points = [];
  }
  /**
   * Removes all points from this polyline
   */
  clearPoints() {
    this._points = [];
  }
  /**
   * Gets the points in this polyline
   * @returns the points in this polyline
   */
  getPoints() {
    return this._points;
  }
  /**
   * Adds a point to the polyline
   * @param point the point to add to the line
   */
  pushPoint(t) {
    this._points.push(t.copy());
  }
}
class Y_ extends da {
  constructor() {
    super(...arguments), this._polylines = [];
  }
  /**
   * Removes all polylines from the collection
   */
  clear() {
    this._polylines = [];
  }
  /**
   * Creates a new array of points that represent a polyline. Add Point2 objects to the array to construct the polyline
   * @returns new array which represents a polyline.
   */
  createPolyline() {
    const t = [];
    return this._polylines.push(t), t;
  }
  /**
   * @returns the polylines in this collection
   */
  getPolylines() {
    return this._polylines;
  }
}
const Tc = class extends Qr {
  constructor(n) {
    super(n), this._uniqueId = Qi(), this._points = [], this._polylineShape = new fr(), this._previousDragPlanePosition = d.zero(), this._polylineShape.setStrokeWidth(2), this._polylineShape.setStrokeColor(it.red());
  }
  addPoint(n) {
    this._points.push(n.copy());
  }
  getPoints() {
    const n = [];
    return this._points.forEach((t) => {
      n.push(t.copy());
    }), n;
  }
  _update() {
    const n = this._viewer.view;
    this._polylineShape.clearPoints();
    for (const t of this._points) {
      const e = E.fromPoint3(n.projectPoint(t));
      this._polylineShape.pushPoint(e);
    }
  }
  draw() {
    this._update(), this.isValid() && this._viewer.markupManager.getRenderer().drawPolyline(this._polylineShape);
  }
  hit(n) {
    return this.hitWithTolerance(n, 0);
  }
  hitWithTolerance(n, t) {
    this._update();
    const e = this._polylineShape.getStrokeWidth() + t, i = this._polylineShape.getPoints();
    if (i.length > 1) {
      for (let s = 1; s < i.length; s++)
        if (oo(n, i[s - 1], i[s], e))
          return !0;
    }
    return !1;
  }
  onSelect() {
    this._polylineShape.setStrokeWidth(4);
  }
  onDeselect() {
    this._polylineShape.setStrokeWidth(2);
  }
  getClassName() {
    return Tc.className;
  }
  isValid() {
    return this._points.length > 1;
  }
  // dragging methods
  onDragStart(n) {
    const t = this._viewer.view, e = t.getCamera().getCameraPlaneIntersectionPoint(n, t);
    return e !== null && this._previousDragPlanePosition.assign(e), !1;
  }
  onDragMove(n) {
    const t = this._viewer.view, e = t.getCamera().getCameraPlaneIntersectionPoint(n, t);
    if (e !== null) {
      const i = d.subtract(e, this._previousDragPlanePosition);
      for (const s of this._points)
        s.add(i);
      this._polylineShape.clearPoints(), this._previousDragPlanePosition.assign(e);
    }
    return !0;
  }
  // Serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const n = [];
    for (const t of this._points)
      n.push(t.toJson());
    return {
      uniqueId: this._uniqueId,
      points: n
    };
  }
  /**
   * Creates a new [[RedlinePolyline]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new Tc(t);
    i._uniqueId = e.uniqueId;
    for (const s of e.points)
      i.addPoint(d.fromJson(s));
    return i;
  }
};
let Kr = Tc;
Kr.className = "Communicator.Markup.Redline.RedlinePolyline";
Ui(Kr.className, Kr.fromJson);
class Fl extends gr {
  constructor() {
    super(...arguments), this._borderRadius = 0;
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._borderRadius = t._borderRadius;
  }
  /**
   * Gets the border radius for this shape
   * @returns the border radius
   */
  getBorderRadius() {
    return this._borderRadius;
  }
  /**
   * Sets the border radius for this shape
   * @param borderRadius the border radius in pixels
   */
  setBorderRadius(t) {
    this._borderRadius = t;
  }
}
class Kl extends Fl {
  /**
   * Creates a new rectangle markup item
   * @param position the screen space position of the top left of the rectangle.
   * @param size the point object representing the width and height of the rectangle in pixels.
   */
  constructor(t, e) {
    super(), this._position = E.zero(), this._size = E.zero(), t && this._position.assign(t), e && this._size.assign(e);
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._position.assign(t._position), this._size.assign(t._size);
  }
  /**
   * Sets the rectanlge position
   * @param position the top left corner of the rectangle
   */
  setPosition(t) {
    this._position.assign(t);
  }
  /**
   * Gets rectangle position
   * @returns the rectangle position
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Sets the rectanlge size
   * @param size indicating the rectangle width and height
   */
  setSize(t) {
    this._size.assign(t);
  }
  /**
   * Gets rectangle size
   * @returns the rectangle size
   */
  getSize() {
    return this._size.copy();
  }
}
class hm {
  constructor(t, e) {
    this.position = t.copy(), this.size = e.copy();
  }
}
class G_ extends Fl {
  constructor() {
    super(...arguments), this._rectangles = [];
  }
  /**
   * Removes all rectangles from this collection
   */
  clear() {
    this._rectangles = [];
  }
  /**
   * Adds a rectangle to the collection
   * @param position the top left corner of the rectangle
   * @param size indicating the rectangle width and height
   */
  addRectangle(t, e) {
    this._rectangles.push(new hm(t, e));
  }
  /**
   * Gets the rectangles in the collection
   */
  getRectangles() {
    return this._rectangles;
  }
}
const _o = class extends Qr {
  constructor(n) {
    super(n), this._uniqueId = Qi(), this._point1 = d.zero(), this._point2 = d.zero(), this._rectangleShape = new Kl(), this._previousDragPlanePosition = d.zero(), this._rectangleShape.setFillOpacity(0), this._rectangleShape.setStrokeColor(it.red()), this._rectangleShape.setStrokeWidth(2);
  }
  setPoint1(n) {
    this._point1.assign(n);
  }
  getPoint1() {
    return this._point1.copy();
  }
  setPoint2(n) {
    this._point2.assign(n);
  }
  getPoint2() {
    return this._point2.copy();
  }
  getUniqueId() {
    return this._uniqueId;
  }
  _update() {
    const n = this._viewer.view, t = n.projectPoint(this._point1), e = n.projectPoint(this._point2), i = new E(
      Math.min(t.x, e.x),
      Math.min(t.y, e.y)
    ), s = new E(
      Math.max(t.x, e.x),
      Math.max(t.y, e.y)
    ), r = E.subtract(s, i);
    this._rectangleShape.setPosition(i), this._rectangleShape.setSize(r);
  }
  draw() {
    this._update(), this._viewer.markupManager.getRenderer().drawRectangle(this._rectangleShape);
  }
  hit(n) {
    return this.hitWithTolerance(n, 0);
  }
  hitWithTolerance(n, t) {
    this._update();
    const e = this._rectangleShape.getStrokeWidth() + t, i = this._rectangleShape.getPosition(), s = this._rectangleShape.getSize(), r = i, o = new E(i.x + s.x, r.y), a = new E(i.x, i.y + s.y), l = new E(i.x + s.x, i.y + s.y);
    return oo(n, r, o, e) || oo(n, o, l, e) || oo(n, l, a, e) ? !0 : !!oo(n, a, r, e);
  }
  onSelect() {
    this._rectangleShape.setStrokeWidth(4);
  }
  onDeselect() {
    this._rectangleShape.setStrokeWidth(2);
  }
  isValid() {
    const n = this._rectangleShape.getSize();
    return n.x > _o._validSizeTolerance.x && n.y > _o._validSizeTolerance.y;
  }
  // dragging methods
  onDragStart(n) {
    const t = this._viewer.view, e = t.getCamera().getCameraPlaneIntersectionPoint(n, t);
    return e !== null && this._previousDragPlanePosition.assign(e), !1;
  }
  onDragMove(n) {
    const t = this._viewer.view, e = t.getCamera().getCameraPlaneIntersectionPoint(n, t);
    if (e !== null) {
      const i = d.subtract(e, this._previousDragPlanePosition);
      this._point1.add(i), this._point2.add(i), this._previousDragPlanePosition.assign(e);
    }
    return !0;
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      uniqueId: this._uniqueId,
      className: this.getClassName(),
      point1: this._point1.toJson(),
      point2: this._point2.toJson()
    };
  }
  /**
   * Creates a new [[RedlineRectangle]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new _o(t);
    return i._uniqueId = e.uniqueId, i.setPoint1(d.fromJson(e.point1)), i.setPoint2(d.fromJson(e.point2)), i;
  }
  getClassName() {
    return _o.className;
  }
};
let mr = _o;
mr.className = "Communicator.Markup.Redline.RedlineRectangle";
mr._validSizeTolerance = new E(5, 5);
Ui(mr.className, mr.fromJson);
const Da = class {
  constructor(n, t) {
    this._sizeChanged = !1, this._sizeUpdateCallback = n, this._textUpdateCallback = t, this._createTextBox();
  }
  _createTextBox() {
    this._currentSize = Da._defaultSize.copy(), this._textArea = document.createElement("textarea"), this._textArea.style.position = "absolute", this._textArea.style.width = `${Da._defaultSize.x}px`, this._textArea.style.height = `${Da._defaultSize.y}px`, this._textArea.style.zIndex = "1", this._textArea.style.pointerEvents = "none", this._textArea.style.resize = "none", this._textArea.style.letterSpacing = "1px", this.setBorderWidth(2), this._textArea.onmousemove = (t) => {
      t.stopPropagation();
      const e = new E(
        parseInt(this._textArea.style.width, 10),
        parseInt(this._textArea.style.height, 10)
      );
      this.setSize(e);
    }, this._textArea.onmouseup = (t) => {
      t.stopPropagation(), this._sizeChanged && (this._sizeChanged = !1, this._sizeUpdateCallback(this._currentSize));
    };
    const n = () => {
      this._textUpdateCallback(this._textArea.value);
    };
    this._textArea.oninput = n;
  }
  setPosition(n) {
    this._textArea.style.left = `${n.x}px`, this._textArea.style.top = `${n.y}px`;
  }
  setBorderWidth(n) {
    this._textArea.style.outline = `${n}px solid red`;
  }
  setText(n) {
    this._textArea.textContent = n;
  }
  setSize(n) {
    this._currentSize.equals(n) || (this._sizeChanged = !0, this._currentSize.assign(n), this._textArea.style.width = `${n.x}px`, this._textArea.style.height = `${n.y}px`);
  }
  focus() {
    this._textArea.focus(), this._textArea.style.pointerEvents = "auto", this._textArea.style.resize = "both";
  }
  blur() {
    this._textArea.blur(), this._textArea.style.pointerEvents = "none", this._textArea.style.resize = "none";
  }
  getTextArea() {
    return this._textArea;
  }
};
let Wh = Da;
Wh._defaultSize = new E(100, 100);
const za = class extends Qr {
  constructor(n, t = za.defaultText) {
    super(n), this._uniqueId = Qi(), this._position = d.zero(), this._size = new E(100, 100), this._redlineElementId = null, this._previousDragPlanePosition = d.zero(), this._text = t;
    const e = (s) => {
      this.setSize(s);
    }, i = (s) => {
      this.setText(s);
    };
    this._redlineTextElement = new Wh(e, i), this._redlineTextElement.setText(this._text), this._callbacks = {
      selectionArray: () => {
        this.onDeselect();
      }
    }, this._viewer.setCallbacks(this._callbacks);
  }
  setPosition(n) {
    this._position.assign(n);
  }
  getPosition() {
    return this._position.copy();
  }
  setSize(n) {
    this._size.assign(n), this._redlineTextElement.setSize(n), this._viewer.trigger("redlineUpdated", this);
  }
  getSize() {
    return this._size.copy();
  }
  setText(n) {
    this._text = n, this._redlineTextElement.setText(n), this._viewer.trigger("redlineUpdated", this);
  }
  getText() {
    return this._text;
  }
  draw() {
    const n = E.fromPoint3(this._viewer.view.projectPoint(this._position));
    this._redlineTextElement.setPosition(n), this._redlineElementId === null && (this._redlineElementId = this._viewer.markupManager.addMarkupElement(
      this._redlineTextElement.getTextArea()
    ));
  }
  hit(n) {
    return this.hitWithTolerance(n, 0);
  }
  hitWithTolerance(n, t) {
    const e = this._redlineTextElement.getTextArea(), i = new E(
      parseFloat(e.style.left || "0"),
      parseFloat(e.style.top || "0")
    ), s = new E(
      parseFloat(e.style.width || "0"),
      parseFloat(e.style.height || "0")
    );
    return Uu(n, i, s, t);
  }
  getClassName() {
    return za.className;
  }
  onSelect() {
    this._redlineTextElement.setBorderWidth(4), this._redlineTextElement.focus();
  }
  onDeselect() {
    this._redlineTextElement.setBorderWidth(2), this._redlineTextElement.blur();
  }
  isValid() {
    return this._text.length > 0;
  }
  remove() {
    this._redlineElementId && (this._viewer.markupManager.removeMarkupElement(this._redlineElementId), this._redlineElementId = null), this._callbacks !== null && (this._viewer.unsetCallbacks(this._callbacks), this._callbacks = null), super.remove();
  }
  // drag methods and drop methods
  onDragStart(n) {
    const t = this._viewer.view, e = t.getCamera().getCameraPlaneIntersectionPoint(n, t);
    return e !== null && this._previousDragPlanePosition.assign(e), !1;
  }
  onDragMove(n) {
    const t = this._viewer.view, e = t.getCamera().getCameraPlaneIntersectionPoint(n, t);
    if (e !== null) {
      const i = d.subtract(e, this._previousDragPlanePosition), s = this.getPosition();
      s.add(i), this.setPosition(s), this._previousDragPlanePosition.assign(e);
    }
    return !0;
  }
  // Serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      uniqueId: this._uniqueId,
      className: this.getClassName(),
      position: this._position.toJson(),
      size: this._size.toJson(),
      text: this._text
    };
  }
  /**
   * Creates a new [[RedlineText]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new za(t, e.text);
    return i._uniqueId = e.uniqueId, i.setPosition(d.fromJson(e.position)), i.setSize(E.fromJson(e.size)), i;
  }
};
let Rs = za;
Rs.className = "Communicator.Markup.Redline.RedlineText";
Rs.defaultText = "Type Here...";
Ui(Rs.className, Rs.fromJson);
const T_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RedlineCircle: dr,
  RedlinePolyline: Kr,
  RedlineRectangle: mr,
  RedlineText: Rs,
  RedlineTextElement: Wh
}, Symbol.toStringTag, { value: "Module" })), Ec = class extends _s {
  constructor(n, t = null, e = null, i = null, s = null) {
    super(), this._uniqueId = Qi(), this._lineMeshId = null, this._lineMeshInstanceId = null, this._lineColor = it.red(), this._lineOpacity = 1, this._linePattern = null, this._linePatternLength = null, this._linePatternLengthUnit = null, this._viewer = n, this._firstPoint = t, this._secondPoint = e, this._firstNodeId = i, this._secondNodeId = s;
  }
  /**
   * Sets the line color.
   * @param color
   */
  setLineColor(n) {
    this._lineColor = n;
  }
  /**
   * Gets the line color.
   */
  getLineColor() {
    return this._lineColor;
  }
  /**
   * Sets the line opacity.
   * @param opacity
   */
  setLineOpacity(n) {
    this._lineOpacity = n;
  }
  /**
   * Gets the line opacity.
   */
  getLineOpacity() {
    return this._lineOpacity;
  }
  /**
   * Sets the line pattern.
   * @param pattern The line pattern.
   * @param patternLength The length of a single repetition of the line pattern.
   * @param patternLengthUnit The unit in which the pattern length is measured.
   */
  setLinePattern(n, t, e) {
    this._linePattern = n, this._linePatternLength = t, this._linePatternLengthUnit = e;
  }
  /**
   * Gets the line pattern.
   */
  getLinePattern() {
    return this._linePattern !== void 0 ? this._linePattern : null;
  }
  /**
   * Gets the length of a single repetition of the line pattern.
   */
  getLinePatternLength() {
    return this._linePatternLength !== void 0 ? this._linePatternLength : null;
  }
  /**
   * Gets the unit in which the line pattern length is measured.
   */
  getLinePatternLengthUnit() {
    return this._linePatternLengthUnit !== void 0 ? this._linePatternLengthUnit : null;
  }
  /**
   * Sets the first point on the line.
   * @param firstPoint
   */
  setFirstPoint(n) {
    this._firstPoint = n;
  }
  /**
   * Gets the first point on the line.
   * @returns the first point, or null if none is set.
   */
  getFirstPoint() {
    return this._firstPoint;
  }
  /**
   * Sets the second point on the line.
   * @param secondPoint
   */
  setSecondPoint(n) {
    this._secondPoint = n;
  }
  /**
   * Gets the second point on the line.
   * @returns the second point, or null if none is set.
   */
  getSecondPoint() {
    return this._secondPoint;
  }
  /**
   * Sets the NodeId of the part associated with the first line point
   * @param nodeId
   */
  setFirstNodeId(n) {
    this._firstNodeId = n;
  }
  /**
   * Gets the NodeId of the part associated with the first line point
   */
  getFirstNodeId() {
    return this._firstNodeId;
  }
  /**
   * Sets the NodeId of the part associated with the second line point
   * @param nodeId
   */
  setSecondNodeId(n) {
    this._secondNodeId = n;
  }
  /**
   * Gets the NodeId of the part associated with the second line point
   */
  getSecondNodeId() {
    return this._secondNodeId;
  }
  /**
   * Gets the node id associated with the line markup.
   */
  getNodeId() {
    return this._lineMeshInstanceId;
  }
  /**
   * Removes the line geometry from the scene.
   */
  async removeLine() {
    const n = this._viewer.model;
    this._lineMeshInstanceId !== null && (await n.deleteMeshInstances([this._lineMeshInstanceId]), this._lineMeshInstanceId = null, this._lineMeshId !== null && (await n.deleteMeshes([this._lineMeshId]), this._lineMeshId = null));
  }
  /**
   * Draws updated line geometry in the scene.
   */
  async updateLine() {
    if (await this.removeLine(), this._firstPoint !== null && this._secondPoint !== null) {
      const n = new Hi();
      n.addPolyline([
        this._firstPoint.x,
        this._firstPoint.y,
        this._firstPoint.z,
        this._secondPoint.x,
        this._secondPoint.y,
        this._secondPoint.z
      ]);
      const t = this._viewer.model, e = await t.createMesh(n);
      this._lineMeshId = e;
      const i = new bn(e);
      i.setLineColor(this._lineColor), i.setLineOpacity(this._lineOpacity), i.setCreationFlags(xt.ExcludeBounding);
      const s = await t.createMeshInstance(i);
      this._linePattern !== null && t.setNodesLinePattern(
        [s],
        this._linePattern,
        this._linePatternLength,
        this._linePatternLengthUnit
      ), this._lineMeshInstanceId = s;
    }
  }
  /**
   * Returns a unique markup id for this line.
   */
  getId() {
    return this._uniqueId;
  }
  /**
   * Sets a markup id for this line.
   * @param id
   */
  setId(n) {
    this._uniqueId = n;
  }
  /**
   * Returns the class name for this markup item.
   */
  getClassName() {
    return Ec.className;
  }
  _toJson() {
    return {
      className: this.getClassName(),
      uniqueId: this._uniqueId,
      firstPoint: this.getFirstPoint(),
      secondPoint: this.getSecondPoint(),
      firstNodeId: this.getFirstNodeId(),
      secondNodeId: this.getSecondNodeId(),
      lineColor: this.getLineColor(),
      lineOpacity: this.getLineOpacity(),
      linePattern: this.getLinePattern(),
      linePatternLength: this.getLinePatternLength(),
      linePatternLengthUnit: this.getLinePatternLengthUnit()
    };
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  /**
   * Creates a new [[LineMarkup]] from an object given by [[toJson]].
   * @param An object given by [[toJson]].
   * @returns The prepared object.
   */
  static async fromJson(n, t) {
    const e = n, i = new Ec(
      t,
      d.fromJson(e.firstPoint),
      d.fromJson(e.secondPoint),
      e.firstNodeId,
      e.secondNodeId
    );
    return i.setId(e.uniqueId), i.setLineColor(it.fromJson(e.lineColor)), i.setLineOpacity(e.lineOpacity), e.linePattern != null && e.linePatternLength != null && e.linePatternLengthUnit != null && i.setLinePattern(e.linePattern, e.linePatternLength, e.linePatternLengthUnit), i;
  }
};
let Or = Ec;
Or.className = "Communicator.Markup.Line.LineMarkup";
Ui(Or.className, Or.fromJson);
const E_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LineMarkup: Or
}, Symbol.toStringTag, { value: "Module" }));
class Ar {
  constructor(t, e, i, s, r, o) {
    this._version = pn.Unknown, this._components = {}, this._lines = [], this._clippingPlanes = [], this._viewer = o, this._filename = t, this._version = i, this._modelBounding = s, this._unitScale = 1e3 / r, this._parseDocument(e);
  }
  static async createViewpoint(t, e, i = null) {
    const s = (Y) => {
      const P = [];
      return Y.forEach((L) => {
        let N = null;
        for (; L !== null && N === null; )
          N = r.getNodeGenericId(L), L = r.getNodeParent(L);
        P.push(N);
      }), console.assert(Y.length === P.length), P;
    }, r = t.model, o = r.getAbsoluteRootNode(), a = await r.getVisibilityState(o), l = await r.getNodeColorMap(o, Je.Faces), c = await r.getModelBounding(!0, !1), h = r.getNodeUnitMultiplier(o), u = new Ar(
      e,
      null,
      pn.v2_1,
      c,
      h,
      t
    ), p = a.defaultVisibility;
    u.setDefaultVisibility(p);
    const m = a.visibilityExceptions, g = [];
    m.forEach((Y) => {
      g.push(Y);
    });
    const _ = [], y = s(g);
    for (let Y = 0; Y < y.length; Y++) {
      const P = y[Y];
      let L;
      P !== null ? L = r.getNodeIdsByGenericIds([P]) : L = [g[Y]];
      for (const N of L) {
        const D = await r.getVisibilityState(N), B = { genericId: P, nodeId: N };
        p ? D.visibilityExceptions.size === 0 && _.push(B) : (D.visibilityExceptions.size !== 0 || D.defaultVisibility) && _.push(B);
      }
    }
    u.setVisibilityExceptionNodes(_);
    const w = t.selectionManager.getResults().map((Y) => Y.getNodeId()), v = s(w), C = [];
    for (let Y = 0; Y < w.length; Y++) {
      const P = {
        genericId: v[Y],
        nodeId: w[Y]
      };
      C.push(P);
    }
    u.setSelectionNodes(C);
    const k = /* @__PURE__ */ new Map();
    if (l.size > 0 && l.forEach((Y, P) => {
      const L = r.getNodeParent(P);
      if (L === null)
        return;
      const N = r.getNodeGenericId(L);
      let D = k.get(Y);
      D === void 0 && (D = /* @__PURE__ */ new Set(), k.set(Y, D)), D.add({ genericId: N, nodeId: P });
    }), u.setColorNodes(k), u.setCamera(t.view.getCamera()), i !== null) {
      const Y = Ar._markupRedlineToBcf(i.getMarkup(), t.view);
      u.setLines(Y);
    }
    return u;
  }
  static _markupRedlineToBcf(t, e) {
    const r = (h) => {
      const u = e.projectPoint(h);
      return e.unprojectPoint(E.fromPoint3(u), 0);
    }, o = (h, u, p) => {
      const m = Math.PI * 2 / p, g = [];
      for (let _ = 0; _ <= p; _++) {
        const y = _ * m;
        g.push(
          new E(h.x + Math.cos(y) * u, h.y + Math.sin(y) * u)
        );
      }
      return g;
    }, a = (h) => {
      for (let u = 0; u < h.length - 1; ++u) {
        const p = h[u], m = h[u + 1];
        if (p !== null && m !== null) {
          const g = [p.copy().scale(1e-3), m.copy().scale(1e-3)];
          c.push(g);
        }
      }
    }, l = (h) => {
      for (let u = 0; u < h.length; ++u) {
        const p = h[u], m = h[(u + 1) % h.length];
        if (p !== null && m !== null) {
          const g = [p.copy().scale(1e-3), m.copy().scale(1e-3)];
          c.push(g);
        }
      }
    }, c = [];
    return t.forEach((h) => {
      if (h instanceof Kr) {
        const p = h.getPoints().map(r);
        a(p);
      } else if (h instanceof dr) {
        const u = h.getCenter(), p = h.getRadiusPoint(), m = E.fromPoint3(e.projectPoint(u)), g = E.fromPoint3(e.projectPoint(p)), _ = E.subtract(g, m).length(), b = o(m, _, 40).map((w) => e.unprojectPoint(w, 0));
        l(b);
      } else if (h instanceof mr) {
        const u = h.getPoint1(), p = h.getPoint2(), m = E.fromPoint3(e.projectPoint(u)), g = E.fromPoint3(e.projectPoint(p)), _ = [];
        _.push(e.unprojectPoint(m, 0)), _.push(
          e.unprojectPoint(new E(m.x, g.y), 0)
        ), _.push(e.unprojectPoint(g, 0)), _.push(
          e.unprojectPoint(new E(g.x, m.y), 0)
        ), l(_);
      }
    }), c;
  }
  _parseDocument(t) {
    if (t === null)
      return;
    const e = t.documentElement, i = e.attributes.getNamedItem("Guid");
    i !== null && (this._viewpointGuid = i.value);
    let s = e.firstElementChild;
    for (; s !== null; ) {
      const r = s.localName;
      if (r === null)
        break;
      switch (r) {
        case "Components":
          this._version >= pn.v2_1 ? this._parseComponents(s) : this._parseComponentsV2_0(s);
          break;
        case "OrthogonalCamera":
          this._parseOrthogonalCamera(s);
          break;
        case "PerspectiveCamera":
          this._parsePerspectiveCamera(s);
          break;
        case "Lines":
          this._parseLines(s);
          break;
        case "ClippingPlanes":
          this._parseClippingPlanes(s);
          break;
      }
      s = s.nextElementSibling;
    }
  }
  _exportComponents(t) {
    const e = t.createElement("Components"), i = t.createElement("ViewSetupHints"), s = this._components.viewSetupHints;
    s && (e.setAttribute("SpacesVisible", go(s.spacesVisible)), e.setAttribute(
      "SpaceBoundariesVisible",
      go(s.spaceBoundariesVisible)
    ), e.setAttribute("OpeningsVisible", go(s.openingsVisible))), e.appendChild(i);
    const r = t.createElement("Selection"), o = this._components.selection;
    o && o.forEach((p) => {
      r.appendChild(Fa(t, p));
    }), e.appendChild(r);
    const a = t.createElement("Visibility"), l = this._components.defaultVisibility, c = this._components.visibilityExceptions;
    if (l !== void 0 && c !== void 0) {
      a.setAttribute("DefaultVisibility", go(l));
      const p = t.createElement("Exceptions");
      c.forEach((m) => {
        p.appendChild(Fa(t, m));
      }), a.appendChild(p);
    }
    e.appendChild(a);
    const h = t.createElement("Coloring"), u = this._components.coloring;
    return u && u.forEach((p) => {
      const m = t.createElement("Color");
      m.setAttribute("Color", sm(p.color, p.alpha)), p.components.forEach((g) => {
        m.appendChild(Fa(t, g));
      }), h.appendChild(m);
    }), e.appendChild(h), e;
  }
  _exportOrthogonalCamera(t, e) {
    const i = t.createElement("OrthogonalCamera"), s = t.createElement("CameraViewPoint"), r = t.createElement("CameraDirection"), o = t.createElement("CameraUpVector");
    Zn(t, s, e.cameraViewPoint), Zn(t, r, e.cameraDirection), Zn(t, o, e.cameraUpVector);
    const a = t.createElement("ViewToWorldScale");
    return a.innerHTML = e.viewToWorldScale.toString(), i.appendChild(s), i.appendChild(r), i.appendChild(o), i.appendChild(a), i;
  }
  _exportPerspectiveCamera(t, e) {
    const i = t.createElement("PerspectiveCamera"), s = t.createElement("CameraViewPoint"), r = t.createElement("CameraDirection"), o = t.createElement("CameraUpVector");
    Zn(t, s, e.cameraViewPoint), Zn(t, r, e.cameraDirection), Zn(t, o, e.cameraUpVector);
    const a = t.createElement("FieldOfView");
    return a.innerHTML = e.fieldOfView.toString(), i.appendChild(s), i.appendChild(r), i.appendChild(o), i.appendChild(a), i;
  }
  _exportLines(t) {
    const e = t.createElement("Lines");
    return this._lines.forEach((i) => {
      const s = t.createElement("Line"), r = t.createElement("StartPoint"), o = t.createElement("EndPoint");
      Zn(t, r, i.startPoint), Zn(t, o, i.endPoint), s.appendChild(r), s.appendChild(o), e.appendChild(s);
    }), e;
  }
  _exportClippingPlanes(t) {
    const e = t.createElement("ClippingPlanes");
    return this._clippingPlanes.forEach((i) => {
      const s = t.createElement("ClippingPlane"), r = t.createElement("Location"), o = t.createElement("Direction");
      Zn(t, r, i.location), Zn(t, o, i.direction), s.appendChild(r), s.appendChild(o), e.appendChild(s);
    }), e;
  }
  /**
   * @returns XML document containing the viewpoint data.
   */
  export() {
    const t = document.implementation.createDocument("", "", null), e = t.createElement("VisualizationInfo");
    return e.appendChild(this._exportComponents(t)), this._viewpointGuid !== void 0 && e.setAttribute("Guid", this._viewpointGuid), this._orthogonalCamera ? e.appendChild(this._exportOrthogonalCamera(t, this._orthogonalCamera)) : this._perspectiveCamera && e.appendChild(this._exportPerspectiveCamera(t, this._perspectiveCamera)), this._lines.length > 0 && e.appendChild(this._exportLines(t)), this._clippingPlanes.length > 0 && e.appendChild(this._exportClippingPlanes(t)), t.appendChild(e), t;
  }
  /**
   * Activates viewpoint.
   * Sets the camera, visibility, cutting planes, colors, and markup.
   */
  async activate() {
    await this._activateCamera(), await this._activateComponentsVisibility(), await this._activateMarkup(), await this._activateCuttingPlanes(), this._activateSelected(), await this._activateColors();
  }
  async _activateCamera() {
    const t = this.getCamera();
    t !== null && await this._viewer.view._setCameraPromise(t, 800);
  }
  async _activateComponentsVisibility() {
    const t = this._viewer.model, e = this._getDefaultVisibility(), i = this.getVisibilityExceptionNodes();
    i.length ? (await t.setNodesVisibility([-2], e), await t.setNodesVisibility(i, !e)) : await t.reset();
  }
  async _activateMarkup() {
    const t = this._viewer.lineManager;
    await t.removeAllLines();
    const e = [];
    for (let i = 0; i < this._lines.length; ++i) {
      const s = this._lines[i], r = new Or(
        this._viewer,
        s.startPoint.copy().scale(1e3),
        s.endPoint.copy().scale(1e3)
      );
      e.push(t.addLine(r));
    }
    await Promise.all(e);
  }
  async _activateCuttingPlanes() {
    const e = await this._viewer.model.getModelBounding(!0, !1), i = this._viewer.cuttingManager;
    await i.clearAllCuttingSections();
    for (let s = 0; s < this._clippingPlanes.length; ++s) {
      const r = i.getCuttingSection(s);
      await r.clear();
      const o = this._clippingPlanes[s], a = o.location.copy().scale(1e3), l = o.direction.normalize(), c = je.createFromPointAndNormal(a, l), h = i.createReferenceGeometryFromFaceNormal(
        l,
        a,
        e
      );
      await r.addPlane(c, h);
    }
    await i.activateCuttingSections();
  }
  _activateSelected() {
    const t = this._getNodeIdsFromComponents(this._components.selection);
    this._viewer.selectionManager.clear(), t.forEach((e) => {
      this._viewer.selectionManager.selectNode(e, ai.Add);
    });
  }
  async _activateColors() {
    const t = this._viewer.model, e = t.getAbsoluteRootNode();
    if (t.unsetNodesFaceColor([e]), t.unsetNodesLineColor([e]), this._components.coloring !== void 0) {
      const i = /* @__PURE__ */ new Map();
      for (let s = 0; s < this._components.coloring.length; ++s) {
        const r = this._components.coloring[s];
        this._getNodeIdsFromComponents(r.components).forEach((a) => {
          i.set(a, r.color);
        });
      }
      await this._viewer.model.setNodesColors(i);
    }
  }
  /**
   * Gets the viewpoint filename.
   */
  getFilename() {
    return this._filename;
  }
  /**
   * Gets the GUID associated with the viewpoint.
   */
  getViewpointGuid() {
    return this._viewpointGuid || null;
  }
  _fromBCFPerspectiveCamera(t, e) {
    const i = new ci();
    i.setProjection(te.Perspective);
    const s = t.cameraViewPoint.copy().scale(this._unitScale), r = t.cameraDirection.copy().normalize().scale(e), o = d.add(s, r), a = t.cameraUpVector.copy().normalize();
    i.setPosition(s), i.setTarget(o), i.setUp(a);
    const l = cs(t.fieldOfView), c = Math.tan(l / 2), u = 2 * d.subtract(i.getTarget(), i.getPosition()).length() * c;
    return i.setWidth(u), i.setHeight(u), i;
  }
  _fromBCFOrthogonalCamera(t, e) {
    const i = new ci();
    i.setProjection(te.Orthographic);
    const s = t.cameraViewPoint.copy().scale(this._unitScale), r = t.cameraDirection.copy().normalize().scale(e), o = d.add(s, r), a = t.cameraUpVector.copy().normalize();
    i.setPosition(s), i.setTarget(o), i.setUp(a);
    const l = t.viewToWorldScale * this._unitScale * 2;
    return i.setWidth(l), i.setHeight(l), i;
  }
  /**
   * Gets the viewpoint camera, or null if none is set.
   */
  getCamera() {
    const t = this._modelBounding.extents().length();
    return this._perspectiveCamera ? this._fromBCFPerspectiveCamera(this._perspectiveCamera, t / 40) : this._orthogonalCamera ? this._fromBCFOrthogonalCamera(this._orthogonalCamera, t) : null;
  }
  /**
   * Sets the viewpoint camera.
   * @param camera
   */
  setCamera(t) {
    t.getProjection() === te.Perspective ? (this._perspectiveCamera = this._toBCFPerspectiveCamera(t), this._orthogonalCamera = void 0) : (this._orthogonalCamera = this._toBCFOrthogonalCamera(t), this._perspectiveCamera = void 0);
  }
  _toBCFOrthogonalCamera(t) {
    const e = t.getPosition(), i = t.getTarget(), s = d.subtract(i, e).normalize(), r = t.getUp().normalize(), o = e.copy().scale(1 / this._unitScale), l = t.getWidth() / (this._unitScale * 2);
    return {
      cameraDirection: s,
      cameraUpVector: r,
      cameraViewPoint: o,
      viewToWorldScale: l
    };
  }
  _toBCFPerspectiveCamera(t) {
    const e = t.getPosition(), i = t.getTarget(), s = d.subtract(i, e).normalize(), r = t.getUp().normalize(), o = e.copy().scale(1 / this._unitScale), a = t.getWidth(), l = d.subtract(t.getTarget(), t.getPosition()).length(), c = a / (2 * l), h = Math.atan(c) * 2, u = _l(h);
    return {
      cameraDirection: s,
      cameraUpVector: r,
      cameraViewPoint: o,
      fieldOfView: u
    };
  }
  /**
   * Sets the default visibility.
   * If true, visibility exceptions are hidden.
   * If false, visibility exceptions are shown.
   * @param defaultVisibility
   */
  setDefaultVisibility(t) {
    this._components.defaultVisibility = t;
  }
  _getDefaultVisibility() {
    return this._components.defaultVisibility !== void 0 ? this._components.defaultVisibility : !0;
  }
  /**
   * Sets the visibility exceptions. These nodes will be shown or hidden based on the default visibility setting.
   * @param visibilityExceptions Array of GenericIds corresponding to components.
   */
  setVisibilityExceptions(t) {
    const e = t.map(
      (i) => {
        const s = this._viewer.model.getNodeIdsByGenericIds([i]), r = s.length !== 0 ? s[0] : void 0;
        return {
          ifcGuid: i,
          authoringToolId: r,
          originatingSystem: Xn
        };
      }
    );
    this._components.visibilityExceptions = e;
  }
  /**
   * Sets the visibility exceptions. These nodes will be shown or hidden based on the default visibility setting.
   * @param visibilityExceptions Array of BcfNodes corresponding to components.
   */
  setVisibilityExceptionNodes(t) {
    const e = t.map(
      (i) => ({
        ifcGuid: i.genericId !== null ? i.genericId : void 0,
        authoringToolId: i.nodeId,
        originatingSystem: Xn
      })
    );
    this._components.visibilityExceptions = e;
  }
  /**
   * Gets the visibility exception generic ids.
   * @returns Array of GenericIds corresponding to components.
   */
  getVisibilityExceptions() {
    return this._getGenericIdsFromComponents(this._components.visibilityExceptions);
  }
  /**
   * Gets the visibility exception node ids.
   * @returns Array of NodeIds corresponding to components.
   */
  getVisibilityExceptionNodes() {
    return this._getNodeIdsFromComponents(this._components.visibilityExceptions);
  }
  /**
   * Sets the colors.
   * @param colorGenericIdMap Map correlating color to GenericIds.
   */
  setColors(t) {
    const e = [];
    t.forEach((i, s) => {
      const r = [];
      i.forEach((a) => {
        const l = this._viewer.model.getNodeIdsByGenericIds([a]), c = l.length !== 0 ? l[0] : void 0;
        r.push({
          ifcGuid: a,
          authoringToolId: c,
          originatingSystem: Xn
        });
      });
      const o = {
        color: s,
        components: r
      };
      e.push(o);
    }), this._components.coloring = e;
  }
  /**
   * Sets the colors.
   * @param colorNodeMap Map correlating color to BfcNodes.
   */
  setColorNodes(t) {
    const e = [];
    t.forEach((i, s) => {
      const r = [];
      i.forEach((a) => {
        const l = a.genericId !== null ? a.genericId : void 0;
        r.push({
          ifcGuid: l,
          authoringToolId: a.nodeId,
          originatingSystem: Xn
        });
      });
      const o = {
        color: s,
        components: r
      };
      e.push(o);
    }), this._components.coloring = e;
  }
  /**
   * @returns Map correlating color to components.
   */
  getColors() {
    const t = /* @__PURE__ */ new Map(), e = this._components.coloring;
    return e !== void 0 && e.forEach((i) => {
      const s = i.color.copy(), r = /* @__PURE__ */ new Set();
      i.components.map((o) => {
        o.ifcGuid !== void 0 && r.add(o.ifcGuid);
      }), t.set(s, r);
    }), t;
  }
  /**
   * @returns Map correlating color to nodes.
   */
  getColorsToNodes() {
    const t = /* @__PURE__ */ new Map(), e = this._components.coloring;
    return e !== void 0 && e.forEach((i) => {
      const s = i.color.copy(), r = /* @__PURE__ */ new Set();
      i.components.map((o) => {
        o.authoringToolId !== void 0 && o.originatingSystem === Xn && r.add(o.authoringToolId);
      }), t.set(s, r);
    }), t;
  }
  /**
   * Sets the markup lines.
   * @param lines array of start point and end point line pairs.
   */
  setLines(t) {
    this._lines = [], t.forEach((e) => {
      const i = {
        startPoint: e[0].copy(),
        endPoint: e[1].copy()
      };
      this._lines.push(i);
    });
  }
  /**
   * Gets markup lines.
   * @returns Array containing start point and end point line pairs.
   */
  getLines() {
    const t = [];
    return this._lines.forEach((e) => {
      t.push([e.startPoint.copy(), e.endPoint.copy()]);
    }), t;
  }
  /**
   * Sets the clipping planes.
   * @param planes array containing position and direction pairs.
   */
  setClippingPlanes(t) {
    this._clippingPlanes = [], t.forEach((e) => {
      const i = {
        location: e[0].copy(),
        direction: e[1].copy()
      };
      this._clippingPlanes.push(i);
    });
  }
  /**
   * Gets the clipping planes.
   * @returns Array containing position and direction pairs.
   */
  getClippingPlanes() {
    const t = [];
    return this._clippingPlanes.forEach((e) => {
      t.push([e.location.copy(), e.direction.copy()]);
    }), t;
  }
  /**
   * Sets a list of items to be added to the selection set.
   */
  setSelection(t) {
    const e = t.map((i) => {
      const s = this._viewer.model.getNodeIdsByGenericIds([i]), r = s.length !== 0 ? s[0] : void 0;
      return {
        ifcGuid: i,
        authoringToolId: r,
        originatingSystem: Xn
      };
    });
    this._components.selection = e;
  }
  /**
   * Sets a list of items to be added to the selection set.
   */
  setSelectionNodes(t) {
    const e = t.map((i) => ({
      ifcGuid: i.genericId !== null ? i.genericId : void 0,
      authoringToolId: i.nodeId,
      originatingSystem: Xn
    }));
    this._components.selection = e;
  }
  /**
   * Gets a list of generic IDs that are in the selection set.
   */
  getSelection() {
    const t = [], e = this._components.selection;
    return e !== void 0 && e.forEach((i) => {
      i.ifcGuid && t.push(i.ifcGuid);
    }), t;
  }
  /**
   * Gets a list of node IDs that are in the selection set.
   */
  getSelectionNodes() {
    const t = [], e = this._components.selection;
    return e !== void 0 && e.forEach((i) => {
      i.authoringToolId !== void 0 && i.originatingSystem === Xn && t.push(i.authoringToolId);
    }), t;
  }
  _getGenericIdsFromComponents(t) {
    if (!t)
      return [];
    const e = [];
    for (let i = 0; i < t.length; ++i) {
      const s = t[i];
      s.ifcGuid !== void 0 && e.push(s.ifcGuid);
    }
    return e;
  }
  _getNodeIdsFromComponents(t) {
    if (!t)
      return [];
    const e = /* @__PURE__ */ new Set(), i = [];
    for (let r = 0; r < t.length; ++r) {
      const o = t[r];
      o.authoringToolId !== void 0 && o.originatingSystem === Xn ? e.add(o.authoringToolId) : o.ifcGuid !== void 0 && i.push(o.ifcGuid);
    }
    const s = this._viewer.model.getNodeIdsByGenericIds(i);
    for (const r of s)
      e.add(r);
    return Array.from(e);
  }
  _parseComponentsV2_0(t) {
    console.assert(this._version <= pn.v2_0);
    const e = [], i = [], s = [];
    let r = !0, o = t.firstElementChild;
    for (; o !== null; ) {
      const a = o.localName;
      if (a === null)
        break;
      switch (a) {
        case "Component":
          {
            const l = o.attributes, c = l.getNamedItem("IfcGuid"), h = l.getNamedItem("Selected"), u = l.getNamedItem("Visible"), p = l.getNamedItem("Color");
            if (c !== null && c.value) {
              const g = {
                ifcGuid: c.value
              };
              if (h !== null && h.value === "true" && e.push(g), r = !1, u !== null && u.value === "false" || i.push(g), p !== null && p.value) {
                const _ = p.value;
                s.push(this._colorFromArgb(_, [g]));
              }
            }
          }
          break;
      }
      o = o.nextElementSibling;
    }
    this._components = {
      defaultVisibility: r,
      selection: e,
      visibilityExceptions: i,
      coloring: s
    };
  }
  _parseComponents(t) {
    console.assert(this._version >= pn.v2_1);
    let e = t.firstElementChild;
    const i = {
      spacesVisible: !1,
      spaceBoundariesVisible: !1,
      openingsVisible: !1
    };
    let s = [], r = !0, o = [], a = [];
    for (; e !== null; ) {
      const l = e.localName;
      if (l === null)
        break;
      const c = e.attributes;
      switch (l) {
        case "ViewSetupHints":
          {
            const h = c.getNamedItem("SpacesVisible"), u = c.getNamedItem("SpaceBoundariesVisible"), p = c.getNamedItem("OpeningsVisible");
            h !== null && (i.spacesVisible = h.value === "true"), u !== null && (i.spaceBoundariesVisible = u.value === "true"), p !== null && (i.openingsVisible = p.value === "true");
          }
          break;
        case "Selection":
          s = this._getComponents(e);
          break;
        case "Visibility":
          {
            const h = c.getNamedItem("DefaultVisibility");
            h && (r = h.value === "true");
            const u = e.firstElementChild;
            u !== null && (o = this._getComponents(u));
          }
          break;
        case "Coloring":
          a = this._getColoring(e);
          break;
      }
      e = e.nextElementSibling;
    }
    this._components = {
      viewSetupHints: i,
      selection: s,
      defaultVisibility: r,
      visibilityExceptions: o,
      coloring: a
    };
  }
  _getCameraData(t) {
    const e = [];
    let i = t.firstElementChild;
    for (; i !== null; )
      switch (i.nodeName) {
        case "FieldOfView":
        case "ViewToWorldScale":
          {
            const s = i.textContent;
            s !== null && e.push(parseFloat(s)), i = null;
          }
          break;
        default:
          e.push(this._getPoint(i)), i = i.nextElementSibling;
      }
    return e;
  }
  _parseOrthogonalCamera(t) {
    const e = this._getCameraData(t);
    e.length === 4 && (this._orthogonalCamera = {
      cameraViewPoint: e[0],
      cameraDirection: e[1],
      cameraUpVector: e[2],
      viewToWorldScale: e[3]
    });
  }
  _parsePerspectiveCamera(t) {
    const e = this._getCameraData(t);
    e.length === 4 && (this._perspectiveCamera = {
      cameraViewPoint: e[0],
      cameraDirection: e[1],
      cameraUpVector: e[2],
      fieldOfView: e[3]
    });
  }
  _parseLines(t) {
    let e = t.firstElementChild;
    for (; e !== null; )
      this._lines.push(this._getLine(e)), e = e.nextElementSibling;
  }
  _parseClippingPlanes(t) {
    let e = t.firstElementChild;
    for (; e !== null; )
      this._clippingPlanes.push(this._getClippingPlane(e)), e = e.nextElementSibling;
  }
  _getClippingPlane(t) {
    let e = t.firstElementChild, i = d.zero(), s = d.zero();
    return e !== null && (i = this._getPoint(e), e = e.nextElementSibling, e !== null && (s = this._getPoint(e))), {
      location: i,
      direction: s
    };
  }
  _getLine(t) {
    let e = t.firstElementChild, i = d.zero(), s = d.zero();
    return e !== null && (i = this._getPoint(e), e = e.nextElementSibling, e !== null && (s = this._getPoint(e))), {
      startPoint: i,
      endPoint: s
    };
  }
  _getPoint(t) {
    const e = [];
    let i = t.firstElementChild;
    for (; i !== null; ) {
      const s = i.firstChild;
      s !== null && e.push(parseFloat(s.wholeText)), i = i.nextElementSibling;
    }
    return console.assert(e.length === 3), new d(e[0], e[1], e[2]);
  }
  _colorFromArgb(t, e) {
    const i = {
      color: it.black(),
      components: e
    }, s = [];
    for (let r = 0; r < t.length; r += 2) {
      const o = t.substr(r, 2);
      s.push(parseInt(o, 16));
    }
    return s.length === 3 ? i.color.set(s[0], s[1], s[2]) : s.length === 4 && (i.alpha = s[0], i.color.set(s[1], s[2], s[3])), i;
  }
  _getColoring(t) {
    const e = [];
    let i = t.firstElementChild;
    for (; i !== null; ) {
      const r = i.attributes.getNamedItem("Color"), o = this._getComponents(i);
      r && o.length && e.push(this._colorFromArgb(r.value, o)), i = i.nextElementSibling;
    }
    return e;
  }
  _getComponents(t) {
    const e = [];
    let i = t.firstElementChild;
    for (; i !== null; ) {
      const s = i.attributes, r = s.getNamedItem("IfcGuid"), o = s.getNamedItem("OriginatingSystem"), a = s.getNamedItem("AuthoringToolId");
      if (r !== null) {
        const l = {
          ifcGuid: r.value
        };
        o !== null && (l.originatingSystem = o.value), a !== null && (l.authoringToolId = parseInt(a.value, 10)), e.push(l);
      }
      i = i.nextElementSibling;
    }
    return e;
  }
}
class Ol {
  constructor(t, e, i, s) {
    this._viewpointMap = /* @__PURE__ */ new Map(), this._snapshotMap = /* @__PURE__ */ new Map(), this._viewer = s, this._topicId = i, this._bcfDataId = t, this._bcfFilename = e;
  }
  /**
   * Takes a MarkupView and creates a BCF Topic from it.
   * @param bcfDataId
   * @param bcfFilename
   * @param viewer
   * @param markupView
   * @param topicTitle
   */
  static async createTopic(t, e, i, s, r = null) {
    const o = Qi(), a = new Ol(e, i, o, t), l = "markup.bcf", c = a.addMarkup(l, null);
    c.setTopicTitle(s), c.setTopicId(o);
    const h = "viewpoint.bcfv", u = await Ar.createViewpoint(t, h, r);
    a.setViewpoint(h, u);
    const p = "snapshot.png", m = (r !== null ? r.getSnapshotImage() : null) || await t.takeSnapshot(), g = or.createFromImage(p, m);
    return a.setSnapshot(p, g), a;
  }
  /**
   * Gets the topic id corresponding to the BCF topic folder.
   */
  getTopicId() {
    return this._topicId;
  }
  /**
   * Adds a BCF markup.
   * @param markup BCF markup data.
   */
  addMarkup(t, e) {
    return this._markup = new lm(t, e, this), this._markup;
  }
  /**
   * @returns BCF markup data.
   */
  getMarkup() {
    return this._markup;
  }
  /**
   * Creates and adds BCF viewpoint.
   * @param fileName viewpoint filename.
   * @param viewpoint BCF viewpoint data.
   */
  addViewpoint(t, e, i, s, r) {
    const o = new Ar(
      t,
      e,
      i,
      s,
      r,
      this._viewer
    );
    return this.setViewpoint(t, o), o;
  }
  /**
   * Adds a BCF Viewpoint. If there is a already a viewpoint with the same filename, it will be replaced.
   * @param filename
   * @param viewpoint
   */
  setViewpoint(t, e) {
    this._viewpointMap.set(t, e);
  }
  /**
   * @returns A map associating viewpoint filenames with viewpoint data.
   */
  getViewpointMap() {
    return this._viewpointMap;
  }
  /**
   * Gets viewpoint data.
   * @param filename viewpoint filename.
   */
  getViewpoint(t) {
    return this._viewpointMap.get(t) || null;
  }
  /**
   * Creates and adds a Snapshot.
   * @param fileName Snapshot filename.
   * @param png Image data.
   */
  addSnapshot(t, e) {
    const i = new or(t, e);
    this.setSnapshot(t, i);
  }
  /**
   * Adds a BCF Snapshot. If there is already a snapshot with the smae filename, it will be replaced.
   * @param filename
   * @param snapshot
   */
  setSnapshot(t, e) {
    this._snapshotMap.set(t, e);
  }
  /**
   * @returns A map associating snapshot filenames with snapshot data.
   */
  getSnapshotMap() {
    return this._snapshotMap;
  }
  /**
   * Gets snapshot data.
   * @param filename snapshot or corresponding viewpoint filename
   */
  getSnapshot(t) {
    return this._snapshotMap.get(this._massageSnapshotFilename(t)) || null;
  }
  _massageSnapshotFilename(t) {
    if (t === "viewpoint.bcfv")
      return "snapshot.png";
    const e = t.split(".");
    return e[1] === "bcfv" ? `${e[0]}.png` : t;
  }
}
const K0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BCFComment: Gc,
  BCFData: Oa,
  BCFFileType: Ci,
  BCFMarkup: lm,
  BCFMarkupHeaderFile: om,
  BCFMarkupViewpoint: am,
  BCFSnapshot: or,
  BCFTopic: Ol,
  BCFVersion: pn,
  BCFViewpoint: Ar,
  addElem: On,
  appendPoint3: Zn,
  argbStringFromColor: sm,
  boolToString: go,
  conditionalAddElem: ze,
  conditionalBoolToString: Ka,
  conditionalDateToString: fo,
  conditionalNumberToString: Yc,
  conditionalSetAttribute: Fn,
  defaultOriginatingSystem: Xn,
  exportComponent: Fa
}, Symbol.toStringTag, { value: "Module" }));
var cl = /* @__PURE__ */ ((n) => (n[n.avatarOffset = 1500] = "avatarOffset", n[n.maxClimbHeight = 600] = "maxClimbHeight", n[n.negligibleClimbHeight = 20] = "negligibleClimbHeight", n[n.maxFallDistance = 5e3] = "maxFallDistance", n))(cl || {}), hl = /* @__PURE__ */ ((n) => (n[n.avatarOffset = 150] = "avatarOffset", n))(hl || {}), ul = /* @__PURE__ */ ((n) => (n[n.transparencyRange = 4e3] = "transparencyRange", n))(ul || {});
const O0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DefaultDoorConfig: ul,
  DefaultFloorConfig: cl,
  DefaultWallConfig: hl
}, Symbol.toStringTag, { value: "Module" }));
var Ls = /* @__PURE__ */ ((n) => (n[n.Never = 0] = "Never", n[n.Bim = 1] = "Bim", n[n.BimWalk = 2] = "BimWalk", n))(Ls || {}), oi = /* @__PURE__ */ ((n) => (n.Inactive = "inactive", n.Activating = "activating", n.Active = "active", n))(oi || {});
function Nc(n) {
  if (n.length === 0)
    return new Q();
  if (n.length === 1)
    return n[0];
  let t = Q.multiply(n[1], n[0]);
  for (let e = 2; e < n.length; ++e)
    t = Q.multiply(n[e], t);
  return t;
}
function Sr(n, t, e) {
  return Math.max(t, Math.min(e, n));
}
function um(n, t) {
  return n.x >= t.min.x && n.x <= t.max.x && n.y >= t.min.y && n.y <= t.max.y && n.z >= t.min.z && n.z <= t.max.z;
}
function Rc(n, t) {
  return n.z >= t.min.z && n.z <= t.max.z;
}
class dm {
  constructor(t, e, i, s, r) {
    this.floorplanNode = null, this.floorNode = t, this.bounds = e, this.slabNodes = i, this.spaceNodes = s, this.floorplanMeshCreationNodes = r;
  }
}
class ma {
  constructor() {
    this.overlayAnchor = Jt.LowerRightCorner, this.overlaySize = new E(0.25, 1), this.overlayWidthUnit = Bt.ProportionOfCanvas, this.overlayHeightUnit = Bt.ProportionOfOtherDimension, this.overlayOffset = new E(0, 0), this.overlayOffsetXUnit = Bt.Pixels, this.overlayOffsetYUnit = Bt.Pixels, this.backgroundColor = it.white(), this.backgroundOpacity = 0.25, this.borderColor = it.black(), this.borderOpacity = 1, this.avatarColor = it.createFromFloat(1, 0, 1), this.avatarOutlineColor = it.black(), this.avatarOpacity = 1, this.avatarScale = 1, this.fixedAvatarScale = !0, this.overlayFeetPerPixel = 0.1, this.zoomLevel = 1, this.autoActivate = Ls.BimWalk, this.floorplanOrientation = Wr.NorthUp, this.customAvatar = null, this.trackCameraEnabled = !1;
  }
  /**
   * Per-floor information.
   * @returns Copy of this configuration object.
   */
  copy() {
    const t = new ma();
    return t.overlayAnchor = this.overlayAnchor, t.overlaySize = this.overlaySize.copy(), t.overlayWidthUnit = this.overlayWidthUnit, t.overlayHeightUnit = this.overlayHeightUnit, t.overlayOffset = this.overlayOffset.copy(), t.overlayOffsetXUnit = this.overlayOffsetXUnit, t.overlayOffsetYUnit = this.overlayOffsetYUnit, t.backgroundColor = this.backgroundColor.copy(), t.backgroundOpacity = this.backgroundOpacity, t.borderColor = this.borderColor.copy(), t.borderOpacity = this.borderOpacity, t.avatarColor = this.avatarColor.copy(), t.avatarOutlineColor = this.avatarOutlineColor.copy(), t.avatarOpacity = this.avatarOpacity, t.avatarScale = this.avatarScale, t.fixedAvatarScale = this.fixedAvatarScale, t.customAvatar = this.customAvatar, t.overlayFeetPerPixel = this.overlayFeetPerPixel, t.zoomLevel = this.zoomLevel, t.trackCameraEnabled = this.trackCameraEnabled, t.autoActivate = this.autoActivate, t.floorplanOrientation = this.floorplanOrientation, t;
  }
}
class be {
  constructor(t = Xt.Face) {
    this.respectVisibility = !0, this.forceEffectiveVisibilityMask = Xt.None, this.forceEffectiveSceneVisibilityMask = Xt.None, this.respectDepthRange = !0, this.oneEntityPerTypePerInstance = !0, this.restrictLinesAndPointsToSelectedFaceInstances = !0, this.enableProximityFaces = !1, this.ignoreCappingGeometry = !1, this.ignoreOverlays = !1, this.restrictToOverlays = !1, this.selectionMask = t;
  }
  /** Returns a copy of this [[PickConfig]]. */
  copy() {
    const t = new be();
    return _g(this, t), t;
  }
  get allowFaces() {
    return (this.selectionMask & Xt.Face) !== 0;
  }
  set allowFaces(t) {
    this.selectionMask = Yr(this.selectionMask, Xt.Face, t);
  }
  get allowLines() {
    return (this.selectionMask & Xt.Line) !== 0;
  }
  set allowLines(t) {
    this.selectionMask = Yr(this.selectionMask, Xt.Line, t);
  }
  get allowPoints() {
    return (this.selectionMask & Xt.Point) !== 0;
  }
  set allowPoints(t) {
    this.selectionMask = Yr(this.selectionMask, Xt.Point, t);
  }
}
class Al {
  constructor(t = Xt.All) {
    this.mustBeFullyContained = !1, this.respectVisibility = !0, this.forceEffectiveVisibilityMask = Xt.None, this.forceEffectiveSceneVisibilityMask = Xt.None, this.allowFaces = !0, this.allowLines = !0, this.allowPoints = !0, this.ignoreCuttingSections = !0, this.onlyStreamedInstances = !1, this.ignoreUnrequestedInstances = !1, this.allowFaces = (t & Xt.Face) !== 0, this.allowLines = (t & Xt.Line) !== 0, this.allowPoints = (t & Xt.Point) !== 0;
  }
}
class Xs {
  constructor(t, e, i, s) {
    this.x = t, this.xUnit = e, this.y = i, this.yUnit = s;
  }
}
class mm {
  constructor(t, e, i) {
    this._anchor = t, this._position = e, this._size = i;
  }
  getAnchor() {
    return this._anchor;
  }
  getPosition() {
    return this._position;
  }
  getSize() {
    return this._size;
  }
}
class pm {
  /** @hidden */
  constructor(t, e) {
    this._viewer = t, this._engine = e, this._viewports = [];
    for (let i = 0; i <= this.maxIndex(); i++)
      this._viewports.push(null);
  }
  /**
   * Gets the maximum index value that can be used for indexing overlays.
   * @returns the maximum index value.
   */
  maxIndex() {
    return Gt.First - 1;
  }
  /**
   * Creates an overlay or updates an existing one.
   * @param index the index of the overlay. This value may be any number between 1 and maxIndex(). If No overlay exists for this index one will be created.
   * @param anchor the anchor point for the viewport.
   * @param x the x value of the viewport location.
   * @param xUnit the unit type of the x parameter.
   * @param y the y value of the viewport location.
   * @param yUnit the unit type of the y parameter.
   */
  setViewport(t, e, i, s, r, o, a, l, c, h) {
    if (t === 0)
      throw new Mt("Index 0 is reserved and may not be used to specify an overlay.");
    if (t < 0)
      throw new Mt(`Invalid index ${t} specified when setting viewport.`);
    if (s === Bt.ProportionOfOtherDimension && o === Bt.ProportionOfOtherDimension)
      throw new Mt("Both x and y may not be set proportional to each other");
    if (l === Bt.ProportionOfOtherDimension && h === Bt.ProportionOfOtherDimension)
      throw new Mt(
        "Both width and height may not be set proportional to each other"
      );
    this._validateUnit(i, s, "x"), this._validateUnit(r, o, "y"), this._validateUnit(a, l, "width"), this._validateUnit(c, h, "height");
    const u = new Xs(i, s, r, o), p = new Xs(a, l, c, h), m = new mm(e, u, p);
    return this._viewports[t] = m, this._engine.setOverlayViewport(
      t,
      e,
      i,
      s,
      r,
      o,
      a,
      l,
      c,
      h
    ), this._viewer._getCallbackManager().trigger("overlayViewportSet", t), Promise.resolve();
  }
  /**
   * @hidden
   * Gets the position of a viewport as it was defined with OverlayUnits
   * @param index Index to get position of
   * @returns OverlayUnitPoint expressing overlay's position
   */
  _getViewportPosition(t) {
    const e = this._viewports[t];
    return e === null ? null : e.getPosition();
  }
  /**
   * Gets position in pixels of the viewport with the supplied index, or `null` if none has been set.
   * Note: This does not take the anchor point into account
   * @param index The index of the overlay to get the position of.
   */
  getViewportPixelPosition(t) {
    const e = this._viewports[t];
    if (e === null)
      return null;
    const i = e.getPosition();
    return this._toPixelPoint(i);
  }
  /**
   * Gets the calculated position of the upper-left corner of the viewport with the supplied index, or `null`
   * if none has been set.
   * @param index The index of the overlay to get the offset of
   */
  getViewportPixelOffsetInCanvas(t) {
    const e = this.getViewportPixelPosition(t);
    if (e === null)
      return null;
    const i = this.getViewportPixelSize(t);
    if (i === null)
      return null;
    const s = this.getViewportAnchor(t);
    if (s === null)
      return null;
    const r = this._getOverlayOffset(s, i), o = E.add(r, e);
    switch (s) {
      case Jt.UpperRightCorner:
      case Jt.RightCenter:
      case Jt.LowerRightCorner:
        o.x = r.x - e.x;
        break;
    }
    switch (s) {
      case Jt.LeftCenter:
      case Jt.Center:
      case Jt.RightCenter:
      case Jt.LowerLeftCorner:
      case Jt.BottomCenter:
      case Jt.LowerRightCorner:
        o.y = r.y - e.y;
    }
    return o;
  }
  /**
   * @hidden
   * Gets the size of a viewport as it was defined with OverlayUnits
   * @param index Index to get size of
   * @returns OverlayUnitPoint expressing overlay's size
   */
  _getViewportSize(t) {
    const e = this._viewports[t];
    return e === null ? null : e.getSize();
  }
  /**
   * Gets size in pixels of the viewport with the supplied index, or `null` if none has been set.
   * @param index The index of the overlay to get the size of.
   */
  getViewportPixelSize(t) {
    const e = this._viewports[t];
    if (e === null)
      return null;
    const i = e.getSize();
    return this._toPixelPoint(i);
  }
  /**
   * Get the anchor point of the viewport with the supplied index, or `null` if none has been set.
   * @param index The index of the overlay to get the anchor of.
   */
  getViewportAnchor(t) {
    const e = this._viewports[t];
    return e === null ? null : e.getAnchor();
  }
  /**
   * Sets the visibility state for the given viewport.
   * @param index the overlay index.
   * @param visibility boolean value indicating whether the overlay should be rendered.
   */
  setVisibility(t, e) {
    return this._engine.setOverlayVisibility(t, e), Promise.resolve();
  }
  /**
   * Removes an overlay from the system. All nodes that have been assigned to this overlay will be returned to the default view.
   * @param index the index of the overlay to destroy.
   */
  destroy(t) {
    return this._engine.destroyOverlay(t), this._viewports[t] = null, Promise.resolve();
  }
  /**
   * Adds nodes into the overlay at the given index. They will no longer be rendered in the main window or any other overlay.
   * This method should not be called before the model structure ready callback has been triggered.
   * @param index the overlay index to add nodes into.
   * @param nodes the nodes to add into the overlay.
   */
  addNodes(t, e) {
    const i = this._viewer.model._gatherInstanceIncsFromNodeIds(e);
    return i.length > 0 && this._engine.addNodesToOverlay(i, t), Promise.resolve();
  }
  /**
   * Sets the camera for the given index.
   * @param index
   * @param camera
   */
  setCamera(t, e) {
    return this._engine.setOverlayCamera(t, e), Promise.resolve();
  }
  /** @hidden */
  _getOverlayOffset(t, e) {
    const s = this._viewer.view.getCanvasSize(), r = E.zero();
    return t === Jt.LowerRightCorner || t === Jt.UpperRightCorner || t === Jt.RightCenter ? r.x = s.x - e.x : (t === Jt.Center || t === Jt.TopCenter || t === Jt.BottomCenter) && (r.x = 0.5 * (s.x - e.x)), t === Jt.LowerLeftCorner || t === Jt.LowerRightCorner || t === Jt.BottomCenter ? r.y = s.y - e.y : (t === Jt.Center || t === Jt.LeftCenter || t === Jt.RightCenter) && (r.y = 0.5 * (s.y - e.y)), r;
  }
  /**
   * @hidden
   * Converts an OverlayUnitPoint to a pixel defined Point2 using the viewer's current dimensions
   * @param unitPoint Point defined with [[OverlayUnit]]s to convert
   * @returns point expressed in pixels based on viewer's current size
   */
  _toPixelPoint(t) {
    const e = this._viewer.view.getCanvasSize(), i = E.zero();
    let s = !1;
    switch (t.xUnit) {
      case Bt.Pixels:
        i.x = t.x;
        break;
      case Bt.ProportionOfCanvas:
        i.x = e.x * t.x;
        break;
      case Bt.ProportionOfOtherDimension:
        s = !0;
        break;
    }
    switch (t.yUnit) {
      case Bt.Pixels:
        i.y = t.y;
        break;
      case Bt.ProportionOfCanvas:
        i.y = e.y * t.y;
        break;
      case Bt.ProportionOfOtherDimension:
        i.y = i.x * t.y;
        break;
    }
    return s && (i.x = t.x * i.y), i;
  }
  _validateUnit(t, e, i) {
    if (e !== Bt.Pixels && (t < 0 || t > 1))
      throw new fn(
        `value for ${i} should be between 0.0 and 1.0 when specifying non pixel value`
      );
  }
}
const A0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  OverlayManager: pm,
  OverlayUnitPoint: Xs,
  OverlayViewport: mm
}, Symbol.toStringTag, { value: "Module" })), Kn = class {
  /** @hidden */
  constructor(n, t, e, i, s, r) {
    this._active = oi.Inactive, this._isSceneReady = !1, this._isModelLoaded = !1, this._isOverlayVisible = !1, this._isCallbacksSet = !1, this._onCameraUpdateFunc = this._doCameraUpdate.bind(this), this._onFrameDrawnFunc = this._onFrameDrawn.bind(this), this._floorplanNode = null, this._currentFloorInfo = null, this._config = new ma(), this._floorLock = !1, this._tightBoundings = !1, this._genericStoreyType = "IFCBUILDINGSTOREY", this._floorInfos = /* @__PURE__ */ new Map(), this._floorInfosArray = new Array(), this._avatarNode = null, this._avatarDirty = !0, this._borderNode = null, this._borderDirty = !0, this._backgroundNode = null, this._backgroundDirty = !0, this._canvasSize = new E(1, 1), this._sync = new Ns(1, !0), this._setFloorplanSync = new bf(!1), this._viewer = n, this._model = t, this._engine = i, this._modelStructure = s, this._overlayManager = e, this._config = r.copy(), this._viewer.setCallbacks({
      sceneReady: () => {
        console.assert(
          this._active !== oi.Active,
          "Got sceneReady while Floorplan is Active"
        ), this._isSceneReady = !0, this._active === oi.Activating && this._sync.push(() => this._doUpdateActivation());
      },
      modelSwitchStart: () => {
        this._isModelLoaded = !1, this._sync.push(async () => this._deactivate());
      },
      firstModelLoaded: () => {
        this._isModelLoaded = !0, this._onModelLoaded();
      },
      subtreeLoaded: () => {
        this._isModelLoaded = !0, this._onModelLoaded();
      }
    });
  }
  /** Sets a custom avatar. See [[FloorplanConfig.customAvatar]] for detailed information. */
  async setCustomAvatar(n) {
    if (this._config.customAvatar !== n)
      return await this._doSetCustomAvatar(n), this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the size of the floorplan overlay window. See [[FloorplanConfig.overlaySize]] for detailed information. */
  async setOverlaySize(n, t, e) {
    return this._config.overlaySize = n.copy(), this._config.overlayWidthUnit = t, this._config.overlayHeightUnit = e, this._onConfigurationChanged();
  }
  /** Sets the anchor position of the floorplan overlay window. See [[FloorplanConfig.overlayAnchor]] for detailed information. */
  async setOverlayAnchor(n) {
    return this._config.overlayAnchor = n, this._onConfigurationChanged();
  }
  /** Sets the offset position of the floorplan overlay window. See [[FloorplanConfig.overlayOffset]] for detailed information. */
  async setOverlayOffset(n) {
    return this._config.overlayOffset = n.copy(), this._onConfigurationChanged();
  }
  /** Sets the overlay scaling. See [[FloorplanConfig.overlayFeetPerPixel]] for detailed information. */
  async setOverlayFeetPerPixel(n) {
    return this._config.overlayFeetPerPixel = n, this._onConfigurationChanged();
  }
  /** Sets the overlay zoom level. See [[FloorplanConfig.zoomLevel]] for detailed information. */
  async setZoomLevel(n) {
    return this._config.zoomLevel = n, this._onConfigurationChanged();
  }
  /** Sets the overlay background color. See [[FloorplanConfig.backgroundColor]] for detailed information. */
  async setBackgroundColor(n) {
    return this._config.backgroundColor = n, this._backgroundDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the overlay background opacity. See [[FloorplanConfig.backgroundOpacity]] for detailed information. */
  async setBackgroundOpacity(n) {
    return this._config.backgroundOpacity = n, this._backgroundDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the overlay border color. See [[FloorplanConfig.borderColor]] for detailed information. */
  async setBorderColor(n) {
    return this._config.borderColor = n, this._borderDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the overlay border opacity. See [[FloorplanConfig.borderOpacity]] for detailed information. */
  async setBorderOpacity(n) {
    return this._config.borderOpacity = n, this._borderDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar primary color. See [[FloorplanConfig.avatarColor]] for detailed information. */
  async setAvatarColor(n) {
    return this._config.avatarColor = n, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar outline color. See [[FloorplanConfig.avatarOutlineColor]] for detailed information. */
  async setAvatarOutlineColor(n) {
    return this._config.avatarOutlineColor = n, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar opacity. See [[FloorplanConfig.avatarOpacity]] for detailed information. */
  async setAvatarOpacity(n) {
    return this._config.avatarOpacity = n, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar scale. See [[FloorplanConfig.avatarScale]] for detailed information. */
  async setAvatarScale(n) {
    return this._config.avatarScale = n, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar size to fixed scale. See [[FloorplanConfig.fixedAvatarScale]] for detailed information. */
  async setFixedAvatarScale(n) {
    if (this._config.fixedAvatarScale !== n)
      return await this._deleteAvatarNode(), this._config.fixedAvatarScale = n, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the floorplan tracking mode. See [[FloorplanConfig.trackCameraEnabled]] for detailed information. */
  async setTrackCameraEnabled(n) {
    return this._config.trackCameraEnabled = n, this._onConfigurationChanged();
  }
  /** Sets the floorplan display orientation. See [[FloorplanConfig.floorplanOrientation]] for detailed information. */
  async setFloorplanOrientation(n) {
    return this._config.floorplanOrientation = n, this._onConfigurationChanged();
  }
  /** Sets the auto-activate capability for any models loaded after this call. See [[FloorplanConfig.autoActivate]] for detailed information. */
  async setAutoActivate(n) {
    return this._config.autoActivate = n, this._onConfigurationChanged();
  }
  /** Locks floorplan to current floor such that changing floors will not change the displayed floorplan. */
  async setFloorLock(n) {
    if (this._floorLock = n, this.isActive() && !n) {
      const t = this._viewer.view.getCamera().getPosition();
      await this._setFloorplanFromPosition(t);
    }
  }
  /** Returns `true` if displayed floor has been locked with [[setFloorLock]]. */
  getFloorLock() {
    return this._floorLock;
  }
  /**
   * Makes floorplans use tight boundings during creation which can result in a better fit for the overlay.
   * This involves recreating any already existing floorplans.
   * This can be significantly more time consuming than using loose boundings if your floors are complex.
   * Defaults to `false`.
   */
  async setUseTightBoundings(n) {
    n !== this._tightBoundings && (await this._deleteAllFloorplans(), this._tightBoundings = n, this.isActive() && await this._onProcessIfc());
  }
  /**
   * Updates the floorplan to use the given configuration. This function allows
   * the user to set all configuration values with a single operation. There are
   * also `set<config-value>()` functions for easily setting individual configuration
   * values.
   *
   * Note that when using this function, all settings in the given configuration are
   * used and thus overwrite any individual settings changed with a prior
   * `set<config-value>()` call.
   *
   * All values from the passed configuration will be copied as part of this operation.
   */
  async setConfiguration(n) {
    const t = this._config.customAvatar;
    return this._config = n.copy(), t !== this._config.customAvatar && await this._doSetCustomAvatar(this._config.customAvatar), this._borderDirty = !0, this._backgroundDirty = !0, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Returns a copy of the current floorplan configuration. */
  getConfiguration() {
    return this._config.copy();
  }
  /** Gets the [[NodeId]] of the current storey. */
  getCurrentFloorNodeId() {
    return this._currentFloorInfo !== null ? this._currentFloorInfo.floorNode : null;
  }
  /** Gets the [[NodeId]] of the floorplan avatar. */
  getAvatarNodeId() {
    return this._avatarNode;
  }
  /** Returns `true` if the given point is inside the floorplan overlay and `false` otherwise. */
  insideOverlay(n) {
    const t = this._getOverlaySizeInPixels(), e = this._getOverlayOffsetInPixels();
    return n.x >= e.x && n.y >= e.y && n.x <= e.x + t.x && n.y <= e.y + t.y;
  }
  /**
   *  Activate the floorplan overlay.
   */
  async activate() {
    await this._sync.push(() => this._activate());
  }
  /**
   *  Deactivate the floorplan overlay. Once explicitly deactivated via this call, auto-activation
   *  will be suppressed for any new model that is loaded. Auto-activation can be reenabled by
   *  calling [[setAutoActivate]].
   */
  async deactivate() {
    await this._sync.push(() => this._deactivate());
  }
  /**
   * The avatar node needs to be deleted any time we are making changes to the mesh,
   * such as switching to a custom avatar or fixed avatar scale.
   */
  async _deleteAvatarNode() {
    if (this._avatarNode !== null) {
      try {
        this._modelStructure.allowNodeDeletion(this._avatarNode), await this._model.deleteNode(this._avatarNode);
      } catch (n) {
        console.log(`Problem deleting existing avatar: ${n.message}`);
      }
      this._avatarNode = null;
    }
  }
  /** Perform the steps needed to set a custom avatar. */
  async _doSetCustomAvatar(n) {
    await this._deleteAvatarNode(), this._config.customAvatar = n;
  }
  /** Call after something in the configuration has changed. Will update all visuals accordingly */
  async _onConfigurationChanged() {
    return this._config.zoomLevel = Sr(this._config.zoomLevel, 0.1, 10), this._config.avatarScale = Sr(this._config.avatarScale, 0.1, 10), this._config.backgroundOpacity = Sr(this._config.backgroundOpacity, 0, 1), this._config.borderOpacity = Sr(this._config.borderOpacity, 0, 1), this._config.avatarOpacity = Sr(this._config.avatarOpacity, 0, 1), this._isModelLoaded && this._active === oi.Inactive && this._config.autoActivate === Ls.Bim ? this._onModelLoaded() : (this._isOverlayVisible && (this._isOverlayVisible = !1, await this._setupOverlay()), this._doCameraUpdate());
  }
  /** Sets the best floorplan for the given world position */
  async _setFloorplanFromPosition(n) {
    return this._setFloorplanSync.push(() => this._doSetFloorplanFromPosition(n));
  }
  /** Sets what floor the floorplan displays based on position */
  async _doSetFloorplanFromPosition(n) {
    let t = null;
    const e = [];
    for (const s of this._floorInfosArray)
      um(n, s.bounds) && e.push(s);
    if (t = await (async (s) => {
      const r = await this._performDownwardSelection(n);
      for (const o of r) {
        const a = o.getNodeId(), l = this._model.getNodeParent(a);
        if (l === null)
          continue;
        const c = this._viewer.model.getNodeGenericType(l);
        if (c !== null) {
          if (Kn._ifcSpaceTypes.has(c)) {
            const h = await this._viewer.model.getNodesBounding([l]);
            if (!Rc(n, h))
              continue;
            for (const p of s)
              if (p.spaceNodes.indexOf(l) !== -1)
                return p;
          } else if (Kn._ifcFloorTypes.has(c)) {
            for (const h of s)
              if (h.slabNodes.indexOf(l) !== -1)
                return h;
          }
        }
      }
      return null;
    })(e), t === null) {
      for (const s of this._floorInfosArray)
        if (Rc(n, s.bounds)) {
          t = s;
          break;
        }
    }
    if (t !== null && (this._currentFloorInfo = t, this._floorplanNode === null || this._floorplanNode !== t.floorplanNode))
      return this._setFloorplanFromFloorNode(t.floorNode);
  }
  /** This function performs a downward selection and sorts the results by the top of their boundings */
  async _performDownwardSelection(n) {
    const t = new be();
    t.respectVisibility = !1, t.oneEntityPerTypePerInstance = !0;
    const e = new Gn(n, new d(0, 0, -1)), i = await this._viewer.view.pickAllFromRay(e, t), s = /* @__PURE__ */ new Map();
    for (const o of i) {
      const a = o.getNodeId(), l = await this._model.getNodesBounding([a]);
      s.set(a, l.max.z);
    }
    const r = (o, a) => {
      const l = s.get(o.getNodeId()), c = s.get(a.getNodeId());
      return l === void 0 || c === void 0 ? -1 : c - l;
    };
    return i.sort(r);
  }
  /**
   *  Will set the active state appropriately and kick off activation processing
   */
  async _activate() {
    this._active === oi.Inactive && (this._active = oi.Activating, await this._doUpdateActivation());
  }
  /**
   *  Deactivation will remove camera callbacks, hide the overlay, delete floornodes, and any other necessary cleanup
   */
  async _deactivate() {
    this._active !== oi.Inactive && (this._active = oi.Inactive, this._isCallbacksSet && (this._isCallbacksSet = !1, this._viewer.unsetCallbacks({
      camera: this._onCameraUpdateFunc,
      frameDrawn: this._onFrameDrawnFunc,
      transitionEnd: this._onCameraUpdateFunc
    })), this._isOverlayVisible = !1, await this._overlayManager.setVisibility(Gt.Floorplan, this._isOverlayVisible), this._borderNode && (await this._model.deleteNode(this._borderNode), this._borderNode = null), this._backgroundNode && (await this._model.deleteNode(this._backgroundNode), this._backgroundNode = null), await this._deleteAllFloorplans());
  }
  /**  This will be called anytime a model has loaded... first model, second model, etc. */
  async _onModelLoaded() {
    await this._sync.push(() => this._doOnModelLoaded());
  }
  /**
   * When a model is loaded, the active state will be examined and possibly modified here based on the incoming model.
   */
  async _doOnModelLoaded() {
    console.assert(this._isModelLoaded, "Model not loaded as expected");
    const n = this._model.getNodesByGenericType(this._genericStoreyType), t = n && n.size > 0;
    if (!t) {
      await this._deactivate();
      return;
    }
    this._active === oi.Inactive ? t && this._config.autoActivate === Ls.Bim && (this._active = oi.Activating) : this._active === oi.Active && (this._active = oi.Activating), this._active === oi.Activating && await this._doUpdateActivation();
  }
  /**
   *  This will activate the floorplan visuals if conditions allow.
   */
  async _doUpdateActivation() {
    this._active !== oi.Activating || !this._isSceneReady || !this._isModelLoaded || (this._active = oi.Active, this._isOverlayVisible || await this._setupOverlay(), await this._onProcessIfc(), this._isCallbacksSet || (this._isCallbacksSet = !0, this._viewer.setCallbacks({
      camera: this._onCameraUpdateFunc,
      frameDrawn: this._onFrameDrawnFunc,
      transitionEnd: this._onCameraUpdateFunc
    })));
  }
  /**
   *  Deletes all floorplan infos including generated nodes
   */
  async _deleteAllFloorplans() {
    const n = this._floorInfosArray.slice();
    this._floorInfos.clear(), this._floorInfosArray.length = 0, this._floorplanNode = null, this._currentFloorInfo = null;
    for (const t of n)
      t.floorplanNode && await this._model.deleteNode(t.floorplanNode);
  }
  /** Hides the currently active floorplan */
  async _hideActiveFloorplan() {
    this._floorplanNode !== null && (await this._hideOverlayNode(this._floorplanNode), this._floorplanNode = null, this._currentFloorInfo = null);
  }
  /**
   *  Call when IFC information is available from the model tree. Note that this call can happen multiple
   *  times within a session, thus it must be tolerant of existing data vs new data.
   */
  async _onProcessIfc() {
    console.assert(this._active === oi.Active), await this._gatherFloorInfos(), await this._doCameraUpdate();
  }
  /**
   */
  _hasFloorInfo(n) {
    return this._floorInfos.has(n);
  }
  /**
   */
  _getFloorInfo(n) {
    const t = this._floorInfos.get(n);
    return t === void 0 ? null : t;
  }
  /**
   * Creates floorplan related information from a floor node
   */
  async _createFloorInfo(n) {
    const t = new Array();
    this._gatherDescendentIfcNodes(n, Kn._ifcFloorTypes, t);
    const e = new Array();
    this._gatherDescendentIfcNodes(n, Kn._ifcSpaceTypes, e);
    const i = new Array();
    if (this._gatherDescendentIfcNodes(
      n,
      Kn._ifcFloorplanCreationTypes,
      i
    ), i.length === 0)
      return null;
    const s = await this._model.getNodesBounding(i, {
      bodyInstance: !0,
      pmiBody: !1,
      viewFrame: !1,
      tightBounding: this._tightBoundings
    }), r = new dm(
      n,
      s,
      t,
      e,
      i
    );
    return this._floorInfos.set(n, r), this._floorInfosArray.push(r), r;
  }
  /**
   *  Find the root floor nodes within the model.
   */
  async _gatherFloorInfos() {
    const n = this._model.getNodesByGenericType(Kn._genericStoreyType);
    if (n === null || n.size === 0) {
      await this._deactivate();
      return;
    }
    for (const t of us(n))
      this._hasFloorInfo(t) || await this._createFloorInfo(t);
    this._floorInfos.size === 0 && await this._deactivate();
  }
  /**
   * Gathers all descendent nodes that have IFC types matching the given IFC types
   */
  _gatherDescendentIfcNodes(n, t, e) {
    const i = this._model.getNodeChildren(n);
    for (const s of i) {
      const r = this._model.getNodeGenericType(s);
      r !== null && t.has(r) && e.push(s), this._gatherDescendentIfcNodes(s, t, e);
    }
  }
  /**
   * Creates a floorplan mesh from a FloorInfo object and returns the NodeId of the resulting mesh.
   * Note: This does not attach the created floorplan mesh to the FloorInfo param. That must be done after.
   */
  async _createFloorplanFromFloorInfo(n) {
    const t = this._model._gatherInstanceIncsFromNodeIds(
      n.floorplanMeshCreationNodes
    ), e = await this._engine.createFloorplanMesh(t), i = e[0], s = e[1];
    return this._modelStructure.createMeshInstance(
      i,
      s,
      "floorplan",
      null,
      !0,
      !0,
      !1
    );
  }
  /** We need to handle a canvas size updates, so use the frame-drawn callback */
  async _onFrameDrawn() {
    const n = this._viewer.view.getCanvasSize();
    n.equals(this._canvasSize) || (this._canvasSize = n.copy(), this._isOverlayVisible && (this._isOverlayVisible = !1, await this._setupOverlay()));
  }
  /** Updates the overlay camera based on current state */
  async _doCameraUpdate() {
    if (this.isActive()) {
      this._floorLock || await this._setFloorplanFromPosition(this._viewer.view.getCamera().getPosition());
      try {
        this._viewer.pauseRendering(), await this._updateOverlay();
      } finally {
        this._viewer.resumeRendering();
      }
    }
  }
  /**
   * Returns `true` if the [[FloorplanManager]] is fully active.
   */
  isActive() {
    return this._active === oi.Active;
  }
  /** Call anytime something in the floorplan overlay might need to change. */
  async _updateOverlay() {
    if (!this.isActive())
      return;
    const n = this._viewer.view.getCamera(), t = n.getPosition();
    let e = d.subtract(n.getTarget(), t);
    e.z = 0, e.normalize(), (isNaN(e.x) || e.length() === 0) && (e = new d(0, 1, 0)), await this._updateOverlayCamera(t, e), await this._updateOverlayNodes(t, e);
  }
  /**
   * Call anytime something in the floorplan overlay might need to change.
   */
  async _updateOverlayNodes(n, t) {
    const e = this._model, i = this._config, s = this._model.getNodeUnitMultiplier(this._model.getAbsoluteRootNode()) * 304.8, r = this._getOverlaySizeInPixels(), o = r.x / r.y, a = s * i.overlayFeetPerPixel / i.zoomLevel, l = a / o;
    let c = a * r.x, h = c / o;
    if (!i.trackCameraEnabled) {
      const C = this._getFixedCameraSize(o);
      C !== null && (c = C.x, h = C.y);
    }
    const u = new Q().setTranslationComponent(
      n.x,
      n.y,
      Kn._avatarZ
    ), p = s * i.avatarScale, m = new Q().setScaleComponent(p, p, p), g = new Q();
    g.m[0] = t.y, g.m[1] = -t.x, g.m[2] = 0, g.m[4] = t.x, g.m[5] = t.y, g.m[6] = 0, g.m[8] = 0, g.m[9] = 0, g.m[10] = 1, await this._viewer.model.setNodeMatrix(
      this._avatarNode,
      Nc([u, g, m])
    ), this._avatarDirty && (i.customAvatar === null && (e.setNodesFaceColor([this._avatarNode], i.avatarColor), e.setNodesLineColor([this._avatarNode], i.avatarOutlineColor), e.setNodesOpacity([this._avatarNode], i.avatarOpacity)), this._avatarDirty = !1), this._borderDirty && (e.setNodesLineColor([this._borderNode], i.borderColor), e.setNodesOpacity([this._borderNode], i.borderOpacity), this._borderDirty = !1), this._backgroundDirty && (e.setNodesFaceColor([this._backgroundNode], i.backgroundColor), e.setNodesOpacity([this._backgroundNode], i.backgroundOpacity), this._backgroundDirty = !1);
    const _ = c - a, y = h - l, b = new Q().setScaleComponent(_, y, 1), w = new Q();
    if (!this._config.trackCameraEnabled && this._currentFloorInfo !== null) {
      const C = this._currentFloorInfo.bounds.center();
      w.setTranslationComponent(C.x, C.y, 0);
    } else
      w.setTranslationComponent(n.x, n.y, 0);
    const v = this._config.floorplanOrientation === Wr.AvatarUp ? Nc([w, g, b]) : Q.multiply(b, w);
    await this._viewer.model.setNodeMatrix(this._borderNode, v), await this._viewer.model.setNodeMatrix(this._backgroundNode, v);
  }
  /**
   * Moves the camera such that the avatar will appear at the provided point on the overlay.
   * This is only available when the floorplan is not tracking the camera.
   * @param point Point in canvas within overlay
   */
  snapAvatarToPoint(n) {
    if (this._currentFloorInfo === null || !this.insideOverlay(n))
      return;
    if (this._config.trackCameraEnabled) {
      console.log(
        "FP: snapAvatarToPoint: currently only supported when trackCameraEnabled is false"
      );
      return;
    }
    const t = this._getOverlaySizeInPixels(), e = this._getOverlayOffsetInPixels(), i = new E(n.x - e.x, n.y - e.y), s = this._currentFloorInfo.bounds, r = s.extents(), o = r.x / r.y, a = t.x / t.y, l = this._viewer.view.getCamera(), c = l.getPosition(), h = l.getTarget();
    let u = new Q();
    if (this._config.floorplanOrientation !== Wr.NorthUp) {
      const b = d.subtract(h, c), w = new d(b.x, b.y, 0).normalize(), v = new d(0, 1, 0), C = new d(-1, 0, 0), k = Yn(C, w) > 90 ? new d(0, 0, -1) : new d(0, 0, 1), Y = Yn(v, w);
      u = Q.createFromOffAxisRotation(k, Y);
    }
    let p, m;
    a > o ? (p = r.y / t.y, m = new E(
      s.center().x - r.y / 2 * a,
      s.center().y + r.y / 2
    )) : (p = r.x / t.x, m = new E(
      s.center().x - r.x / 2,
      s.center().y + r.x / 2 / a
    ));
    let g = new d(
      i.x * p + m.x,
      m.y - i.y * p,
      c.z
    );
    g = u.transform(g);
    const _ = d.subtract(h, c), y = d.add(g, _);
    l.setPosition(g), l.setTarget(y), l.setProjection(te.Perspective), this._viewer.view.setCamera(l);
  }
  /** Figure out the pixel size of the overlay window */
  _getOverlaySizeInPixels() {
    const n = new Xs(
      this._config.overlaySize.x,
      this._config.overlayWidthUnit,
      this._config.overlaySize.y,
      this._config.overlayHeightUnit
    );
    return this._viewer.overlayManager._toPixelPoint(n);
  }
  /** Get overlay offset in pixels */
  _getOverlayOffsetInPixels() {
    const n = this._overlayManager.getViewportPixelOffsetInCanvas(
      Gt.Floorplan
    );
    return n === null ? E.zero() : n;
  }
  _getFixedCameraSize(n) {
    if (this._currentFloorInfo !== null) {
      const t = this._currentFloorInfo.bounds.extents();
      return t.x / t.y > n ? new E(t.x, t.x / n) : new E(t.y * n, t.y);
    }
    return null;
  }
  /** Updates the camera settings for the overlay. Only update if the floorplan has changed?  */
  async _updateOverlayCamera(n, t) {
    const e = this._config, i = this._getOverlaySizeInPixels(), s = i.x / i.y;
    let a = this._model.getNodeUnitMultiplier(this._model.getAbsoluteRootNode()) * 304.8 * e.overlayFeetPerPixel / e.zoomLevel * i.x, l = a / s;
    if (!e.trackCameraEnabled) {
      const h = this._getFixedCameraSize(s);
      h !== null && (a = h.x, l = h.y);
    }
    const c = new ci();
    if (c.setWidth(a), c.setHeight(l), !this._config.trackCameraEnabled && this._currentFloorInfo !== null) {
      const h = this._currentFloorInfo.bounds.center();
      c.setTarget(new d(h.x, h.y, 0)), c.setPosition(new d(h.x, h.y, 10));
    } else
      c.setTarget(new d(n.x, n.y, 0)), c.setPosition(new d(n.x, n.y, 10));
    e.floorplanOrientation === Wr.AvatarUp ? c.setUp(t) : e.floorplanOrientation === Wr.NorthUp && c.setUp(new d(0, 1, 0)), await this._overlayManager.setCamera(Gt.Floorplan, c);
  }
  /**
   * Sets the current floorplan based on the floorNode.
   *
   * @param floorNode A IFC Story node.
   */
  async _setFloorplanFromFloorNode(n) {
    await this._hideActiveFloorplan();
    const t = this._hasFloorInfo(n) ? this._getFloorInfo(n) : await this._createFloorInfo(n);
    if (t !== null) {
      if (t.floorplanNode === null) {
        const e = await this._createFloorplanFromFloorInfo(t), i = new Q();
        await this._model.setNodeMatrix(e, i, !0), await this._overlayManager.addNodes(Gt.Floorplan, [e]), t.floorplanNode = e, this._floorplanNode = e, this._currentFloorInfo = t, await this._showOverlayNode(e);
      } else
        this._floorplanNode = t.floorplanNode, this._currentFloorInfo = t, await this._showOverlayNode(t.floorplanNode);
      await this._updateOverlay();
    }
  }
  /**
   *  Creates the floorplan overlay
   */
  async _setupOverlay() {
    const n = this._config;
    console.assert(this.isActive());
    const t = this._overlayManager;
    this._isOverlayVisible = !0, await t.setViewport(
      Gt.Floorplan,
      n.overlayAnchor,
      n.overlayOffset.x,
      n.overlayOffsetXUnit,
      n.overlayOffset.y,
      n.overlayOffsetYUnit,
      n.overlaySize.x,
      n.overlayWidthUnit,
      n.overlaySize.y,
      n.overlayHeightUnit
    ), await t.setVisibility(Gt.Floorplan, this._isOverlayVisible), this._avatarNode || (this._avatarNode = this._config.customAvatar = this._config.customAvatar ?? await this._createAvatar(), this._modelStructure.preventNodeDeletion(this._avatarNode), await this._overlayManager.addNodes(Gt.Floorplan, [this._avatarNode])), this._borderNode || (this._borderNode = await this._create2dBox(!0, !1, Kn._borderZ), await this._overlayManager.addNodes(Gt.Floorplan, [this._borderNode]), this._borderDirty = !0), this._backgroundNode || (this._backgroundNode = await this._create2dBox(!1, !0, Kn._backgroundZ), await this._overlayManager.addNodes(Gt.Floorplan, [this._backgroundNode]), this._backgroundDirty = !0), await this._updateOverlay();
  }
  /** Nodes within the the overlay displays aren't honoring their visibility settings. This is a workaround
   *  until that problem is fixed. Since the floorplan is a top-down view, we can just move "hidden" nodes
   *  far enough out of the camera view so they aren't rendered.
   */
  async _hideOverlayNode(n) {
    const t = new Q();
    t.setTranslationComponent(1e30, 0, 0), await this._model.setNodeMatrix(n, t, !0);
  }
  /** See _hideOverlayNode for workaround description */
  async _showOverlayNode(n) {
    await this._model.setNodeMatrix(n, new Q(), !0);
  }
  /** Creates a simple node to show the camera-position as an avatar on the overlay */
  async _createAvatar() {
    const n = this._config.fixedAvatarScale ? 1e4 : 1, t = 1.2 / n, e = 1.5 / n, i = -1.1 / n, s = [
      0,
      e,
      0,
      -t,
      -e,
      0,
      0,
      i,
      0,
      0,
      e,
      0,
      0,
      i,
      0,
      t,
      -e,
      0
    ], r = [
      -t,
      -e,
      0,
      0,
      e,
      0,
      t,
      -e,
      0,
      0,
      i,
      0,
      -t,
      -e,
      0
    ], o = new Hi();
    o.setBackfacesEnabled(!1), o.addFaces(s, void 0, void 0, void 0), o.addPolyline(r, void 0);
    const a = await this._viewer.model.createMesh(o), l = new bn(a), c = (this._config.fixedAvatarScale ? xt.SuppressCameraScale : xt.None) | xt.ExcludeBounding;
    return l.setCreationFlags(c), await this._viewer.model.createMeshInstance(
      l,
      null,
      !0,
      !0
    );
  }
  /** Create a 2d line based box. Used for the overlay border & background */
  async _create2dBox(n, t, e) {
    const a = new Hi();
    if (n) {
      const u = [
        -0.5,
        -0.5,
        e,
        -0.5,
        0.5,
        e,
        0.5,
        0.5,
        e,
        0.5,
        -0.5,
        e,
        -0.5,
        -0.5,
        e
      ];
      a.addPolyline(u, void 0);
    }
    if (t) {
      const u = [
        0.5,
        -0.5,
        e,
        0.5,
        0.5,
        e,
        -0.5,
        0.5,
        e,
        -0.5,
        0.5,
        e,
        -0.5,
        -0.5,
        e,
        0.5,
        -0.5,
        e
      ], p = [
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1
      ];
      a.addFaces(u, p), a.setBackfacesEnabled(!1);
    }
    const l = await this._viewer.model.createMesh(a), c = new bn(l);
    return c.setCreationFlags(
      xt.ExcludeBounding | xt.DoNotReset
    ), await this._viewer.model.createMeshInstance(c, null, !0, !0);
  }
};
let ys = Kn;
ys._genericStoreyType = "IFCBUILDINGSTOREY";
ys._ifcFloorTypes = /* @__PURE__ */ new Set(["IFCSLAB"]);
ys._ifcSpaceTypes = /* @__PURE__ */ new Set(["IFCSPACE"]);
ys._ifcFloorplanCreationTypes = /* @__PURE__ */ new Set([
  "IFCWALL",
  "IFCWALLSTANDARDCASE",
  "IFCCURTAINWALL",
  "IFCSLAB",
  "IFCCOLUMN"
]);
ys._backgroundZ = -1;
ys._avatarZ = 1;
ys._borderZ = 2;
const D0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ActiveState: oi,
  FloorInfo: dm,
  FloorplanAutoActivation: Ls,
  FloorplanConfig: ma,
  FloorplanManager: ys,
  clamp: Sr,
  isPointInBox: um,
  isPointInBoxOnlyZ: Rc,
  multiplyMatrices: Nc
}, Symbol.toStringTag, { value: "Module" }));
class Dl {
  constructor() {
    this._date = /* @__PURE__ */ new Date(), this._handled = !1;
  }
  /**
   * Gets the handled state of the event
   * @returns whether the event has been handled
   */
  getHandled() {
    return this._handled;
  }
  /**
   * Sets the handled state of the event. When an event has been handled it will not propagate any further
   * @param handled Indicates whether this event has been handled.
   */
  setHandled(t) {
    this._handled = t;
  }
  /**
   * Gets the Date this event occurred
   * @returns the event Date
   */
  getDate() {
    return this._date;
  }
}
class Lc extends Dl {
  /** @hidden */
  constructor(t, e, i) {
    super(), this._keyCode = t, this._eventType = i;
  }
  /**
   * gets the key code
   * @returns the key code of the event
   */
  getKeyCode() {
    return this._keyCode;
  }
  /**
   * gets the event type
   * @returns the type of key event
   */
  getEventType() {
    return this._eventType;
  }
}
class Ph extends Dl {
  /** @hidden */
  constructor(t, e, i, s) {
    super(), this._position = new E(t, e), this._modifiers = i, this._inputType = s;
  }
  /**
   * gets the window position of the mouse pointer for this event
   * @returns the mouse position for this event
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * gets the state of the shift key
   * @returns whether the shift key was down when this event was generated
   */
  shiftDown() {
    return (this._modifiers & _e.Shift) === _e.Shift;
  }
  /**
   * gets the state of the alt key
   * @returns whether the alt key was down when this event was generated
   */
  altDown() {
    return (this._modifiers & _e.Alt) === _e.Alt;
  }
  /**
   * gets the state of the control key
   * @returns whether the control key was down when this event was generated
   */
  controlDown() {
    return (this._modifiers & _e.Control) === _e.Control;
  }
  /**
   * gets the state of the command key
   * @returns whether the command key was down when this event was generated
   */
  commandDown() {
    return (this._modifiers & _e.Command) === _e.Command;
  }
  /**
   * gets the event type
   * @returns the type of mouse event
   */
  getEventType() {
    return this._inputType;
  }
  /**
   * gets the event modifiers
   * @returns bitwise combination of KeyModifiers
   */
  getModifiers() {
    return this._modifiers;
  }
}
class Qn extends Ph {
  /**
   * Mouse Event class
   * @param positionX X window position of the mouse
   * @param positionY Y window position of the mouse
   * @param button mouse button associated with this event
   * @param buttons mouse buttons currently pressed with this event
   * @param modifiers bitwise collection of values from KeyModifiers enum
   * @param inputType the type of the event
   */
  constructor(t, e, i, s, r, o) {
    super(t, e, r, o), this._button = i, this._buttons = s;
  }
  /**
   * gets the mouse button associated with this event
   * @returns the mouse button for this event
   */
  getButton() {
    return this._button;
  }
  /**
   * gets the mouse buttons currently pressed with this event
   * @returns the mouse buttons currently pressed for this event
   */
  getButtons() {
    return this._buttons;
  }
}
class gm extends Ph {
  /**
   * Mousewheel Event class
   * @param positionX X window position of the mouse
   * @param positionY Y window position of the mouse
   * @param wheelDelta the direction the mouse wheel moved
   * @param buttons mouse buttons currently pressed with this event
   * @param modifiers bitwise collection of values from KeyModifiers enum
   * @param inputType the type of the event
   * @hidden
   */
  constructor(t, e, i, s, r, o) {
    super(t, e, r, o), this._wheelDelta = i, this._buttons = s;
  }
  /**
   * Gets the wheel delta for this event. A positive value indicates that the wheel was scrolled Up, while a negative value indicated the wheel was scrolled down.
   * @returns Wheel dela value
   */
  getWheelDelta() {
    return this._wheelDelta;
  }
  /**
   * gets the mouse buttons currently pressed with this event
   * @returns the mouse buttons currently pressed for this event
   */
  getButtons() {
    return this._buttons;
  }
}
var ls = /* @__PURE__ */ ((n) => (n[n.Dec = 0] = "Dec", n[n.Inc = 1] = "Inc", n))(ls || {});
function Xc(n, t) {
  if (t.getNodeType(n) === At.BodyInstance) {
    let e = n;
    for (; e !== null; ) {
      if (t.getNodeGenericId(e) !== null)
        return e;
      e = t.getNodeParent(e);
    }
  }
  return n;
}
class dl {
  constructor(t, e, i) {
    this.faceItem = t, this.lineItem = e, this.pointItem = i;
  }
  /**
   * Returns the most relevant selection item for the provided selection mask.
   * The priority used by this method is points -> lines -> faces.
   * For example, if your selection mask was Faces | Lines and this item contained and all fields were populated, this method would return its lineItem.
   * @param mask a selection mask used to indicate the relevancy of the item to retrieve.
   * @returns the most relevant selection item if one exists.  If no relevant item is found, null is returned.
   */
  fetchMostRelevant(t) {
    return this.pointItem !== null && t & Xt.Point ? this.pointItem : this.lineItem !== null && t & Xt.Line ? this.lineItem : this.faceItem !== null && t & Xt.Face ? this.faceItem : null;
  }
}
class pa {
  /** @hidden */
  constructor(t, e, i, s, r, o, a) {
    this._position = t.copy(), this._normal = e.copy(), this._elementIndex = i, this._elementBits = r, this._bounding = o.copy(), this._overlayIndex = s, this._isProximityFace = a;
  }
  /**
   * Returns whether or not this face entity was selected by proximity or was instead selected dead-on.
   * @returns True if this face entity was selected by proximity and false otherwise.
   */
  isProximityFace() {
    return this._isProximityFace;
  }
  /**
   * Returns whether or not this face entity is capping geometry or not.
   * @returns True if this face entity is capping geometry and false otherwise.
   */
  isCappingGeometry() {
    return this._elementIndex === -1;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      position: this._position.toJson(),
      normal: this._normal.toJson(),
      cadFaceIndex: this._elementIndex,
      cadFaceBits: this._elementBits,
      bounding: this._bounding.toJson(),
      overlayIndex: this._overlayIndex,
      isProximityFace: this._isProximityFace
    };
  }
  /**
   * Creates a new [[FaceEntity]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = d.fromJson(e.position), s = d.fromJson(e.normal), r = ni.fromJson(e.bounding), o = e.overlayIndex, a = e.isProximityFace === !0;
    return new pa(
      i,
      s,
      e.cadFaceIndex,
      o,
      e.cadFaceBits,
      r,
      a
    );
  }
  /**
   * Gets the world space position of the selection point.
   * @returns World space position of the selection point if it can be determined.
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Gets the face normal for the selection Point.
   * @returns Face normal for the selection position if it can be determined.
   */
  getNormal() {
    return this._normal.copy();
  }
  /**
   * Gets the cad face index for the selection Point.
   * @returns The index for the cad face.
   */
  getCadFaceIndex() {
    return this._elementIndex;
  }
  /**
   * Gets the cad face bits for the selection Point.
   * @returns The bits set on the cad face.
   */
  getCadFaceBits() {
    return this._elementBits;
  }
  /**
   * Gets the bounding box for the face entity
   * @returns Bounding box for the face entity
   */
  getBounding() {
    return this._bounding.copy();
  }
  /**
   * @returns The index of the overlay the entity belongs to.
   */
  overlayIndex() {
    return this._overlayIndex;
  }
}
class yo {
  constructor(t) {
    this._handle = t;
  }
}
class ga {
  /** @hidden */
  constructor(t, e, i, s, r, o, a) {
    if (this._lineSegmentVertices = [], this._elementIndex = t, this._elementBits = a, this._position = e.copy(), this._bounding = r.copy(), this._overlayIndex = o, i) {
      if (s >= 0) {
        const l = 3 * s;
        this._bestLineSegmentVertexIndex = new d(
          i[l],
          i[l + 1],
          i[l + 2]
        );
      }
      this._lineSegmentVertices.push(
        new d(i[0], i[1], i[2])
      );
      for (let l = 3; l < i.length; l += 6)
        this._lineSegmentVertices.push(
          new d(i[l], i[l + 1], i[l + 2])
        );
    }
  }
  isCappingGeometry() {
    return this._elementIndex < 0;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (const e of this._lineSegmentVertices)
      t.push(e.toJson());
    return {
      lineId: this._elementIndex,
      lineBits: this._elementBits,
      position: this._position.toJson(),
      linePoints: t,
      bounding: this._bounding.copy(),
      overlayIndex: this._overlayIndex
    };
  }
  /**
   * Creates a new [[LineEntity]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = d.fromJson(e.position), s = ni.fromJson(e.bounding), r = e.overlayIndex, o = new ga(e.lineId, i, null, -1, s, r, 0);
    for (const a of e.linePoints) {
      const l = d.fromJson(a);
      o._lineSegmentVertices.push(l);
    }
    return o;
  }
  /**
   * Gets the line identifier
   * @returns the identifier of the line that was selected
   */
  getLineId() {
    return this._elementIndex;
  }
  /**
   * Gets the closest point on the selected line
   * @returns the closest point on the line
   */
  getPosition() {
    return this._position.copy();
  }
  getPoints() {
    return this._lineSegmentVertices;
  }
  /**
   * Returns the vertex of the line that is closest to the selection
   * point.
   *
   * Clipped vertices are skipped. If the vertex is occluded, then
   * `null` is returned.
   */
  getBestVertex() {
    return this._bestLineSegmentVertexIndex ? this._bestLineSegmentVertexIndex.copy() : null;
  }
  /**
   * Gets the kine bits for the selection Point.
   * @returns The bits set on the line/edge.
   */
  getLineBits() {
    return this._elementBits;
  }
  /**
   * Gets the bounding box for the line entity
   * @returns Bounding box for the line entity
   */
  getBounding() {
    return this._bounding.copy();
  }
  /**
   * @returns The index of the overlay the entity belongs to.
   */
  overlayIndex() {
    return this._overlayIndex;
  }
}
class fm {
  constructor() {
    this.none = 0, this.face = 0, this.line = 0, this.point = 0, this.part = 0;
  }
  update(t, e) {
    switch (t.getSelectionType()) {
      case pi.None:
        e === ls.Dec ? --this.none : ++this.none;
        break;
      case pi.Face:
        e === ls.Dec ? --this.face : ++this.face;
        break;
      case pi.Line:
        e === ls.Dec ? --this.line : ++this.line;
        break;
      case pi.Point:
        e === ls.Dec ? --this.point : ++this.point;
        break;
      case pi.Part:
        e === ls.Dec ? --this.part : ++this.part;
        break;
    }
  }
  sum() {
    return this.none + this.face + this.line + this.point + this.part;
  }
}
class fa {
  /** @hidden */
  constructor(t, e, i, s) {
    this._position = t.copy(), this._elementIndex = e, this._overlayIndex = i, this._elementBits = s;
  }
  /**
   * Creates a new [[PointEntity]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = d.fromJson(e.position), s = e.overlayIndex;
    return new fa(i, e.pointId, e.pointBits, s);
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      pointId: this._elementIndex,
      pointBits: this._elementBits,
      position: this._position.toJson(),
      overlayIndex: this._overlayIndex
    };
  }
  /**
   * Gets the world space position of the selection point.
   * @returns World space position of the selection point if it can be determined.
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Gets the cad bits for the selection Point.
   * @returns The bits set on the point.
   */
  getPointBits() {
    return this._elementBits;
  }
  /**
   * Gets the point identifier
   * @returns the identifier of the point that was selected
   */
  getPointId() {
    return this._elementIndex;
  }
  /**
   * @returns The index of the overlay the entity belongs to.
   */
  overlayIndex() {
    return this._overlayIndex;
  }
}
class de {
  /** @hidden */
  constructor(t = null, e = null, i = null, s = null, r = null) {
    this._nodeId = t, this._inclusionKey = e, this._faceEntity = i, this._lineEntity = s, this._pointEntity = r;
  }
  static create(t, e, i, s, r) {
    return new de(t, e, i, s, r);
  }
  getSelectionType() {
    return this._nodeId === null ? pi.None : this._faceEntity !== null ? pi.Face : this._lineEntity !== null ? pi.Line : this._pointEntity !== null ? pi.Point : pi.Part;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      nodeId: this._nodeId,
      includeId: this._inclusionKey,
      faceEntity: this._faceEntity ? this._faceEntity.toJson() : null,
      lineEntity: this._lineEntity ? this._lineEntity.toJson() : null,
      pointEntity: this._pointEntity ? this._pointEntity.toJson() : null
    };
  }
  /** @hidden */
  static _fromJson(t) {
    const e = t;
    return new de(
      e.nodeId,
      e.includeId,
      e.faceEntity ? pa.fromJson(e.faceEntity) : null,
      e.lineEntity ? ga.fromJson(e.lineEntity) : null,
      e.pointEntity ? fa.fromJson(e.pointEntity) : null
    );
  }
  /**
   * Gets the face entity for this selection.
   * @returns the face entity if one was selected, otherwise null
   */
  getFaceEntity() {
    return this._faceEntity;
  }
  /**
   * Gets the line entity for this selection.
   * @returns the line entity if one was selected, otherwise null
   */
  getLineEntity() {
    return this._lineEntity;
  }
  /**
   * Gets the point entity for this selection.
   * @returns the point entity if one was selected, otherwise null
   */
  getPointEntity() {
    return this._pointEntity;
  }
  /**
   * Gets the part id for this selection.
   * @returns the part id associated with this selection item
   */
  getNodeId() {
    return this._nodeId ?? jd;
  }
  /**
   * Gets the include id for this selection.
   * @returns the inclusion key associated with this selection item
   */
  getInclusionKey() {
    return this._inclusionKey;
  }
  /**
   * Convenience method for getting the world space position of the selection point.
   * [[SelectionItem]]s with a type of [[SelectionType.Part]] will not have a position and null will be returned.
   * @returns World space position of the selection point if it can be determined.
   */
  getPosition() {
    return this._faceEntity !== null ? this._faceEntity.getPosition() : this._lineEntity !== null ? this._lineEntity.getPosition() : this._pointEntity !== null ? this._pointEntity.getPosition() : null;
  }
  /**
   * Gets the overlay index for this selection.
   * @returns the overlay index associated with this selection item
   */
  overlayIndex() {
    return this._faceEntity ? this._faceEntity.overlayIndex() : this._lineEntity ? this._lineEntity.overlayIndex() : this._pointEntity ? this._pointEntity.overlayIndex() : null;
  }
  /** @hidden */
  _setNodeId(t) {
    this._nodeId = t;
  }
  /**
   * Determines if two selection items are equal.
   * @param selectionItem The selection item to test against.
   * @returns whether or not the two items are equal.
   */
  equals(t) {
    return this._nodeId !== t._nodeId || this.getSelectionType() !== t.getSelectionType() ? !1 : this._faceEntity && t._faceEntity ? this._faceEntity.getCadFaceIndex() === t._faceEntity.getCadFaceIndex() : this._lineEntity && t._lineEntity ? this._lineEntity.getLineId() === t._lineEntity.getLineId() : this._pointEntity && t._pointEntity ? this._pointEntity.getPointId() === t._pointEntity.getPointId() : !0;
  }
  /** @hidden */
  _hash(t) {
    let e = this._nodeId !== null ? this._nodeId.toString(36) : "";
    return t || (e += `;${this.getSelectionType()};`, this._faceEntity && (e += this._faceEntity.getCadFaceIndex().toString(36)), e += ";", this._lineEntity && (e += this._lineEntity.getLineId().toString(36)), e += ";", this._pointEntity && (e += this._pointEntity.getPointId().toString(36))), e;
  }
  /**
   * @returns true if the object has the fields required for an [[EntitySelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isEntitySelection() {
    return this._faceEntity !== null || this._lineEntity !== null || this._pointEntity !== null;
  }
  /**
   * @returns true if the object has the fields required for a [[NodeSelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isNodeSelection() {
    return this._nodeId !== null;
  }
  /**
   * @returns true if the object has the fields required for a [[NodeEntitySelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isNodeEntitySelection() {
    return this._nodeId !== null && this.isEntitySelection();
  }
  /**
   * @returns true if the object has the fields required for a [[FaceSelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isFaceSelection() {
    return this._nodeId !== null && this._faceEntity !== null;
  }
  /**
   * @returns true if the object has the fields required for a [[LineSelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isLineSelection() {
    return this._nodeId !== null && this._lineEntity !== null;
  }
  /**
   * @returns true if the object has the fields required for a [[PointSelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isPointSelection() {
    return this._nodeId !== null && this._pointEntity !== null;
  }
}
class _m {
  constructor(t) {
    this.futureItemHash = null, this.pastItemHash = t;
  }
}
class zl {
  /** @hidden */
  constructor(t, e, i, s, r) {
    this._selectedItemsPruned = /* @__PURE__ */ new Map(), this._selectedItemsFull = /* @__PURE__ */ new Map(), this._selectedNodeCounts = /* @__PURE__ */ new Map(), this._temporalLinks = /* @__PURE__ */ new Map(), this._oldestItemHash = null, this._newestItemHash = null, this._selectedLayers = /* @__PURE__ */ new Set(), this._selectedTypes = /* @__PURE__ */ new Set(), this._nodeSelectionColor = new it(255, 255, 0), this._nodeSelectionOutlineColor = new it(255, 255, 0), this._elementSelectionColor = it.red(), this._elementSelectionOutlineColor = it.red(), this._nodeHighlightMode = Ln.HighlightAndOutline, this._nodeElementHighlightMode = Ln.HighlightAndOutline, this._highlightNodeSelection = !0, this._highlightFaceElementSelection = !0, this._highlightLineElementSelection = !0, this._highlightPointElementSelection = !0, this._selectParentIfSelected = !0, this._pruneSelectionDescendants = !0, this._ignoreEntityWhenTogglingChildSelection = !0, this._singleEntityToggleMode = !1, this._suppressImplicitRemovalCallback = !1, this._selectionFilter = null, this._incrementalBlacklistedInstanceNodes = /* @__PURE__ */ new Set(), this._engine = e, this._view = i, this._model = s, this._modelStructure = r, this._callbackManager = t, this._callbackManager.bind({
      _subtreeLoaded: (o) => {
        for (const a of o)
          this._onSubtreeLoaded(a);
        return Promise.resolve();
      }
    });
  }
  /** * @hidden */
  _init() {
    this._updateHighlightingMode(), this._engine.setHighlightColorizeCompression(0.7);
  }
  /**
   * This allows manipulating the selected NodeId.
   * To reset the filter, set it to null.
   * @param selectionFilter function that manipulates the selected NodeId.
   */
  setSelectionFilter(t) {
    this._selectionFilter = t;
  }
  /**
   * @returns [[SelectionFilter]] function or null if none is set.
   */
  getSelectionFilter() {
    return this._selectionFilter;
  }
  /**
   * Enables / disables descendant pruning and clears the current selection set.  When enabled, a parent and child will not be present in the same selection set.  This behavior is enabled by default.
   */
  setPruneSelectionDescendants(t) {
    this._pruneSelectionDescendants = t, this.clear();
  }
  /**
   * Gets whether descendant pruning is enabled.
   * See also: [[setPruneSelectionDescendants]]
   */
  getPruneSelectionDescendants() {
    return this._pruneSelectionDescendants;
  }
  /**
   * Enables / disables automatic parent selection.  When enabled, if a selected part is selected again, its parent will be selected.  This behavior is enabled by default.
   */
  setSelectParentIfSelected(t) {
    this._selectParentIfSelected = t;
  }
  /**
   * Gets whether automatic parent selection is enabled.
   * See also: [[setSelectParentIfSelected]]
   */
  getSelectParentIfSelected() {
    return this._selectParentIfSelected;
  }
  /**
   * Enables / disables ignore entity when toggling child selection mode.
   *
   * When enabled, a [[NodeSelectionItem]] that has a selected ancestor may only be toggled if it does not contain an entity selection.
   * A selection item without an entity selection is usually generated from selecting a node via a model tree control.
   * A selection item containing an entity selection is usually generated as a result of a viewport picking operation.
   *
   * This behavior is enabled by default.
   * See Also: [[toggle]]
   */
  setIgnoreEntityWhenTogglingChildSelection(t) {
    this._ignoreEntityWhenTogglingChildSelection = t;
  }
  /**
   * Gets whether ignore entity when toggling child selection mode is enabled.
   * See also: [[setIgnoreEntityWhenTogglingChildSelection]]
   */
  getIgnoreEntityWhenTogglingChildSelection() {
    return this._ignoreEntityWhenTogglingChildSelection;
  }
  /**
   * Enables / disables single entity toggle mode.
   *
   * When enabled, limits the selection set to containing only one entity selection for each node id.
   * Toggling with an entity selection that has the same node id as a [[NodeSelectionItem]]
   * already in the selection set will remove that item from the selection set.
   *
   * This behavior is disabled by default.
   * See Also: [[toggle]]
   */
  setSingleEntityToggleModeEnabled(t) {
    this._singleEntityToggleMode = t, this.clear();
  }
  /**
   * Gets whether single entity toggle mode is enabled.
   * See also: [[setSingleEntityToggleModeEnabled]]
   */
  getSingleEntityToggleModeEnabled() {
    return this._singleEntityToggleMode;
  }
  /**
   * Sets whether to generate selectionArray callbacks with implicitly removed nodes.
   *
   * For example, consider the case where you have a parent node that has a multiple child nodes.
   * Normally, if the parent begins selected and then a child is removed from the selection set
   * there will be two selectionArray callbacks generated. The first will for the removal of the
   * parent node. The second wil be for the addition of all of it's children except the one that was
   * initially removed.
   *
   * When this behavior is enabled only a single selectionArray callback will be generated for the
   * child node that was removed.
   *
   * This behavior is disabled by default.
   */
  setSuppressImplicitRemovalCallback(t) {
    this._suppressImplicitRemovalCallback = t;
  }
  /**
   * Gets whether implicit removal callbacks are being suppressed
   * See also: [[setSuppressImplicitRemovalCallback]]
   */
  getSuppressImplicitRemovalCallback() {
    return this._suppressImplicitRemovalCallback;
  }
  /**
   * Performs a selection operation from the given position on the canvas. The best candidate entity is selected.
   * This method triggers a selection event.
   * @param point The canvas position to select from.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @returns Promise that resolves when this operation has completed.
   */
  async selectFromPoint(t, e, i = ai.Set) {
    const s = await this._view.pickFromPoint(t, e);
    this._onSelectionItem(s, i);
  }
  /**
   * Performs a selection operation from the given position on the canvas. All candidate entities are selected.
   * This method triggers a selection event.
   * @param point The canvas position to select from.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @returns Promise that resolves when this operation has completed.
   */
  async selectAllFromPoint(t, e, i = ai.Set) {
    const s = await this._view.pickAllFromPoint(t, e);
    this._onSelectionItems(s, i);
  }
  /**
   * Performs a selection operation from the given world-space ray. The best candidate entity is selected.
   * This method triggers a selection event.
   * @param ray The world-space ray to perform the selection with.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @returns Promise that resolves when this operation has completed.
   */
  async selectFromRay(t, e, i = ai.Set) {
    const s = await this._view.pickFromRay(t, e);
    this._onSelectionItem(s, i);
  }
  /**
   * Performs a selection operation from the given world-space ray. All candidate entities are selected.
   * This method triggers a selection event.
   * @param ray The world-space ray to perform the selection with.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @returns Promise that resolves when this operation has completed.
   */
  async selectAllFromRay(t, e, i = ai.Set) {
    const s = await this._view.pickAllFromRay(t, e);
    this._onSelectionItems(s, i);
  }
  _onSelectionItem(t, e) {
    t.isNodeEntitySelection() ? this._processSelection(t, e) : this._triggerNullSelection();
  }
  _onSelectionItems(t, e) {
    if (e === ai.Set && this.clear(!1), t.length === 0) {
      this._triggerNullSelection();
      return;
    }
    switch (e) {
      case ai.Add:
      case ai.Set:
        this.add(t);
        break;
      case ai.Toggle:
        for (const i of t)
          this.toggle(i);
        break;
      default:
        $n();
    }
  }
  /**
   * Creates a new and active selection context for the provided selection window.
   * @param areaCssMin The minimum coordinate in css pixel space for the selection window.
   * @param areaCssMax The maximum coordinate in css pixel space for the selection window.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  beginScreenSelectByArea(t, e, i) {
    return this._view.beginScreenSelectByArea(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection ray.
   * The ray is created at the supplied ray origin and is cast into the scene.
   * Faces are selected if they lie along the ray.
   * Lines and points are selected if they lie within the ray's box radius.
   *
   * Note: Somewhat confusingly ray drill selection is actually a selection by volume.
   * The provided ray origin and radius are used to create a frustum to preform the selection.
   * This has some consequences. For example, the `SelectionResult`s returned by advancing a
   * ray drill selection will not have selection positions, since they were not selected at
   * a single point.
   * @param rayCssOrigin The coordinate in css pixel space for the selection ray's origin.
   * @param rayCssBoxRadius The radius around the ray in css pixel space used for line and point selection proximity.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  beginRayDrillSelection(t, e, i) {
    return this._view.beginRayDrillSelection(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection volume.
   * The selection volume is a convex polyhedron defined by the bounded intersection of its half-spaces.
   * @param volumePlanes The planes used to define volume. A point p is inside the volume if and only if (plane.determineSide(p) == true) for all supplied planes.
   * @param heuristicOrigin A point used to compute distances against for ordering returned results. This is typically (but not necessarily) the center of the volume.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  beginConvexPolyhedronSelection(t, e, i) {
    return this._view.beginConvexPolyhedronSelection(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection sphere.
   * @param sphereCenter The center of the selection sphere.
   * @param sphereRadius The radius of the selection sphere.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  beginSphereSelection(t, e, i) {
    return this._view.beginSphereSelection(t, e, i);
  }
  /**
   * Deactivates and destroys the provided selection context.
   * @param handle The selection context to destroy.
   */
  endIncrementalSelection(t) {
    return this._callbackManager.trigger("incrementalSelectionEnd"), this._view.endIncrementalSelection(t), Promise.resolve();
  }
  /**
   * Adds the next batch of instances selected by the supplied selection
   * context to the selection set.
   *
   * @param handle The handle to an active area selection context.
   * @param predicate An optional function that returns `true` if a given
   * [[NodeSelectionItem]] should be added to the selection set. If
   * `false` is returned, the item will not be added.
   *
   * @returns `true` if there are possibly more items to select and
   * `false` if not.
   */
  async advanceIncrementalSelection(t, e = null) {
    let i = await this._view.advanceIncrementalSelection(t);
    if (i === null)
      return !1;
    if (e !== null) {
      const s = await Promise.all(i.map(e));
      i = i.filter((r, o) => s[o]);
    }
    return this.add(i), !0;
  }
  isSelected(t) {
    return this.contains(t) ? !0 : t.isNodeSelection() ? this._findAncestor(t) !== null : !1;
  }
  /**
   * Checks whether a node, or its parents, appear in the selection set or not.
   * Note: for the purposes of this function element selections on a node
   * are considered the same as node selection.
   * @param nodeId Node to check for
   * @returns `true` if the node or its parents appear in the selection set. `false` otherwise
   */
  isNodeSelected(t) {
    for (const i of this.getResults())
      if (i.getNodeId() === t)
        return !0;
    const e = de.create(t);
    return this._findAncestor(e) !== null;
  }
  contains(t) {
    return this._selectedItemsPruned.has(t._hash(this._singleEntityToggleMode));
  }
  /**
   * Checks if the parent of a selection item is in the selection set.
   * @param selectionItem
   * @returns parent selection item, or null if not found
   */
  containsParent(t) {
    return this._findAncestor(t);
  }
  _findAncestor(t) {
    if (this._selectedItemsPruned.size > 0)
      for (; ; ) {
        const e = this._model.getNodeParent(t.getNodeId());
        if (e === null)
          return null;
        t = de.create(e);
        const i = t._hash(this._singleEntityToggleMode);
        if (this._selectedItemsPruned.has(i))
          return t;
      }
    return null;
  }
  /**
   * Adds all items in a layer to the selection set.
   * @param layerName
   * @param selectionMode
   */
  selectLayer(t, e) {
    e === ai.Set && this.clear();
    const i = [], s = this._model.getLayerIdsFromName(t);
    if (s !== null)
      for (const o of s) {
        const a = this._model.getNodesFromLayer(o, !0);
        if (a !== null)
          for (const l of a)
            i.push(de.create(l));
      }
    const r = this._selectedLayers.has(t);
    e === ai.Toggle && r ? this.remove(i) : (this.add(i), this._selectedLayers.add(t));
  }
  /**
   * Gets all selected layers.
   */
  getSelectedLayers() {
    const t = [];
    return this._selectedLayers.forEach((e) => {
      t.push(e);
    }), t;
  }
  /**
   * Adds all items with an IFC type to the selection set.
   * @param genericType
   */
  selectType(t, e) {
    e === ai.Set && this.clear();
    const i = [], s = this._model.getNodesByGenericType(t);
    s !== null && s.forEach((o) => {
      i.push(de.create(o));
    });
    const r = this._selectedTypes.has(t);
    if (e === ai.Toggle && r)
      for (const o of i)
        this.remove(o);
    else
      this.add(i), this._selectedTypes.add(t);
  }
  /**
   * Gets all selected IFC types.
   */
  getSelectedTypes() {
    const t = [];
    return this._selectedTypes.forEach((e) => {
      t.push(e);
    }), t;
  }
  /**
   * Selects a node with the given Id.
   * @param nodeId nodeId of the node to select. Pass null to clear the selection.
   * @returns the selection type of this operation.
   */
  selectNode(t, e = ai.Set) {
    if (t !== null && this._modelStructure.isIdValid(t)) {
      const i = de.create(t);
      return this._processSelection(i, e), i.getSelectionType();
    } else
      return this._processSelection(null, e), pi.None;
  }
  _triggerNullSelection() {
    this._callbackManager.trigger("selectionArray", [], !1);
  }
  _isInAxisOverlay(t) {
    const i = t.getFaceEntity();
    if (i)
      return i.overlayIndex() === 1;
    const s = t.getLineEntity();
    if (s)
      return s.overlayIndex() === 1;
    const r = t.getPointEntity();
    return r ? r.overlayIndex() === 1 : !1;
  }
  _getNodeCounts(t) {
    const e = t.getNodeId();
    let i = this._selectedNodeCounts.get(e);
    return i || (i = new fm(), this._selectedNodeCounts.set(e, i)), i;
  }
  _addToFull(t, e) {
    for (; this._selectedItemsFull.set(e, t); ) {
      const i = this._model.getNodeParent(t.getNodeId());
      if (i === null)
        return;
      t = de.create(i), e = t._hash(this._singleEntityToggleMode);
    }
  }
  _addItems(t, e) {
    const i = t.length;
    if (i === 0)
      return;
    this._callbackManager.trigger("incrementalSelectionBatchBegin");
    const s = [];
    for (let r = 0; r < i; ++r) {
      const o = this._filterItem(t[r]);
      if (o !== null && this._addImpl(o, o._hash(this._singleEntityToggleMode))) {
        const a = new An(o);
        s.push(a);
      }
    }
    s.length === 0 ? this._triggerNullSelection() : e || this._callbackManager.trigger("selectionArray", s, !1), this._callbackManager.trigger("incrementalSelectionBatchEnd");
  }
  _addItem(t, e) {
    const i = this._filterItem(t);
    if (i !== null && this._addImpl(i, i._hash(this._singleEntityToggleMode))) {
      const s = new An(i);
      e || this._callbackManager.trigger("selectionArray", [s], !1);
    } else
      this._triggerNullSelection();
  }
  /**
   * Manually adds an item or array of items to the selection set.
   * Triggers a selection event.
   * @param itemOrItems A selectionItem or selectionItem array that will be added to the current selection set.
   * @param suppressCallback Optional boolean param to suppress the selectionArray callbacks calls to this generate.
   */
  add(t, e = !1) {
    if (t === null) {
      this._triggerNullSelection();
      return;
    }
    Array.isArray(t) ? this._addItems(t, e) : this._addItem(t, e);
  }
  _filterItem(t) {
    if (this._selectionFilter === null)
      return t;
    const e = t.getNodeId(), i = this._selectionFilter(e, this._model);
    return i === e ? t : i === null ? null : de.create(i);
  }
  _addImpl(t, e) {
    if (t.getSelectionType() === pi.None)
      return !1;
    if (this._isInAxisOverlay(t))
      return !0;
    if (this._selectedItemsPruned.has(e))
      return !1;
    if (this._pruneSelectionDescendants) {
      if (this._findAncestor(t) !== null)
        return !1;
      this._removeDescendants(t);
    }
    this._selectedItemsPruned.set(e, t), this._addToFull(t, e), this._getNodeCounts(t).update(t, ls.Inc);
    const i = this._newestItemHash;
    if (this._newestItemHash = e, this._oldestItemHash || (this._oldestItemHash = e), i !== null) {
      const r = this._temporalLinks.get(i);
      r && (r.futureItemHash = e);
    }
    const s = new _m(i);
    if (this._temporalLinks.set(e, s), this._updateItemHighlight(t, !0, !0), this._modelStructure.getType(t.getNodeId()) === At.Pmi) {
      const r = this._modelStructure.getPmiTopologyReferences(t.getNodeId());
      if (r !== null)
        for (const o of r) {
          const a = o.body.getRuntimeId(), l = o.faceIds;
          for (const h of l)
            this._model.setNodeFaceHighlighted(a, h, !0);
          const c = o.edgeIds;
          for (const h of c)
            this._model.setNodeLineHighlighted(a, h, !0);
        }
    }
    return !0;
  }
  _removeUpdateLayers(t) {
    if (this._selectedLayers.size > 0) {
      const e = t.getNodeId();
      if (e !== null) {
        const i = this._model.getNodeLayerId(e);
        if (i !== null) {
          const s = this._model.getLayerName(i);
          s !== null && this._selectedLayers.delete(s);
        }
      }
    }
  }
  _removeUpdateTypes(t) {
    if (this._selectedTypes.size > 0) {
      const e = t.getNodeId();
      if (e !== null) {
        const i = this._model.getNodeGenericType(e);
        i !== null && this._selectedTypes.delete(i);
      }
    }
  }
  _removeFromFull(t, e) {
    if (this._removeUpdateLayers(t), this._removeUpdateTypes(t), this._selectedItemsFull.delete(e)) {
      const i = this._model.getNodeChildren(t.getNodeId());
      for (const s of i) {
        const r = de.create(s);
        this._removeFromFull(r, r._hash(this._singleEntityToggleMode));
      }
    }
  }
  _removeItems(t, e) {
    const i = [];
    t.forEach((s) => {
      this._removeImpl(s, s._hash(this._singleEntityToggleMode)) && i.push(new An(s));
    }), e || this._callbackManager.trigger("selectionArray", i, !0);
  }
  _removeItem(t, e) {
    if (this._removeImpl(t, t._hash(this._singleEntityToggleMode))) {
      const i = new An(t);
      e || this._callbackManager.trigger("selectionArray", [i], !0);
    }
  }
  /**
   * Manually removes an item or an array of items from the selection set.
   * Triggers a selection event.
   * @param itemOrItems A selectionItem or an array of selection items that will be removed from the current selection set.
   * @param suppressCallback Optional boolean param to suppress the selectionArray callbacks calls to this generate.
   */
  remove(t, e = !1) {
    Array.isArray(t) ? this._removeItems(t, e) : this._removeItem(t, e);
  }
  /** hidden */
  _removeImpl(t, e) {
    if (this._singleEntityToggleMode) {
      const a = this._selectedItemsPruned.get(e);
      a && (t = a);
    }
    if (!this._selectedItemsPruned.delete(e))
      return !1;
    this._removeFromFull(t, e);
    const i = this._getNodeCounts(t);
    i.update(t, ls.Dec);
    const s = this._temporalLinks.get(e);
    if (s !== void 0) {
      if (this._temporalLinks.delete(e), s.pastItemHash !== null) {
        const a = this._temporalLinks.get(s.pastItemHash);
        a && (a.futureItemHash = s.futureItemHash);
      }
      if (s.futureItemHash !== null) {
        const a = this._temporalLinks.get(s.futureItemHash);
        a && (a.pastItemHash = s.pastItemHash);
      }
      this._oldestItemHash === e && (this._oldestItemHash = s.futureItemHash), this._newestItemHash === e && (this._newestItemHash = s.pastItemHash);
    }
    let r = !0;
    const o = !1;
    if (i.sum() === 0) {
      r = !1;
      const a = t.getNodeId();
      this._selectedNodeCounts.delete(a);
    }
    return this._updateItemHighlight(t, r, o), !0;
  }
  static _selectionItemIsFromModelBrowser(t) {
    return t.getFaceEntity() === null && t.getLineEntity() === null && t.getPointEntity() === null;
  }
  /**
   * Manually adds or removes an item from the selection set.
   * Triggers a selection event.
   * @param selectionItem A selectionItem that will be added or removed from the selection set.
   */
  toggle(t) {
    const e = this._filterItem(t);
    if (e === null)
      return;
    const i = this._findAncestor(e), s = e._hash(this._singleEntityToggleMode);
    if (i !== null) {
      if (zl._selectionItemIsFromModelBrowser(t) ? this._removeImplicit(t, i, this._suppressImplicitRemovalCallback) : this._ignoreEntityWhenTogglingChildSelection || this._removeImplicit(
        de.create(e.getNodeId()),
        i,
        this._suppressImplicitRemovalCallback
      ), this._suppressImplicitRemovalCallback) {
        const r = new An(e);
        this._callbackManager.trigger("selectionArray", [r], !0);
      }
    } else if (this._selectedItemsPruned.has(s)) {
      if (this._removeImpl(e, s)) {
        const r = new An(t);
        this._callbackManager.trigger("selectionArray", [r], !0);
      }
    } else if (e !== null && this._addImpl(e, s)) {
      const r = new An(e);
      this._callbackManager.trigger("selectionArray", [r], !1);
    }
  }
  /**
   * Manually removes all currently selected items (if any) from the selection set and adds the supplied item.
   * Triggers a selection event.
   * @param selectionItem A selectionItem that will become the new selection item.
   */
  set(t) {
    this.clear(!1), this.add(t);
  }
  /**
   * Gets all current selection items.
   * @returns array of all selection items.
   */
  getResults() {
    const t = [];
    return this.each((e) => {
      t.push(e);
    }), t;
  }
  /**
   * Gets a selection at the specified index. The first selected item will be at index 0.
   * @param index index of selection item to get
   * @returns the selection result at the given index.
   */
  getResult(t) {
    const e = this.size();
    if (t < 0 || t >= e)
      return null;
    const i = e - t - 1;
    return t <= i ? this._getItemFromOldest(t) : this._getItemFromNewest(i);
  }
  _getItemFromOldest(t) {
    let e = this._oldestItemHash;
    for (; e; ) {
      if (t-- === 0)
        return this._selectedItemsPruned.get(e) || null;
      e = this._temporalLinks.get(e).futureItemHash;
    }
    return null;
  }
  _getItemFromNewest(t) {
    let e = this._newestItemHash;
    for (; e; ) {
      if (t-- === 0)
        return this._selectedItemsPruned.get(e) || null;
      e = this._temporalLinks.get(e).pastItemHash;
    }
    return null;
  }
  /**
   * Gets the least recent selection item.
   * @returns the least recently selected item (if any).
   */
  getFirst() {
    return this._oldestItemHash !== null && this._selectedItemsPruned.get(this._oldestItemHash) || null;
  }
  /**
   * Gets the most recent selection item.
   * @returns the most recently selected item (if any).
   */
  getLast() {
    return this._newestItemHash !== null && this._selectedItemsPruned.get(this._newestItemHash) || null;
  }
  /**
   * Gets the number of selection items.
   * @returns the number of selected items.
   */
  size() {
    return this._selectedItemsPruned.size;
  }
  /**
   * Iterates over all selection items.
   * The function passed in will be called once for every selection item and will receive the item as its parameter.
   * @param func a function to be called for every selection item.
   */
  each(t) {
    let e = this._oldestItemHash;
    for (; e; ) {
      const i = this._selectedItemsPruned.get(e);
      t(i), e = this._temporalLinks.get(e).futureItemHash;
    }
  }
  /**
   * Removes all items from the selection set.
   * @param triggerCallback triggers a null selection callback when true.
   */
  clear(t = !0) {
    this._selectedLayers.clear(), this._selectedTypes.clear(), this._clearHighlight(), this._selectedItemsPruned.clear(), this._selectedItemsFull.clear(), this._selectedNodeCounts.clear(), this._temporalLinks.clear(), this._oldestItemHash = null, this._newestItemHash = null, t && this._triggerNullSelection();
  }
  /**
   * Sets the color to be used when selecting nodes.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param color the color to apply to the selected node.
   */
  setNodeSelectionColor(t) {
    return this._setNodeSelectionColor(t), Promise.resolve();
  }
  _setNodeSelectionColor(t) {
    this._nodeSelectionColor.assign(t), this._updateHighlightingMode();
  }
  /**
   * Gets the color to be used when selecting nodes.
   * @returns the color that is applied to a selected node.
   */
  getNodeSelectionColor() {
    return this._nodeSelectionColor.copy();
  }
  /**
   * Sets color for the node selection outline.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param color the color to apply to the node selection outline.
   */
  setNodeSelectionOutlineColor(t) {
    return this._setNodeSelectionOutlineColor(t), Promise.resolve();
  }
  _setNodeSelectionOutlineColor(t) {
    this._nodeSelectionOutlineColor.assign(t), this._updateHighlightingMode();
  }
  /**
   * Gets the color to be used for outlining the node selection.
   * @returns the color for node selection outline.
   */
  getNodeSelectionOutlineColor() {
    return this._nodeSelectionOutlineColor.copy();
  }
  /**
   * Sets the color to use for node element selection.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param color the color to apply to selected node elements.
   */
  setNodeElementSelectionColor(t) {
    return this._setNodeElementSelectionColor(t), Promise.resolve();
  }
  _setNodeElementSelectionColor(t) {
    this._elementSelectionColor.assign(t), this._updateHighlightingMode();
  }
  /**
   * Gets the color to use for face and line selection.
   * @returns the color used for face and line selection.
   */
  getNodeElementSelectionColor() {
    return this._elementSelectionColor.copy();
  }
  /**
   * Gets the color to use for outlining node element selection.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param color the color used for outlining face and line selection.
   */
  setNodeElementSelectionOutlineColor(t) {
    return this._setNodeElementSelectionOutlineColor(t), Promise.resolve();
  }
  _setNodeElementSelectionOutlineColor(t) {
    this._elementSelectionOutlineColor.assign(t), this._updateHighlightingMode();
  }
  /**
   * Gets the color to use for outlining face and line selection.
   * @returns color the color used for outlining face and line selection.
   */
  getNodeElementSelectionOutlineColor() {
    return this._elementSelectionOutlineColor.copy();
  }
  /**
   * Gets whether face elements will be highlighted on selection.
   * @returns boolean the current value for face element selection highlighting.
   */
  getHighlightFaceElementSelection() {
    return this._highlightFaceElementSelection;
  }
  /**
   * Sets whether face elements should be highlighted when a selection occurs.
   * By default the system will automatically highlight face elements associated with a selection item.
   * @param highlightFaceElementSelection value indicating whether selected face elements should be highlighted.
   */
  setHighlightFaceElementSelection(t) {
    return this._highlightFaceElementSelection = t, this._updateHighlight(), Promise.resolve();
  }
  /**
   * Sets the highlighting mode for selected nodes. The default behavior is to highlight the node and render an overlay outline.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param highlightMode the highlighting mode that will be applied to selected nodes.
   */
  setNodeSelectionHighlightMode(t) {
    return this._setNodeSelectionHighlightMode(t), Promise.resolve();
  }
  _setNodeSelectionHighlightMode(t) {
    this._nodeHighlightMode = t, this._updateHighlightingMode();
  }
  /**
   * Gets the highlighting mode for selected nodes.
   * @returns the current
   */
  getNodeSelectionHighlightMode() {
    return this._nodeHighlightMode;
  }
  /**
   * Sets the highlighting mode for selected node elements.
   * The default behavior is to highlight the node element and render an overlay outline.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param highlightMode the highlighting mode that will be applied to selected nodes.
   */
  setNodeElementSelectionHighlightMode(t) {
    return this._setNodeElementSelectionHighlightMode(t), Promise.resolve();
  }
  _setNodeElementSelectionHighlightMode(t) {
    this._nodeElementHighlightMode = t, this._updateHighlightingMode();
  }
  getNodeElementSelectionHighlightMode() {
    return this._nodeElementHighlightMode;
  }
  /**
   * Sets whether nodes should be highlighted when a selection occurs.
   * By default, the system will automatically highlight the node associated with a selection item.
   * @param highlightNodeSelection value indicating whether selected nodes should be highlighted.
   */
  setHighlightNodeSelection(t) {
    return this._highlightNodeSelection = t, this._updateHighlight(), Promise.resolve();
  }
  /**
   * Gets whether nodes will be highlighted on selection.
   * @returns the current value for node selection highlighting.
   */
  getHighlightNodeSelection() {
    return this._highlightNodeSelection;
  }
  /**
   * Gets whether line elements will be highlighted on selection.
   * @returns boolean the current value for line element selection highlighting.
   */
  getHighlightLineElementSelection() {
    return this._highlightLineElementSelection;
  }
  /**
   * Gets whether point elements will be highlighted on selection.
   * @returns boolean the current value for point element selection highlighting.
   */
  getHighlightPointElementSelection() {
    return this._highlightPointElementSelection;
  }
  /**
   * Sets whether line elements should be highlighted when a selection occurs.
   * By default the system will automatically highlight line elements associated with a selection item.
   * @param highlightLineElementSelection value indicating whether selected line elements should be highlighted.
   */
  setHighlightLineElementSelection(t) {
    return this._highlightLineElementSelection = t, this._updateHighlight(), Promise.resolve();
  }
  /**
   * Sets whether point elements should be highlighted when a selection occurs.
   * By default the system will automatically highlight point elements associated with a selection item.
   * @param highlightPointElementSelection value indicating whether selected point elements should be highlighted.
   */
  setHighlightPointElementSelection(t) {
    return this._highlightPointElementSelection = t, this._updateHighlight(), Promise.resolve();
  }
  /**
   * Sets the pick tolerance in pixels for line and point picking.
   * If a line or point is within this pixel tolerance of the click point,
   * it will be prioritized over the face at the click position.
   *
   * The default value is 20.
   * @param Pick Tolerance value in pixels
   */
  setPickTolerance(t) {
    this._engine.setPickTolerance(t);
  }
  /**
   * Gets the pick tolerance in pixels for line and point picking.
   *
   * The default value is 20.
   * @returns number Pick tolerance value in pixels
   */
  getPickTolerance() {
    return this._engine.getPickTolerance();
  }
  /**
   * Exports selection objects so that they may be loaded back into the the system at a later time using loadSelectionData.
   * @returns exported selection data.
   */
  exportSelectionData() {
    const t = [], e = this.getResults();
    for (const i of e)
      t.push(i.toJson());
    return t;
  }
  /**
   * Loads serialized selection items exported using [[exportSelectionData]] back into the [[SelectionManager]].
   * The current selection will be cleared. A selection event will be triggered for each loaded item.
   * This method should not be called before the [[CallbackMap.modelStructureReady]] callback has been triggered.
   * @param data data to be imported in the form of a JavaScript object or JSON string
   */
  loadSelectionData(t) {
    if (this.clear(!1), typeof t == "string" && (t = JSON.parse(t), !Array.isArray(t)))
      throw new fn("Expected JSON depicting an Array.");
    const e = [];
    for (const i of t) {
      const s = de._fromJson(i);
      s.isNodeSelection() && e.push(s);
    }
    this.add(e);
  }
  _pathToParent(t, e) {
    const i = [];
    for (; !t.equals(e); ) {
      i.push(t);
      const s = this._model.getNodeParent(t.getNodeId());
      if (s === null)
        break;
      t = de.create(s);
    }
    return i;
  }
  _removeImplicit(t, e, i) {
    const s = this._pathToParent(t, e), r = (c) => {
      for (const h of s)
        if (c.equals(h))
          return !0;
      return !1;
    };
    let o = e;
    const a = [t], l = [];
    for (; s.length > 0; ) {
      a.push(o);
      const c = this._model.getNodeChildren(o.getNodeId());
      for (const h of c) {
        const u = de.create(h);
        r(u) || l.push(u);
      }
      o = s.pop();
    }
    console.assert(t === o), this.remove(a, i), this.add(l, i);
  }
  _removeDescendants(t) {
    const e = this._model.getNodeChildren(t.getNodeId());
    for (const i of e) {
      const s = de.create(i);
      this._removeDescendantsRecursive(s);
    }
  }
  _removeDescendantsRecursive(t) {
    const e = t._hash(this._singleEntityToggleMode);
    if (this._selectedItemsFull.delete(e)) {
      this._removeImpl(t, e);
      const i = this._model.getNodeChildren(t.getNodeId());
      for (const s of i) {
        const r = de.create(s);
        this._removeDescendantsRecursive(r);
      }
    }
  }
  _processSelection(t, e) {
    switch (e) {
      case ai.Add:
        this.add(t);
        break;
      case ai.Set:
        this.set(t);
        break;
      case ai.Toggle:
        t !== null && this.toggle(t);
        break;
    }
  }
  _clearHighlight() {
    this._selectedItemsPruned.size > 0 && this._engine.clearHighlight();
  }
  _updateHighlight() {
    this._clearHighlight(), this._selectedItemsPruned.forEach((t) => {
      t && this._updateItemHighlight(t, !0, !0);
    }), this._highlightNodeSelection && this._model.setNodesHighlighted([], !0);
  }
  _updateItemHighlight(t, e, i) {
    const s = t.getNodeId();
    if (this._highlightNodeSelection && this._model.setNodesHighlighted([s], e), this._model.getNodeType(s) !== At.Pmi) {
      const r = t.getFaceEntity();
      this._highlightFaceElementSelection && r !== null && !r.isCappingGeometry() && this._model.setNodeFaceHighlighted(s, r.getCadFaceIndex(), i);
      const o = t.getLineEntity();
      this._highlightLineElementSelection && o !== null && !o.isCappingGeometry() && this._model.setNodeLineHighlighted(s, o.getLineId(), i);
      const a = t.getPointEntity();
      this._highlightPointElementSelection && a !== null && this._model.setNodePointHighlighted(s, a.getPointId(), i);
    }
  }
  _updateHighlightingMode() {
    switch (this._nodeHighlightMode) {
      case Ln.HighlightOnly:
        this._engine.setNodeHighlightColor(this._nodeSelectionColor, null);
        break;
      case Ln.OutlineOnly:
        this._engine.setNodeHighlightColor(null, this._nodeSelectionOutlineColor);
        break;
      case Ln.HighlightAndOutline:
        this._engine.setNodeHighlightColor(
          this._nodeSelectionColor,
          this._nodeSelectionOutlineColor
        );
        break;
    }
    switch (this._nodeElementHighlightMode) {
      case Ln.HighlightOnly:
        this._engine.setElementHighlightColor(this._elementSelectionColor, null);
        break;
      case Ln.OutlineOnly: {
        this._nodeHighlightMode === Ln.OutlineOnly ? this._engine.setElementHighlightColor(null, this._elementSelectionOutlineColor) : this._engine.setElementHighlightColor(
          this._nodeSelectionColor,
          this._elementSelectionOutlineColor
        );
        break;
      }
      case Ln.HighlightAndOutline:
        this._engine.setElementHighlightColor(
          this._elementSelectionColor,
          this._elementSelectionOutlineColor
        );
        break;
    }
  }
  _onSubtreeLoaded(t) {
    const e = de.create(t);
    if (this.isSelected(e))
      return this._updateItemHighlight(e, !0, !0);
  }
}
const z0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CompositeSelectionItem: dl,
  FaceEntity: pa,
  IncrementalSelectionId: yo,
  LineEntity: ga,
  NodeCounts: fm,
  Op: ls,
  PointEntity: fa,
  SelectionItem: de,
  SelectionManager: zl,
  TemporalLink: _m,
  ifcSelectionFilter: Xc
}, Symbol.toStringTag, { value: "Module" }));
class An {
  /**
   * Creates a new NodeSelectionEvent
   * @hidden
   */
  constructor(t) {
    this._selection = t;
  }
  /**
   * Gets the result of the selection operator.
   * @returns the result of the selection
   */
  getType() {
    return this._selection ? this._selection.getSelectionType() : pi.None;
  }
  /**
   * Gets the selection object.
   * @returns Selection object containing detailed information about the selection
   */
  getSelection() {
    return this._selection;
  }
  /**
   * Creates a no-selection event.
   * @returns Selection event with result set to none.
   * @hidden
   */
  static _createNull() {
    return new An(de.create());
  }
}
class Ja extends Dl {
  /**
   * Touch Event class
   * @param id unique identifier for this touch
   * @param positionX X window position of the touch
   * @param positionY Y window position of the touch
   * @hidden
   */
  constructor(t, e, i, s, r) {
    super(), this._id = t, this._position = new E(e, i), this._buttons = s, this._inputType = r;
  }
  /**
   * gets the id this event
   * @returns the unique identifier for this touch
   */
  getId() {
    return this._id;
  }
  /**
   * gets the window position of the mouse pointer for this event
   * @returns the mouse position for this event
   */
  getPosition() {
    return this._position;
  }
  /**
   * gets the event type
   * @returns the type of touch event
   */
  getEventType() {
    return this._inputType;
  }
  /**
   * gets the mouse buttons currently pressed with this event
   * @returns the mouse buttons currently pressed for this event
   */
  getButtons() {
    return this._buttons;
  }
}
function N_(n) {
  switch (n) {
    case kt.MouseDown:
      return !0;
    case kt.MouseMove:
      return !0;
    case kt.MouseUp:
      return !0;
    case kt.Mousewheel:
      return !0;
    case kt.TouchStart:
      return !1;
    case kt.TouchMove:
      return !1;
    case kt.TouchEnd:
      return !1;
    case kt.KeyDown:
      return !1;
    case kt.KeyUp:
      return !1;
    case kt.ViewOrientationChange:
      return !1;
    default:
      return !1;
  }
}
const J0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  InputEvent: Dl,
  KeyInputEvent: Lc,
  MouseInputEvent: Qn,
  MouseInputEventBase: Ph,
  MouseWheelInputEvent: gm,
  NodeSelectionEvent: An,
  TouchInputEvent: Ja,
  isMouseEventType: N_
}, Symbol.toStringTag, { value: "Module" }));
class ym {
  constructor(t, e, i) {
    this._markupItems = /* @__PURE__ */ new Map(), this._activeView = null, this._selectedMarkup = null, this._pendingUpdateHandleTimer = new Os(), this._pickTolerance = 0, this._callbackManager = t, this._domElements = e, this._markupRenderer = i;
  }
  shutdown() {
    this.setActiveView(null), this._markupItems.forEach((t) => {
      t.remove();
    }), this._markupItems.clear();
  }
  _updateLater(t) {
    this._pendingUpdateHandleTimer.isIdle(mi.BeforeAction) && this._pendingUpdateHandleTimer.set(0, () => {
      this.update();
    }), t !== null && this._pendingUpdateHandleTimer.waitForIdle(mi.AfterAction).then(() => {
      t.resolve();
    });
  }
  updateLater() {
    this._updateLater(null);
  }
  update() {
    this._pendingUpdateHandleTimer.clear(), this.renderMarkup(), this.renderActiveViewMarkup();
  }
  registerMarkupItem(t) {
    const e = Qi();
    return this._markupItems.set(e, t), e;
  }
  unregisterMarkupItem(t) {
    const e = this._markupItems.get(t);
    e && (e.remove && e.remove(), this._markupItems.delete(t));
  }
  getActiveView() {
    return this._activeView;
  }
  async setActiveView(t) {
    this._selectedMarkup && (this._selectedMarkup.onDeselect(), this._selectedMarkup = null);
    const e = this._activeView;
    if (this._activeView = t, e !== null && e !== t) {
      const i = e.getMarkup();
      for (const r of i)
        r.remove();
      const s = ye();
      this._updateLater(s), await s, this._callbackManager.trigger("viewDeactivated", e);
    } else
      await this._pendingUpdateHandleTimer.waitForIdle(mi.AfterAction);
  }
  renderMarkup() {
    this._markupRenderer._setCanvas(this._domElements.getMarkupSvgElement()), this._markupRenderer._clear(), this._markupItems.forEach((t) => {
      t.draw();
    }), this._markupRenderer._finalize();
  }
  renderActiveViewMarkup() {
    if (this._markupRenderer._setCanvas(this._domElements.getRedlineSvgElement()), this._markupRenderer._clear(), !this._activeView)
      return;
    const t = this._activeView.getMarkup();
    for (const e of t)
      e.draw();
    this._markupRenderer._finalize();
  }
  getPickTolerance() {
    return this._pickTolerance;
  }
  setPickTolerance(t) {
    this._pickTolerance = t;
  }
  pick(t) {
    if (this._activeView) {
      const i = this._activeView.getMarkup();
      for (const s of i)
        if (s.hitWithTolerance(t, this._pickTolerance) || s.hit(t))
          return s;
    }
    let e = null;
    return this._markupItems.forEach((i) => {
      e === null && (i.hitWithTolerance(t, this._pickTolerance) || i.hit(t)) && (e = i);
    }), e;
  }
  select(t) {
    this._selectedMarkup && t !== this._selectedMarkup && this._selectedMarkup.onDeselect(), this._selectedMarkup = t, this._selectedMarkup && this._selectedMarkup.onSelect(), this.update();
  }
  getSelected() {
    return this._selectedMarkup;
  }
}
class bm {
  constructor(t, e) {
    this.markupView = t, this.itemResults = e;
  }
}
class qo {
  /** @hidden */
  constructor(t, e, i, s, r, o = null) {
    this._lineVisibility = !0, this._faceVisibility = !0, this._markupItems = /* @__PURE__ */ new Set(), this._sheetId = null, this._colorMap = /* @__PURE__ */ new Map(), this._snapshotImage = null, this._defaultVisibility = !0, this._visibilityExceptions = /* @__PURE__ */ new Set(), this._uniqueId = t, this._camera = i, this._name = e, this._explodeMagnitude = s, this._cuttingPlaneData = r, this._sheetId = o;
  }
  /**
   * Gets the camera of this view
   * @returns the camera of this view
   */
  getCamera() {
    return this._camera;
  }
  /**
   * Gets the sheet id for this view
   * @returns the id of the sheet for this view. If no view was active at the time of creation this function will return null.
   */
  getSheetId() {
    return this._sheetId;
  }
  /**
   * Gets the unique identifier of this view
   * @returns unique identifier of this view
   */
  getUniqueId() {
    return this._uniqueId;
  }
  /**
   * Gets the name of this view
   * @returns name of this view
   */
  getName() {
    return this._name;
  }
  /**
   * Sets the name for this view
   * @param name name to set
   */
  setName(t) {
    this._name = t;
  }
  /**
   * Gets line visibility setting for this view
   * @returns line visibility setting for this view
   */
  getLineVisibility() {
    return this._lineVisibility;
  }
  /**
   * Sets line visibility for this view
   * @param lineVisibility line visibility setting for this view
   */
  setLineVisibility(t) {
    this._lineVisibility = t;
  }
  /**
   * Gets face visibility setting for this view
   * @returns face visibility setting for this view
   */
  getFaceVisibility() {
    return this._faceVisibility;
  }
  /**
   * Sets face visibility for this view
   * @param faceVisibility face visibility setting for this view
   */
  setFaceVisibility(t) {
    this._faceVisibility = t;
  }
  /**
   * Adds a markup item to this view
   * @param markupItem the markup to be added to this view.
   */
  addMarkupItem(t) {
    this._markupItems.add(t);
  }
  /**
   * Gets an array of markup items associated with this view
   * @returns {boolean} face visibility setting for this view
   */
  getMarkup() {
    return us(this._markupItems);
  }
  /**
   * Removes a markup item from the view
   * @param markupItem the markup to be removed from this view.
   * @returns result of the removal operation
   */
  removeMarkup(t) {
    return t.remove(), this._markupItems.delete(t);
  }
  /**
   * @returns a JSON object with the cutting plane data associated with this view
   */
  getCuttingPlaneData() {
    return this._cuttingPlaneData;
  }
  /**
   * Takes a JSON cutting plane data object and associates it with this view
   * @param cuttingPlaneData
   */
  setCuttingPlaneData(t) {
    this._cuttingPlaneData = t;
  }
  /**
   * @returns the explode value associated with this view
   */
  getExplodeMagnitude() {
    return this._explodeMagnitude;
  }
  /**
   * Takes an explode magnitude and associates it with this view
   */
  setExplodeMagnitude(t) {
    this._explodeMagnitude = t;
  }
  /**
   * @returns A color map associating NodeIds to Colors.
   */
  getColorMap() {
    return this._colorMap;
  }
  /**
   * Takes a color map associating NodeIds to Colors and associates it with this view.
   * @param colorMap
   */
  setColorMap(t) {
    this._colorMap = t;
  }
  getDefaultVisibility() {
    return this._defaultVisibility;
  }
  setDefaultVisibility(t) {
    this._defaultVisibility = t;
  }
  getVisibilityExceptions() {
    return this._visibilityExceptions;
  }
  setVisibilityExceptions(t) {
    this._visibilityExceptions = t;
  }
  getSnapshotImage() {
    return this._snapshotImage;
  }
  setSnapshotImage(t) {
    this._snapshotImage = t;
  }
  _handleLoadMarkupItem(t) {
    return t instanceof _s ? (this.addMarkupItem(t), !0) : !1;
  }
  /** @hidden */
  static async _fromJson(t, e) {
    const i = t, s = ci.fromJson(i.camera);
    let r;
    if (i.hasOwnProperty("sheetId") && i.sheetId) {
      const p = parseInt(t.sheetId, 10);
      isNaN(p) || (r = p);
    }
    const o = new qo(
      i.uniqueId,
      i.name,
      s,
      i.explodeMagnitude,
      i.cuttingData,
      r
    );
    if (o.setLineVisibility(i.lineVisibility), o.setFaceVisibility(i.faceVisibility), i.defaultVisibility !== void 0 && i.visibilityExceptions !== void 0) {
      o.setDefaultVisibility(i.defaultVisibility);
      const p = /* @__PURE__ */ new Set();
      i.visibilityExceptions.forEach((m) => {
        p.add(m);
      }), o.setVisibilityExceptions(p);
    }
    const a = /* @__PURE__ */ new Map(), l = i.colors;
    if (Array.isArray(l))
      for (const p of l) {
        const m = p[0], g = it.fromJson(p[1]);
        a.set(m, g);
      }
    o.setColorMap(a);
    const c = [];
    console.assert(Array.isArray(i.markup));
    for (const p of i.markup) {
      const m = ph(p.className);
      if (m) {
        const g = m(p, e);
        g instanceof Promise ? c.push(
          g.then((_) => o._handleLoadMarkupItem(_))
        ) : c.push(Promise.resolve(o._handleLoadMarkupItem(g)));
      }
    }
    const h = i.imageSrc;
    if (h !== void 0 && h.length > 0) {
      const p = new Image();
      p.src = h, o.setSnapshotImage(p);
    }
    const u = await Promise.all(c);
    return new bm(o, u);
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = {
      uniqueId: this._uniqueId,
      name: this._name,
      camera: this._camera.toJson(),
      cuttingData: this._cuttingPlaneData,
      explodeMagnitude: this._explodeMagnitude,
      lineVisibility: this._lineVisibility,
      faceVisibility: this._faceVisibility,
      markup: [],
      sheetId: this._sheetId,
      defaultVisibility: this._defaultVisibility,
      visibilityExceptions: [],
      colors: [],
      imageSrc: ""
    };
    return this._markupItems.forEach((e) => {
      const i = e.toJson();
      i.className = e.getClassName(), t.markup.push(i);
    }), this._visibilityExceptions.forEach((e) => {
      t.visibilityExceptions.push(e);
    }), this._colorMap.forEach((e, i) => {
      t.colors.push([i, e.toJson()]);
    }), this._snapshotImage !== null && (t.imageSrc = this._snapshotImage.src), t;
  }
}
const R_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RedlineItem: Qr
}, Symbol.toStringTag, { value: "Module" }));
class Wi extends da {
  /**
   * Creates a new Line Shape
   * @param p1 Optional first point on the line. If omitted, default value of (0,0) is used.
   * @param p2 Optional second point on the line. If omitted, default value of (0,0) is used.
   * @returns new Line object.
   */
  constructor(t, e) {
    super(), t ? this._p1 = t.copy() : this._p1 = E.zero(), e ? this._p2 = e.copy() : this._p2 = E.zero();
  }
  /**
   * Sets the points that define the line segment
   * @param p1 first point of the line segment
   * @param p2 second point of the line segment
   */
  set(t, e) {
    this._p1.assign(t), this._p2.assign(e);
  }
  /**
   * Gets the first point of the line segment
   * @returns the first point of the line segment
   */
  getP1() {
    return this._p1.copy();
  }
  /**
   * Sets the first point of the line segment
   * @param p1 first point of the line segment
   */
  setP1(t) {
    this._p1.assign(t);
  }
  /**
   * Gets the second point of the line segment
   * @returns the second point of the line segment
   */
  getP2() {
    return this._p2;
  }
  /**
   * sets the first point of the line segment
   * @param p2 second point of the line segment
   */
  setP2(t) {
    this._p2.assign(t);
  }
}
class Im {
  constructor(t, e) {
    this.p1 = t.copy(), this.p2 = e.copy();
  }
}
class L_ extends da {
  constructor() {
    super(...arguments), this._lines = [];
  }
  /**
   * Adds a line segment to the collection
   * @param p1 first point of the line segment
   * @param p2 second point of the line segment
   */
  addLine(t, e) {
    this._lines.push(new Im(t, e));
  }
  /**
   * Gets the lines in the collection
   */
  getLines() {
    return this._lines;
  }
  /**
   * Removes all line segments from this collection
   */
  clear() {
    this._lines = [];
  }
}
class wm extends gr {
  constructor() {
    super(...arguments), this._points = [];
  }
  /**
   * Removes all points from this polygon
   */
  clearPoints() {
    this._points = [];
  }
  /**
   * Gets the points in this polyline
   * @returns the points in this polygon
   */
  getPoints() {
    return this._points;
  }
  /**
   * Adds a point to the polygon
   * @param point the point to add to the polygon
   */
  pushPoint(t) {
    this._points.push(t.copy());
  }
}
class X_ extends gr {
  constructor() {
    super(...arguments), this._polygons = [];
  }
  /**
   * Removes all polygons from the collection
   */
  clear() {
    this._polygons = [];
  }
  /**
   * Creates a new array of points that represent a polygon. Add Point2 objects to the array to construct the polygon
   * @returns new array which represents a polygon.
   */
  createPolygon() {
    const t = [];
    return this._polygons.push(t), t;
  }
  /**
   * @returns the polylines in this collection
   */
  getPolygons() {
    return this._polygons;
  }
}
class Jl extends gr {
  /** @hidden */
  constructor() {
    super(), this._fontFamily = null, this._fontSize = 12, this.setStrokeWidth(0);
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._fontFamily = t._fontFamily, this._fontSize = t._fontSize;
  }
  /**
   * Gets the font family for this text
   * @returns the font family
   */
  getFontFamily() {
    return this._fontFamily;
  }
  /**
   * Sets the font family this shape
   * @param fontFamily font family to use for this text
   */
  setFontFamily(t) {
    this._fontFamily = t;
  }
  /**
   * Sets the font size for this text
   * @param fontSize size to use for this text
   */
  setFontSize(t) {
    this._fontSize = t;
  }
  /**
   * Gets the font size for this text
   * @returns the font size
   */
  getFontSize() {
    return this._fontSize;
  }
}
class F_ extends Jl {
  /**
   * Creates a new markup text item.
   * @param text the text associated with this item.
   * @param position the screen space point of the top left of the text string.
   */
  constructor(t, e) {
    super(), this._position = E.zero(), this._text = "", e && (this._position = e.copy()), t && this.setText(t);
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._text = t._text, this._position.assign(t._position);
  }
  /**
   * Sets the text position
   * @returns the top left position to render text from
   */
  setPosition(t) {
    this._position.assign(t);
  }
  /**
   * Gets the text position
   * @returns the text position
   */
  getPosition() {
    return this._position;
  }
  /**
   * Sets the text content
   * @param text the text to render
   */
  setText(t) {
    this._text = t;
  }
  /**
   * Gets the text content
   * @returns the text content
   */
  getText() {
    return this._text;
  }
}
class Vh {
  constructor(t, e) {
    this.text = t, this.position = e.copy();
  }
}
class vm extends Jl {
  constructor() {
    super(...arguments), this._textStrings = [];
  }
  /**
   * Removes all text strings from this collection
   */
  clear() {
    this._textStrings = [];
  }
  /**
   * Adds a string to the collection
   * @param text the text to render
   * @param position the top left position of the text
   */
  addString(t, e) {
    this._textStrings.push(new Vh(t, e));
  }
  /**
   * Gets the strings in the collection
   */
  getStrings() {
    return this._textStrings;
  }
}
class Yh {
  /** @hidden */
  constructor() {
    this._padding = 5, this._text = new Jl(), this._box = new Fl(), this._box.setFillOpacity(0), this._box.setFillColor(it.white());
  }
  /** @hidden */
  _assign(t) {
    this._text._assign(t._text), this._box._assign(t._box), this._padding = t._padding;
  }
  /**
   * Gets the Text portion of the TextBox. Use the methods on this object to modify the appearance of the text string
   * @returns the text markup object
   */
  getTextPortion() {
    return this._text;
  }
  /**
   * Gets the Box portion of the TextBox. Use the methods on this object to modify the appearance of the rectangle around the text string
   * @returns the rectangle markup object.
   */
  getBoxPortion() {
    return this._box;
  }
  /**
   * Gets the Pixel distance between the text and outer rectangle
   * @returns the padding value.
   */
  getPadding() {
    return this._padding;
  }
  /**
   * Sets the Pixel distance between the text and outer rectangle
   * @param padding the padding value.
   */
  setPadding(t) {
    this._padding = t;
  }
}
class qr extends Yh {
  /**
   * Creates a new TextBox Markup Shape.
   * @param position the screen space point of the top left of the box. Default value is (0,0).
   * @param text the text string for the box. Default value is empty string.
   */
  constructor(t, e) {
    super(), this._position = E.zero(), this._textStr = "", t && this._position.assign(t), e && (this._textStr = e);
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._position.assign(t._position);
  }
  /**
   * Gets the position in screen space of the top-left corner of the TextBox rectangle
   * @returns the TextBox position
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Sets the position in screen space of the top-left corner of the TextBox rectangle
   * @param position the TextBox position
   */
  setPosition(t) {
    this._position.assign(t);
  }
  /**
   * Gets the text string for this box
   * @returns the text string
   */
  getTextString() {
    return this._textStr;
  }
  /**
   * Sets the text string for this box
   * @param text the text string
   */
  setTextString(t) {
    this._textStr = t;
  }
}
class K_ extends Yh {
  constructor() {
    super(...arguments), this._textStrings = [];
  }
  /**
   * Removes all text strings from this collection
   */
  clear() {
    this._textStrings = [];
  }
  /**
   * Adds a string to the collection
   * @param text the text to render
   * @param position the top left position of the text
   */
  addString(t, e) {
    this._textStrings.push(new Vh(t, e));
  }
  /**
   * Gets the strings in the collection
   */
  getStrings() {
    return this._textStrings;
  }
}
const O_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Circle: qn,
  CircleCollection: Mh,
  EndcapShape: da,
  EndcapType: ii,
  FilledShape: gr,
  Line: Wi,
  LineCollection: L_,
  Polygon: wm,
  PolygonCollection: X_,
  Polyline: fr,
  PolylineCollection: Y_,
  Rectangle: Kl,
  RectangleBase: Fl,
  RectangleCollection: G_,
  StrokedShape: kh,
  Text: F_,
  TextBox: qr,
  TextBoxBase: Yh,
  TextBoxCollection: K_,
  TextCollection: vm,
  TextMarkupBase: Jl,
  _MarkupCircleData: cm,
  _MarkupLineData: Im,
  _MarkupRectangleData: hm,
  _MarkupTextData: Vh
}, Symbol.toStringTag, { value: "Module" })), Ji = "http://www.w3.org/2000/svg";
function Dr(n) {
  return `rgb(${n.r}, ${n.g}, ${n.b})`;
}
function Fc(n) {
  let t = "";
  for (let e = 0; e < n.length; e++)
    e && (t += " "), t += `${n[e].x},${n[e].y}`;
  return t;
}
function Kc(n, t) {
  const e = n * 1.1, i = new E(e, 0), s = new E(e, n), r = new E(0, n / 2), o = document.createElementNS(Ji, "marker");
  o.id = Qi(), o.markerWidth.baseVal.value = e, o.markerHeight.baseVal.value = n, o.setOrientToAuto(), o.refY.baseVal.value = n / 2;
  const a = `M${i.x},${i.y} L${s.x},${s.y} L${r.x},${r.y} Z`, l = document.createElementNS(Ji, "path");
  return l.setAttribute("d", a), l.setAttributeNS(null, "fill", Dr(t)), o.appendChild(l), o;
}
function Oc(n, t) {
  const e = n * 1.1, i = E.zero(), s = new E(0, n), r = new E(e, n / 2), o = document.createElementNS(Ji, "marker");
  o.id = Qi(), o.markerWidth.baseVal.value = e, o.markerHeight.baseVal.value = n, o.setOrientToAuto(), o.refY.baseVal.value = n / 2, o.refX.baseVal.value = n;
  const a = `M${i.x},${i.y} L${s.x},${s.y} L${r.x},${r.y} Z`, l = document.createElementNS(Ji, "path");
  return l.setAttribute("d", a), l.setAttributeNS(null, "fill", Dr(t)), o.appendChild(l), o;
}
function Ac(n, t, e, i) {
  const s = e / 2, r = Dr(i), o = document.createElementNS(Ji, "circle");
  return o.setAttributeNS(null, "cx", n.x.toString()), o.setAttributeNS(null, "cy", n.y.toString()), o.setAttributeNS(null, "r", s.toString()), o.setAttributeNS(null, "fill", r), t > 0 && (o.setAttributeNS(null, "stroke-width", t.toString()), o.setAttributeNS(null, "stroke", r)), o;
}
class xm {
  constructor() {
    this._svgCanvas = null, this._svgDefsElement = null, this._svgElements = [], this._svgTextElements = [];
  }
  _setCanvas(t) {
    this._svgCanvas = t, this._svgDefsElement = document.createElementNS(Ji, "defs"), this._svgCanvas.appendChild(this._svgDefsElement);
  }
  _clear() {
    if (this._svgCanvas === null || this._svgDefsElement === null)
      throw new Mt("canvas not set");
    for (; this._svgCanvas.firstChild; )
      this._svgCanvas.removeChild(this._svgCanvas.firstChild);
    for (this._svgElements = [], this._svgTextElements = []; this._svgDefsElement.firstChild; )
      this._svgDefsElement.removeChild(this._svgDefsElement.firstChild);
    this._svgCanvas.appendChild(this._svgDefsElement);
  }
  _finalize() {
    if (this._svgCanvas === null)
      throw new Mt("canvas not set");
    for (const t of this._svgElements)
      this._svgCanvas.appendChild(t);
    for (const t of this._svgTextElements)
      this._svgCanvas.appendChild(t);
  }
  drawCircle(t) {
    return this._addCircleNode(t.getCenter(), t.getRadius(), t);
  }
  drawCircles(t) {
    const e = t.getCircles(), i = [];
    for (const s of e) {
      const r = this._addCircleNode(s.center, s.radius, t);
      i.push(r);
    }
    return i;
  }
  drawLine(t) {
    return this._addLineElement(t.getP1(), t.getP2(), t);
  }
  drawLines(t) {
    const e = t.getLines(), i = [];
    for (const s of e) {
      const r = this._addLineElement(s.p1, s.p2, t);
      i.push(r);
    }
    return i;
  }
  drawText(t) {
    return this._addTextElement(t.getText(), t.getPosition(), t);
  }
  drawTexts(t) {
    const e = t.getStrings(), i = [];
    for (const s of e) {
      const r = this._addTextElement(s.text, s.position, t);
      i.push(r);
    }
    return i;
  }
  measureText(t, e) {
    if (this._svgCanvas === null)
      throw new Mt("canvas not set");
    const i = this._createTextElement(t, E.zero(), e);
    this._svgCanvas.appendChild(i);
    const s = i.getBoundingClientRect(), r = new E(s.width, s.height);
    return this._svgCanvas.removeChild(i), r;
  }
  measureTextBox(t) {
    const e = this.measureText(t.getTextString(), t.getTextPortion());
    return e.x += 2 * t.getBoxPortion().getStrokeWidth(), e.y += 2 * t.getBoxPortion().getStrokeWidth(), e.x += 2 * t.getPadding(), e.y += 2 * t.getPadding(), e;
  }
  drawPolyline(t) {
    return this._addPolylineElement(t.getPoints(), t);
  }
  drawPolylines(t) {
    const e = t.getPolylines(), i = [];
    for (const s of e) {
      const r = this._addPolylineElement(s, t);
      i.push(r);
    }
    return i;
  }
  drawPolygon(t) {
    return this._addPolygonElement(t.getPoints(), t);
  }
  drawPolygons(t) {
    const e = t.getPolygons(), i = [];
    for (const s of e) {
      const r = this._addPolygonElement(s, t);
      i.push(r);
    }
    return i;
  }
  drawRectangle(t) {
    return this._addRectangleElement(t.getPosition(), t.getSize(), t);
  }
  drawRectangles(t) {
    const e = t.getRectangles(), i = [];
    for (const s of e) {
      const r = this._addRectangleElement(s.position, s.size, t);
      i.push(r);
    }
    return i;
  }
  drawTextBox(t) {
    return this._addTextBoxElement(t.getTextString(), t.getPosition(), t);
  }
  drawTextBoxes(t) {
    const e = t.getStrings(), i = [];
    for (const s of e) {
      const r = this._addTextBoxElement(s.text, s.position, t);
      i.push(r);
    }
    return i;
  }
  _addTextBoxElement(t, e, i) {
    const s = this.measureText(t, i.getTextPortion());
    s.x += 2 * i.getPadding(), s.y += 2 * i.getPadding();
    const r = [], o = this._addRectangleElement(
      e,
      s,
      i.getBoxPortion(),
      !0
    );
    r.push(o);
    const a = e.copy();
    a.x += i.getPadding(), a.y += i.getPadding() / 2 + i.getBoxPortion().getStrokeWidth();
    const l = this._addTextElement(t, a, i.getTextPortion());
    return r.push(l), r;
  }
  _renderEndcaps(t, e, i, s) {
    if (this._svgDefsElement === null)
      throw new Mt("canvas not set");
    if (i.getStartEndcapType() === ii.Arrowhead) {
      let r;
      i.getEndcapsInverted() ? (r = Oc(
        i.getStartEndcapSize(),
        i.getStartEndcapColor()
      ), r.refX.baseVal.value = i.getStartEndcapSize()) : r = Kc(
        i.getStartEndcapSize(),
        i.getStartEndcapColor()
      ), s.style.markerStart = `url(#${r.id})`, this._svgDefsElement.appendChild(r);
    } else if (i.getStartEndcapType() === ii.Circle) {
      const r = Ac(
        t,
        i.getStrokeWidth(),
        i.getStartEndcapSize(),
        i.getStartEndcapColor()
      );
      this._addSVGElement(r);
    }
    if (i.getEndEndcapType() === ii.Arrowhead) {
      let r;
      i.getEndcapsInverted() ? r = Kc(i.getEndEndcapSize(), i.getEndEndcapColor()) : r = Oc(i.getEndEndcapSize(), i.getEndEndcapColor()), s.style.markerEnd = `url(#${r.id})`, this._svgDefsElement.appendChild(r);
    } else if (i.getEndEndcapType() === ii.Circle) {
      const r = Ac(
        e,
        i.getStrokeWidth(),
        i.getEndEndcapSize(),
        i.getEndEndcapColor()
      );
      this._addSVGElement(r);
    }
  }
  _createTextElement(t, e, i) {
    const s = document.createElementNS(Ji, "text"), r = t.split(`
`);
    for (const a of r) {
      const l = document.createElementNS(Ji, "tspan");
      l.textContent = a, l.setAttributeNS(null, "x", `${e.x}`), l.setAttributeNS(null, "dy", "1.2em"), s.appendChild(l);
    }
    const o = i.getFontFamily();
    return o && s.setAttributeNS(null, "font-family", o), s.setAttributeNS(null, "font-size", i.getFontSize().toString()), s.setAttributeNS(null, "x", `${e.x}`), s.setAttributeNS(null, "y", `${e.y}`), this._setGenericFillAttributes(s, i), this._setGenericStrokeAttributes(s, i), s;
  }
  _addTextElement(t, e, i) {
    const s = this._createTextElement(t, e, i);
    return this._addSVGTextItemElement(s), s;
  }
  _addRectangleElement(t, e, i, s = !1) {
    const r = document.createElementNS(Ji, "rect");
    r.setAttributeNS(null, "x", t.x.toString()), r.setAttributeNS(null, "y", t.y.toString()), r.setAttributeNS(null, "width", e.x.toString()), r.setAttributeNS(null, "height", e.y.toString());
    const o = i.getBorderRadius();
    return o > 0 && (r.setAttributeNS(null, "rx", o.toString()), r.setAttributeNS(null, "ry", o.toString())), this._setGenericFillAttributes(r, i), this._setGenericStrokeAttributes(r, i), s ? this._addSVGTextItemElement(r) : this._addSVGElement(r), r;
  }
  _addLineElement(t, e, i) {
    const s = document.createElementNS(Ji, "line");
    return s.setAttributeNS(null, "x1", t.x.toString()), s.setAttributeNS(null, "y1", t.y.toString()), s.setAttributeNS(null, "x2", e.x.toString()), s.setAttributeNS(null, "y2", e.y.toString()), this._setGenericStrokeAttributes(s, i), this._addSVGElement(s), this._renderEndcaps(t, e, i, s), s;
  }
  _addPolygonElement(t, e) {
    const i = Fc(t), s = document.createElementNS(Ji, "polygon");
    return s.setAttributeNS(null, "points", i), this._setGenericStrokeAttributes(s, e), this._setGenericFillAttributes(s, e), this._addSVGElement(s), s;
  }
  _addPolylineElement(t, e) {
    const i = Fc(t), s = document.createElementNS(Ji, "polyline");
    return s.setAttributeNS(null, "points", i), s.setAttributeNS(null, "fill", "none"), this._renderEndcaps(t[0], t[t.length - 1], e, s), this._setGenericStrokeAttributes(s, e), this._addSVGElement(s), s;
  }
  _addCircleNode(t, e, i) {
    const s = document.createElementNS(Ji, "circle");
    return s.setAttributeNS(null, "cx", t.x.toString()), s.setAttributeNS(null, "cy", t.y.toString()), s.setAttributeNS(null, "r", e.toString()), this._setGenericFillAttributes(s, i), this._setGenericStrokeAttributes(s, i), this._addSVGElement(s), s;
  }
  _setGenericFillAttributes(t, e) {
    t.setAttributeNS(null, "fill", Dr(e.getFillColor())), t.setAttributeNS(null, "fill-opacity", e.getFillOpacity().toString());
  }
  _setGenericStrokeAttributes(t, e) {
    t.setAttributeNS(null, "stroke", Dr(e.getStrokeColor())), t.setAttributeNS(null, "stroke-width", e.getStrokeWidth().toString());
  }
  _addSVGTextItemElement(t) {
    this._svgTextElements.push(t);
  }
  _addSVGElement(t) {
    this._svgElements.push(t);
  }
}
const A_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SVGMarkupRenderer: xm,
  createCircleMarker: Ac,
  createEndArrowMarker: Oc,
  createStartArrowMarker: Kc,
  svgColorRgbString: Dr,
  svgNamespace: Ji,
  svgPointString: Fc
}, Symbol.toStringTag, { value: "Module" })), B0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Line: E_,
  MarkupItem: _s,
  MarkupItemManager: ym,
  MarkupView: qo,
  Redline: R_,
  Shapes: O_,
  Svg: A_,
  _MarkupViewConstruction: bm
}, Symbol.toStringTag, { value: "Module" })), Sm = 45, Zm = -45, Cm = 150, km = 30;
function Mm(n) {
  Zr(n, Ot.Forward, Ot.Backward), Zr(n, Ot.Left, Ot.Right), Zr(n, Ot.Up, Ot.Down), Zr(n, Ot.RotateLeft, Ot.RotateRight), Zr(n, Ot.TiltUp, Ot.TiltDown);
}
function Zr(n, t, e) {
  n.has(t) && n.has(e) && (n.delete(t), n.delete(e));
}
function Dc(n, t, e) {
  return Math.max(Math.min(n, e), t);
}
function Wm(n) {
  const t = n.getViewAxes().upVector;
  return console.assert(t.isAxis()), d.scale(t, -1);
}
function Gh(n, t) {
  const e = new be(Xt.Face);
  return e.bimMask = n, e.ignoreOverlays = !0, t !== null && (e.maxWorldDistance = t), e;
}
async function zc(n, t, e, i) {
  const s = new Gn(t, e), r = Gh(ei.Floor, i), o = await n.pickFromRay(s, r);
  return o.isFaceSelection() ? o.getPosition() : null;
}
async function Pm(n, t, e, i) {
  const s = new Gn(t, e.copy().normalize()), r = Gh(ei.Wall, i), o = await n.pickFromRay(s, r);
  return o.isFaceSelection() ? o : null;
}
class D_ {
  constructor() {
    this._action = new fs(!0), this._latestPromise = null, this._timestamp = 0;
  }
  isIdle() {
    return this._latestPromise === null && this._action.isIdle();
  }
  /**
   * Returned promise can reject if future calls are made. This is by design.
   */
  set(t) {
    const e = ++this._timestamp;
    this._latestPromise !== null && this._latestPromise.reject(void 0);
    const i = ye();
    return this._latestPromise = i, this._action.clear(), this._action.waitForIdle().then(() => {
      e === this._timestamp && this._action.set(() => {
        if (e !== this._timestamp)
          return;
        i === this._latestPromise && (this._latestPromise = null), typeof t == "function" && (t = ji.create(t));
        let s;
        try {
          s = t.get();
        } catch (r) {
          return this._advance(i, !0, r);
        }
        return s === void 0 ? this._advance(i, !1, null) : s.then(
          () => this._advance(i, !1, null),
          (r) => this._advance(i, !0, r)
        );
      });
    }), i;
  }
  _advance(t, e, i) {
    t === this._latestPromise && (this._latestPromise = null), e ? t.reject(i) : t.resolve();
  }
}
class Jc {
  constructor(t, e) {
    this._button = t, this._modifier = e;
  }
  getButton() {
    return this._button;
  }
  getModifier() {
    return this._modifier;
  }
}
class xe {
  /** @hidden */
  constructor(t) {
    this._ptFirst = E.zero(), this._ptPrevious = E.zero(), this._ptCurrent = E.zero(), this._dragging = !1, this._dragCount = 0, this._primaryTouchId = null, this._mapping = [], this._buttonModifierActive = !1, this._doubleClickInterval = 200, this._firstMouseDownTime = null, this._isDoubleClick = !1, this._viewer = t;
  }
  /** @hidden */
  onDoubleClick(t) {
  }
  /** @hidden */
  onMouseDown(t) {
    if (this._firstMouseDownTime ? Date.now() - this._firstMouseDownTime < this._doubleClickInterval ? (this._isDoubleClick = !0, this._firstMouseDownTime = null) : this._firstMouseDownTime = Date.now() : (this._firstMouseDownTime = Date.now(), this._isDoubleClick = !1), this._isDoubleClick)
      this.onDoubleClick(t);
    else {
      if (this._buttonModifierActive = this.checkMapping(t), this._buttonModifierActive) {
        const e = t.getPosition();
        this._ptFirst.assign(e), this._ptPrevious.assign(e), this._ptCurrent.assign(e);
      }
      this._dragging = !0;
    }
  }
  /** @hidden */
  onMouseMove(t) {
    this.isActive() && (this._ptPrevious.assign(this._ptCurrent), this._ptCurrent.assign(t.getPosition()), this._dragging && (this._ptCurrent.equals(this._ptPrevious) || (++this._dragCount, this._dragCount === 1 && this._viewer.trigger("beginInteraction"))));
  }
  /** @hidden */
  onMouseUp(t) {
    this._buttonModifierActive && this.stopInteraction(), this._dragging = !1, this._dragCount = 0;
  }
  /** @hidden */
  stopInteraction() {
    this._viewer.trigger("endInteraction"), this._dragging = !1, this._dragCount = 0, this._buttonModifierActive = !1;
  }
  /** @hidden */
  isDragging() {
    return this._dragging;
  }
  /** @hidden */
  isActive() {
    return (this._buttonModifierActive || this._primaryTouchId !== null) && !this._isDoubleClick && !this._viewer.getContextMenuStatus();
  }
  /** @hidden */
  onTouchStart(t) {
    if (this._primaryTouchId === null) {
      this._primaryTouchId = t.getId();
      const e = t.getPosition(), i = new Qn(
        e.x,
        e.y,
        Kt.None,
        t.getButtons(),
        _e.None,
        Vn.Down
      );
      this.onMouseDown(i);
    }
    t.setHandled(this.setHandled());
  }
  /** @hidden */
  async onTouchMove(t) {
    if (this._primaryTouchId === t.getId()) {
      const e = t.getPosition(), i = new Qn(
        e.x,
        e.y,
        Kt.None,
        t.getButtons(),
        _e.None,
        Vn.Move
      );
      await this.onMouseMove(i);
    }
    return t.setHandled(this.setHandled()), Promise.resolve();
  }
  /** @hidden */
  onTouchEnd(t) {
    if (this._primaryTouchId === t.getId()) {
      const e = t.getPosition(), i = new Qn(
        e.x,
        e.y,
        Kt.None,
        t.getButtons(),
        _e.None,
        Vn.Up
      );
      this.onMouseUp(i), this._primaryTouchId = null;
    }
    t.setHandled(this.setHandled());
  }
  /**
   * Adds a button and key modifier mapping for the operator. If no mapping is provided, all combinations are considered valid.
   * All mappings require a mouse button, but a key modifier is optional.
   * @param button
   * @param modifier
   */
  addMapping(t, e = _e.None) {
    this._mapping.push(new Jc(t, e));
  }
  /**
   * Clears any button and key modifier mappings for the operator.
   */
  clearMapping() {
    this._mapping = [];
  }
  /**
   * Sets the button and key modifier mapping for the operator.
   * @param button
   * @param modifier
   */
  setMapping(t, e = _e.None) {
    this._mapping = [], this._mapping.push(new Jc(t, e));
  }
  /** @hidden */
  checkMapping(t) {
    if (this._mapping.length === 0)
      return !0;
    for (const e of this._mapping)
      if (e.getButton() === t.getButton() && e.getModifier() === t.getModifiers())
        return !0;
    return !1;
  }
  /** @hidden */
  setHandled() {
    return !1;
  }
  /** @hidden */
  onDeactivate() {
    const t = this.stopInteraction();
    return this._primaryTouchId = null, t;
  }
}
class _a {
  constructor(t, e) {
    this._mode = t, this._impl = new H_(e);
  }
  /**
   * Creates a new `IncrementalSelection` object that can be used to perform incremental selections.
   *
   * @param mode Controls whether or not selections are performed using the [[View]] or the [[SelectionManager]].
   * @param viewer The `WebViewer` of the scene.
   * @param createSelectionPredicate This callback is used to create a selection predicate. Return null to not filter selection results.
   * @returns The created `IncrementalSelection` object.
   */
  static create(t, e) {
    return new _a(t, e);
  }
  performSelection(t, e, i) {
    const s = this._impl.viewer;
    let r;
    return this._mode === "View" ? (r = s.view, i === void 0 && (i = [])) : (this._mode, r = s.selectionManager), e === void 0 && (e = null), this._impl.performSelection(r, t, e, i);
  }
  /**
   * Returns whether or not this object has an active selection in progress.
   * @returns `true` if active and `false` if idle.
   */
  isIdle() {
    return this._impl.isIdle();
  }
  /**
   * Used to wait for this object to become idle.
   * @returns A promise that resolves when this becomes idle.
   */
  waitForIdle() {
    return this._impl.waitForIdle();
  }
  /**
   * Stops the selection.
   * @returns A `Promise` that resolves when completed.
   */
  stopSelection() {
    return this._impl.stopSelection();
  }
  /**
   * Stops and clears the selection.
   * @returns A `Promise` that resolves when completed.
   */
  clearSelection() {
    return this._impl.clearSelection();
  }
}
function z_(n) {
  return "areaCssMin" in n;
}
function J_(n) {
  return "rayCssBoxRadius" in n;
}
function B_(n) {
  return "volumePlanes" in n;
}
function j_(n) {
  return "sphereRadius" in n;
}
class H_ {
  constructor(t) {
    this._killHandles = [], this._activeSelectionCount = 0, this._inactivityPromise = null, this.viewer = t;
  }
  isIdle() {
    return this._activeSelectionCount === 0;
  }
  async waitForIdle() {
    return this._activeSelectionCount === 0 ? (console.assert(this._inactivityPromise === null), Promise.resolve()) : (this._inactivityPromise === null && (this._inactivityPromise = ye()), this._inactivityPromise);
  }
  async stopSelection() {
    console.assert(this._killHandles.length === this._activeSelectionCount);
    const t = [];
    for (const e of this._killHandles)
      t.push(e());
    return zt(t);
  }
  async clearSelection() {
    const t = this.viewer.selectionManager;
    t.clear(), await this.stopSelection(), t.clear();
  }
  async _advanceBySelectionManager(t, e) {
    return this.viewer.selectionManager.advanceIncrementalSelection(t, e);
  }
  async _advanceByView(t, e, i) {
    let r = await this.viewer.view.advanceIncrementalSelection(t);
    if (r === null)
      return !1;
    if (e) {
      const o = await Promise.all(r.map(e));
      r = r.filter((a, l) => o[l]);
    }
    for (const o of r)
      i.push(o);
    return !0;
  }
  _wrapBeginSelection(t, e) {
    return z_(e) ? t.beginScreenSelectByArea(
      e.areaCssMin,
      e.areaCssMax,
      e.pickConfig
    ) : J_(e) ? t.beginRayDrillSelection(
      e.rayCssOrigin,
      e.rayCssBoxRadius,
      e.pickConfig
    ) : B_(e) ? t.beginConvexPolyhedronSelection(
      e.volumePlanes,
      e.heuristicOrigin,
      e.pickConfig
    ) : j_(e) ? t.beginSphereSelection(
      e.sphereCenter,
      e.sphereRadius,
      e.pickConfig
    ) : $n();
  }
  async performSelection(t, e, i, s) {
    return s === void 0 ? this._performSelection(t, e, i, null) : (await this._performSelection(t, e, i, s), s);
  }
  async _performSelection(t, e, i, s) {
    const r = this._wrapBeginSelection(t, e);
    if (r === null)
      return;
    ++this._activeSelectionCount;
    const o = this.viewer.selectionManager, a = s === null;
    let l = !1;
    const c = ji.create(async () => {
      l = !0;
      try {
        const u = await r;
        a ? await o.endIncrementalSelection(u) : await this.viewer.view.endIncrementalSelection(u);
      } finally {
        const u = this._killHandles.indexOf(h);
        console.assert(u >= 0), this._killHandles.splice(u, 1), --this._activeSelectionCount, this._activeSelectionCount === 0 && this._inactivityPromise !== null && (this._inactivityPromise.resolve(), this._inactivityPromise = null);
      }
    }), h = () => c.get();
    this._killHandles.push(h);
    try {
      const u = await r;
      let p = !0;
      for (; p && !l; )
        a ? p = await this._advanceBySelectionManager(u, i) : p = await this._advanceByView(u, i, s), p && !l && await Nl(1);
    } finally {
      await h();
    }
  }
}
class Vm {
  constructor(t) {
    this._nearbyDoors = /* @__PURE__ */ new Set(), this._viewer = t;
  }
  _performSphereSelection(t, e, i) {
    const s = _a.create("View", this._viewer), r = new Al(Xt.Face);
    return r.bimMask = i, r.onlyStreamedInstances = !0, r.ignoreUnrequestedInstances = !0, s.performSelection({
      pickConfig: r,
      sphereCenter: t,
      sphereRadius: e
    });
  }
  async updateNearbyDoors(t, e, i) {
    const s = await this._performSphereSelection(
      t,
      e,
      ei.Door
    ), r = /* @__PURE__ */ new Set();
    for (const u of s) {
      const p = u.getNodeId();
      r.add(p);
    }
    const o = bc(r, this._nearbyDoors), a = bc(this._nearbyDoors, r), l = us(o), c = us(a), h = this._viewer.model;
    h.setNodesOpacity(l, i), h.resetNodesOpacity(c), this._nearbyDoors = r;
  }
  forgetNearbyDoors() {
    const t = us(this._nearbyDoors);
    this._nearbyDoors.clear(), this._viewer.model.resetNodesOpacity(t);
  }
}
class Th extends xe {
  /** @hidden */
  constructor(t) {
    super(t), this._elevationSpeed = 0, this._rotationSpeed = 0, this._viewAngle = 90, this._zoomDistance = 0, this._walkDistance = 0, this._tilt = 0, this._majorAxis = Ht.X, this._maxExtents = 0, this._walkActive = !1, this._activeWalk = new fs(!0), this._bimModeEnabled = !1, this._synchronizedToggleBimMode = new D_(), this._initialInteractiveDrawLimitIncreaseStatus = !0, this._logical = {
      floor: {
        ...cl
      },
      wall: {
        ...hl
      },
      door: {
        ...ul
      }
    }, this._effective = {
      floor: {
        ...cl
      },
      wall: {
        ...hl
      },
      door: {
        ...ul
      }
    }, this._doorCache = new Vm(t), this._downAxis = new d(0, -1, 0), t.setCallbacks({
      subtreeLoaded: (e, i) => {
        i === ps.LoadModel && this._updateSceneFloor();
      }
    });
  }
  _updateSceneFloor() {
    this._downAxis = Wm(this._viewer.model);
  }
  isBimModeEnabled() {
    return this._bimModeEnabled;
  }
  async _enableBimMode() {
    this._bimModeEnabled = !0, this._effective.floor = this._scaleAgainstModelUnit(this._logical.floor), this._effective.wall = this._scaleAgainstModelUnit(this._logical.wall), this._effective.door = this._scaleAgainstModelUnit(this._logical.door), this._updateSceneFloor(), await this._applyGravity(), await this._updateNearbyDoors();
  }
  _disableBimMode() {
    this._bimModeEnabled = !1, this._doorCache.forgetNearbyDoors();
  }
  /**
   * Enables BIM mode, which includes collision detection
   */
  enableBimMode() {
    return this._synchronizedToggleBimMode.set(async () => {
      await this._enableBimMode();
    });
  }
  /**
   * Disables BIM mode, which includes collision detection
   */
  disableBimMode() {
    return this._synchronizedToggleBimMode.set(() => {
      this._disableBimMode();
    });
  }
  /**
   * Toggles BIM mode, deactivating it if it's activated and activating it if it's deactivated
   */
  toggleBimMode() {
    return this._synchronizedToggleBimMode.set(() => this._bimModeEnabled ? this._disableBimMode() : this._enableBimMode());
  }
  /** @hidden */
  async onActivate() {
    this._viewer.view.setProjectionMode(te.Perspective);
    const t = this._viewer.view;
    if (this._initialInteractiveDrawLimitIncreaseStatus = await t.getInteractiveDrawLimitIncreaseEnabled(), t.setInteractiveDrawLimitIncreaseEnabled(!1), this._calculateInitialPosition(), this._maxExtents === 0 && await this.resetDefaultWalkSpeeds(), this._bimModeEnabled && await this._updateNearbyDoors(), this._viewer.floorplanManager.getConfiguration().autoActivate === Ls.BimWalk) {
      const i = this._viewer.model.getNodesByGenericType("IFCBUILDINGSTOREY");
      i && i.size > 0 && await this._viewer.floorplanManager.activate();
    }
  }
  /** @hidden */
  async onDeactivate() {
    if (this._viewer.view.setInteractiveDrawLimitIncreaseEnabled(
      this._initialInteractiveDrawLimitIncreaseStatus
    ), this._doorCache.forgetNearbyDoors(), this._viewer.floorplanManager.getConfiguration().autoActivate === Ls.BimWalk) {
      const e = this._viewer.model.getNodesByGenericType("IFCBUILDINGSTOREY");
      e && e.size > 0 && await this._viewer.floorplanManager.deactivate();
    }
    super.onDeactivate();
  }
  /**
   * Sets the walk, rotate, and mouse look speeds to the default values.
   */
  async resetDefaultWalkSpeeds() {
    this._rotationSpeed = 40, this._viewAngle = 90;
    const e = (await this._viewer.model.getLooseBounding()).extents();
    this._maxExtents = Math.max(e.x, e.y, e.z), this._walkDistance = this._maxExtents / 15, this._elevationSpeed = this._maxExtents / 10, this._zoomDistance = this._maxExtents / 30;
  }
  /**
   * Gets the floor distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  getBimFloorConfig() {
    return { ...this._logical.floor };
  }
  /**
   * Sets the floor distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  setBimFloorConfig(t) {
    this._logical.floor = { ...t }, this._effective.floor = this._scaleAgainstModelUnit(this._logical.floor);
  }
  /**
   * Gets the wall distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  getBimWallConfig() {
    return { ...this._logical.wall };
  }
  /**
   * Sets the wall distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  setBimWallConfig(t) {
    this._logical.wall = { ...t }, this._effective.wall = this._scaleAgainstModelUnit(this._logical.wall);
  }
  /**
   * Gets the door distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  getBimDoorConfig() {
    return { ...this._logical.door };
  }
  /**
   * Sets the door distance config used by BIM mode.
   */
  setBimDoorConfig(t) {
    this._logical.door = { ...t }, this._effective.door = this._scaleAgainstModelUnit(this._logical.door);
  }
  _scaleAgainstModelUnit(t) {
    const e = this._viewer.model, i = 1 / e.getNodeUnitMultiplier(e.getAbsoluteRootNode());
    t = { ...t };
    const s = Object.keys(t);
    for (const r of s)
      typeof t[r] == "number" && (t[r] *= i);
    return t;
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t);
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
  }
  /** @hidden */
  onMouseUp(t) {
    super.onMouseUp(t);
  }
  /** @hidden */
  async _applyGravity() {
    const t = this._viewer.view, e = t.getCamera();
    let i = e.getPosition(), s = await zc(
      t,
      i,
      this._downAxis,
      this._effective.floor.maxFallDistance
    );
    if (s === null && (i = d.subtract(
      i,
      d.scale(this._downAxis, this._effective.floor.avatarOffset)
    ), s = await zc(
      t,
      i,
      this._downAxis,
      this._effective.floor.maxFallDistance
    ), s === null))
      return;
    const r = new d(0, 0, this._effective.floor.avatarOffset), o = d.add(s, r), a = d.subtract(o, i), l = a.length();
    l > this._effective.floor.negligibleClimbHeight && Yn(a, this._downAxis) > 90 && l > this._effective.floor.maxClimbHeight || this._applyWalkDelta(e, a);
  }
  /** @hidden */
  _updateNearbyDoors() {
    const e = this._viewer.view.getCamera().getPosition(), i = 0.5;
    return this._doorCache.updateNearbyDoors(
      e,
      this._effective.door.transparencyRange,
      i
    );
  }
  _updateCamera(t) {
    this._resetPosition(t), this._updateCameraTilt(t), this._updateCameraViewAngle(t), this._viewer.view.setCamera(t);
  }
  /** @hidden */
  _applyWalkDelta(t, e) {
    t.dolly(d.scale(e, -1)), this._updateCamera(t);
  }
  /** @hidden */
  async _applyWalkDeltaWithCollisionCheck(t, e, i) {
    const s = t.getPosition(), o = Q.createFromOffAxisRotation(i, 90).transform(e), l = Q.createFromOffAxisRotation(i, -90).transform(e), c = this._testWallCollision(
      s,
      o,
      this._effective.wall.avatarOffset
    ), h = this._testWallCollision(
      s,
      l,
      this._effective.wall.avatarOffset
    ), u = this._testWallCollision(
      s,
      e,
      e.length() + this._effective.wall.avatarOffset
    ), [p, m] = await Promise.all([
      c,
      h
    ]);
    if (p !== null || m !== null) {
      const _ = (y) => {
        if (y !== null) {
          const b = y.getFaceEntity().getNormal();
          return Yn(b, e) > 90;
        }
        return !1;
      };
      if (_(p) || _(m))
        return;
    }
    const g = await u;
    if (g !== null) {
      const _ = e.length(), y = d.scale(e, 1 / _), w = d.subtract(g.getPosition(), s).length() - this._effective.wall.avatarOffset, v = Math.min(_, w);
      e = d.scale(y, v);
    }
    this._applyWalkDelta(t, e);
  }
  _testWallCollision(t, e, i) {
    return Pm(this._viewer.view, t, e, i);
  }
  _walkBackward(t, e) {
    const s = this._viewer.view.getCamera();
    this._resetPosition(s);
    const r = s.getTarget(), o = s.getPosition(), a = s.getUp(), c = d.subtract(o, r).normalize().copy().scale(t);
    return e ? this._applyWalkDeltaWithCollisionCheck(s, c, a) : this._applyWalkDelta(s, c);
  }
  _walkForward(t, e) {
    return this._walkBackward(-t, e);
  }
  _walkLeft(t, e) {
    const s = this._viewer.view.getCamera();
    this._resetPosition(s);
    const r = s.getTarget(), o = s.getPosition(), a = s.getUp(), l = d.subtract(r, o).normalize(), h = d.cross(a, l).normalize().copy().scale(t);
    return e ? this._applyWalkDeltaWithCollisionCheck(s, h, a) : this._applyWalkDelta(s, h);
  }
  _walkRight(t, e) {
    return this._walkLeft(-t, e);
  }
  walkBackward(t) {
    return this._walkBackward(t, !1);
  }
  walkForward(t) {
    return this._walkForward(t, !1);
  }
  walkLeft(t) {
    return this._walkLeft(t, !1);
  }
  walkRight(t) {
    return this._walkRight(t, !1);
  }
  walkBackwardWithCollision(t) {
    return this._walkBackward(t, !0);
  }
  walkForwardWithCollision(t) {
    return this._walkForward(t, !0);
  }
  walkLeftWithCollision(t) {
    return this._walkLeft(t, !0);
  }
  walkRightWithCollision(t) {
    return this._walkRight(t, !0);
  }
  walkDown(t) {
    const i = this._viewer.view.getCamera();
    this._resetPosition(i);
    const s = i.getUp().normalize().scale(t);
    this._applyWalkDelta(i, s);
  }
  walkUp(t) {
    this.walkDown(-t);
  }
  rotateRight(t) {
    const i = this._viewer.view.getCamera();
    this._resetPosition(i);
    const s = i.getTarget(), r = i.getPosition(), a = d.subtract(r, s).length(), l = d.subtract(s, r).normalize(), c = cs(t), h = Math.tan(c), p = d.subtract(i.getTarget(), i.getPosition()).length() * h, m = d.cross(l, i.getUp()).scale(p);
    let g = s.copy().add(m);
    const _ = d.subtract(g, r).normalize().scale(a);
    g = d.add(r, _), i.setTarget(g), this._updateCamera(i);
  }
  rotateLeft(t) {
    this.rotateRight(-t);
  }
  tiltDown(t) {
    this.setTilt(this._tilt + t);
    const i = this._viewer.view.getCamera();
    this._resetPosition(i), this._updateCamera(i);
  }
  tiltUp(t) {
    this.tiltDown(-t);
  }
  /** @hidden */
  _calculateInitialPosition() {
    const e = this._viewer.view.getCamera();
    this._calculateMajorAxis(e), this.setTilt(this._calculateInitialTilt(e)), this._resetPosition(e), this._updateCamera(e);
  }
  _updateCameraViewAngle(t) {
    const e = cs(this._viewAngle), i = Math.tan(e / 2), r = d.subtract(t.getTarget(), t.getPosition()).length() * i;
    t.setWidth(r), t.setHeight(r);
  }
  _updateCameraTilt(t) {
    const e = t.getPosition(), i = t.getTarget(), s = t.getUp().normalize(), r = d.subtract(i, e).normalize(), o = d.cross(s, r).normalize(), a = d.distance(i, e);
    Q.createFromOffAxisRotation(o, this._tilt).transform(r, r), t.setTarget(d.add(e, r.scale(a)));
  }
  _calculateInitialTilt(t) {
    const e = t.getTarget(), i = t.getPosition(), s = d.subtract(e, i), r = s.length();
    this._majorAxis === Ht.X ? s.x = 0 : this._majorAxis === Ht.Y ? s.y = 0 : this._majorAxis === Ht.Z && (s.z = 0);
    const o = s.length();
    return Math.acos(o / r) * (180 / Math.PI);
  }
  /** @hidden */
  _resetPosition(t) {
    this._calculateMajorAxis(t);
    const e = t.getPosition(), i = t.getTarget(), s = d.subtract(i, e);
    let r = s.length();
    switch (this.getWalkSpeed() > 0 && (r = this.getWalkSpeed()), this._majorAxis) {
      case Ht.X:
        s.set(0, s.y, s.z), t.setUp(new d(1, 0, 0));
        break;
      case Ht.Y:
        s.set(s.x, 0, s.z), t.setUp(new d(0, 1, 0));
        break;
      case Ht.Z:
        s.set(s.x, s.y, 0), t.setUp(new d(0, 0, 1));
        break;
    }
    s.normalize().scale(r), t.setTarget(d.add(e, s));
  }
  /** @hidden */
  _calculateMajorAxis(t) {
    const e = t.getUp(), i = Math.abs(e.x), s = Math.abs(e.y), r = Math.abs(e.z);
    r >= i && r >= s ? this._majorAxis = Ht.Z : s >= i && s >= r ? this._majorAxis = Ht.Y : this._majorAxis = Ht.X;
  }
  /**
   * Sets the speed to walk when using the mouse scroll wheel.
   * @param zoomSpeed distance for walking with the mouse scroll wheel.
   */
  setZoomSpeed(t) {
    this._zoomDistance = t;
  }
  /**
   * Gets the speed used when walking with the mouse scroll wheel.
   */
  getZoomSpeed() {
    return this._zoomDistance;
  }
  /**
   * Sets the tilt value. Values must be between -45 and 45 degrees.
   * @param tilt
   */
  setTilt(t) {
    this._tilt = Dc(t, Zm, Sm);
    const e = this._viewer.view.getCamera();
    this._updateCamera(e);
  }
  /**
   * Gets the tilt value.
   */
  getTilt() {
    return this._tilt;
  }
  /**
   * Sets the view angle. Values must be between 30 and 150 degrees.
   * @param viewAngle
   */
  setViewAngle(t) {
    const e = Dc(t, km, Cm);
    this._viewAngle !== e && (this._viewAngle = e, this._updateCamera(this._viewer.view.getCamera()));
  }
  /**
   * Gets the view angle.
   */
  getViewAngle() {
    return this._viewAngle;
  }
  /**
   * Sets the walkSpeed for walking forward, backwards, left, and right.
   * @param walkSpeed The camera will move by walkSpeed per second.
   */
  setWalkSpeed(t) {
    this._walkDistance = t;
  }
  /**
   * Gets the walkSpeed for walking forward, backwards, left, and right.
   */
  getWalkSpeed() {
    return this._walkDistance;
  }
  /**
   * Sets the elevation speed for moving the camera up and down.
   * @param elevationSpeed The camera will move by elevationSpeed per second.
   */
  setElevationSpeed(t) {
    this._elevationSpeed = t;
  }
  /**
   * Gets the elevation speed for moving the camera up and down.
   */
  getElevationSpeed() {
    return this._elevationSpeed;
  }
  /**
   * Sets the rotation speed for tilt and rotate.
   * @param rotationSpeed The camera will rotate by rotationSpeed degrees per second.
   */
  setRotationSpeed(t) {
    this._rotationSpeed = t;
  }
  /**
   * Gets the rotation speed for tilt and rotate.
   */
  getRotationSpeed() {
    return this._rotationSpeed;
  }
  /** @hidden */
  setWalkActive(t) {
    this._walkActive = t;
  }
  /**
   * Returns true if walking is currently active
   */
  getWalkActive() {
    return this._walkActive;
  }
  /**
   * Returns true if BIM mode is currently active
   */
  getBimModeEnabled() {
    return this._bimModeEnabled;
  }
  /**
   * Get major axis
   */
  getMajorAxis() {
    return this._majorAxis;
  }
  /** @hidden */
  getActiveWalk() {
    return this._activeWalk;
  }
}
class ml extends Th {
  /** @hidden */
  constructor(t) {
    super(t), this._keyWalkMapping = /* @__PURE__ */ new Map(), this._keyUpMap = /* @__PURE__ */ new Map(), this._keyDownMap = /* @__PURE__ */ new Map(), this._mouseLookSpeed = 0, this._mouseLookEnabled = !0, this._previousWalkTime = 0, this._tickTimerId = null, t.setCallbacks({
      camera: (e) => {
        e.getProjection() !== te.Perspective && this._keyDownMap.clear();
      }
    }), this.addKeyMapping(Ut.a, Ot.Left), this.addKeyMapping(Ut.d, Ot.Right), this.addKeyMapping(Ut.w, Ot.Forward), this.addKeyMapping(Ut.s, Ot.Backward), this.addKeyMapping(Ut.q, Ot.RotateLeft), this.addKeyMapping(Ut.e, Ot.RotateRight), this.addKeyMapping(Ut.r, Ot.TiltUp), this.addKeyMapping(Ut.f, Ot.TiltDown), this.addKeyMapping(Ut.x, Ot.Up), this.addKeyMapping(Ut.c, Ot.Down), this.addKeyMapping(Ut.LeftArrow, Ot.Left), this.addKeyMapping(Ut.RightArrow, Ot.Right), this.addKeyMapping(Ut.UpArrow, Ot.Forward), this.addKeyMapping(Ut.DownArrow, Ot.Backward);
  }
  /**
   * Adds a key mapping for a walk direction.
   * @param key
   * @param walkDirection
   */
  addKeyMapping(t, e) {
    this._keyWalkMapping.set(t, e);
  }
  /**
   * Gets the walk direction key mapping.
   */
  getKeyMapping() {
    return wl(this._keyWalkMapping);
  }
  /**
   * Clears all key mappings.
   */
  clearKeyMappings() {
    this._keyWalkMapping.clear();
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this._viewer.focusInput(!0);
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this._dragging && this._mouseLookEnabled) {
      this._viewer.view.setProjectionMode(te.Perspective);
      const e = window.screen.width, i = window.screen.height;
      t.setHandled(!0);
      const s = E.subtract(this._ptPrevious, this._ptCurrent);
      this.rotateLeft(s.x / e * this._mouseLookSpeed), this.tiltUp(s.y / i * this._mouseLookSpeed);
    }
  }
  /** @hidden */
  onMouseUp(t) {
    this._dragCount > 5 && t.setHandled(!0), super.onMouseUp(t);
  }
  /** @hidden */
  onMousewheel(t) {
    this._viewer.view.setProjectionMode(te.Perspective);
    const e = this._viewer.view, i = e.getCamera(), s = t.getPosition(), r = t.getWheelDelta();
    e.pickFromPoint(s, new be(Xt.Face)).then((o) => {
      const a = o.getPosition();
      if (o !== null && a !== null) {
        const c = d.subtract(
          i.getPosition(),
          a
        ).normalize().scale(this.getZoomSpeed() * r);
        this._applyWalkDelta(i, c);
      } else
        this.walkBackward(r * this.getWalkSpeed());
    });
  }
  /** @hidden */
  onKeyDown(t) {
    this._viewer.view.setProjectionMode(te.Perspective);
    const e = t.getKeyCode();
    e === Ut.v && this.toggleBimMode(), this._keyCodeActive(e) || (this._keyDownMap.set(e, t.getDate().getTime()), this._onKeyChange(e));
  }
  /** @hidden */
  onKeyUp(t) {
    const e = t.getKeyCode();
    this._keyUpMap.set(e, t.getDate().getTime()), this._onKeyChange(e);
  }
  _keyCodeActive(t) {
    const e = this._keyDownMap.get(t);
    if (e !== void 0) {
      const i = this._keyUpMap.get(t);
      if (i === void 0 || e > i)
        return !0;
    }
    return !1;
  }
  _onKeyChange(t) {
    this._keyCodeActive(t) && this._keyWalkMapping.has(t) && (this.getWalkActive() || (this._previousWalkTime = Date.now()), this._onTick());
  }
  /**
   * Sets the speed for mouse look.
   * @param mouseLookSpeed
   */
  setMouseLookSpeed(t) {
    this._mouseLookSpeed = t;
  }
  /**
   * Gets the mouse look speed.
   */
  getMouseLookSpeed() {
    return this._mouseLookSpeed;
  }
  /**
   * Sets whether the mouse look is enabled. If enabled, mouse move events will not continue down the operator stack.
   * @param mouseLookEnabled
   */
  setMouseLookEnabled(t) {
    this._mouseLookEnabled = t;
  }
  /**
   * Gets whether the mouse look is enabled. If enabled, mouse move events will not continue down the operator stack.
   */
  getMouseLookEnabled() {
    return this._mouseLookEnabled;
  }
  async resetDefaultWalkSpeeds() {
    return super.resetDefaultWalkSpeeds().then(() => {
      this._mouseLookSpeed = 300;
    });
  }
  _execWalkDirection(t, e, i) {
    const s = this.getWalkSpeed() * e;
    switch (t) {
      case Ot.Forward:
        return i ? this.walkForwardWithCollision(s) : this.walkForward(s);
      case Ot.Backward:
        return i ? this.walkBackwardWithCollision(s) : this.walkBackward(s);
      case Ot.Left:
        return i ? this.walkLeftWithCollision(s) : this.walkLeft(s);
      case Ot.Right:
        return i ? this.walkRightWithCollision(s) : this.walkRight(s);
      case Ot.Up:
        return this.walkUp(this.getElevationSpeed() * e);
      case Ot.Down:
        return this.walkDown(this.getElevationSpeed() * e);
      case Ot.RotateLeft:
        return this.rotateLeft(this.getRotationSpeed() * e);
      case Ot.RotateRight:
        return this.rotateRight(this.getRotationSpeed() * e);
      case Ot.TiltUp:
        return this.tiltUp(this.getRotationSpeed() * e);
      case Ot.TiltDown:
        return this.tiltDown(this.getRotationSpeed() * e);
      default:
        $n();
    }
  }
  _queueWalkDirections(t) {
    const e = /* @__PURE__ */ new Set();
    this._keyWalkMapping.forEach((s, r) => {
      this._keyCodeActive(r) && e.add(s);
    }), Mm(e);
    const i = us(e);
    if (i.sort(), i.length > 0) {
      this.setWalkActive(!0);
      const s = this.getBimModeEnabled();
      this.getActiveWalk().set(async () => {
        const r = new Mo(1, !0);
        if (t > 0)
          for (const o of i)
            r.push(() => this._execWalkDirection(o, t, s));
        if (s && (!e.has(Ot.Up) && !e.has(Ot.Down) && r.push(async () => {
          await this._applyGravity();
        }), r.push(async () => {
          await this._updateNearbyDoors();
        })), !r.isIdle())
          return r.waitForIdle();
      });
    }
  }
  /** @hidden */
  _onTick() {
    const t = Date.now(), e = (t - this._previousWalkTime) / 1e3;
    this._previousWalkTime = t;
    const i = !this.getActiveWalk().isIdle();
    this.setWalkActive(i), this._queueWalkDirections(e), this._tickTimerId !== null && (cancelAnimationFrame(this._tickTimerId), this._tickTimerId = null), this.getWalkActive() && (this._tickTimerId = requestAnimationFrame(() => {
      this._onTick();
    }));
  }
}
class Ym {
  /**
   * Caches a stream of points generated in time by storing them in a wrapped array, from oldest to newest. When the wrap occurs, the oldest, earliest entries are overwritten
   * @param {number} maxPoints the maximum point stream size
   */
  constructor(t = 10) {
    this._count = 0, this._points = new Array(t), this._times = new Array(t);
  }
  /**
   * Clears the array of points
   */
  clear() {
    this._count = 0;
  }
  /**
   * Adds a point to the array of points, possibly overwriting the oldest one
   */
  add(t, e = Date.now()) {
    const i = this._count % this._points.length;
    this._points[i] === void 0 ? this._points[i] = t.copy() : this._points[i].assign(t), this._times[i] = e, this._count++;
  }
  /**
   * Gets the average offset from the first point specified between (now - offset) and now
   */
  getAverageOffsetWithinMilliseconds(t, e = Date.now()) {
    let i = -1;
    const s = E.zero(), r = Math.min(this._points.length, this._count);
    if (r > 0) {
      let o = 0;
      for (let a = 0; a < r; a++) {
        const l = (this._count - 1 - a) % this._points.length;
        if (e - this._times[l] > t)
          break;
        i = l, s.add(this._points[l]), o++;
      }
      o > 1 ? (s.subtract(this._points[i]), o--, s.scale(1 / o)) : (i = -1, s.set(0, 0));
    }
    return i >= 0 ? E.subtract(s, this._points[i]) : s;
  }
}
class Eh extends xe {
  /** @hidden */
  constructor(t, e) {
    super(t), this._cameraRotationMomentumEnabled = !1, this._isDown = !1, this._mouseDragged = !1, this._averagedMousePoints = new Ym(), this._averageTimeIntervalMilliseconds = 150, this._previousMouseMovePoint = E.zero(), this._mouseMovePoint = E.zero(), this._mouseMoveOffset = E.zero(), this._previousMouseMoveTime = null, this._mouseMoveTime = null, this._mouseMoveElapsedTimeSeconds = 0, this._rotationDegreesPerSecond = [0, 0], this._animationLastTickTime = 0, this._animationElapsedTimeSeconds = 0, this._animationIntervalResult = null, this._preferredAnimationIntervalMilliseconds = 16, this._momentum = 0, this._momentumLossPerSecond = 0, this._degreesPerPixel = 0.5, this._maxRotationMagnitudeScale = 8, this._initialSelectionPosition = null, this._cameraRotateFunction = e;
  }
  getCameraRotationMomentumEnabled() {
    return this._cameraRotationMomentumEnabled;
  }
  setCameraRotationMomentumEnabled(t) {
    t !== this._cameraRotationMomentumEnabled && (this._cameraRotationMomentumEnabled = t, t || this.stopAnimation());
  }
  isCurrentlyAnimating() {
    return this._cameraRotationMomentumEnabled && this.getMomentum() > 0;
  }
  /** @hidden */
  onDeactivate() {
    return super.onDeactivate();
  }
  /** @hidden */
  onViewOrientationChange() {
    this.stopAnimation();
  }
  supportsAnimation() {
    return !0;
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && (this._initialSelectionPosition = t.getPosition(), this._isDown = !0, this.stopAnimation(), this._mouseDragged = !1, this._previousMouseMoveTime = Date.now(), this._mouseMoveTime = this._previousMouseMoveTime, this._mouseMovePoint.assign(this._initialSelectionPosition), this._previousMouseMovePoint.assign(this._mouseMovePoint), this._averagedMousePoints.clear(), this._averagedMousePoints.add(this._mouseMovePoint, this._mouseMoveTime));
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this.isActive()) {
      if (!this._isDown)
        return;
      this._mouseDragged = !0, this._previousMouseMovePoint.assign(this._mouseMovePoint), this._mouseMovePoint.assign(t.getPosition()), this._mouseMoveOffset = E.subtract(this._mouseMovePoint, this._previousMouseMovePoint), this._previousMouseMoveTime = this._mouseMoveTime, this._mouseMoveTime = Date.now(), this._mouseMoveElapsedTimeSeconds = this._previousMouseMoveTime === null ? 0 : (this._mouseMoveTime - this._previousMouseMoveTime) / 1e3, this._averagedMousePoints.add(this._mouseMovePoint, this._mouseMoveTime);
      const e = this._getMouseMoveOffsetForRotation();
      this._rotateCamera(e);
    }
  }
  /** @hidden */
  onMouseUp(t) {
    if (this.isActive() && (this._isDown = !1, this._mouseDragged && this.getCameraRotationMomentumEnabled())) {
      this._mouseMoveOffset = this._averagedMousePoints.getAverageOffsetWithinMilliseconds(
        this._averageTimeIntervalMilliseconds
      );
      const e = this._getMouseMoveOffsetForRotation();
      if (e[0] !== 0 || e[1] !== 0) {
        for (let i = 0; i < 2; i++) {
          const s = Math.abs(e[i]) * this._maxRotationMagnitudeScale;
          this._rotationDegreesPerSecond[i] = e[i] / this._mouseMoveElapsedTimeSeconds, this._rotationDegreesPerSecond[i] < -s ? this._rotationDegreesPerSecond[i] = -s : this._rotationDegreesPerSecond[i] > s && (this._rotationDegreesPerSecond[i] = s);
        }
        this._momentum = 1, this._startAnimation();
      } else
        this._momentum = 0;
    }
    super.onMouseUp(t);
  }
  _rotateCamera(t) {
    this._cameraRotateFunction(t);
  }
  stopAnimation() {
    this._animationIntervalResult !== null && (clearInterval(this._animationIntervalResult), this._animationIntervalResult = null);
  }
  getMomentum() {
    return this._momentum;
  }
  /**
   * Sets proportion of momentum lost per second if camera rotation momentum is enabled. At 0
   * no momentum is lost and the camera will orbit indefinitely. Above 1 the camera will stop
   * orbiting within a second of release. Only values greater than or equal to 0 are accepted.
   * @param amountLost Proportion of momentum lost per second
   */
  setMomentumLossPerSecond(t) {
    t >= 0 && (this._momentumLossPerSecond = t);
  }
  getMomentumLossPerSecond() {
    return this._momentumLossPerSecond;
  }
  isAnimating() {
    return this._animationIntervalResult !== null;
  }
  _startAnimation() {
    this._animationIntervalResult === null && (this._animationLastTickTime = Date.now(), this._animationIntervalResult = window.setInterval(() => {
      this._onTick();
    }, this._preferredAnimationIntervalMilliseconds));
  }
  _getMouseMoveOffsetForRotation() {
    return [
      -this._mouseMoveOffset.x * this._degreesPerPixel,
      this._mouseMoveOffset.y * this._degreesPerPixel
    ];
  }
  _onTick() {
    const t = Date.now();
    this._animationElapsedTimeSeconds = (t - this._animationLastTickTime) / 1e3, this._animationLastTickTime = t;
    const e = [
      this._animationElapsedTimeSeconds * this._rotationDegreesPerSecond[0],
      this._animationElapsedTimeSeconds * this._rotationDegreesPerSecond[1]
    ];
    if (this._rotateCamera(e), this._momentumLossPerSecond > 0)
      if (this._momentum = Math.max(
        0,
        this._momentum - this._animationElapsedTimeSeconds * this._momentumLossPerSecond
      ), this._momentum > 0)
        for (let i = 0; i < this._rotationDegreesPerSecond.length; i++)
          this._rotationDegreesPerSecond[i] *= this._momentum;
      else {
        for (let i = 0; i < this._rotationDegreesPerSecond.length; i++)
          this._rotationDegreesPerSecond[i] = 0;
        this._rotateCamera(this._rotationDegreesPerSecond), this.stopAnimation();
      }
  }
}
class Gm extends _s {
  constructor(t, e, i) {
    super(), this._circle = new qn(), this._viewer = t, this._position = e, this._circle.setRadius(i);
  }
  draw() {
    if (this._circle) {
      const t = this._viewer.view.projectPoint(this._position);
      this._circle.setCenter(E.fromPoint3(t)), this._viewer.markupManager.getRenderer().drawCircle(this._circle);
    }
  }
}
class Nh extends Eh {
  /** @hidden */
  constructor(t) {
    super(t, (e) => {
      if (!this._viewer.sheetManager.isDrawingSheetActive())
        if (this._pickPosition !== null) {
          if (this._circleMarkupHandler === null) {
            const i = new Gm(
              this._viewer,
              this._pickPosition,
              this._circleRadius
            );
            this._circleMarkupHandler = this._viewer.markupManager.registerMarkup(i);
          }
          this._orbitByTurnTiltWithTarget(e, this._pickPosition);
        } else {
          const i = this._viewer.view.getCamera();
          switch (this._orbitFallbackMode) {
            default:
            case mo.CameraTarget:
              this._orbitByTurnTiltWithTarget(e, i.getTarget());
              break;
            case mo.ModelCenter:
              this._modelCenter && this._orbitByTurnTiltWithTarget(e, this._modelCenter);
              break;
            case mo.OrbitTarget:
              this._orbitByTurnTiltWithTarget(e, this._orbitTarget);
              break;
          }
        }
    }), this._orbitTarget = d.zero(), this._orbitFallbackMode = mo.ModelCenter, this._modelCenter = null, this._circleMarkupHandler = null, this._circleRadius = 3, this._updateCameraCenterAction = new fs(!1), this._updateCameraCenterTimer = new Os(), this._primaryButton = Kt.Middle, this._pickPosition = null, this._bimOrbitEnabled = !1, this._viewer.setCallbacks({
      sceneReady: () => {
        this._updateModelCenter();
      },
      modelSwitched: () => {
        this._updateModelCenter();
      },
      visibilityChanged: () => {
        this._updateModelCenter();
      },
      _updateTransform: (e) => {
        e || this._updateModelCenter();
      },
      _geometryCreated: () => {
        this._updateModelCenter();
      },
      hwfParseComplete: () => {
        this._updateModelCenter();
      }
    });
  }
  _updateModelCenter(t = 50) {
    this._updateCameraCenterTimer.clear(), this._updateCameraCenterAction.set(async () => {
      const e = await this._viewer.model.getModelBounding(!0, !1);
      if (e.isDegenerate() && t > 0) {
        this._updateCameraCenterTimer.set(500, () => {
          this._updateModelCenter(t - 1);
        });
        return;
      }
      this._modelCenter = e.center();
    });
  }
  /** @hidden */
  async onMouseDown(t) {
    if (super.onMouseDown(t), this.isActive() && t.getButton() === this._primaryButton) {
      const e = await this._viewer.view.pickFromPoint(
        t.getPosition(),
        new be(Xt.Face)
      );
      e !== null && e.overlayIndex() === 0 ? (this._pickPosition = e.getPosition(), t.setHandled(!0)) : this._pickPosition = null;
    }
  }
  /** @hidden */
  onMouseUp(t) {
    super.onMouseUp(t), t.getButton() === this._primaryButton && (this._pickPosition = null), this._removeMarkup();
  }
  /** @hidden */
  onDeactivate() {
    const t = super.onDeactivate();
    return this._updateCameraCenterTimer.clear(), t;
  }
  /**
   * BIM orbit is intended to make orbiting building models easier.
   * It slows the rotation speed, clamps vertical rotation to 180 degrees, and restricts horizontal rotation to rotate around the vertical axis.
   * @param bimOrbitEnabled
   */
  setBimOrbitEnabled(t) {
    this._bimOrbitEnabled = t;
  }
  /**
   * Returns true if BIM orbit is enabled.
   */
  getBimOrbitEnabled() {
    return this._bimOrbitEnabled;
  }
  /** @hidden */
  _removeMarkup() {
    this._circleMarkupHandler !== null && (this._viewer.markupManager.unregisterMarkup(this._circleMarkupHandler), this._circleMarkupHandler = null);
  }
  _getClampedRotationMatrix(t, e, i, s) {
    const r = Q.createFromOffAxisRotation(t, e), o = d.zero();
    return r.transform(i, o), _l(Math.asin(d.dot(s, o))) <= 0 ? new Q() : r;
  }
  _orbitByTurnTiltWithTarget(t, e) {
    const i = this._viewer.view, s = i.getCamera();
    let r = s.getPosition().subtract(e), o = s.getTarget().subtract(e), a = s.getUp().normalize();
    const l = d.subtract(o, r).normalize(), c = d.cross(a, l).normalize(), h = t[0], u = t[1];
    let p = new Q(), m = new Q();
    if (this._bimOrbitEnabled) {
      const _ = this._viewer.model.getViewAxes().upVector.copy();
      p = this._getClampedRotationMatrix(c, u, a, _), m = Q.createFromOffAxisRotation(_, h / 4);
      const y = m.transform(p.transform(r)), b = m.transform(p.transform(o)), w = m.transform(p.transform(d.add(r, a)));
      w.subtract(y), r = y, o = b, a = w;
    } else {
      p = Q.createFromOffAxisRotation(c, u), m = Q.createFromOffAxisRotation(a, h);
      const g = Q.multiply(m, p), _ = g.transform(r), y = g.transform(o), b = g.transform(d.add(r, a));
      b.subtract(_), r = _, o = y, a = b;
    }
    r.add(e), o.add(e), s.setPosition(r), s.setTarget(o), s.setUp(a), i.setCamera(s);
  }
  /**
   * Sets the fallback mode. This is used to specify whether to orbit
   * around a set target, the model center, or camera target.
   */
  setOrbitFallbackMode(t) {
    this._orbitFallbackMode = t;
  }
  /**
   * Gets the orbit fallback mode.
   * @returns orbit fallback mode
   */
  getOrbitFallbackMode() {
    return this._orbitFallbackMode;
  }
  /**
   * Sets the orbit target for the orbit fallback mode OrbitTarget.
   * @param orbitTarget
   */
  setOrbitTarget(t) {
    this._orbitTarget = t;
  }
  /**
   * Gets the orbit target point.
   * @returns orbit target
   */
  getOrbitTarget() {
    return this._orbitTarget;
  }
  /**
   * Sets the primary mouse button. When this button is pressed, we will orbit around the selected point on the model.
   * If there is no selected point, the orbit fallback mode will be used for orbit.
   * @param button
   */
  setPrimaryButton(t) {
    this._primaryButton = t;
  }
  /**
   * @returns the primary orbit button
   */
  getPrimaryButton() {
    return this._primaryButton;
  }
}
class Tm extends xe {
  /** @hidden */
  constructor(t, e, i, s) {
    super(t), this._activeOperator = null, this._activeTouchCount = 0, this._touchMoveCount = 0, this._returnToOrbit = !1, this._bimNavigationEnabled = !1, this._orbitOperator = e, this._panOperator = i, this._zoomOperator = s;
  }
  /**
   * When BIM navigation is enabled, the following controls for orbit, pan, and zoom are set:
   * Left mouse button: orbit
   * Middle mouse wheel: zoom
   * Middle mouse button: pan
   * Right mouse button: zoom
   * @param bimNavigation
   */
  setBimNavigationEnabled(t) {
    this._bimNavigationEnabled = t;
    const e = this._orbitOperator, i = this._zoomOperator, s = this._panOperator;
    e.clearMapping(), i.clearMapping(), s.clearMapping(), e.setMapping(Kt.Left), e.setBimOrbitEnabled(t), i.setDollyZoomEnabled(t), t ? (e.setPrimaryButton(Kt.Left), i.setMapping(Kt.Right), s.setMapping(Kt.Middle), this._setBimCamera()) : (e.addMapping(Kt.Middle), e.setPrimaryButton(Kt.Middle), i.addMapping(Kt.Left, _e.Shift), s.addMapping(Kt.Right), s.addMapping(Kt.Left, _e.Control));
  }
  _setBimCamera() {
    const t = this._viewer.view.getCamera(), e = d.subtract(t.getPosition(), t.getTarget()).normalize(), s = this._viewer.model.getViewAxes().upVector.copy(), r = d.cross(e, s), o = d.cross(r, e);
    t.setUp(o), t.setProjection(te.Perspective), this._viewer.view.setCamera(t);
  }
  /**
   * Returns true if BIM navigation is enabled.
   */
  getBimNavigationEnabled() {
    return this._bimNavigationEnabled;
  }
  /** @hidden */
  onViewOrientationChange() {
    this._activeTouchCount = 0, this._returnToOrbit = !1;
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this._setActiveOperatorForMouseInput(t), this._activeOperator && (this._bimNavigationEnabled && this._setBimCamera(), this._activeOperator.onMouseDown(t));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this._activeOperator && this._dragging && this._dragCount > 3 && this._activeOperator.onMouseMove(t);
  }
  /** @hidden */
  onMouseUp(t) {
    this._activeOperator && this._activeOperator.onMouseUp(t), this._activeOperator instanceof Nh || this._orbitOperator._removeMarkup(), super.onMouseUp(t);
  }
  /** @hidden */
  async onMousewheel(t) {
    await this._zoomOperator.onMousewheel(t);
  }
  /** @hidden */
  onTouchStart(t) {
    ++this._activeTouchCount, this._orbitOperator.onTouchStart(t), this._zoomOperator.onTouchStart(t), this._viewer.sheetManager.isDrawingSheetActive() && (this._panOperator.onTouchStart(t), this._orbitOperator.onDeactivate()), this._activeTouchCount === 1 && (this._primaryTouchId = t.getId()), this._activeTouchCount === 2 && (this._orbitOperator.onDeactivate(), this._panOperator.onTouchStart(t), this._zoomOperator.onTouchStart(t));
  }
  /** @hidden */
  async onTouchMove(t) {
    ++this._touchMoveCount, this._touchMoveCount > 5 && (this._returnToOrbit ? (this._orbitOperator.onTouchStart(t), this._returnToOrbit = !1) : this._activeTouchCount === 1 ? (await this._orbitOperator.onTouchMove(t), await this._zoomOperator.onTouchMove(t), await this._panOperator.onTouchMove(t)) : this._activeTouchCount === 2 && (await this._zoomOperator.onTouchMove(t), await this._panOperator.onTouchMove(t)));
  }
  /** @hidden */
  onTouchEnd(t) {
    this._activeTouchCount === 2 && (this._returnToOrbit = !0), this._zoomOperator.onTouchEnd(t), this._panOperator.onTouchEnd(t), this._orbitOperator.onTouchEnd(t), this._activeTouchCount > 0 && --this._activeTouchCount, this._activeTouchCount === 0 && (this._touchMoveCount = 0);
  }
  /** @hidden */
  stopInteraction() {
    const t = [];
    let e;
    return e = super.stopInteraction(), e !== void 0 && t.push(e), this._activeTouchCount = 0, this._touchMoveCount = 0, e = this._zoomOperator.onDeactivate(), e !== void 0 && t.push(e), e = this._panOperator.onDeactivate(), e !== void 0 && t.push(e), e = this._orbitOperator.onDeactivate(), e !== void 0 && t.push(e), zt(t);
  }
  _setActiveOperatorForMouseInput(t) {
    const e = this._orbitOperator, i = this._panOperator, s = this._zoomOperator;
    this._activeOperator = null, this._viewer.sheetManager.isDrawingSheetActive() ? this._activeOperator = i : e.checkMapping(t) ? this._activeOperator = e : s.checkMapping(t) ? this._activeOperator = s : i.checkMapping(t) && (this._activeOperator = i);
  }
  /** @hidden */
  onDeactivate() {
    super.onDeactivate(), this._orbitOperator.onDeactivate(), this._panOperator.onDeactivate(), this._zoomOperator.onDeactivate();
  }
}
class Em extends xe {
  /** @hidden */
  constructor(t) {
    super(t), this._cameraPtPrevious = d.zero();
  }
  /** @hidden */
  onMouseDown(t) {
    if (super.onMouseDown(t), this.isActive() || this._viewer.sheetManager.isDrawingSheetActive()) {
      const e = this._viewer.view, s = e.getCamera().getCameraPlaneIntersectionPoint(t.getPosition(), e);
      s && this._cameraPtPrevious.assign(s);
    }
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this.isActive() || this._viewer.sheetManager.isDrawingSheetActive()) {
      const e = this._viewer.view, i = e.getCamera(), s = i.getCameraPlaneIntersectionPoint(t.getPosition(), e);
      if (s) {
        const r = d.subtract(s, this._cameraPtPrevious);
        i.dolly(r), e.setCamera(i);
      }
    }
  }
}
class Nm extends Eh {
  /** @hidden */
  constructor(t) {
    super(t, (e) => {
      this._rotateAroundAxis(this._rotationAxis, e[0]);
    }), this._rotationAxis = new d(0, 0, 1), this._tiltAmount = 12;
  }
  _rotateAroundAxis(t, e) {
    const i = this._viewer.view, s = i.getCamera(), r = s.getPosition(), o = s.getUp().normalize(), a = s.getTarget(), l = Q.createFromOffAxisRotation(t, e), c = new Q().setTranslationComponent(-a.x, -a.y, -a.z), h = Q.multiply(c, l), u = new Q().setTranslationComponent(a.x, a.y, a.z);
    Q.multiply(h, u).transform(r, r), l.transform(o, o), o.normalize(), s.setPosition(r), s.setUp(o), i.setCamera(s);
  }
  /** @hidden */
  onMousewheel(t) {
    const e = t.getWheelDelta(), i = this._viewer.view.getCamera(), s = i.getUp().normalize(), r = d.subtract(i.getTarget(), i.getPosition()).normalize(), o = d.cross(s, r).normalize();
    e > 0 ? this._rotateAroundAxis(o, this._tiltAmount) : this._rotateAroundAxis(o, -this._tiltAmount);
  }
  _axisToPoint3(t) {
    let e = null;
    switch (t) {
      case Ht.X:
        e = new d(1, 0, 0);
        break;
      case Ht.Y:
        e = new d(0, 1, 0);
        break;
      case Ht.Z:
        e = new d(0, 0, 1);
        break;
    }
    return e;
  }
  /**
   * Sets the rotation axis.
   * @param axis [[Axis]] or [[Point3]] used to set the rotation axis.
   */
  setRotationAxis(t) {
    let e = null;
    return t instanceof d ? e = t : e = this._axisToPoint3(t), e !== null ? (this._rotationAxis.assign(e), !0) : !1;
  }
}
class Rm {
  /** @hidden */
  constructor(t, e, i) {
    this._keyboardWalkOperator = i, this._walkOperator = e, this._activeOperator = e, this._walkMode = po.Mouse, this._active = !1;
  }
  /**
   * Sets the walk mode to Mouse or Keyboard.
   * @param walkMode
   */
  async setWalkMode(t) {
    this._walkMode !== t && (this._walkMode = t, t === po.Keyboard ? (this._activeOperator = this._keyboardWalkOperator, this._active && (await this._walkOperator.onDeactivate(), await this._keyboardWalkOperator.onActivate())) : (this._activeOperator = this._walkOperator, this._active && (await this._keyboardWalkOperator.onDeactivate(), await this._walkOperator.onActivate())));
  }
  /**
   * Gets the walk mode.
   * @returns Keyboard or Mouse
   */
  getWalkMode() {
    return this._activeOperator instanceof ml ? po.Keyboard : po.Mouse;
  }
  /** @hidden */
  onMouseDown(t) {
    this._activeOperator.onMouseDown(t);
  }
  /** @hidden */
  onMouseMove(t) {
    this._activeOperator.onMouseMove(t);
  }
  /** @hidden */
  onMouseUp(t) {
    this._activeOperator.onMouseUp(t);
  }
  /** @hidden */
  onMousewheel(t) {
    this._activeOperator.onMousewheel(t);
  }
  /** @hidden */
  onTouchStart(t) {
    this._activeOperator.onTouchStart(t);
  }
  /** @hidden */
  async onTouchMove(t) {
    await this._activeOperator.onTouchMove(t);
  }
  /** @hidden */
  onTouchEnd(t) {
    this._activeOperator.onTouchEnd(t);
  }
  /** @hidden */
  onKeyDown(t) {
    this._activeOperator.onKeyDown(t);
  }
  /** @hidden */
  onKeyUp(t) {
    this._activeOperator instanceof ml && this._activeOperator.onKeyUp(t);
  }
  /** @hidden */
  onDeactivate() {
    return this._activeOperator.onDeactivate();
  }
  /** @hidden */
  onActivate() {
    return this._active = !0, this._activeOperator.onActivate();
  }
  /** @hidden */
  onViewOrientationChange() {
    this._active = !1;
  }
  /** @hidden */
  stopInteraction() {
    return this._activeOperator.stopInteraction();
  }
  /**
   * Sets BIM mode enables/disabled on both mouse and keyboard walk
   */
  async setBimModeEnabled(t) {
    const e = [];
    return t ? (e.push(this._keyboardWalkOperator.enableBimMode()), e.push(this._walkOperator.enableBimMode())) : (e.push(this._keyboardWalkOperator.disableBimMode()), e.push(this._walkOperator.disableBimMode())), Promise.all(e).then(() => {
    });
  }
  /**
   * Resets speeds to defaults on both mouse and keyboard walk
   */
  async resetDefaultWalkSpeeds() {
    return Promise.all([
      this._walkOperator.resetDefaultWalkSpeeds(),
      this._keyboardWalkOperator.resetDefaultWalkSpeeds()
    ]).then(() => {
    });
  }
  /**
   * Sets BIM floor config on both mouse and keyboard walk
   */
  setBimFloorConfig(t) {
    this._walkOperator.setBimFloorConfig(t), this._keyboardWalkOperator.setBimFloorConfig(t);
  }
  /**
   * Sets BIM wall config on both mouse and keyboard walk
   */
  setBimWallConfig(t) {
    this._walkOperator.setBimWallConfig(t), this._keyboardWalkOperator.setBimWallConfig(t);
  }
  /**
   * Sets BIM door config on both mouse and keyboard walk
   */
  setBimDoorConfig(t) {
    this._walkOperator.setBimDoorConfig(t), this._keyboardWalkOperator.setBimDoorConfig(t);
  }
  /**
   * Sets zoom speed on both mouse and keyboard walk
   */
  setZoomSpeed(t) {
    this._walkOperator.setZoomSpeed(t), this._keyboardWalkOperator.setZoomSpeed(t);
  }
  /**
   * Sets walk speed for both mouse and keyboard walk
   */
  setWalkSpeed(t) {
    this._walkOperator.setWalkSpeed(t), this._keyboardWalkOperator.setWalkSpeed(t);
  }
  /**
   * Sets elevation speed for both mouse and keyboard walk
   */
  setElevationSpeed(t) {
    this._walkOperator.setElevationSpeed(t), this._keyboardWalkOperator.setElevationSpeed(t);
  }
  /**
   * Sets rotation speed for both mouse and keyboard walk
   */
  setRotationSpeed(t) {
    this._walkOperator.setRotationSpeed(t), this._keyboardWalkOperator.setRotationSpeed(t);
  }
  /**
   * Sets view angle (FOV) for both mouse and keyboard walk operators
   */
  setViewAngle(t) {
    this._walkOperator.setViewAngle(t), this._keyboardWalkOperator.setViewAngle(t);
  }
}
class Lm extends Th {
  /** @hidden */
  constructor(t) {
    super(t), this._timerId = null, this._walkButton = Kt.None, this._previousTimestamp = 0, this._activeTouchCount = 0, this._maxDistance = 200;
  }
  /** @hidden */
  async onActivate() {
    await super.onActivate(), this._viewer.trigger("walkOperatorActivated");
  }
  /** @hidden */
  onKeyDown(t) {
    const e = t.getKeyCode(), i = this.getWalkSpeed();
    e === Ut.PgUp && this.setWalkSpeed(i * 1.2), e === Ut.PgDown && this.setWalkSpeed(i * 0.8), e === Ut.v && this.toggleBimMode();
  }
  /** @hidden */
  async onDeactivate() {
    const t = this._resetCameraTarget();
    return this.stopWalking(), await super.onDeactivate(), this._viewer.trigger("walkOperatorDeactivated"), t;
  }
  // This can resolve issues that arise if the user activates a CAD view while walking that may change the projection mode.
  _checkProjection() {
    const t = this._viewer.view;
    t.getProjectionMode() !== te.Perspective && (t.setProjectionMode(te.Perspective), this._calculateInitialPosition());
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this._checkProjection(), this.isActive() && (this.stopWalking(), this.setWalkActive(!0), this._walkButton = t.getButton());
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this.getWalkActive() && this._timerId === null && this.isActive() && (this._previousTimestamp = Date.now(), this._onTick());
  }
  /** @hidden */
  onMouseUp(t) {
    this.isActive() && this.stopWalking(), super.onMouseUp(t);
  }
  /** @hidden */
  onTouchStart(t) {
    super.onTouchStart(t), ++this._activeTouchCount, this._activeTouchCount === 1 ? this._walkButton = Kt.Left : this._activeTouchCount === 2 ? this._walkButton = Kt.Right : this._activeTouchCount === 3 && (this._walkButton = Kt.None);
  }
  /** @hidden */
  async onTouchMove(t) {
    if (this._activeTouchCount === 3 && this._primaryTouchId === t.getId()) {
      this._ptCurrent.assign(t.getPosition());
      const e = E.subtract(this._ptCurrent, this._ptPrevious);
      this._adjustTilt(e.y / 100 * 1.5);
    } else
      this._activeTouchCount < 3 && await super.onTouchMove(t);
    return Promise.resolve();
  }
  /** @hidden */
  onTouchEnd(t) {
    super.onTouchEnd(t), this._activeTouchCount > 0 && --this._activeTouchCount;
  }
  /** @hidden */
  onMousewheel(t) {
    this._checkProjection(), t.getWheelDelta() > 0 ? this._adjustTilt(3) : this._adjustTilt(-3);
  }
  /** @hidden */
  stopWalking() {
    this._timerId !== null && (cancelAnimationFrame(this._timerId), this._timerId = null), this.setWalkActive(!1);
  }
  /** @hidden */
  async _testWalk(t, e, i) {
    const s = new Qn(
      0,
      0,
      i,
      Ai.None,
      _e.None,
      Vn.Down
    ), r = new Qn(
      0,
      t,
      i,
      Ai.None,
      _e.None,
      Vn.Move
    ), o = new Qn(
      0,
      t,
      i,
      Ai.None,
      _e.None,
      Vn.Up
    );
    this.onMouseDown(s), this.onMouseMove(r), await Nl(e), this.onMouseUp(o);
  }
  /** @hidden */
  _onTick() {
    const t = Date.now(), e = (t - this._previousTimestamp) / 1e3;
    this._previousTimestamp = t;
    const i = this._viewer.view, s = E.subtract(this._ptCurrent, this._ptFirst), r = new E(
      Math.abs(s.x) / this._maxDistance,
      Math.abs(s.y) / this._maxDistance
    ), o = this.getRotationSpeed() * e * r.x, a = this.getWalkSpeed() * e * r.y, l = this.getElevationSpeed() * e * r.x, c = this.getElevationSpeed() * e * r.y;
    if (this._walkButton === Kt.Left) {
      if (s.x !== 0 && (s.x > 0 ? this.rotateRight(o) : s.x < 0 && this.rotateLeft(o)), s.y !== 0) {
        const h = i.getCamera();
        this._resetPosition(h);
        const u = h.getTarget(), p = h.getPosition(), m = d.subtract(u, p).normalize(), g = h.getUp();
        let _ = d.scale(m, a);
        s.y > 0 && (_ = _.negate()), this.setWalkActive(!0);
        const y = this.getBimModeEnabled();
        this.getActiveWalk().set(async () => {
          if (y)
            await this._applyWalkDeltaWithCollisionCheck(h, _, g), await this._applyGravity(), await this._updateNearbyDoors();
          else
            return this._applyWalkDelta(h, _);
        });
      }
    } else
      (this._walkButton === Kt.Right || this._walkButton === Kt.Middle) && (Math.abs(s.y) > 0 && (s.y > 0 ? this.walkUp(c) : this.walkDown(c)), Math.abs(s.x) > 0 && (s.x > 0 ? this.walkRight(l) : this.walkLeft(l)));
    this._timerId = requestAnimationFrame(() => {
      this._onTick();
    });
  }
  _adjustTilt(t) {
    const e = this._viewer.view;
    this.setTilt(this.getTilt() + t);
    const i = e.getCamera();
    this._resetPosition(i);
    const s = i.getTarget(), r = i.getPosition(), o = d.distance(s, r), a = i.getUp().normalize(), l = d.subtract(s, r).normalize(), c = d.cross(a, l).normalize();
    Q.createFromOffAxisRotation(c, this.getTilt()).transform(l, l), l.normalize().scale(o), i.setTarget(d.add(r, l)), e.setCamera(i);
  }
  async _resetCameraTarget() {
    const t = this._viewer.view, e = t.getCanvasSize(), i = new E(Math.round(e.x / 2), Math.round(e.y / 2)), s = new be(), r = await t.pickFromPoint(i, s);
    if (r.isEntitySelection()) {
      const o = t.getCamera();
      o.setTarget(r.getPosition()), t.updateCamera(o);
    }
  }
}
class fi extends _s {
  /** @hidden */
  constructor(t) {
    super(), this._stage = 0, this._finalized = !1, this._uniqueId = "", this._positions = [], this._name = "", this._measurementValue = 0, this._unitMultiplier = 1, this._textShape = new qr(), this._visibility = !0, this._positions = [], this._lineShapes = [], this._viewer = t;
  }
  /**
   * Gets the name of this measurement.
   * @returns the measurement name
   */
  getName() {
    return this._name;
  }
  /**
   * Sets the name of this measurement
   * @param name the name to set
   */
  setName(t) {
    this._name = t;
  }
  /** @hidden */
  _getStage() {
    return this._stage;
  }
  /** @hidden */
  _nextStage() {
    this._stage++;
  }
  /** @hidden */
  _setId(t) {
    this._uniqueId = t;
  }
  /** @hidden */
  _getId() {
    return this._uniqueId;
  }
  /** @hidden */
  adjust(t) {
  }
  /** @hidden */
  _isFinalized() {
    return this._finalized;
  }
  /** @hidden */
  update() {
  }
  /** @hidden */
  draw() {
    this.update();
  }
  setVisibility(t) {
    this._visibility = t, this.draw(), t ? this._viewer.trigger("measurementShown", this) : this._viewer.trigger("measurementHidden", this);
  }
  getVisibility() {
    return this._visibility;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {};
  }
  /**
   * Returns the unit agnostic value for this measurement.
   * In the case where this value represents distance, use [[getUnitMultiplier]] to determine the measurement units.
   * In other cases, this value will be the angle measurement in degrees.
   * @returns the measurement value
   */
  getMeasurementValue() {
    return this._measurementValue;
  }
  /**
   * Returns the unit multiplier incorporated into the measurement value.
   * This number is a multiplier of millimeters (for example inches will be `25.4`).
   * The default value is `1.0`.
   */
  getUnitMultiplier() {
    return this._unitMultiplier;
  }
  /**
   * Sets the measurement text that is rendered with this measurement.
   * @param measurementText the text to render with this measurement
   */
  setMeasurementText(t) {
    this._textShape.setTextString(t);
  }
  /**
   * Gets the text for this measurement. By default this will contain the measurement value and units for the model in the cases where the measurement is a distance.
   * In other cases it will contain the angle in degrees.
   */
  getMeasurementText() {
    return this._textShape.getTextString();
  }
  /**
   * Returns whether the measurement markup is valid. Override in subclasses when needed.
   */
  isMarkupValid() {
    return !0;
  }
  /** @hidden */
  _setMeasurementValue(t) {
    this._measurementValue = t / this._unitMultiplier, this.setMeasurementText(Go(this._measurementValue, this._unitMultiplier)), this._viewer.trigger("measurementValueSet", this);
  }
  /** @hidden */
  static _serializePointArray(t) {
    const e = [];
    for (const i of t)
      e.push(i.toJson());
    return e;
  }
  /** @hidden */
  static _constructPointArray(t) {
    const e = [];
    for (const i of t) {
      const s = d.fromJson(i);
      e.push(s);
    }
    return e;
  }
}
class Rh extends fi {
  constructor(t, e) {
    super(t), this._rectangle = new Kl(), this._markupHandle = null, this._dim = new E(0, 0), this.initialPosition = new E(0, 0), this.currentPosition = new E(0, 0), this.min = new E(0, 0), this.max = new E(0, 0), this._name = "_RectangleMarkup", this._rectangle.setFillOpacity(0), this._rectangle.setStrokeColor(it.red()), this._constantStrokeColor = e;
  }
  draw() {
    this._viewer.markupManager.getRenderer().drawRectangle(this._rectangle);
  }
  updateCurrentPosition(t) {
    if (this.currentPosition.assign(t), this._constantStrokeColor || this._rectangle.setStrokeColor(
      this.initialPosition.x < this.currentPosition.x ? it.red() : it.blue()
    ), this.min.assign(this.initialPosition), this.max.assign(this.currentPosition), this.max.x < this.min.x) {
      const e = this.max.x;
      this.max.x = this.min.x, this.min.x = e;
    }
    if (this.max.y < this.min.y) {
      const e = this.max.y;
      this.max.y = this.min.y, this.min.y = e;
    }
    this._dim.assign(this.max), this._dim.subtract(this.min), this._updateRectangleVertices();
  }
  _updateRectangleVertices() {
    this._rectangle.setPosition(this.min), this._rectangle.setSize(this._dim);
  }
  activate(t) {
    this.initialPosition.assign(t), this.currentPosition.assign(t), this.min.assign(t), this.max.assign(t), this._dim.set(0, 0), this._rectangle.setStrokeWidth(1), this._updateRectangleVertices();
    const e = this._viewer.markupManager;
    this._markupHandle = e.registerMarkup(this);
  }
  deactivate() {
    this.initialPosition.set(0, 0), this.currentPosition.set(0, 0), this.min.set(0, 0), this.max.set(0, 0), this._dim.set(0, 0), this._rectangle.setStrokeWidth(0), this._updateRectangleVertices();
    const t = this._viewer.markupManager;
    this._markupHandle !== null && (t.unregisterMarkup(this._markupHandle), this._markupHandle = null), t.refreshMarkup();
  }
  isActive() {
    return this._markupHandle !== null;
  }
}
class Xm extends xe {
  /** @hidden */
  constructor(t) {
    super(t), this._rectangleMarkup = new Rh(t, !0), this._view = t.view, this._computeTarget = !1, this._preserveViewAngle = !0;
  }
  /**
   * When enabled, the camera target will be computed using selection while zooming.
   * This can provide a better zoom behavior in perspective projection mode,
   * but comes at the cost of performing a selection on the model during each zoom operation,
   * which may not be ideal for performance on large models.
   *
   * This setting is disabled by default.
   */
  setComputeTarget(t) {
    this._computeTarget = t;
  }
  /**
   * Returns whether a new camera target will be computed using selection.
   * See [[setComputeTarget]]
   */
  getComputeTarget() {
    return this._computeTarget;
  }
  /**
   * Sets whether to maintain a constant view angle while zooming. If
   * enabled, when zooming causes the camera's field of view to shrink or
   * grow, the camera's position will also be moved toward or away from
   * the target, respectively.
   *
   * This may prevent confusing camera behavior when perspective
   * projection is used or might be used. When using only orthographic
   * projection, it is better to disable this.
   *
   * If window zoom is being using in conjunction with mouse wheel zoom
   * this setting should be the same in both.
   *
   * This setting is enabled by default.
   */
  setPreserveViewAngle(t) {
    this._preserveViewAngle = t;
  }
  /**
   * Gets whether to maintain a constant view angle while zooming. See
   * [[setPreserveViewAngle]].
   */
  getPreserveViewAngle() {
    return this._preserveViewAngle;
  }
  adjustPositionToPlane(t, e) {
    const s = this._view.getCamera().getViewMatrix(this._viewer), r = s.transform(e), o = s.transform(t);
    r.z = o.z;
    const a = Q.inverse(s);
    return a === null ? null : a.transform(r);
  }
  computeNewField(t, e, i) {
    const s = E.add(t, E.scale(E.subtract(e, t), 0.5)), r = new E(e.x, s.y), o = new E(s.x, e.y), a = new E(t.x, s.y), l = new E(s.x, t.y), c = this._view.getCamera(), h = c.getCameraPlaneIntersectionPoint(r, this._view), u = c.getCameraPlaneIntersectionPoint(o, this._view), p = c.getCameraPlaneIntersectionPoint(a, this._view), m = c.getCameraPlaneIntersectionPoint(l, this._view);
    if (h === null || u === null || p === null || m === null)
      return null;
    const g = this.adjustPositionToPlane(i, h), _ = this.adjustPositionToPlane(i, u), y = this.adjustPositionToPlane(i, p), b = this.adjustPositionToPlane(i, m);
    if (g === null || _ === null || y === null || b === null)
      return null;
    const w = d.subtract(g, y), v = d.subtract(_, b);
    return [w.length(), v.length()];
  }
  async computeReasonableTarget(t, e) {
    const i = E.add(t, E.scale(E.subtract(e, t), 0.5)), s = await this._view.pickFromPoint(i, new be());
    if (s.getNodeId() !== null)
      return s.getPosition();
    {
      let r = 0;
      const o = d.zero(), a = await this._view.beginScreenSelectByArea(
        t,
        e,
        new Al()
      );
      for (; ; ) {
        const h = await this._view.advanceIncrementalSelection(a);
        if (h === null)
          break;
        for (const u of h) {
          const p = u.getPosition();
          p !== null && (o.add(p), r++);
        }
      }
      let c = this._view.getCamera().getCameraPlaneIntersectionPoint(i, this._view);
      if (c === null)
        return null;
      if (r !== 0) {
        const h = d.scale(o, 1 / r);
        c = this.adjustPositionToPlane(h, c);
      }
      return c;
    }
  }
  async getCameraTarget(t, e) {
    if (this._computeTarget)
      return this.computeReasonableTarget(t, e);
    const i = this._view.getCamera(), s = E.add(t, E.scale(E.subtract(e, t), 0.5));
    return i.getCameraPlaneIntersectionPoint(s, this._view);
  }
  async doZoom(t, e) {
    const i = this._view.getCamera(), s = i.copy(), r = i.getTarget(), o = await this.getCameraTarget(t, e);
    if (o === null)
      return;
    const a = this.computeNewField(t, e, o);
    if (a === null)
      return;
    const [l, c] = a, h = this._view.getCanvasSize(), u = new E(0, 0), p = d.distance(
      i.getCameraPlaneIntersectionPoint(h, this._view),
      i.getCameraPlaneIntersectionPoint(u, this._view)
    );
    s.setWidth(l), s.setHeight(c), s.setTarget(o), this._viewer.pauseRendering(() => {
      this._view.setCamera(s);
      const m = d.subtract(r, i.getPosition());
      let g;
      if (this._preserveViewAngle) {
        const _ = d.distance(
          s.getCameraPlaneIntersectionPoint(h, this._view),
          s.getCameraPlaneIntersectionPoint(u, this._view)
        ), y = m.length() / p;
        g = d.add(
          o,
          d.scale(m.negate().normalize(), y * _)
        );
      } else
        g = d.subtract(o, m);
      s.setPosition(g), this._view.setCamera(s);
    });
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && (t.setHandled(!0), this._rectangleMarkup.isActive() && this._rectangleMarkup.deactivate(), this._rectangleMarkup.activate(t.getPosition()));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this.isActive() && this._rectangleMarkup.isActive() && (t.setHandled(!0), this._rectangleMarkup.updateCurrentPosition(t.getPosition()), this._viewer.markupManager.refreshMarkup());
  }
  /** @hidden */
  async onMouseUp(t) {
    if (this.isActive() && this._rectangleMarkup.isActive()) {
      const e = this._rectangleMarkup;
      if (e.updateCurrentPosition(t.getPosition()), E.subtract(e.max, e.min).length() <= 3) {
        e.deactivate();
        return;
      }
      t.setHandled(!0), await this.doZoom(e.min, e.max);
    }
    this._rectangleMarkup.isActive() && this._rectangleMarkup.deactivate(), super.onMouseUp(t);
  }
}
class Fm extends xe {
  /** @hidden */
  constructor(t) {
    super(t), this._mouseMoveZoomDelta = 3, this._mouseWheelZoomDelta = 0.25, this._pinchZoomModifier = 2.5, this._zoomToMousePosition = !0, this._dollyZoomEnabled = !1, this._adjustCameraTarget = !1, this._preserveViewAngle = !0, this._mouseMoveZoomFactor = 1, this._mouseWheelZoomFactor = -1, this._secondaryTouchId = null, this._lastTouch1 = E.zero(), this._lastTouch2 = E.zero(), this._prevLen = 0;
  }
  /**
   * When true, scrolling up will zoom towards the model.
   * @param inverted
   */
  setMouseWheelZoomInverted(t) {
    t ? this._mouseWheelZoomFactor = -1 : this._mouseWheelZoomFactor = 1;
  }
  getMouseWheelZoomInverted() {
    return this._mouseWheelZoomFactor === -1;
  }
  /**
   * When true, moving the mouse up will zoom towards the model.
   * @param inverted
   */
  setMouseMoveZoomInverted(t) {
    t ? this._mouseMoveZoomFactor = -1 : this._mouseMoveZoomFactor = 1;
  }
  getMouseMoveZoomInverted() {
    return this._mouseMoveZoomFactor === -1;
  }
  /**
   * Sets the delta to zoom when moving the mouse
   * @param delta
   */
  setMouseMoveZoomDelta(t) {
    this._mouseMoveZoomDelta = t;
  }
  /**
   * Gets the mouse move zoom delta
   * @returns number
   */
  getMouseMoveZoomDelta() {
    return this._mouseMoveZoomDelta;
  }
  /**
   * Sets the delta to zoom when scrolling
   * @param delta
   */
  setMouseWheelZoomDelta(t) {
    this._mouseWheelZoomDelta = t;
  }
  /**
   * Gets the scrollwheel zoom delta
   * @returns number
   */
  getMouseWheelZoomDelta() {
    return this._mouseWheelZoomDelta;
  }
  /**
   * When set, the zoom will be towards the mouse position. When not set, the zoom will be from the center of the screen.
   * @param zoom
   */
  setZoomToMousePosition(t) {
    this._zoomToMousePosition = t;
  }
  /**
   * @returns boolean When true, the zoom will be towards the mouse position. When false, the zoom will be towards the center of the screen.
   */
  getZoomToMousePosition() {
    return this._zoomToMousePosition;
  }
  /**
   * When dolly zoom is enabled, the camera position will move towards the camera target when zooming.
   * @moveCameraPositon
   */
  setDollyZoomEnabled(t) {
    this._dollyZoomEnabled = t;
  }
  /**
   * Returns true if dolly zoom is enabled.
   */
  getDollyZoomEnabled() {
    return this._dollyZoomEnabled;
  }
  /**
   * When enabled, the camera target will be updated to the selection position while zooming.
   * This can provide a better zoom behavior in perspective projection mode,
   * but comes at the cost of performing a selection on the model during each mouse scroll,
   * which may not be ideal for performance on large models.
   *
   * This setting is disabled by default.
   */
  setMouseWheelAdjustCameraTarget(t) {
    this._adjustCameraTarget = t;
  }
  /**
   * Returns whether the camera target will be updated to the selection
   * position while zooming. See [[setMouseWheelAdjustCameraTarget]].
   */
  getMouseWheelAdjustCameraTarget() {
    return this._adjustCameraTarget;
  }
  /**
   * Sets whether to maintain a constant view angle while zooming. If
   * enabled, when zooming causes the camera's field of view to shrink or
   * grow, the camera's position will also be moved toward or away from
   * the target, respectively.
   *
   * This may prevent confusing camera behavior when perspective
   * projection is used or might be used. When using only orthographic
   * projection, it is better to disable this.
   *
   * If mouse wheel zoom is being using in conjunction with window zoom
   * this setting should be the same in both.
   *
   * This setting is enabled by default.
   */
  setPreserveViewAngle(t) {
    this._preserveViewAngle = t;
  }
  /**
   * Gets whether to maintain a constant view angle while zooming. See
   * [[setPreserveViewAngle]].
   */
  getPreserveViewAngle() {
    return this._preserveViewAngle;
  }
  /** @hidden */
  async onMouseMove(t) {
    if (super.onMouseMove(t), this.isDragging() && this.isActive()) {
      const e = this._viewer.view, i = e.pointToWindowPosition(this._ptCurrent), s = e.pointToWindowPosition(this._ptPrevious), r = i.y - s.y, o = i.x - s.x, a = this._mouseMoveZoomDelta * this._mouseMoveZoomFactor * (r - o);
      this._dollyZoomEnabled ? await this._dollyZoom(a, void 0, void 0, !0) : await this._doZoom(a);
    }
  }
  /** @hidden */
  async onMousewheel(t) {
    const e = this._mouseWheelZoomDelta * this._mouseWheelZoomFactor * t.getWheelDelta();
    this._dollyZoomEnabled ? await this._dollyZoom(-e, void 0, t.getPosition()) : await this._doZoom(e, void 0, t.getPosition());
  }
  /** @hidden */
  onTouchStart(t) {
    const e = this._viewer.view;
    this._primaryTouchId === null ? (this._primaryTouchId = t.getId(), this._lastTouch1.assign(e.pointToWindowPosition(t.getPosition()))) : this._secondaryTouchId === null && (this._secondaryTouchId = t.getId(), this._lastTouch2.assign(e.pointToWindowPosition(t.getPosition()))), this._primaryTouchId !== null && this._secondaryTouchId !== null && (this._prevLen = E.subtract(this._lastTouch2, this._lastTouch1).length(), this._dragging = !0);
  }
  /** @hidden */
  onTouchMove(t) {
    const e = this._viewer.view, i = t.getId(), s = t.getPosition();
    if (i === this._primaryTouchId ? this._lastTouch1.assign(e.pointToWindowPosition(s)) : i === this._secondaryTouchId && this._lastTouch2.assign(e.pointToWindowPosition(s)), this._dragging && (i === this._primaryTouchId || i === this._secondaryTouchId)) {
      const r = E.subtract(this._lastTouch2, this._lastTouch1).length(), a = 1 / (1 - (this._prevLen - r) * this._pinchZoomModifier);
      this._zoomHelper(a, this._viewer.view.getCamera()), this._prevLen = r;
    }
    return Promise.resolve();
  }
  /** @hidden */
  onTouchEnd(t) {
    const e = t.getId();
    this._primaryTouchId === e ? this._primaryTouchId = null : this._secondaryTouchId === e && (this._secondaryTouchId = null), this._dragging = !1;
  }
  /** @hidden */
  onDeactivate() {
    this._primaryTouchId = null, this._secondaryTouchId = null;
  }
  _updateCameraViewAngle(t) {
    const e = cs(90), i = Math.tan(e / 2), r = d.subtract(t.getTarget(), t.getPosition()).length() * i;
    return t.setWidth(r), t.setHeight(r), t;
  }
  async _dollyZoom(t, e = this._viewer.view.getCamera(), i, s = !1) {
    const r = this._viewer.view;
    e.setProjection(te.Perspective);
    const o = e.getPosition(), a = e.getTarget();
    if (i) {
      const h = (await this._viewer.model.getModelBounding(!1, !1, !1)).extents().length() / 100, p = (await this._viewer.view.pickFromPoint(i, new be())).getPosition();
      if (p !== null) {
        const g = d.subtract(a, o), _ = d.subtract(p, o), y = d.add(o, g.scale(d.dot(g, _) / d.dot(g, g)));
        e.setTarget(y);
      }
      let m = d.subtract(e.getTarget(), o);
      t > 0 && m.length() < h && e.setTarget(
        d.add(
          a,
          m.copy().normalize().scale(h * 2)
        )
      ), m = d.subtract(e.getTarget(), o), e.setPosition(d.add(o, m.copy().scale(t / 10)));
    } else {
      const l = d.subtract(a, o).scale(t / 10);
      e.setPosition(d.add(o, l)), s && e.setTarget(d.add(a, l));
    }
    e = this._updateCameraViewAngle(e), this._viewer.pauseRendering(() => {
      if (i) {
        const l = e.getCameraPlaneIntersectionPoint(
          i,
          this._viewer.view
        );
        r.setCamera(e);
        const c = e.getCameraPlaneIntersectionPoint(
          i,
          this._viewer.view
        );
        l !== null && c !== null && e.dolly(d.subtract(c, l));
      }
      r.setCamera(e);
    });
  }
  async _doZoom(t, e = this._viewer.view.getCamera(), i) {
    const s = this._viewer.view, r = Math.max(1 / (1 - t), 1e-3);
    if (i && this._zoomToMousePosition) {
      if (this._adjustCameraTarget) {
        const o = await this._viewer.view.pickFromPoint(i, new be());
        if (o !== void 0 && o.isEntitySelection()) {
          const a = e.getPosition().subtract(e.getTarget()), l = d.subtract(e.getTarget(), e.getPosition()), c = d.subtract(o.getPosition(), e.getPosition()), h = e.getPosition().add(l.scale(d.dot(l, c) / d.dot(l, l)));
          e.setTarget(h), e.setPosition(d.add(h, a));
        }
      }
      this._viewer.pauseRendering(() => {
        const o = e.getCameraPlaneIntersectionPoint(
          i,
          this._viewer.view
        );
        this._zoomHelper(r, e);
        const a = e.getCameraPlaneIntersectionPoint(
          i,
          this._viewer.view
        );
        o !== null && a !== null && e.dolly(d.subtract(a, o)), s.setCamera(e);
      });
    } else
      this._zoomHelper(r, e);
  }
  _zoomHelper(t, e) {
    const i = this._viewer.view;
    if (e.setWidth(e.getWidth() * t), e.setHeight(e.getHeight() * t), this._preserveViewAngle && !this._viewer.sheetManager.isDrawingSheetActive()) {
      const s = e.getPosition(), r = e.getTarget(), o = d.subtract(r, s).scale(t), a = d.subtract(r, o);
      e.setPosition(a);
    }
    i.setCamera(e);
  }
}
const U_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CameraKeyboardWalkOperator: ml,
  CameraNavigationOperator: Tm,
  CameraOrbitBaseOperator: Eh,
  CameraOrbitOperator: Nh,
  CameraPanOperator: Em,
  CameraTurntableOperator: Nm,
  CameraWalkBaseOperator: Th,
  CameraWalkModeOperator: Rm,
  CameraWalkOperator: Lm,
  CameraWindowZoomOperator: Xm,
  CameraZoomOperator: Fm,
  DoorCache: Vm,
  MAX_ANGLE: Cm,
  MAX_TILT: Sm,
  MIN_ANGLE: km,
  MIN_TILT: Zm,
  OrbitMarkup: Gm,
  TimedPoints: Ym,
  applyGravity: zc,
  buildCollisionRayConfig: Gh,
  clamp: Dc,
  getDownAxis: Wm,
  normalizeDirections: Mm,
  removeOpposing: Zr,
  testWallCollision: Pm
}, Symbol.toStringTag, { value: "Module" }));
var tn = /* @__PURE__ */ ((n) => (n[n.NoPointsSelected = 0] = "NoPointsSelected", n[n.OnePointSelected = 1] = "OnePointSelected", n[n.TwoPointsSelected = 2] = "TwoPointsSelected", n))(tn || {}), Pr = /* @__PURE__ */ ((n) => (n[n.First = 0] = "First", n[n.Last = 1] = "Last", n[n.Midpoint = 2] = "Midpoint", n))(Pr || {}), Vr = /* @__PURE__ */ ((n) => (n[n.First = 0] = "First", n[n.Last = 1] = "Last", n[n.Midpoint = 2] = "Midpoint", n))(Vr || {});
function Ba(n, t) {
  const e = new jn(t.x, t.y, t.z, 1), i = new jn(0, 0, 0, 0);
  n.view.getFullCameraMatrix().transform4(e, i);
  const s = 1 / i.w, r = new E(i.x * s, i.y * s), { x: o, y: a } = n.view.getCanvasSize();
  return r.x = 0.5 * o * (r.x + 1), r.y = 0.5 * a * (r.y + 1), r.x = Math.max(0, Math.min(r.x, o)), r.y = a - Math.max(0, Math.min(r.y, a)), r;
}
const Bc = class extends fi {
  constructor(n) {
    super(n), this._firstNode = null, this._firstPointShape = new qn(), this._secondPointShape = new qn(), this._arrowsInvert = !1, this._measurePoint1 = null, this._measurePoint2 = null, this._leaderPoint1 = null, this._leaderPoint2 = null, this._textPoint = null, this._name = "MeasureBodyBodyDistance", this._lineShapes = [];
    for (let t = 0; t < 6; t++)
      this._lineShapes.push(new Wi()), this._lineShapes[t].setStrokeColor(this._viewer.measureManager.getMeasurementColor()), this._lineShapes[t].setEndEndcapColor(this._viewer.measureManager.getMeasurementColor()), this._lineShapes[t].setStartEndcapColor(this._viewer.measureManager.getMeasurementColor());
    this._viewer = n, this.initCircle(this._firstPointShape), this.initCircle(this._secondPointShape), this._textShape = new qr(), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new it(255, 255, 255));
  }
  initCircle(n) {
    n.setRadius(2.5), n.setFillColor(this._viewer.measureManager.getMeasurementColor());
  }
  setUnitMultiplier(n) {
    this._unitMultiplier = n;
  }
  setFirstNode(n) {
    this._stage = 1, this._firstNode = n;
  }
  getFirstNode() {
    return this._firstNode;
  }
  async setSecondNode(n) {
    if (this._firstNode === null)
      return;
    this._stage = 2;
    const t = await this._viewer.model.computeMinimumBodyBodyDistance(
      this._firstNode,
      n
    );
    this._measurePoint1 = t.pos1.copy(), this._measurePoint2 = t.pos2.copy(), this._textPoint = t.pos2.copy(), this._setMeasurementValue(t.distance);
  }
  _getStage() {
    return this._stage;
  }
  finalize() {
    this._stage++;
  }
  // adjusts the position of the measurement just before it's finalized
  adjust(n) {
    if (super.adjust(n), this._stage < 2)
      return;
    const t = this._viewer.view.raycastFromPoint(n);
    if (t === null || this._measurePoint1 === null || this._measurePoint2 === null || this._textPoint == null)
      return;
    let e = new d(1, 0, 0);
    this._measurePoint2.equals(this._measurePoint1) || (e = d.subtract(this._measurePoint2, this._measurePoint1));
    const s = this._viewer.view.getCamera().getUp(), r = d.cross(t.direction, s).normalize(), o = new d(
      (this._measurePoint1.x + this._measurePoint2.x) / 2,
      (this._measurePoint1.y + this._measurePoint2.y) / 2,
      (this._measurePoint1.z + this._measurePoint2.z) / 2
    ), a = new d(o.x + s.x, o.y + s.y, o.z + s.z), l = new d(
      o.x + r.x,
      o.y + r.y,
      o.z + r.z
    ), c = new d(
      t.origin.x + t.direction.x * 1e6,
      t.origin.y + t.direction.y * 1e6,
      t.origin.z + t.direction.z * 1e6
    );
    let h = new d(0, 0, 0);
    Ts(
      t.origin,
      c,
      o,
      a,
      l,
      h
    ), this._textPoint.assign(h);
    let u = new d(0, 0, 0);
    Math.abs(e.x) <= Math.abs(e.y) && Math.abs(e.x) <= Math.abs(e.z) ? u = new d(1, 0, 0) : Math.abs(e.y) <= Math.abs(e.x) && Math.abs(e.y) <= Math.abs(e.z) ? u = new d(0, 1, 0) : u = new d(0, 0, 1);
    const p = d.cross(u, e), m = d.cross(p, e);
    p.set(
      this._measurePoint1.x + p.x,
      this._measurePoint1.y + p.y,
      this._measurePoint1.z + p.z
    ), m.set(
      this._measurePoint1.x + m.x,
      this._measurePoint1.y + m.y,
      this._measurePoint1.z + m.z
    );
    const g = new d(
      h.x + e.x * 1e4,
      h.y + e.y * 1e4,
      h.z + e.z * 1e4
    ), _ = new d(
      h.x - e.x * 1e4,
      h.y - e.y * 1e4,
      h.z - e.z * 1e4
    ), y = Ts(
      g,
      _,
      this._measurePoint1,
      p,
      m,
      h
    ), b = !isNaN(h.x) && !isNaN(h.y) && !isNaN(h.z);
    (!y || !b) && (h = this._measurePoint2.copy());
    const w = d.subtract(h, this._measurePoint1);
    this._leaderPoint1 = new d(
      this._measurePoint1.x + w.x,
      this._measurePoint1.y + w.y,
      this._measurePoint1.z + w.z
    ), this._leaderPoint2 = new d(
      this._measurePoint2.x + w.x,
      this._measurePoint2.y + w.y,
      this._measurePoint2.z + w.z
    ), this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup();
  }
  _updateArrowsInverted() {
    if (this._leaderPoint1 === null || this._leaderPoint2 === null || this._textPoint === null)
      return;
    const n = new d(
      (this._leaderPoint1.x + this._leaderPoint2.x) / 2,
      (this._leaderPoint1.y + this._leaderPoint2.y) / 2,
      (this._leaderPoint1.z + this._leaderPoint2.z) / 2
    ), t = d.subtract(this._leaderPoint2, this._leaderPoint1);
    d.subtract(this._textPoint, n).length() * 2 > t.length() ? this._arrowsInvert = !0 : this._arrowsInvert = !1;
  }
  // Called as part of drawing the markup. Sets line positions and determines if the markup is in view
  update() {
    if (super.update(), this._stage <= 1)
      return;
    const n = this._viewer.view;
    this._behindView = !1;
    const t = (a) => {
      if (a === null)
        return E.zero();
      const l = n.projectPoint(a);
      return l.z <= 0 && (this._behindView = !0), E.fromPoint3(l);
    }, e = t(this._measurePoint1), i = t(this._measurePoint2), s = t(this._textPoint), r = t(this._leaderPoint1), o = t(this._leaderPoint2);
    this._firstPointShape.setCenter(e), this._textShape && this._textShape.setPosition(s), this._secondPointShape.setCenter(i), this._lineShapes[0].set(e, i), this._lineShapes[1].set(r, o), this._lineShapes[2].set(e, r), this._lineShapes[3].set(i, o), this._lineShapes[4].set(r, s), this._lineShapes[5].set(r, o), this._lineShapes[5].setEndcapType(ii.Arrowhead), this._lineShapes[5].setStartEndcapType(ii.Arrowhead), this._lineShapes[5].setEndcapsInverted(this._arrowsInvert);
  }
  draw() {
    if (!this._visibility || this._viewer.explodeManager.getMagnitude() !== 0 || (this.update(), this._behindView))
      return;
    const n = this._viewer.markupManager.getRenderer();
    if (this._stage === 2 || this._stage === 3) {
      n.drawCircle(this._firstPointShape), n.drawCircle(this._secondPointShape);
      for (const t of this._lineShapes)
        n.drawLine(t);
      n.drawTextBox(this._textShape);
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      name: this._name,
      measurePoint1: this._measurePoint1,
      measurePoint2: this._measurePoint2,
      leaderPoint1: this._leaderPoint1,
      leaderPoint2: this._leaderPoint2,
      textPoint: this._textPoint,
      text: this._textShape.getTextString(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasureBodyBodyDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new Bc(t);
    return i._name = e.name, i._measurePoint1 = d.fromJson(e.measurePoint1), i._measurePoint2 = d.fromJson(e.measurePoint2), i._textPoint = d.fromJson(e.textPoint), i._textShape.setTextString(e.text), i._leaderPoint1 = d.fromJson(e.leaderPoint1), i._leaderPoint2 = d.fromJson(e.leaderPoint2), i._measurementValue = e.measurementValue, i._unitMultiplier = e.unitMultiplier || 1, i._updateArrowsInverted(), i._stage = 2, i;
  }
  getClassName() {
    return Bc.className;
  }
};
let $o = Bc;
$o.className = "Communicator.Markup.Measure.MeasureBodyBodyDistanceMarkup";
Ui(
  $o.className,
  $o.fromJson
);
class Km extends xe {
  constructor(t, e) {
    super(t), this._moveSelectionAction = new fs(!0), this._currentMoveHighlight = null, this._currentSelectHighlight = null, this._markup = null, this._measureManager = e;
  }
  _unsetCurrentMoveHighlight() {
    this._currentMoveHighlight !== null && (this._viewer.model.setNodesHighlighted([this._currentMoveHighlight.getNodeId()], !1), this._currentMoveHighlight = null);
  }
  _unsetCurrentSelectionHighlight() {
    this._currentSelectHighlight !== null && (this._viewer.model.setNodesHighlighted([this._currentSelectHighlight.getNodeId()], !1), this._currentSelectHighlight = null);
  }
  async _performMoveSelection(t) {
    const e = this._viewer.view, i = this._viewer.model, s = await e.pickFromPoint(t, new be());
    if (s.overlayIndex() !== 0 || !s.isNodeSelection()) {
      this._unsetCurrentMoveHighlight();
      return;
    }
    const r = s.getNodeId();
    if (!(r === null || i.getNodeType(r) !== At.BodyInstance)) {
      if (this._markup) {
        const o = this._markup.getFirstNode();
        if (o !== null && r === o)
          return;
      }
      this._currentMoveHighlight !== null ? s.equals(this._currentMoveHighlight) ? s.getSelectionType() === pi.None && this._unsetCurrentMoveHighlight() : (this._unsetCurrentMoveHighlight(), this._currentMoveHighlight = s, i.setNodesHighlighted([r], !0)) : (this._currentMoveHighlight = s, i.setNodesHighlighted([r], !0));
    }
  }
  async _performUpSelection(t) {
    const e = this._viewer.view, i = this._viewer.model, s = await e.pickFromPoint(t, new be());
    if (s.overlayIndex())
      return;
    if (this._markup && this._markup._getStage() === 1 && this._viewer.trigger("measurementBegin"), this._markup && this._markup._getStage() > 1) {
      const o = this._markup;
      this._markup = null, o.finalize(), this._measureManager.finalizeMeasurement(o);
      return;
    }
    const r = s.getNodeId();
    r !== null && i.getNodeType(r) === At.BodyInstance && (!this._markup || this._markup._getStage() <= 1) && (this._unsetCurrentMoveHighlight(), this._markup ? (this._unsetCurrentSelectionHighlight(), await this._markup.setSecondNode(r), this._markup.adjust(t)) : (this._markup = new $o(this._viewer), this._markup.setUnitMultiplier(i.getNodeUnitMultiplier(r)), this._markup.setFirstNode(r), s.isNodeSelection() && (this._unsetCurrentSelectionHighlight(), this._currentSelectHighlight = s, this._viewer.model.setNodesHighlighted([r], !0)), this._measureManager.addMeasurement(this._markup)));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = t.getPosition();
    (!this._markup || this._markup._getStage() <= 1) && this._moveSelectionAction.set(() => this._performMoveSelection(e)), this._viewer.markupManager.refreshMarkup(), this._markup !== null && this._markup._getStage() > 0 && this._markup.adjust(e);
  }
  async _onMouseUpImpl(t) {
    if (!this.isActive())
      return;
    const e = this._primaryTouchId !== null && this._markup !== null && this._markup._getStage() > 1;
    if (!(this._dragCount < 3 || e))
      return;
    const i = t.getPosition();
    await this._performUpSelection(i);
  }
  /** @hidden */
  async onMouseUp(t) {
    await this._onMouseUpImpl(t), super.onMouseUp(t);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  onKeyUp(t) {
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Ut.Escape && (this._markup !== null ? (this._measureManager.removeMeasurement(this._markup), this._markup = null) : this._measureManager.removeLastMeasurement());
  }
  /** @hidden */
  setHandled() {
    return this._markup !== null && this._markup._getStage() > 1;
  }
  /** @hidden */
  onDeactivate() {
    super.onDeactivate(), this._unsetCurrentMoveHighlight(), this._markup !== null && (this._measureManager.removeMeasurement(this._markup), this._markup = null);
  }
}
const Om = class extends fi {
  /** @hidden */
  constructor(n) {
    super(n), this._lineEdgeShape = new fr(), this._linePositions = [], this._name = "MeasureLength", this._positions = [], this._lineShapes = [], this._lineEdgeShape.setStrokeWidth(4), this._lineEdgeShape.setStrokeColor(n.measureManager.getMeasurementEdgeColor());
  }
  setLineGeometry(n) {
    this._linePositions = n, this._stage = 1;
  }
  setMeasurementEdgeColor(n) {
    this._lineEdgeShape.setStrokeColor(n);
  }
  reset() {
    this._stage = 0;
  }
  adjust(n) {
    super.adjust(n);
  }
  draw() {
  }
  getLineEdgeShape() {
    return this._lineEdgeShape;
  }
  //serialization methods
  getClassName() {
    return Om.className;
  }
};
let Bl = Om;
Bl.className = "Communicator.Markup.Measure.MeasureLengthMarkup";
const jc = class extends Bl {
  constructor(n, t, e, i) {
    super(n), this._circlePoints = [], this._radius = 0, this._surfaceCenter = d.zero(), this._circlePlane = new je(), this._arrowsInvert = !1, this._name = "MeasureCircleEdgeLength", this._lineProperties = t, this._matrix = e.copy(), this._unitMultiplier = i, this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new it(255, 255, 255));
    const r = n.measureManager.getMeasurementColor();
    for (let o = 0; o < 5; o++)
      this._lineShapes.push(new Wi()), this._lineShapes[o].setStrokeColor(r), this._lineShapes[o].setEndEndcapColor(r), this._lineShapes[o].setStartEndcapColor(r);
  }
  createCircleData() {
    ig(
      this._circlePoints,
      this._lineProperties.origin,
      this._lineProperties.radius,
      32,
      this._lineProperties.normal
    ), this._matrix.transformArray(this._circlePoints, this._circlePoints), this._positions[0] = this._circlePoints[0].copy(), this._positions[1] = this._circlePoints[16].copy();
    const n = new d(this._lineProperties.radius, 0, 0), t = new d(0, 0, 0);
    this._matrix.transform(n, n), this._matrix.transform(t, t);
    let e = d.subtract(t, n);
    this._radius = e.length(), e = d.subtract(this._positions[1], this._positions[0]), this._positions[4] = this._positions[1].copy(), this._surfaceCenter = this._matrix.transform(this._lineProperties.origin);
    const i = new d(
      this._circlePoints[0].x,
      this._circlePoints[0].y,
      this._circlePoints[0].z
    ), s = new d(
      this._circlePoints[1].x,
      this._circlePoints[1].y,
      this._circlePoints[1].z
    );
    this._circlePlane = je.createFromPoints(i, s, this._surfaceCenter);
  }
  setLineGeometry(n) {
    if (super.setLineGeometry(n), this._positions[0] = this._linePositions[0], this._positions[0].equals(this._positions[this._positions.length - 1])) {
      const t = Math.floor(this._positions.length / 2);
      this._positions[1] = this._positions[t];
    } else
      this._positions[1] = this._linePositions[this._linePositions.length - 1];
    this._positions[1] = this._linePositions[this._linePositions.length - 1], this._positions[2] = this._linePositions[1].copy(), this.createCircleData(), this._setMeasurementValue(this._radius);
  }
  adjust(n) {
    super.adjust(n);
    const t = this._viewer.view.raycastFromPoint(n);
    if (t === null)
      return;
    const e = this._surfaceCenter, i = this._circlePlane;
    let s = i.rayIntersection(t);
    if (s === null) {
      const l = d.add(e, t.direction.copy().scale(-2 * this._radius)), h = je.createFromPointAndNormal(l, t.direction).rayIntersection(t);
      console.assert(h !== null);
      const u = new Gn(h, i.normal);
      s = i.rayIntersection(u), s === null && (s = i.rayIntersection(u.negate()));
    }
    s === null && (console.assert(!1), s = e.copy());
    const r = d.subtract(s, e).normalize().scale(this._radius), o = d.add(e, r), a = d.subtract(e, r);
    this._positions[0] = o, this._positions[1] = a, this._positions[2] = o.copy(), this._positions[3] = a.copy(), this._positions[4] = s.copy(), this._positions[5] = this._surfaceCenter.copy(), this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup();
  }
  _updateArrowsInverted() {
    const n = new d(
      (this._positions[4].x + this._positions[5].x) / 2,
      (this._positions[4].y + this._positions[5].y) / 2,
      (this._positions[4].z + this._positions[5].z) / 2
    ), t = d.subtract(this._positions[5], this._positions[4]), e = d.subtract(this._positions[2], n);
    this._arrowsInvert = e.length() * 2 > t.length();
  }
  update() {
    super.update();
    const n = this._viewer.view;
    if (this._stage > 0) {
      this._lineEdgeShape.clearPoints();
      for (const t of this._linePositions) {
        const e = E.fromPoint3(n.projectPoint(t));
        this._lineEdgeShape.pushPoint(e);
      }
    }
    if (this._stage > 1) {
      const t = new Array(6);
      for (let e = 0; e < this._positions.length; e++)
        t[e] = E.fromPoint3(n.projectPoint(this._positions[e]));
      this._textShape && this._textShape.setPosition(t[4]), this._lineShapes[0].set(t[5], t[2]), this._lineShapes[1].set(t[5], t[4]), this._lineShapes[0].setEndcapType(ii.Arrowhead), this._lineShapes[0].setStartEndcapType(ii.None), this._lineShapes[0].setEndcapsInverted(this._arrowsInvert);
    }
  }
  draw() {
    if (this._visibility && this._viewer.explodeManager.getMagnitude() === 0) {
      this.update();
      const t = this._viewer.markupManager.getRenderer();
      switch (this._stage) {
        case 1:
          t.drawPolyline(this._lineEdgeShape);
          break;
        case 2:
        case 3:
          for (let e = 0; e < 2; e++)
            t.drawLine(this._lineShapes[e]);
          t.drawTextBox(this._textShape), t.drawPolyline(this._lineEdgeShape);
          break;
      }
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const n = fi._serializePointArray(this._linePositions), t = fi._serializePointArray(this._positions);
    return {
      matrix: this._matrix.toJson(),
      lineOrigin: this._lineProperties.origin,
      lineRadius: this._lineProperties.radius,
      lineNormal: this._lineProperties.normal,
      linePositions: n,
      positions: t,
      text: this._textShape.getTextString(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasureCircleEdgeLengthMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = Q.fromJson(e.matrix), s = e.lineRadius, r = d.fromJson(e.lineOrigin), o = d.fromJson(e.lineNormal), a = new ha(s, r, o), l = e.unitMultiplier || 1, c = new jc(
      t,
      a,
      i,
      l
    ), h = fi._constructPointArray(e.linePositions), u = fi._constructPointArray(e.positions);
    return c.setLineGeometry(h), c._positions = u, c._textShape.setTextString(e.text), c._stage = 3, c._measurementValue = e.measurementValue, c;
  }
  getClassName() {
    return jc.className;
  }
};
let ta = jc;
ta.className = "Communicator.Markup.Measure.MeasureCircleEdgeLengthMarkupMeasureMarkup";
Ui(
  ta.className,
  ta.fromJson
);
const Hc = class extends Bl {
  /** @hidden */
  constructor(n, t, e, i) {
    super(n), this._lineProperties = null, this._worldSpaceLength = 0, this._arrowsInvert = !1, this._name = "MeasureStraightEdgeLength", this._lineProperties = t, this._matrix = e.copy(), this._matrix.setTranslationComponent(0, 0, 0), this._unitMultiplier = i;
    const r = this._viewer.measureManager.getMeasurementColor();
    for (let a = 0; a < 5; a++) {
      const l = new Wi();
      l.setStrokeColor(r), l.setEndEndcapColor(r), l.setStartEndcapColor(r), this._lineShapes.push(l);
    }
    const o = this._textShape.getBoxPortion();
    o.setFillOpacity(1), o.setFillColor(new it(255, 255, 255));
  }
  /** @hidden */
  setLineGeometry(n) {
    super.setLineGeometry(n), this._positions[0] = this._linePositions[0], this._positions[2] = this._linePositions[0].copy(), this._positions[1] = this._linePositions[this._linePositions.length - 1];
    let t;
    if (this._lineProperties !== null && this._lineProperties.length !== -1) {
      const e = new d(this._lineProperties.length, 0, 0);
      this._matrix.transform(e, e), this._worldSpaceLength = e.length(), t = this._worldSpaceLength;
    } else
      t = d.subtract(this._positions[1], this._positions[0]).length();
    this._setMeasurementValue(t);
  }
  /** @hidden */
  adjust(n) {
    super.adjust(n);
    const t = this._viewer.view, e = t.raycastFromPoint(n);
    if (e === null)
      return;
    const i = this._positions[0], s = this._positions[1];
    let r = new d(1, 0, 0);
    s.equals(i) || (r = d.subtract(s, i));
    const a = t.getCamera().getUp(), l = d.cross(e.direction, a).normalize(), c = d.add(i, s).scale(0.5), h = d.add(c, a), u = d.add(c, l), p = d.add(d.scale(e.direction, 1e6), e.origin), m = new d(0, 0, 0);
    Ts(e.origin, p, c, h, u, m), this._positions[2].assign(m);
    let g = new d(0, 0, 0);
    Math.abs(r.x) <= Math.abs(r.y) && Math.abs(r.x) <= Math.abs(r.z) ? g = new d(1, 0, 0) : Math.abs(r.y) <= Math.abs(r.x) && Math.abs(r.y) <= Math.abs(r.z) ? g = new d(0, 1, 0) : g = new d(0, 0, 1);
    const _ = d.cross(g, r), y = d.cross(_, r);
    _.add(i), y.add(i);
    const b = d.add(d.scale(r, 1e4), m), w = d.add(d.scale(r, -1e4), m);
    Ts(b, w, i, _, y, m);
    const v = d.subtract(m, i);
    this._positions[3] = d.add(i, v), this._positions[4] = d.add(s, v), this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup();
  }
  _updateArrowsInverted() {
    const n = d.add(this._positions[3], this._positions[4]).scale(0.5), t = d.subtract(this._positions[4], this._positions[3]), e = d.subtract(this._positions[2], n);
    this._arrowsInvert = 2 * e.squaredLength() > t.squaredLength();
  }
  /** @hidden */
  update() {
    super.update();
    const n = this._viewer.view;
    if (this._behindView = !1, this._stage > 0) {
      this._lineEdgeShape.clearPoints();
      const t = Array(this._linePositions.length);
      for (let e = 0; e < this._linePositions.length; e++)
        t[e] = n.projectPoint(this._linePositions[e]), t[e].z <= 0 && (this._behindView = !0), this._lineEdgeShape.pushPoint(E.fromPoint3(t[e]));
    }
    if (this._stage > 1) {
      const t = new Array(6), e = Array(6);
      for (let i = 0; i < this._positions.length; i++)
        e[i] = n.projectPoint(this._positions[i]), e[i].z <= 0 && (this._behindView = !0), t[i] = E.fromPoint3(e[i]);
      this._textShape && this._textShape.setPosition(t[2]), this._lineShapes[0].set(t[3], t[4]), this._lineShapes[1].set(t[0], t[3]), this._lineShapes[2].set(t[1], t[4]), this._lineShapes[3].set(t[3], t[2]), this._lineShapes[4].set(t[3], t[4]), this._lineShapes[4].setEndcapType(ii.Arrowhead), this._lineShapes[4].setStartEndcapType(ii.Arrowhead), this._lineShapes[4].setEndcapsInverted(this._arrowsInvert);
    }
  }
  /** @hidden */
  draw() {
    if (this._visibility && this._viewer.explodeManager.getMagnitude() === 0 && (this.update(), !this._behindView)) {
      const n = this._viewer.markupManager.getRenderer();
      switch (this._stage) {
        case 1:
          n.drawPolyline(this._lineEdgeShape);
          break;
        case 2:
        case 3:
          for (const t of this._lineShapes)
            n.drawLine(t);
          n.drawTextBox(this._textShape), n.drawPolyline(this._lineEdgeShape);
          break;
      }
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      name: this._name,
      measurePoint1: this._positions[0].copy(),
      measurePoint2: this._positions[1].copy(),
      leaderPoint1: this._positions[3].copy(),
      leaderPoint2: this._positions[4].copy(),
      textPoint: this._positions[2].copy(),
      text: this._textShape.getTextString(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      className: this.getClassName(),
      matrix: this._matrix.toJson()
    };
  }
  /**
   * Creates a new [[MeasureStraightEdgeLengthMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = Q.fromJson(e.matrix), s = e.unitMultiplier || 1, r = new Hc(t, null, i, s);
    return r._name = e.name, r._positions[0] = d.fromJson(e.measurePoint1), r._positions[1] = d.fromJson(e.measurePoint2), r._positions[2] = d.fromJson(e.textPoint), r._textShape.setTextString(e.text), r._positions[3] = d.fromJson(e.leaderPoint1), r._positions[4] = d.fromJson(e.leaderPoint2), r._measurementValue = e.measurementValue, r._updateArrowsInverted(), r._stage = 2, r;
  }
  getClassName() {
    return Hc.className;
  }
};
let pl = Hc;
pl.className = "Communicator.Markup.Measure.MeasureStraightEdgeLengthMarkup";
class Am extends xe {
  /** @hidden */
  constructor(t, e) {
    super(t), this._pickConfig = new be(Xt.Line), this._moveSelectionAction = new fs(!0), this._lengthMarkup = null, this._edgeMarkup = null, this._measureManager = e, this._pickConfig.restrictLinesAndPointsToSelectedFaceInstances = !1;
  }
  /** @hidden */
  onActivate() {
    this._edgeMarkup === null && (this._edgeMarkup = new pl(this._viewer, null, new Q(), 1));
  }
  _unregisterEdgeMarkup() {
    if (this._edgeMarkup === null)
      return;
    const t = this._edgeMarkup._getId();
    t !== "" && (this._viewer.markupManager.unregisterMarkup(t), this._edgeMarkup._setId(""));
  }
  _registerEdgeMarkup() {
    this._edgeMarkup !== null && (this._unregisterEdgeMarkup(), this._edgeMarkup._setId(this._viewer.markupManager.registerMarkup(this._edgeMarkup)));
  }
  _resetEdgeMarkup() {
    this._edgeMarkup !== null && (this._unregisterEdgeMarkup(), this._edgeMarkup.reset());
  }
  async _performMoveSelection(t, e) {
    const s = await this._viewer.view.pickFromPoint(t, this._pickConfig), r = s.getNodeId(), o = s.getLineEntity();
    r && o && !o.isCappingGeometry() && s.overlayIndex() === 0 && await this._viewer.model.isLineMeasurable(r, o.getLineId()) ? (e.setLineGeometry(o.getPoints()), this._registerEdgeMarkup()) : this._resetEdgeMarkup();
  }
  async _performUpSelection(t) {
    const e = this._viewer.view, i = this._viewer.model, s = await e.pickFromPoint(t, this._pickConfig);
    if (s.overlayIndex())
      return;
    if (this._lengthMarkup && this._lengthMarkup._getStage() === 2) {
      const h = this._lengthMarkup;
      this._lengthMarkup = null, h._nextStage(), this._measureManager.finalizeMeasurement(h);
      return;
    }
    if (this._lengthMarkup || !s.isLineSelection())
      return;
    const r = s.getNodeId();
    if (!r)
      return;
    const o = s.getLineEntity();
    if (!await this._viewer.model.isLineMeasurable(r, o.getLineId()))
      return;
    const l = i.getNodeUnitMultiplier(r), c = await i.getEdgeProperty(r, o.getLineId());
    if (this._viewer.trigger("measurementBegin"), !!c) {
      if (c instanceof vl || c instanceof lr) {
        const h = i.getNodeNetMatrix(r);
        this._lengthMarkup = new pl(
          this._viewer,
          c,
          h,
          l
        ), this._measureManager.addMeasurement(this._lengthMarkup), this._lengthMarkup.setLineGeometry(o.getPoints()), this._lengthMarkup._nextStage(), this._lengthMarkup.adjust(t);
      } else if (c instanceof ha) {
        const h = i.getNodeNetMatrix(r);
        this._lengthMarkup = new ta(
          this._viewer,
          c,
          h,
          l
        ), this._measureManager.addMeasurement(this._lengthMarkup), this._lengthMarkup.setLineGeometry(o.getPoints()), this._lengthMarkup._nextStage(), this._lengthMarkup.adjust(t);
      }
      this._lengthMarkup._getStage() === 2 && this._viewer.trigger("measurementValueSet", this._lengthMarkup);
    }
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = this._edgeMarkup;
    if (e === null)
      return;
    e.setMeasurementEdgeColor(this._viewer.measureManager.getMeasurementEdgeColor());
    const i = t.getPosition();
    this.isDragging() && this._primaryTouchId === null ? this._resetEdgeMarkup() : (this._lengthMarkup === null && this._moveSelectionAction.set(() => this._performMoveSelection(i, e)), this._viewer.markupManager.refreshMarkup(), this._lengthMarkup !== null && this._lengthMarkup._getStage() > 0 && this._lengthMarkup.adjust(i));
  }
  async _onMouseUpImpl(t) {
    if (!this.isActive())
      return;
    const e = this._primaryTouchId !== null && this._lengthMarkup !== null;
    if (!(this._dragCount < 3 || e))
      return;
    const i = t.getPosition();
    await this._performUpSelection(i);
  }
  /** @hidden */
  onMouseUp(t) {
    this._onMouseUpImpl(t), super.onMouseUp(t);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  onKeyUp(t) {
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Ut.Escape && (this._lengthMarkup !== null ? (this._measureManager.removeMeasurement(this._lengthMarkup), this._lengthMarkup = null) : this._measureManager.removeLastMeasurement(), this._edgeMarkup !== null && this._resetEdgeMarkup());
  }
  /** @hidden */
  setHandled() {
    return this._lengthMarkup !== null;
  }
  /** @hidden */
  onDeactivate() {
    this._lengthMarkup !== null && (this._measureManager.removeMeasurement(this._lengthMarkup), this._lengthMarkup = null), this._edgeMarkup !== null && this._resetEdgeMarkup();
  }
}
const fu = 30, Uc = class extends fi {
  constructor(n) {
    super(n), this._faceSelection = [], this._arcArray = [], this._lineGeometryShape = new fr(), this.planeIntersectionLine = [], this._pointOnLine = d.zero(), this._clickpointOriginal2 = d.zero(), this._clickpointOriginal1 = d.zero(), this._plane1 = new je(), this._plane2 = new je(), this._secondPoint = d.zero(), this._firstPoint = d.zero(), this._textPos = d.zero(), this._intermediatePoint = d.zero(), this._textAnchorPoint = d.zero(), this._angle = 0, this._useAuthoredNormals = !0, this._name = "MeasureFaceFaceAngle";
    const e = this._viewer.measureManager.getMeasurementColor();
    this._lineGeometryShape.setStrokeWidth(2), this._lineGeometryShape.setStrokeColor(e), this._lineGeometryShape.setEndEndcapColor(e), this._lineGeometryShape.setStartEndcapColor(e), this._textShape = new qr(), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new it(255, 255, 255));
    for (let i = 0; i < 5; i++)
      this._lineShapes.push(new Wi()), this._lineShapes[i].setStrokeColor(e), this._lineShapes[i].setEndEndcapColor(e), this._lineShapes[i].setStartEndcapColor(e);
  }
  async _getNormalAndPositionFromSelection(n, t, e) {
    const i = n.getNodeId(), s = n.getFaceEntity().getCadFaceIndex();
    e.assign(n.getPosition().copy()), t.assign(n.getFaceEntity().getNormal());
    const r = await this._viewer.model.getFaceProperty(i, s);
    if (this._useAuthoredNormals && r !== null && r instanceof Be) {
      const a = this._viewer.model.getNodeNetMatrix(i).normalMatrix();
      a !== null && a.transform(r.normal, t);
    }
  }
  getFirstSelection() {
    return this._faceSelection[0];
  }
  async setFirstFace(n) {
    const t = n.getNodeId(), e = n.getFaceEntity().getCadFaceIndex();
    this._viewer.model.setNodeFaceColor(t, e, new it(255, 0, 0)), this._faceSelection.push(n);
    const i = d.zero(), s = d.zero();
    await this._getNormalAndPositionFromSelection(n, i, s), this._firstPoint = s.copy(), this._plane1.setFromPointAndNormal(this._firstPoint, i), this._clickpointOriginal1 = n.getPosition().copy(), this._stage++;
  }
  async setSecondFace(n) {
    const t = n.getNodeId(), e = n.getFaceEntity().getCadFaceIndex();
    this._faceSelection[1] = n, this._viewer.model.setNodeFaceColor(t, e, new it(255, 0, 0));
    const i = d.zero(), s = d.zero();
    if (await this._getNormalAndPositionFromSelection(n, s, i), this._secondPoint = i.copy(), this._plane2.setFromPointAndNormal(this._secondPoint, s), this.planeIntersectionLine[0] = new d(0, 0, 0), this.planeIntersectionLine[1] = new d(0, 0, 0), tg(
      this._plane1,
      this._firstPoint,
      this._plane2,
      this._secondPoint,
      this.planeIntersectionLine[0],
      this.planeIntersectionLine[1]
    ) !== 2)
      return !1;
    const o = d.subtract(this.planeIntersectionLine[1], this.planeIntersectionLine[0]);
    o.normalize(), this.planeIntersectionLine[0].set(
      this.planeIntersectionLine[0].x - o.x * 100,
      this.planeIntersectionLine[0].y - o.y * 100,
      this.planeIntersectionLine[0].z - o.z * 100
    ), this.planeIntersectionLine[1].set(
      this.planeIntersectionLine[1].x + o.x * 100,
      this.planeIntersectionLine[1].y + o.y * 100,
      this.planeIntersectionLine[1].z + o.z * 100
    ), ss(
      this._secondPoint,
      this.planeIntersectionLine[0],
      this.planeIntersectionLine[1],
      this._pointOnLine
    );
    const a = new d(0, 0, 0), l = new d(0, 0, 0);
    a.set(
      this._firstPoint.x + o.x,
      this._firstPoint.y + o.y,
      this._firstPoint.z + o.z
    ), ss(this._pointOnLine, this._firstPoint, a, l), this._firstPoint = l.copy(), this._clickpointOriginal2 = n.getPosition().copy();
    const c = new Q(), h = d.subtract(this._secondPoint, this._pointOnLine), u = h.length(), p = d.subtract(this._firstPoint, this._pointOnLine);
    if (p.normalize(), this._intermediatePoint.set(
      this._pointOnLine.x + p.x * u,
      this._pointOnLine.y + p.y * u,
      this._pointOnLine.z + p.z * u
    ), this._angle = Yn(h, p), this._angle === 0)
      return !1;
    this._measurementValue = this._angle, this._textShape.setTextString(`${this._measurementValue.toFixed(2)}°`), this._viewer.trigger("measurementValueSet", this), this._textPos = this._pointOnLine.copy();
    let m = !1, g = new d(0, 0, 0);
    const _ = new d(0, 0, 0);
    ro(o, 1, c), c.transform(h, _), g.set(_.x + this._pointOnLine.x, _.y + this._pointOnLine.y, _.z + this._pointOnLine.z), g = d.subtract(g, this._firstPoint);
    const y = g.length();
    return ro(o, -1, c), c.transform(h, _), g.set(_.x + this._pointOnLine.x, _.y + this._pointOnLine.y, _.z + this._pointOnLine.z), d.subtract(g, this._firstPoint), g.length() < y && (m = !0), this._arcArray = _c(
      o,
      m ? -this._angle : this._angle,
      this._pointOnLine,
      h,
      fu
    ), this._stage++, !0;
  }
  adjust(n) {
    if (super.adjust(n), this._stage <= 1)
      return;
    const t = this._viewer.view.raycastFromPoint(n);
    if (t === null)
      return;
    const e = new d(
      t.origin.x + t.direction.x * 1e6,
      t.origin.y + t.direction.y * 1e6,
      t.origin.z + t.direction.z * 1e6
    ), i = new d(0, 0, 0);
    Ts(
      t.origin,
      e,
      this._pointOnLine,
      this._firstPoint,
      this._secondPoint,
      i
    ), this._textPos = i.copy();
    let s = new d(0, 0, 0);
    s = d.subtract(i, this._pointOnLine);
    const r = s.length();
    s = d.subtract(this._secondPoint, this._pointOnLine), s.normalize(), this._secondPoint.set(
      this._pointOnLine.x + s.x * r,
      this._pointOnLine.y + s.y * r,
      this._pointOnLine.z + s.z * r
    );
    const o = d.subtract(this.planeIntersectionLine[1], this.planeIntersectionLine[0]);
    o.normalize();
    const a = new Q(), l = d.subtract(this._secondPoint, this._pointOnLine), c = l.length(), h = d.subtract(this._firstPoint, this._pointOnLine);
    h.normalize(), this._intermediatePoint.set(
      this._pointOnLine.x + h.x * c,
      this._pointOnLine.y + h.y * c,
      this._pointOnLine.z + h.z * c
    );
    let u = !1, p = new d(0, 0, 0);
    const m = new d(0, 0, 0);
    ro(o, 1, a), a.transform(l, m), p.set(m.x + this._pointOnLine.x, m.y + this._pointOnLine.y, m.z + this._pointOnLine.z), p = d.subtract(p, this._firstPoint);
    const g = p.length();
    ro(o, -1, a), a.transform(l, m), p.set(m.x + this._pointOnLine.x, m.y + this._pointOnLine.y, m.z + this._pointOnLine.z), p = d.subtract(p, this._firstPoint), p.length() < g && (u = !0), this._arcArray = _c(
      o,
      u ? -this._angle : this._angle,
      this._pointOnLine,
      l,
      fu
    );
    let y;
    const b = this._viewer.view.projectPoint(this._textPos);
    for (const w of this._arcArray) {
      const v = this._viewer.view.projectPoint(w), k = new d(
        b.x - v.x,
        b.y - v.y,
        b.z - v.z
      ).length();
      (y === void 0 || y > k) && (y = k);
    }
    if (y === void 0 || y <= 20)
      this._textAnchorPoint = this._textPos;
    else {
      const w = this._viewer.view.projectPoint(this._intermediatePoint), v = this._viewer.view.projectPoint(this._secondPoint), C = new d(
        w.x - b.x,
        w.y - b.y,
        w.z - b.z
      ), k = new d(
        v.x - b.x,
        v.y - b.y,
        v.z - b.z
      ), Y = C.length(), P = k.length();
      Y < P ? this._textAnchorPoint = this._intermediatePoint : this._textAnchorPoint = this._secondPoint;
    }
  }
  _nextStage() {
    this._stage++, this._stage > 2 && (this._finalized = !0, this.cleanup());
  }
  cleanup() {
    const n = (t) => {
      const e = this._faceSelection[t];
      this._viewer.model.unsetNodeFaceColor(
        e.getNodeId(),
        e.getFaceEntity().getCadFaceIndex()
      );
    };
    this._stage >= 2 && n(1), this._stage >= 1 && n(0);
  }
  update() {
    super.update();
    const n = this._viewer.view;
    if (this._stage > 1) {
      this._lineGeometryShape.clearPoints();
      for (const i of this._arcArray)
        this._lineGeometryShape.pushPoint(E.fromPoint3(n.projectPoint(i)));
      this._lineGeometryShape.setEndcapType(ii.Arrowhead), this._lineGeometryShape.setStartEndcapType(ii.Arrowhead), this._lineGeometryShape.setEndEndcapSize(5), this._lineGeometryShape.setStartEndcapSize(5);
      const t = new Array(10);
      t[0] = n.projectPoint(this._textPos), t[1] = n.projectPoint(this._firstPoint), t[2] = n.projectPoint(this._clickpointOriginal1), t[3] = n.projectPoint(this._secondPoint), t[4] = n.projectPoint(this._clickpointOriginal2), t[5] = n.projectPoint(this._intermediatePoint), t[6] = n.projectPoint(this._textAnchorPoint), this._behindView = !1;
      const e = new Array(10);
      for (let i = 0; i <= 6; i++)
        t[i].z <= 0 && (this._behindView = !0), e[i] = E.fromPoint3(t[i]);
      this._textShape && this._textShape.setPosition(e[0]), this._lineShapes[0].set(e[1], e[2]), this._lineShapes[1].set(e[1], e[5]), this._lineShapes[2].set(e[3], e[4]), this._lineShapes[3].set(e[6], e[0]);
    }
  }
  draw() {
    const n = this._viewer.explodeManager.getMagnitude() !== 0;
    if (!(!this._visibility || n) && (this.update(), !this._behindView && this._stage >= 2 && this._stage <= 4)) {
      const t = this._viewer.markupManager.getRenderer();
      for (let e = 0; e < 4; e++)
        t.drawLine(this._lineShapes[e]);
      t.drawTextBox(this._textShape), t.drawPolyline(this._lineGeometryShape);
    }
  }
  /**
   * Sets whether created markup will use authored normals or use selection results to calculate angles
   * @param use
   */
  setUseAuthoredNormals(n) {
    this._useAuthoredNormals = n;
  }
  /**
   * Gets whether created markup will use authored normals or use selection results to calculate angles
   */
  getUseAuthoredNormals() {
    return this._useAuthoredNormals;
  }
  // selection methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const n = [];
    for (const t of this._arcArray) {
      const e = t.toJson();
      n.push(e);
    }
    return {
      text: this._textShape.getTextString(),
      textPos: this._textPos.toJson(),
      arcArray: n,
      firstPoint: this._firstPoint.toJson(),
      clickpointOriginal1: this._clickpointOriginal1.toJson(),
      secondPoint: this._secondPoint.toJson(),
      clickpointOriginal2: this._clickpointOriginal2.toJson(),
      intermediatePoint: this._intermediatePoint.toJson(),
      textAnchorPoint: this._textAnchorPoint.toJson(),
      measurementValue: this._measurementValue,
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasureFaceFaceAngleMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new Uc(t);
    for (const s of e.arcArray) {
      const r = d.fromJson(s);
      i._arcArray.push(r);
    }
    return i._textShape.setTextString(e.text), i._textPos.assign(d.fromJson(e.textPos)), i._firstPoint.assign(d.fromJson(e.firstPoint)), i._clickpointOriginal1 = d.fromJson(e.clickpointOriginal1), i._secondPoint.assign(d.fromJson(e.secondPoint)), i._clickpointOriginal2 = d.fromJson(e.clickpointOriginal2), i._intermediatePoint.assign(d.fromJson(e.intermediatePoint)), i._textAnchorPoint.assign(d.fromJson(e.textAnchorPoint)), i._measurementValue = e.measurementValue, i._stage = 3, i;
  }
  // serialization methods
  getClassName() {
    return Uc.className;
  }
};
let ea = Uc;
ea.className = "Communicator.Markup.Measure.MeasureFaceFaceAngleMarkup";
Ui(ea.className, ea.fromJson);
async function cc(n, t) {
  if (t.getSelectionType() !== pi.None) {
    const e = t.getNodeId(), i = t.getFaceEntity();
    return await n.isFaceMeasurable(e, i.getCadFaceIndex()) ? (i.getCadFaceBits() & kd.SelectionBitsFacePlanar) !== 0 : !1;
  }
  return !1;
}
class Dm extends xe {
  constructor(t, e) {
    super(t), this._moveSelectionAction = new fs(!0), this._currentHighlight = null, this._markup = null, this._useAuthoredNormals = !0, this._measureManager = e;
  }
  _unsetCurrentHighlight() {
    this._currentHighlight !== null && (this._viewer.model.unsetNodeFaceColor(
      this._currentHighlight.getNodeId(),
      this._currentHighlight.getFaceEntity().getCadFaceIndex()
    ), this._currentHighlight = null);
  }
  async _performMoveSelection(t) {
    const e = this._viewer.view, i = this._viewer.model, s = await e.pickFromPoint(t, new be());
    if (s.overlayIndex() !== 0 || !s.isFaceSelection())
      return;
    const r = s.getNodeId(), o = s.getFaceEntity();
    if (i.getNodeType(s.getNodeId()) === At.BodyInstance) {
      if (this._markup) {
        const a = this._markup.getFirstSelection();
        if (r === a.getNodeId()) {
          const l = a.getFaceEntity().getCadFaceIndex(), c = o.getCadFaceIndex();
          if (l === c)
            return;
        }
      }
      this._currentHighlight !== null ? s.equals(this._currentHighlight) ? s.getSelectionType() === pi.None && this._unsetCurrentHighlight() : (this._unsetCurrentHighlight(), await cc(i, s) && (this._currentHighlight = s, i.setNodeFaceColor(r, o.getCadFaceIndex(), it.yellow()))) : this._currentHighlight === null && await cc(i, s) && (this._currentHighlight = s, i.setNodeFaceColor(r, o.getCadFaceIndex(), it.yellow()));
    }
  }
  async _performUpSelection(t) {
    const e = this._viewer.view, i = this._viewer.model, s = await e.pickFromPoint(t, new be());
    if (s.overlayIndex())
      return;
    if (this._markup && this._markup._getStage() > 1) {
      if (this._viewer.trigger("measurementBegin"), this._markup._nextStage(), this._markup._isFinalized()) {
        const a = this._markup;
        this._markup = null, this._measureManager.finalizeMeasurement(a);
      }
      return;
    }
    if (!s.isFaceSelection() || !(i.getNodeType(s.getNodeId()) === At.BodyInstance && (!this._markup || this._markup._getStage() <= 1)) || !await cc(i, s))
      return;
    const r = s.getFaceEntity();
    await i.getFaceProperty(
      s.getNodeId(),
      r.getCadFaceIndex()
    ) instanceof Be && (this._unsetCurrentHighlight(), this._markup === null ? (this._markup = new ea(this._viewer), this._markup.setUseAuthoredNormals(this._useAuthoredNormals), await this._markup.setFirstFace(s), this._measureManager.addMeasurement(this._markup)) : await this._markup.setSecondFace(s) && this._markup.adjust(t));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = t.getPosition();
    (!this._markup || this._markup._getStage() <= 1) && this._performMoveSelection(e), this._viewer.markupManager.refreshMarkup(), this._markup !== null && this._markup._getStage() > 0 && this._markup.adjust(e);
  }
  _onMouseUpImpl(t) {
    if (!this.isActive())
      return;
    const e = this._primaryTouchId !== null && this._markup !== null && this._markup._getStage() > 1;
    if (!(this._dragCount < 3 || e))
      return;
    const i = t.getPosition();
    this._moveSelectionAction.set(() => this._performUpSelection(i));
  }
  /** @hidden */
  onMouseUp(t) {
    this._onMouseUpImpl(t), super.onMouseUp(t);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  onKeyUp(t) {
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Ut.Escape && (this._markup !== null ? (this._markup.cleanup(), this._measureManager.removeMeasurement(this._markup), this._markup = null) : this._measureManager.removeLastMeasurement());
  }
  /** @hidden */
  setHandled() {
    return this._markup !== null && this._markup._getStage() > 1;
  }
  /** @hidden */
  onDeactivate() {
    this._unsetCurrentHighlight(), this._markup !== null && (this._measureManager.removeMeasurement(this._markup), this._markup.cleanup(), this._markup = null);
  }
  /**
   * Sets whether created markup will use authored normals or use selection results to calculate angles
   * @param use
   */
  setUseAuthoredNormals(t) {
    this._useAuthoredNormals = t;
  }
  /**
   * Gets whether created markup will use authored normals or use selection results to calculate angles
   */
  getUseAuthoredNormals() {
    return this._useAuthoredNormals;
  }
}
const bo = class extends fi {
  constructor(n) {
    super(n), this._faceSelection = [], this._line1PreviewShape1 = new Wi(), this._line1PreviewShape2 = new Wi(), this._line2PreviewShape1 = new Wi(), this._line2PreviewShape2 = new Wi(), this._matrix1 = new Q(), this._matrix2 = new Q(), this._lineGeometryShape = new fr(), this._parallelFaces = !1, this._triangulatedDistance = !0, this._pointsOnSameRay = !1, this._arrowsInvert = !1, this._faceData = [], this._distance = 0, this._surfaceCenter = [d.zero(), d.zero()], this._surfaceAxis1 = [d.zero(), d.zero()], this._surfaceAxis2 = [d.zero(), d.zero()], this._cylinderAxisInfinite1 = [d.zero(), d.zero()], this._cylinderAxisInfinite2 = [d.zero(), d.zero()], this._secondPointInitial = d.zero(), this._firstPointHelper = d.zero(), this._secondPointHelper = d.zero(), this._secondPoint = d.zero(), this._firstPoint = d.zero(), this._textPos = d.zero(), this._name = "MeasureFaceFaceDistance", this._lineGeometryShape.setStrokeWidth(2), this._lineGeometryShape.setStrokeColor(this._viewer.measureManager.getMeasurementColor()), this._textShape = new qr(), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new it(255, 255, 255));
    const e = this._viewer.measureManager.getMeasurementColor();
    for (let i = 0; i < 5; i++)
      this._lineShapes.push(new Wi()), this._lineShapes[i].setStrokeColor(e), this._lineShapes[i].setEndEndcapColor(e), this._lineShapes[i].setStartEndcapColor(e);
  }
  setUnitMultiplier(n) {
    this._unitMultiplier = n;
  }
  setFirstFace(n, t, e, i) {
    const s = n.getNodeId(), r = n.getFaceEntity(), o = n.getPosition();
    if (this._matrix1 = e.copy(), this._viewer.model.setNodeFaceColor(s, r.getCadFaceIndex(), new it(255, 0, 0)), this._faceSelection[0] = n, this._firstPoint = o.copy(), this._faceData[0] = t, this._faceData[0] instanceof Be) {
      const a = this._faceData[0], l = new d(
        a.origin.x + a.normal.x,
        a.origin.y + a.normal.y,
        a.origin.z + a.normal.z
      );
      this._matrix1.transform(l, this._surfaceAxis1[0]), this._matrix1.transform(a.origin, this._surfaceCenter[0]);
    } else
      this._faceData[0] instanceof Me && this.createCylinderData(this._faceData[0], e, i);
    this._stage++;
  }
  getFirstSelection() {
    return this._faceSelection[0] || null;
  }
  getFirstFaceData() {
    return this._faceData[0] || null;
  }
  cleanup() {
    const n = this._viewer.model;
    this._stage >= 2 && n.unsetNodeFaceColor(
      this._faceSelection[1].getNodeId(),
      this._faceSelection[1].getFaceEntity().getCadFaceIndex()
    ), this._stage >= 1 && n.unsetNodeFaceColor(
      this._faceSelection[0].getNodeId(),
      this._faceSelection[0].getFaceEntity().getCadFaceIndex()
    );
  }
  createCylinderData(n, t, e) {
    const s = d.subtract(e.max, e.min).length() / 4, r = new d(
      n.origin.x + n.normal.x * 1e4,
      n.origin.y + n.normal.y * 1e4,
      n.origin.z + n.normal.z * 1e4
    ), o = new d(
      n.origin.x - n.normal.x * 1e4,
      n.origin.y - n.normal.y * 1e4,
      n.origin.z - n.normal.z * 1e4
    ), a = new d(0, 0, 0);
    ss(n.origin, r, o, a), this._surfaceCenter[this._stage] = new d(0, 0, 0), t.transform(a, this._surfaceCenter[this._stage]);
    const l = new d(
      a.x + n.normal.x,
      a.y + n.normal.y,
      a.z + n.normal.z
    );
    this._surfaceAxis1[this._stage] = new d(0, 0, 0), t.transform(l, this._surfaceAxis1[this._stage]), l.set(
      a.x - n.normal.x,
      a.y - n.normal.y,
      a.z - n.normal.z
    ), this._surfaceAxis2[this._stage] = new d(0, 0, 0), t.transform(l, this._surfaceAxis2[this._stage]);
    let c = new d(0, 0, 0);
    c = this._surfaceAxis1[this._stage].copy(), c = d.subtract(c, this._surfaceCenter[this._stage]), c.normalize(), this._surfaceAxis1[this._stage].set(
      this._surfaceCenter[this._stage].x + c.x * s,
      this._surfaceCenter[this._stage].y + c.y * s,
      this._surfaceCenter[this._stage].z + c.z * s
    ), this._surfaceAxis2[this._stage].set(
      this._surfaceCenter[this._stage].x - c.x * s,
      this._surfaceCenter[this._stage].y - c.y * s,
      this._surfaceCenter[this._stage].z - c.z * s
    ), this._cylinderAxisInfinite1[this._stage] = new d(
      this._surfaceCenter[this._stage].x + c.x * s * 1e3,
      this._surfaceCenter[this._stage].y + c.y * s * 1e3,
      this._surfaceCenter[this._stage].z + c.z * s * 1e3
    ), this._cylinderAxisInfinite2[this._stage] = new d(
      this._surfaceCenter[this._stage].x - c.x * s * 1e3,
      this._surfaceCenter[this._stage].y - c.y * s * 1e3,
      this._surfaceCenter[this._stage].z - c.z * s * 1e3
    );
  }
  async setSecondFace(n, t, e, i, s) {
    const r = this._faceSelection[0], o = this._faceData[0];
    if (r === void 0 || o === void 0)
      throw new Mt("setSecondFace() called before setFirstFace()");
    if (e instanceof Be) {
      const l = o, c = new d(
        l.origin.x + l.normal.x,
        l.origin.y + l.normal.y,
        l.origin.z + l.normal.z
      );
      this._matrix1.transform(c, this._surfaceAxis1[0]), this._matrix1.transform(l.origin, this._surfaceCenter[0]);
    } else if (e instanceof Me)
      this.createCylinderData(e, i, s);
    else
      return;
    const a = await this._viewer.model.computeMinimumFaceFaceDistance(
      r.getNodeId(),
      r.getFaceEntity().getCadFaceIndex(),
      t.getNodeId(),
      t.getFaceEntity().getCadFaceIndex()
    );
    if (a.distance !== 0) {
      if (this._matrix2 = i.copy(), this._secondPoint = t.getPosition().copy(), this._secondPointInitial = new d(
        this._firstPoint.x,
        this._firstPoint.y,
        this._firstPoint.z
      ), o instanceof Be && e instanceof Be) {
        const l = e, c = new d(
          l.origin.x + l.normal.x,
          l.origin.y + l.normal.y,
          l.origin.z + l.normal.z
        );
        this._matrix2.transform(c, this._surfaceAxis1[1]), this._matrix2.transform(l.origin, this._surfaceCenter[1]);
        const h = new d(
          this._surfaceAxis1[0].x - this._surfaceCenter[0].x,
          this._surfaceAxis1[0].y - this._surfaceCenter[0].y,
          this._surfaceAxis1[0].z - this._surfaceCenter[0].z
        ), u = new d(
          this._surfaceAxis1[1].x - this._surfaceCenter[1].x,
          this._surfaceAxis1[1].y - this._surfaceCenter[1].y,
          this._surfaceAxis1[1].z - this._surfaceCenter[1].z
        );
        h.normalize(), u.normalize();
        const p = new d(-h.x, -h.y, -h.z);
        if (h.equalsWithTolerance(u, 1e-5) || p.equalsWithTolerance(u, 1e-5)) {
          this._secondPointHelper = new d(
            this._secondPoint.x,
            this._secondPoint.y,
            this._secondPoint.z
          ), this._firstPointHelper = new d(
            this._firstPoint.x,
            this._firstPoint.y,
            this._firstPoint.z
          );
          const m = new je();
          m.setFromPointAndNormal(this._surfaceCenter[0], h);
          const g = new je();
          g.setFromPointAndNormal(this._surfaceCenter[1], u);
          const _ = new d(
            this._firstPoint.x + h.x,
            this._firstPoint.y + h.y,
            this._firstPoint.z + h.z
          );
          if (Bu(r.getPosition(), _, g, this._secondPoint), p.equalsWithTolerance(u, 1e-5)) {
            const Y = new d(-h.x, -h.y, -h.z);
            m.setFromPointAndNormal(this._surfaceCenter[0], Y);
          }
          const y = Math.abs(g.d - m.d) / m.normal.length();
          this._distance = y, this._setMeasurementValue(this._distance), this._parallelFaces = !0, this._triangulatedDistance = !1;
          const b = new d(0, 1, 0), w = d.subtract(this._secondPoint, this._firstPoint);
          let v = new d(0, 0, 0);
          v = d.subtract(this._secondPointHelper, this._firstPoint);
          const C = Yn(b, w), k = Yn(b, v);
          this._textPos.assign(this._secondPoint), C - k < 0.1 && C - k > -0.1 && (this._pointsOnSameRay = !0);
        } else
          this._firstPoint.assign(a.pos1), this._secondPoint.assign(a.pos2), this._textPos.assign(a.pos2), this._distance = a.distance, this._setMeasurementValue(this._distance);
      } else if (o instanceof Me && e instanceof Me) {
        const l = new d(
          this._surfaceAxis1[0].x - this._surfaceCenter[0].x,
          this._surfaceAxis1[0].y - this._surfaceCenter[0].y,
          this._surfaceAxis1[0].z - this._surfaceCenter[0].z
        ), c = new d(
          this._surfaceAxis1[1].x - this._surfaceCenter[1].x,
          this._surfaceAxis1[1].y - this._surfaceCenter[1].y,
          this._surfaceAxis1[1].z - this._surfaceCenter[1].z
        );
        l.normalize(), c.normalize();
        const h = new d(-l.x, -l.y, -l.z);
        if (l.equalsWithTolerance(c, 1e-5) || h.equalsWithTolerance(c, 1e-5)) {
          const u = new d(0, 0, 0);
          ss(
            this._firstPoint,
            this._cylinderAxisInfinite1[0],
            this._cylinderAxisInfinite2[0],
            u
          ), this._firstPoint = u.copy();
          let p = new d(this._firstPoint.x, this._firstPoint.y, this._firstPoint.z);
          p = d.subtract(p, this._surfaceCenter[0]), p.set(0, 0, 0), ss(
            this._firstPoint,
            this._cylinderAxisInfinite1[1],
            this._cylinderAxisInfinite2[1],
            u
          ), this._secondPoint = u.copy();
          const m = d.subtract(this._secondPoint, this._firstPoint).length();
          if (m < 1e-7)
            return;
          this._triangulatedDistance = !1, this._textPos.assign(this._secondPoint), this._setMeasurementValue(m);
        } else {
          if (this._distance = ng(
            this._cylinderAxisInfinite1[0],
            this._cylinderAxisInfinite2[0],
            this._cylinderAxisInfinite1[1],
            this._cylinderAxisInfinite2[1],
            this._firstPoint,
            this._secondPoint
          ), this._distance < 1e-7)
            return;
          this._textPos.assign(this._firstPoint), this._setMeasurementValue(this._distance);
        }
      } else if (o instanceof Me && e instanceof Be) {
        const l = new d(
          this._surfaceAxis1[0].x - this._surfaceCenter[0].x,
          this._surfaceAxis1[0].y - this._surfaceCenter[0].y,
          this._surfaceAxis1[0].z - this._surfaceCenter[0].z
        ).normalize(), c = await this._viewer.model.computeMinimumFaceLineDistance(
          t.getNodeId(),
          t.getFaceEntity().getCadFaceIndex(),
          new Gn(this._surfaceCenter[0], l)
        );
        if (this._distance = c.distance, this._distance < 1e-7)
          return;
        this._firstPoint.assign(c.pos1), this._secondPoint.assign(c.pos2), this._textPos.assign(c.pos2), this._secondPointHelper = new d(
          this._secondPoint.x,
          this._secondPoint.y,
          this._secondPoint.z
        ), this._firstPointHelper = new d(
          this._firstPoint.x,
          this._firstPoint.y,
          this._firstPoint.z
        ), this._viewer.model.setNodeFaceColor(
          t.getNodeId(),
          t.getFaceEntity().getCadFaceIndex(),
          new it(255, 0, 0)
        ), this._faceData[1] = e, this._faceSelection[1] = t, this._stage++, this.adjust(n), this._setMeasurementValue(this._distance);
      } else if (o instanceof Be && e instanceof Me) {
        const l = new d(
          this._surfaceAxis1[1].x - this._surfaceCenter[1].x,
          this._surfaceAxis1[1].y - this._surfaceCenter[1].y,
          this._surfaceAxis1[1].z - this._surfaceCenter[1].z
        ).normalize(), c = await this._viewer.model.computeMinimumFaceLineDistance(
          r.getNodeId(),
          r.getFaceEntity().getCadFaceIndex(),
          new Gn(this._surfaceCenter[1], l)
        );
        if (this._distance = c.distance, this._distance < 1e-7)
          return;
        this._firstPoint.assign(c.pos1), this._secondPoint.assign(c.pos2), this._textPos.assign(c.pos2), this._secondPointHelper = new d(
          this._secondPoint.x,
          this._secondPoint.y,
          this._secondPoint.z
        ), this._firstPointHelper = new d(
          this._firstPoint.x,
          this._firstPoint.y,
          this._firstPoint.z
        ), this._viewer.model.setNodeFaceColor(
          t.getNodeId(),
          t.getFaceEntity().getCadFaceIndex(),
          new it(255, 0, 0)
        ), this._faceData[1] = e, this._faceSelection[1] = t, this._stage++, this.adjust(n), this._setMeasurementValue(this._distance);
      } else {
        if (this._firstPoint.assign(a.pos1), this._secondPoint.assign(a.pos2), this._textPos.assign(a.pos2), this._distance = a.distance, this._distance < 1e-7)
          return;
        this._setMeasurementValue(this._distance);
      }
      this._viewer.model.setNodeFaceColor(
        t.getNodeId(),
        t.getFaceEntity().getCadFaceIndex(),
        new it(255, 0, 0)
      ), this._faceData[1] = e, this._faceSelection[1] = t, this._stage++, this.adjust(n);
    }
  }
  adjust(n) {
    if (super.adjust(n), this._stage <= 1)
      return;
    const t = this._viewer.view.raycastFromPoint(n);
    if (t === null)
      return;
    const e = new d(
      t.origin.x + t.direction.x * 1e6,
      t.origin.y + t.direction.y * 1e6,
      t.origin.z + t.direction.z * 1e6
    ), i = Ju(t.direction);
    let s = new d(0, 0, 0);
    s = d.cross(t.direction, i), s.normalize();
    let r = new d(
      (this._firstPoint.x + this._secondPoint.x) / 2,
      (this._firstPoint.y + this._secondPoint.y) / 2,
      (this._firstPoint.z + this._secondPoint.z) / 2
    );
    r = this._textPos.copy(), i.set(r.x + i.x, r.y + i.y, r.z + i.z), s.set(r.x + s.x, r.y + s.y, r.z + s.z);
    const o = new d(0, 0, 0);
    if (Ts(t.origin, e, r, i, s, o), this._stage === 2)
      ss(o, this._firstPoint, this._secondPoint, this._textPos);
    else if (this._parallelFaces || this._triangulatedDistance) {
      const a = new d(0, 0, 0), l = this._faceData[0] instanceof Me || this._faceData[1] instanceof Me, c = this._faceData[0] instanceof Be || this._faceData[1] instanceof Be;
      if (!this._pointsOnSameRay) {
        l && c ? ss(o, this._secondPoint, this._secondPointInitial, a) : ss(o, this._secondPoint, this._secondPointHelper, a);
        let h = new d(0, 0, 0);
        h = d.subtract(a, this._secondPoint), this._secondPoint = a.copy(), this._firstPoint.set(
          this._firstPoint.x + h.x,
          this._firstPoint.y + h.y,
          this._firstPoint.z + h.z
        ), this._textPos.set(
          this._textPos.x + h.x,
          this._textPos.y + h.y,
          this._textPos.z + h.z
        );
      }
    } else {
      const a = new d(0, 0, 0);
      ss(
        o,
        this._cylinderAxisInfinite1[1],
        this._cylinderAxisInfinite2[1],
        a
      );
      const l = d.subtract(a, this._secondPoint);
      this._secondPoint = a.copy(), this._firstPoint.set(
        this._firstPoint.x + l.x,
        this._firstPoint.y + l.y,
        this._firstPoint.z + l.z
      ), this._textPos.set(
        this._textPos.x + l.x,
        this._textPos.y + l.y,
        this._textPos.z + l.z
      );
    }
    this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup();
  }
  _updateArrowsInverted() {
    const n = new d(
      (this._firstPoint.x + this._secondPoint.x) / 2,
      (this._firstPoint.y + this._secondPoint.y) / 2,
      (this._firstPoint.z + this._secondPoint.z) / 2
    ), t = d.subtract(this._secondPoint, this._firstPoint);
    d.subtract(this._textPos, n).length() * 2 > t.length() ? this._arrowsInvert = !0 : this._arrowsInvert = !1;
  }
  _nextStage() {
    this._stage++, (this._stage > 3 || this._stage > 2 && this._triangulatedDistance) && (this._finalized = !0, this.cleanup());
  }
  /** @hidden */
  update() {
    super.update();
    const n = this._viewer.view;
    if (this._behindView = !1, this._stage === 0)
      return;
    const t = new Array(10), e = [];
    for (let i = 0; i < 10; i++)
      e.push(new d(0, 0, 0));
    this._faceData[0] instanceof Me && (e[0] = n.projectPoint(this._surfaceCenter[0]), e[1] = n.projectPoint(this._surfaceAxis1[0]), e[2] = n.projectPoint(this._surfaceAxis2[0]), t[0] = E.fromPoint3(e[0]), t[1] = E.fromPoint3(e[1]), t[2] = E.fromPoint3(e[2]), this._line1PreviewShape1.set(t[0], t[1]), this._line1PreviewShape2.set(t[0], t[2])), this._stage > 1 && this._faceData[1] instanceof Me && (e[0] = n.projectPoint(this._surfaceCenter[1]), e[1] = n.projectPoint(this._surfaceAxis1[1]), e[2] = n.projectPoint(this._surfaceAxis2[1]), t[0] = E.fromPoint3(e[0]), t[1] = E.fromPoint3(e[1]), t[2] = E.fromPoint3(e[2]), this._line2PreviewShape1.set(t[0], t[1]), this._line2PreviewShape2.set(t[0], t[2])), this._stage > 1 && (e[0] = n.projectPoint(this._textPos), e[1] = n.projectPoint(this._firstPoint), e[2] = n.projectPoint(this._secondPoint), t[0] = E.fromPoint3(e[0]), t[1] = E.fromPoint3(e[1]), t[2] = E.fromPoint3(e[2]), this._textShape && this._textShape.setPosition(t[0]), this._lineShapes[0].setEndcapType(ii.Arrowhead), this._lineShapes[0].setStartEndcapType(ii.Arrowhead), this._lineShapes[0].setEndcapsInverted(this._arrowsInvert), this._lineShapes[0].set(t[1], t[2]), e[3] = n.projectPoint(this._firstPointHelper), e[4] = n.projectPoint(this._secondPointHelper), t[3] = E.fromPoint3(e[3]), t[4] = E.fromPoint3(e[4]), this._lineShapes[1].set(t[2], t[4]), this._lineShapes[2].set(t[1], t[3]), this._lineShapes[3].set(t[1], t[0]));
    for (let i = 0; i < 6; i++)
      e[i].z < 0 && (this._behindView = !0);
  }
  draw() {
    if (this._visibility && this._viewer.explodeManager.getMagnitude() === 0 && (this.update(), !this._behindView)) {
      const n = this._faceData[0] instanceof Me || this._faceData[1] instanceof Me, t = this._faceData[0] instanceof Be || this._faceData[1] instanceof Be, e = this._viewer.markupManager.getRenderer();
      switch (this._stage) {
        case 1:
          this._faceData[0] instanceof Me && (e.drawLine(this._line1PreviewShape1), e.drawLine(this._line1PreviewShape2));
          break;
        case 2:
        case 3:
        case 4:
          this._faceData[0] instanceof Me && (e.drawLine(this._line1PreviewShape1), e.drawLine(this._line1PreviewShape2)), this._faceData[1] instanceof Me && (e.drawLine(this._line2PreviewShape1), e.drawLine(this._line2PreviewShape2)), n && t ? (e.drawLine(this._lineShapes[0]), e.drawLine(this._lineShapes[1]), e.drawLine(this._lineShapes[2]), e.drawLine(this._lineShapes[3]), e.drawTextBox(this._textShape)) : (e.drawLine(this._lineShapes[0]), this._parallelFaces && (e.drawLine(this._lineShapes[1]), e.drawLine(this._lineShapes[2])), e.drawLine(this._lineShapes[3]), e.drawTextBox(this._textShape));
          break;
      }
    }
  }
  //serialization methods
  static _serializeFaceProp(n) {
    return n instanceof Me ? {
      type: "CylinderElement",
      origin: n.origin.toJson(),
      normal: n.normal.toJson(),
      radius: n.radius
    } : n instanceof Be ? {
      type: "PlaneElement",
      origin: n.origin.toJson(),
      normal: n.normal.toJson()
    } : null;
  }
  static _constructFaceProp(n) {
    if (n.type === "CylinderElement") {
      const t = d.fromJson(n.origin), e = d.fromJson(n.normal), i = n.radius;
      return new Me(i, t, e);
    } else if (n.type === "PlaneElement") {
      const t = d.fromJson(n.origin), e = d.fromJson(n.normal);
      return new Be(t, e);
    } else
      return null;
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const n = [];
    for (const s of this._faceData)
      n.push(bo._serializeFaceProp(s));
    const t = [];
    for (const s of this._surfaceCenter)
      t.push(s.toJson());
    const e = [];
    for (const s of this._surfaceAxis1)
      e.push(s.toJson());
    const i = [];
    for (const s of this._surfaceAxis2)
      i.push(s.toJson());
    return {
      text: this._textShape.getTextString(),
      textPos: this._textPos.toJson(),
      firstPoint: this._firstPoint.toJson(),
      secondPoint: this._secondPoint.toJson(),
      firstPointHelper: this._firstPointHelper.toJson(),
      secondPointHelper: this._secondPointHelper.toJson(),
      secondPointInitial: this._secondPointInitial.toJson(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      parallelFaces: this._parallelFaces,
      faceData: n,
      surfaceCenter: t,
      surfaceAxis1: e,
      surfaceAxis2: i,
      name: this.getName(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasureFaceFaceDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new bo(t);
    i.setName(e.name), i._textShape.setTextString(e.text), i._textPos.assign(d.fromJson(e.textPos)), i._firstPoint.assign(d.fromJson(e.firstPoint)), i._firstPointHelper.assign(d.fromJson(e.firstPointHelper)), i._secondPoint.assign(d.fromJson(e.secondPoint)), i._secondPointHelper.assign(d.fromJson(e.secondPointHelper)), e.secondPointInitial !== void 0 && i._secondPointInitial.assign(d.fromJson(e.secondPointInitial)), console.assert(Array.isArray(e.faceData));
    for (const s of e.faceData) {
      const r = bo._constructFaceProp(s);
      console.assert(r !== null), i._faceData.push(r);
    }
    return i._surfaceCenter[0].assign(e.surfaceCenter[0]), i._surfaceCenter[1].assign(e.surfaceCenter[1]), i._surfaceAxis1[0].assign(e.surfaceAxis1[0]), i._surfaceAxis1[1].assign(e.surfaceAxis1[1]), i._surfaceAxis2[0].assign(e.surfaceAxis2[0]), i._surfaceAxis2[1].assign(e.surfaceAxis2[1]), i._stage = 4, i._parallelFaces = e.parallelFaces, i._measurementValue = e.measurementValue, i._unitMultiplier = e.unitMultiplier || 1, i;
  }
  getClassName() {
    return bo.className;
  }
};
let ia = bo;
ia.className = "Communicator.Markup.Measure.MeasureFaceFaceDistanceMarkup";
Ui(
  ia.className,
  ia.fromJson
);
class zm extends xe {
  constructor(t, e) {
    super(t), this._moveSelectionAction = new fs(!0), this._currentHighlight = null, this._markup = null, this._measureManager = e;
  }
  _unsetCurrentHighlight() {
    this._currentHighlight !== null && (this._viewer.model.unsetNodeFaceColor(
      this._currentHighlight.getNodeId(),
      this._currentHighlight.getFaceEntity().getCadFaceIndex()
    ), this._currentHighlight = null);
  }
  async _performMoveSelection(t) {
    const e = this._viewer.view, i = this._viewer.model, s = await e.pickFromPoint(t, new be());
    if (s.overlayIndex() !== 0 || !s.isFaceSelection())
      return;
    const r = s.getNodeId(), o = s.getFaceEntity();
    if (i.getNodeType(r) === At.BodyInstance) {
      if (this._markup) {
        const a = this._markup.getFirstSelection();
        if (a !== null && r === a.getNodeId() && o.getCadFaceIndex() === a.getFaceEntity().getCadFaceIndex())
          return;
      }
      this._currentHighlight !== null ? s.equals(this._currentHighlight) ? s.getSelectionType() === pi.None && this._unsetCurrentHighlight() : (this._unsetCurrentHighlight(), await i.isFaceMeasurable(r, o.getCadFaceIndex()) && (this._currentHighlight = s, i.setNodeFaceColor(r, o.getCadFaceIndex(), it.yellow()))) : await i.isFaceMeasurable(r, o.getCadFaceIndex()) && (this._currentHighlight = s, i.setNodeFaceColor(r, o.getCadFaceIndex(), it.yellow()));
    }
  }
  async _performUpSelection(t) {
    const e = this._viewer.view, i = this._viewer.model, s = await e.pickFromPoint(t, new be());
    if (s.overlayIndex())
      return;
    if (this._markup && this._markup._getStage() > 1) {
      if (this._viewer.trigger("measurementBegin"), this._markup._nextStage(), this._markup._isFinalized()) {
        const h = this._markup;
        this._markup = null, this._measureManager.finalizeMeasurement(h);
      }
      return;
    }
    if (!s.isFaceSelection())
      return;
    const r = s.getNodeId(), o = s.getFaceEntity();
    if (!await i.isFaceMeasurable(r, o.getCadFaceIndex()) || !(i.getNodeType(r) === At.BodyInstance && (!this._markup || this._markup._getStage() <= 1)))
      return;
    const l = await i.getFaceProperty(r, o.getCadFaceIndex());
    if (!l)
      return;
    const c = i.getNodeNetMatrix(r);
    if (this._unsetCurrentHighlight(), l instanceof Be || l instanceof Me) {
      const h = await i.getNodesBounding([r]);
      this._markup ? await this._markup.setSecondFace(t, s, l, c, h) : (this._markup = new ia(this._viewer), this._markup.setUnitMultiplier(i.getNodeUnitMultiplier(r)), this._markup.setFirstFace(s, l, c, h), this._measureManager.addMeasurement(this._markup));
    }
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = t.getPosition();
    (!this._markup || this._markup._getStage() <= 1) && this._moveSelectionAction.set(() => this._performMoveSelection(e)), this._viewer.markupManager.refreshMarkup(), this._markup !== null && this._markup._getStage() > 0 && this._markup.adjust(e);
  }
  async _onMouseUpImpl(t) {
    if (!this.isActive())
      return;
    const e = this._primaryTouchId !== null && this._markup !== null && this._markup._getStage() > 1;
    if (!(this._dragCount < 3 || e))
      return;
    const i = t.getPosition();
    await this._performUpSelection(i);
  }
  /** @hidden */
  onMouseUp(t) {
    this._onMouseUpImpl(t), super.onMouseUp(t);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  onKeyUp(t) {
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Ut.Escape && (this._markup !== null ? (this._markup.cleanup(), this._measureManager.removeMeasurement(this._markup), this._markup = null) : this._measureManager.removeLastMeasurement());
  }
  /** @hidden */
  setHandled() {
    return this._markup !== null && this._markup._getStage() > 1;
  }
  /** @hidden */
  onDeactivate() {
    super.onDeactivate(), this._unsetCurrentHighlight(), this._markup !== null && (this._measureManager.removeMeasurement(this._markup), this._markup.cleanup(), this._markup = null);
  }
}
const Qc = class extends fi {
  constructor(n) {
    super(n), this._anchorLinePoint = null, this._firstLinePoint = null, this._secondLinePoint = null, this._selectionPosition = null, this._lineGeometryShape = new fr(), this._viewer = n, this._name = "MeasureLineLineAngle", this._lineGeometryShape.setStrokeWidth(2), this._lineGeometryShape.setStrokeColor(this._viewer.measureManager.getMeasurementColor()), this._lineGeometryShape.setEndcapType(ii.Arrowhead), this._lineGeometryShape.setStartEndcapType(ii.Arrowhead), this._lineGeometryShape.setEndEndcapSize(5), this._lineGeometryShape.setStartEndcapSize(5), this._lineGeometryShape.setEndEndcapColor(this._viewer.measureManager.getMeasurementColor()), this._lineGeometryShape.setStartEndcapColor(this._viewer.measureManager.getMeasurementColor()), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(it.white());
  }
  addPoint(n) {
    if (this._finalized)
      return !1;
    if (this._anchorLinePoint === null)
      this._anchorLinePoint = n.copy(), this._stage = 1;
    else if (this._firstLinePoint === null) {
      if (n.equals(this._anchorLinePoint))
        return !1;
      this._firstLinePoint = n.copy(), this._stage = 2;
    } else {
      if (n.equals(this._anchorLinePoint) || n.equals(this._firstLinePoint))
        return !1;
      const t = d.subtract(this._firstLinePoint, this._anchorLinePoint), e = d.subtract(n, this._anchorLinePoint), i = Yn(t, e);
      if (i === 0 || i === 180)
        return !1;
      this._secondLinePoint = n.copy(), this.setMeasurementText(`${i.toFixed(2)}°`), this._measurementValue = i, this._finalized = !0, this._stage = 3;
    }
    return this.draw(), !0;
  }
  setSelectionPosition(n) {
    this._selectionPosition = n;
  }
  getLineGeometryShape() {
    return this._lineGeometryShape;
  }
  _drawPreviewLine(n, t) {
    const e = this._viewer.markupManager.getRenderer(), i = this._viewer.view, s = E.fromPoint3(i.projectPoint(n)), r = E.fromPoint3(i.projectPoint(t)), o = new Wi(s, r);
    e.drawLine(o);
  }
  _drawAngleMarkup(n, t, e) {
    const i = this._viewer.markupManager.getRenderer(), s = this._viewer.view, r = d.subtract(t, n), o = d.subtract(e, n), a = d.cross(r, o).normalize(), l = Yn(r, o);
    if (l !== 0 && l !== 180 && !isNaN(l)) {
      const y = _c(a, -l, n, o, 30);
      this._lineGeometryShape.clearPoints();
      for (const b of y)
        this._lineGeometryShape.pushPoint(E.fromPoint3(s.projectPoint(b)));
      i.drawPolyline(this._lineGeometryShape);
    }
    const c = o.length(), h = d.add(
      n,
      r.copy().normalize().scale(c)
    ), u = E.fromPoint3(s.projectPoint(n)), p = E.fromPoint3(s.projectPoint(h)), m = E.fromPoint3(s.projectPoint(e)), g = new Wi(u, p);
    i.drawLine(g);
    const _ = new Wi(u, m);
    i.drawLine(_), this._textShape.setPosition(p), this._finalized ? this._textShape.setTextString(this.getMeasurementText()) : isNaN(l) ? this._textShape.setTextString("0°") : this._textShape.setTextString(`${l.toFixed(2)}°`), i.drawTextBox(this._textShape);
  }
  draw() {
    if (!(!this._visibility || this._anchorLinePoint === null || this._viewer.view.projectPoint(this._anchorLinePoint).z <= 0)) {
      if (this._stage === 1) {
        if (this._selectionPosition === null)
          return;
        this._drawPreviewLine(this._anchorLinePoint, this._selectionPosition);
      } else if (this._stage === 2) {
        if (this._firstLinePoint === null || this._selectionPosition === null)
          return;
        this._drawAngleMarkup(this._anchorLinePoint, this._firstLinePoint, this._selectionPosition);
      } else if (this._stage === 3) {
        if (this._firstLinePoint == null || this._secondLinePoint == null)
          return;
        this._drawAngleMarkup(this._anchorLinePoint, this._firstLinePoint, this._secondLinePoint);
      }
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      name: this._name,
      anchorPoint: this._anchorLinePoint.copy(),
      firstPoint: this._firstLinePoint.copy(),
      secondPoint: this._secondLinePoint.copy(),
      measurementValue: this._measurementValue,
      measurementText: this.getMeasurementText(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasurePointPointDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new Qc(t);
    return i._name = e.name, i._anchorLinePoint = d.fromJson(e.anchorPoint), i._firstLinePoint = d.fromJson(e.firstPoint), i._secondLinePoint = d.fromJson(e.secondPoint), i._measurementValue = e.measurementValue, i.setMeasurementText(e.measurementText), i._finalized = !0, i._stage = 3, i;
  }
  getClassName() {
    return Qc.className;
  }
};
let na = Qc;
na.className = "Communicator.Markup.Measure.MeasureLineLineAngleMarkup";
Ui(na.className, na.fromJson);
class Lh extends fi {
  constructor(t) {
    super(t), this._cursorSprite = new qn(), this._name = "CursorMarkup";
    const e = t.measureManager.getMeasurementColor();
    this._cursorSprite.setFillColor(e), this._cursorSprite.setStrokeColor(e), this._cursorSprite.setRadius(0), this._markupId = t.markupManager.registerMarkup(this);
  }
  draw() {
    this._viewer.markupManager.getRenderer().drawCircle(this._cursorSprite);
  }
  enable(t) {
    this._cursorSprite.setRadius(t ? 2.5 : 0);
  }
  isEnabled() {
    return this._cursorSprite.getRadius() > 0;
  }
  setPosition(t) {
    this._cursorSprite.setCenter(t);
  }
  destroy() {
    this._viewer.markupManager.unregisterMarkup(this._markupId);
  }
}
class Jm {
  constructor(t, e, i) {
    this.worldPosition = t, this.screenPosition = e, this.selectionItem = i;
  }
}
class ya {
  constructor(t) {
    this._cursorMarkup = null, this._updateCursorSpriteAction = new fs(!0), this._viewer = t, this.snappingConfig = {
      enabled: !0,
      preferVertices: !0
    };
  }
  async getSelectionCursorPoints(t, e, i) {
    const s = new be(e ? Xt.All : Xt.Face);
    e && (s.enableProximityFaces = !0, s.restrictLinesAndPointsToSelectedFaceInstances = !1);
    const r = await this._viewer.view.pickFromPoint(t, s);
    if (r.overlayIndex() !== 0)
      return null;
    let o = r.getPosition(), a = t;
    if (this.snappingConfig.enabled) {
      const l = r.getLineEntity(), c = r.getPointEntity(), h = r.getFaceEntity();
      if (l || c || h) {
        let u = null;
        l !== null ? u = this._getLineSnapPoint(l, e, i) : c !== null ? u = c.getPosition() : h !== null && h.isProximityFace() && (u = h.getPosition()), u !== null && (o = u, a = Ba(this._viewer, o));
      }
    }
    return new Jm(o, a, r);
  }
  updateCursorSprite(t, e, i) {
    this._updateCursorSpriteAction.set(() => this._updateCursorSpriteImpl(t, e, i));
  }
  async _updateCursorSpriteImpl(t, e, i) {
    if (this._cursorMarkup !== null)
      if (e) {
        const s = await this.getSelectionCursorPoints(
          t,
          e,
          i
        );
        s !== null ? (this._cursorMarkup.setPosition(s.screenPosition), this.activateCursorSprite(!0)) : this.activateCursorSprite(!1);
      } else
        this._cursorMarkup.setPosition(t);
  }
  draw() {
    this._cursorMarkup !== null && this._cursorMarkup.draw();
  }
  activateCursorSprite(t) {
    this._cursorMarkup !== null && this._cursorMarkup.enable(t);
  }
  /**
   * Finds the best point to use for the given lineEntity given the snapping behavior and settings.
   */
  _getLineSnapPoint(t, e, i) {
    const s = this.snappingConfig.preferVertices ? t.getBestVertex() : null;
    if (s !== null)
      return s;
    const r = t.getPosition();
    if (!e || i == null)
      return r;
    const o = t.getPoints(), a = 1e-10, l = (() => {
      for (let b = 0; b < o.length - 1; b++)
        if (rg(o[b], o[b + 1], r, a))
          return b;
      return 0;
    })(), c = o[l], h = o[l + 1];
    if (c === void 0 || h === void 0)
      return r;
    const u = sg(c, h, i), p = Ba(this._viewer, u), m = Ba(this._viewer, r), g = E.subtract(
      p,
      m
    ).squaredLength(), _ = this._viewer.selectionManager.getPickTolerance(), y = _ * _;
    return g <= y ? u : r;
  }
  _clearCursorMarkup() {
    this._cursorMarkup !== null && (this._cursorMarkup.destroy(), this._cursorMarkup = null);
  }
  onOperatorActivate() {
    this._clearCursorMarkup(), this._cursorMarkup = new Lh(this._viewer), this._viewer.sheetManager.isDrawingSheetActive() && this._viewer.sheetManager.setBackgroundSelectionEnabled(!0);
  }
  onOperatorDeactivate() {
    this._clearCursorMarkup(), this._viewer.sheetManager.isDrawingSheetActive() && this._viewer.sheetManager.setBackgroundSelectionEnabled(!1);
  }
}
class Bm extends xe {
  constructor(t, e) {
    super(t), this._markupItem = null, this._cameraInteractionActive = !1, this._measureManager = e, this._cursor = new ya(this._viewer), this._viewer.setCallbacks({
      beginInteraction: () => {
        this._onBeginInteraction();
      },
      endInteraction: () => {
        this._onEndInteraction();
      }
    });
  }
  _onBeginInteraction() {
    this._cameraInteractionActive = !0, this._cursor.activateCursorSprite(!1);
  }
  _onEndInteraction() {
    this._cameraInteractionActive = !1;
  }
  /**
   * Determine if the given mouse event should cause snapping.
   * This is influenced by the snap configuration enabled value.
   */
  _useSnapping(t) {
    return this._cursor.snappingConfig.enabled && !t.altDown();
  }
  async _addPoint(t, e) {
    const i = await this._cursor.getSelectionCursorPoints(t, e, null);
    if (!(i === null || i.worldPosition === null) && (this._markupItem === null && (this._markupItem = new na(this._viewer), this._measureManager.addMeasurement(this._markupItem), this._viewer.trigger("measurementBegin")), this._markupItem.addPoint(i.worldPosition), this._markupItem._isFinalized())) {
      const s = this._markupItem;
      this._markupItem = null, this._measureManager.finalizeMeasurement(s);
    }
  }
  async _updateMarkupSelectionPosition(t, e) {
    if (this._markupItem === null)
      return;
    const i = await this._cursor.getSelectionCursorPoints(t, e, null);
    i !== null && this._markupItem.setSelectionPosition(i.worldPosition);
  }
  async onMouseMove(t) {
    if (super.onMouseMove(t), this._cameraInteractionActive)
      return;
    const e = t.getPosition(), i = this._useSnapping(t);
    this._cursor.updateCursorSprite(e, i, null), await this._updateMarkupSelectionPosition(e, i), this._viewer.markupManager.refreshMarkup();
  }
  async onMouseUp(t) {
    if (!this.isActive())
      return;
    const e = t.getPosition();
    this._ptFirst.equals(e) && await this._addPoint(e, this._useSnapping(t)), super.onMouseUp(t);
  }
  onKeyDown(t) {
    t.getKeyCode() === Ut.Escape && this._clearMeasurement();
  }
  _clearMeasurement() {
    this._markupItem !== null ? (this._measureManager.removeMeasurement(this._markupItem), this._markupItem = null) : this._measureManager.removeLastMeasurement();
  }
  setHandled() {
    return this._markupItem !== null && this._markupItem._getStage() > 1;
  }
  onActivate() {
    this._cursor.onOperatorActivate();
  }
  onDeactivate() {
    this._cursor.onOperatorDeactivate(), this._markupItem !== null && (this._measureManager.removeMeasurement(this._markupItem), this._markupItem = null);
  }
}
const qc = class extends fi {
  constructor(n) {
    super(n), this._firstPointShape = new qn(), this._secondPointShape = new qn(), this._arrowsInvert = !1, this._name = "MeasurePointPointDistance", this._lineShapes = [];
    for (let t = 0; t < 6; t++)
      this._lineShapes.push(new Wi()), this._lineShapes[t].setStrokeColor(this._viewer.measureManager.getMeasurementColor()), this._lineShapes[t].setEndEndcapColor(this._viewer.measureManager.getMeasurementColor()), this._lineShapes[t].setStartEndcapColor(this._viewer.measureManager.getMeasurementColor());
    this._viewer = n, this.initCircle(this._firstPointShape), this.initCircle(this._secondPointShape), this._textShape = new qr(), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new it(255, 255, 255));
  }
  initCircle(n) {
    n.setRadius(2.5), n.setFillColor(this._viewer.measureManager.getMeasurementColor());
  }
  setUnitMultiplier(n) {
    this._unitMultiplier = n;
  }
  setFirstPointPosition(n) {
    this._stage = 1, this._positions[0] = n.copy();
  }
  setSecondPointPosition(n) {
    this._stage = 2, this._positions[1] = n.copy(), this._positions[2] = n.copy(), this._setMeasurementValue(d.subtract(this._positions[1], this._positions[0]).length());
  }
  _getStage() {
    return this._stage;
  }
  finalize() {
    this._stage++;
  }
  getFirstPointPosition() {
    return this._positions[0];
  }
  getSecondPointPosition() {
    return this._positions[1];
  }
  adjust(n) {
    super.adjust(n);
    const t = this._viewer.view.raycastFromPoint(n);
    if (t === null)
      return;
    const e = this._positions[0], i = this._positions[1];
    let s = new d(1, 0, 0);
    i.equals(e) || (s = d.subtract(i, e));
    const o = this._viewer.view.getCamera().getUp(), a = d.cross(t.direction, o).normalize(), l = new d(
      (e.x + i.x) / 2,
      (e.y + i.y) / 2,
      (e.z + i.z) / 2
    ), c = new d(l.x + o.x, l.y + o.y, l.z + o.z), h = new d(
      l.x + a.x,
      l.y + a.y,
      l.z + a.z
    ), u = new d(
      t.origin.x + t.direction.x * 1e6,
      t.origin.y + t.direction.y * 1e6,
      t.origin.z + t.direction.z * 1e6
    );
    let p = new d(0, 0, 0);
    Ts(
      t.origin,
      u,
      l,
      c,
      h,
      p
    ), this._positions[2].assign(p);
    let m = new d(0, 0, 0);
    Math.abs(s.x) <= Math.abs(s.y) && Math.abs(s.x) <= Math.abs(s.z) ? m = new d(1, 0, 0) : Math.abs(s.y) <= Math.abs(s.x) && Math.abs(s.y) <= Math.abs(s.z) ? m = new d(0, 1, 0) : m = new d(0, 0, 1);
    const g = d.cross(m, s), _ = d.cross(g, s);
    g.set(
      e.x + g.x,
      e.y + g.y,
      e.z + g.z
    ), _.set(
      e.x + _.x,
      e.y + _.y,
      e.z + _.z
    );
    const y = new d(
      p.x + s.x * 1e4,
      p.y + s.y * 1e4,
      p.z + s.z * 1e4
    ), b = new d(
      p.x - s.x * 1e4,
      p.y - s.y * 1e4,
      p.z - s.z * 1e4
    ), w = Ts(
      y,
      b,
      e,
      g,
      _,
      p
    ), v = !isNaN(p.x) && !isNaN(p.y) && !isNaN(p.z);
    (!w || !v) && (p = i.copy());
    const C = d.subtract(p, e);
    this._positions[3] = new d(
      e.x + C.x,
      e.y + C.y,
      e.z + C.z
    ), this._positions[4] = new d(
      i.x + C.x,
      i.y + C.y,
      i.z + C.z
    ), this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup();
  }
  _updateArrowsInverted() {
    const n = new d(
      (this._positions[3].x + this._positions[4].x) / 2,
      (this._positions[3].y + this._positions[4].y) / 2,
      (this._positions[3].z + this._positions[4].z) / 2
    ), t = d.subtract(this._positions[4], this._positions[3]);
    d.subtract(this._positions[2], n).length() * 2 > t.length() ? this._arrowsInvert = !0 : this._arrowsInvert = !1;
  }
  update() {
    super.update();
    const n = this._viewer.view, t = new Array(6);
    if (this._stage > 0) {
      this._behindView = !1;
      for (let e = 0; e < this._positions.length; e++)
        n.projectPoint(this._positions[e]).z <= 0 && (this._behindView = !0), t[e] = E.fromPoint3(n.projectPoint(this._positions[e]));
      this._firstPointShape.setCenter(t[0]);
    }
    this._stage > 1 && (this._textShape && this._textShape.setPosition(t[2]), this._secondPointShape.setCenter(t[1]), this._lineShapes[0].set(t[0], t[1]), this._lineShapes[1].set(t[3], t[4]), this._lineShapes[2].set(t[0], t[3]), this._lineShapes[3].set(t[1], t[4]), this._lineShapes[4].set(t[3], t[2]), this._lineShapes[5].set(t[3], t[4]), this._lineShapes[5].setEndcapType(ii.Arrowhead), this._lineShapes[5].setStartEndcapType(ii.Arrowhead), this._lineShapes[5].setEndcapsInverted(this._arrowsInvert));
  }
  draw() {
    if (this._visibility && this._viewer.explodeManager.getMagnitude() === 0 && (this.update(), !this._behindView)) {
      const n = this._viewer.markupManager.getRenderer();
      switch (this._stage) {
        case 1:
          n.drawCircle(this._firstPointShape);
          break;
        case 2:
        case 3:
          n.drawCircle(this._firstPointShape), n.drawCircle(this._secondPointShape);
          for (const t of this._lineShapes)
            n.drawLine(t);
          n.drawTextBox(this._textShape);
          break;
      }
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      name: this._name,
      measurePoint1: this._positions[0].copy(),
      measurePoint2: this._positions[1].copy(),
      leaderPoint1: this._positions[3].copy(),
      leaderPoint2: this._positions[4].copy(),
      textPoint: this._positions[2].copy(),
      text: this._textShape.getTextString(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasurePointPointDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new qc(t);
    return i._name = e.name, i._positions[0] = d.fromJson(e.measurePoint1), i._positions[1] = d.fromJson(e.measurePoint2), i._positions[2] = d.fromJson(e.textPoint), i._textShape.setTextString(e.text), i._positions[3] = d.fromJson(e.leaderPoint1), i._positions[4] = d.fromJson(e.leaderPoint2), i._measurementValue = e.measurementValue, i._unitMultiplier = e.unitMultiplier || 1, i._updateArrowsInverted(), i._stage = 2, i;
  }
  getClassName() {
    return qc.className;
  }
  /**
   * Returns whether the measurement markup is valid.
   */
  isMarkupValid() {
    return this._positions.length >= 5;
  }
};
let sa = qc;
sa.className = "Communicator.Markup.Measure.MeasurePointPointDistanceMarkup";
Ui(
  sa.className,
  sa.fromJson
);
class jm extends xe {
  /** @hidden */
  constructor(t, e) {
    super(t), this._measureMarkup = null, this._cameraInteractionActive = !1, this._viewer = t, this._measureManager = e, this._cursor = new ya(this._viewer), this._viewer.setCallbacks({
      beginInteraction: () => {
        this._onBeginInteraction();
      },
      endInteraction: () => {
        this._onEndInteraction();
      }
    });
  }
  _onBeginInteraction() {
    this._cameraInteractionActive = !0, this._cursor.activateCursorSprite(!1);
  }
  _onEndInteraction() {
    this._cameraInteractionActive = !1;
  }
  _getStage() {
    return this._measureMarkup === null ? tn.NoPointsSelected : this._measureMarkup._getStage();
  }
  _draw() {
    let t = !1;
    this._getStage() < tn.TwoPointsSelected && (this._cursor.draw(), t = !0), this._measureMarkup !== null && (this._measureMarkup.draw(), t = !0), t && this._viewer.markupManager.refreshMarkup();
  }
  async _finalizeMeasurement(t, e) {
    const i = this._measureMarkup;
    if (i === null) {
      console.assert(!1);
      return;
    }
    const s = new be(e ? Xt.All : Xt.Face);
    (await this._viewer.view.pickFromPoint(t, s)).overlayIndex() || (i.finalize(), this._measureMarkup = null, this._measureManager.finalizeMeasurement(i));
  }
  // Gets the first picked position or null if one is not selected.  This is used as a hint when updating the cursor for snapping.
  _getFirstPickPosition() {
    let t = null;
    return this._measureMarkup !== null && this._getStage() >= tn.OnePointSelected && (t = this._measureMarkup.getFirstPointPosition()), t;
  }
  async _updateMeasurementPoints(t, e) {
    const i = this._getStage();
    console.assert(i < tn.TwoPointsSelected), this._viewer.trigger("measurementBegin");
    const s = this._getFirstPickPosition(), r = await this._cursor.getSelectionCursorPoints(
      t,
      e,
      s
    );
    if (r === null || r.worldPosition === null) {
      this._cursor.activateCursorSprite(!1);
      return;
    }
    this._cursor.activateCursorSprite(!0), this._measureMarkup === null && (this._measureMarkup = new sa(this._viewer), this._measureManager.addMeasurement(this._measureMarkup));
    const o = r.worldPosition.copy();
    if (this._viewer.sheetManager.isDrawingSheetActive() && (o.z = 0), i === tn.NoPointsSelected)
      this._measureMarkup.setFirstPointPosition(o), this._measureMarkup.setUnitMultiplier(
        r.selectionItem.isNodeSelection() ? this._viewer.model.getNodeUnitMultiplier(r.selectionItem.getNodeId()) : 1
      );
    else if (i === tn.OnePointSelected) {
      const a = this._getFirstPickPosition();
      r.worldPosition.equalsWithTolerance(a, 1e-7) || (this._measureMarkup.setSecondPointPosition(o), this._measureMarkup.adjust(r.screenPosition));
    }
  }
  /**
   * Determine if the given mouse event should cause snapping. This is influenced by
   * the snap configuration enabled value.
   */
  _useSnapping(t) {
    return this._cursor.snappingConfig.enabled && !t.altDown();
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = this._getStage();
    if (e < tn.TwoPointsSelected) {
      if (!this._cameraInteractionActive) {
        const i = t.getPosition(), s = this._getFirstPickPosition();
        this._cursor.updateCursorSprite(
          i,
          this._useSnapping(t),
          s
        );
      }
    } else
      e === tn.TwoPointsSelected && (this._measureMarkup.adjust(t.getPosition()), t.setHandled(!0));
    this._draw();
  }
  /** @hidden */
  async onMouseUp(t) {
    if (this.isActive()) {
      const e = this._getStage(), i = this._primaryTouchId !== null && this._measureMarkup !== null && e > tn.OnePointSelected;
      if (this._dragCount < 3 || i) {
        const s = this._useSnapping(t), r = t.getPosition();
        e <= tn.OnePointSelected ? await this._updateMeasurementPoints(r, s) : await this._finalizeMeasurement(r, s);
      }
    }
    super.onMouseUp(t);
  }
  /** @hidden */
  onKeyUp(t) {
  }
  _clearMeasurement() {
    this._measureMarkup !== null ? (this._measureManager.removeMeasurement(this._measureMarkup), this._measureMarkup = null) : this._measureManager.removeLastMeasurement();
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Ut.Escape && this._clearMeasurement();
  }
  /** @hidden */
  setHandled() {
    return this._getStage() > tn.OnePointSelected;
  }
  /** @hidden */
  onActivate() {
    this._cursor.onOperatorActivate();
  }
  /** @hidden */
  onDeactivate() {
    this._cursor.onOperatorDeactivate(), this._measureMarkup !== null && (this._measureManager.removeMeasurement(this._measureMarkup), this._measureMarkup = null);
  }
}
const $c = class extends fi {
  constructor(n) {
    super(n), this._initialPoint = new qn(), this._leaderLine = new Wi(), this._endpoints = new Mh(), this._textboxCorners = [
      E.zero(),
      E.zero(),
      E.zero(),
      E.zero()
    ], this._polygon = new wm(), this._plane = null, this.textPosition = d.zero(), this.leaderPosition = d.zero(), this.pointRadius = 2.5, this._viewer = n;
    const t = this._viewer.measureManager.getMeasurementColor();
    this._initialPoint.setFillColor(t), this._initialPoint.setStrokeColor(t), this._leaderLine.setStrokeColor(t), this._endpoints.setFillColor(t), this._endpoints.setStrokeColor(t), this._endpoints.setFillOpacity(1), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(it.white()), this._polygon.setFillColor(t), this._polygon.setFillOpacity(0.4);
  }
  _calculateArea() {
    const n = this._positions.length;
    if (n < 3)
      return 0;
    const t = new Float32Array(n * 3);
    for (let l = 0; l < n; l++) {
      const c = this._positions[l];
      t[3 * l] = c.x, t[3 * l + 1] = c.y, t[3 * l + 2] = c.z;
    }
    const e = d.subtract(this._positions[1], this._positions[0]), i = d.subtract(this._positions[2], this._positions[0]), s = d.cross(e, i), r = this._viewer.model.triangulatePolygon(t, s);
    let o = 0;
    const a = r.length / 3 / 3;
    for (let l = 0; l < a; l++) {
      const c = l * 3 * 3, h = [];
      for (let _ = 0; _ < 3; _++) {
        const y = r[c + _ * 3], b = r[c + _ * 3 + 1], w = r[c + _ * 3 + 2];
        h[_] = new d(y, b, w);
      }
      const u = d.subtract(h[1], h[0]).length(), p = d.subtract(h[2], h[0]).length(), m = d.subtract(h[2], h[1]).length(), g = 0.25 * Math.sqrt(
        (u + p + m) * (-u + p + m) * (u - p + m) * (u + p - m)
      );
      o += g;
    }
    return o;
  }
  /**
   * Adds a point to the point list and updates the calculated polygon area.
   * Only points that are coplanar will be added.
   * Returns a bool representing if the point was accepted or not
   */
  addPoint(n) {
    if (this._positions.length >= 3 && (this._plane === null && (this._plane = je.createFromPoints(
      this._positions[0],
      this._positions[1],
      this._positions[2]
    )), Math.abs(this._plane.distanceToPoint(n)) > 1e-4))
      return !1;
    this._positions.length === 2 && (this._plane = je.createFromPoints(this._positions[0], this._positions[1], n)), this._positions.push(n.copy());
    const t = this._calculateArea(), e = this.getUnitMultiplier(), i = `${Go(t, e)}²`;
    return this._setMeasurementValue(t), this.setMeasurementText(i), !0;
  }
  getPoints() {
    return this._positions;
  }
  getLast() {
    return this._positions.length === 0 ? null : this._positions[this._positions.length - 1].copy();
  }
  // finalizes the measurement
  finalize() {
    if (this._positions.length > 2) {
      const n = this._calculateArea(), t = this.getUnitMultiplier(), e = `${Go(n, t)}²`;
      this._setMeasurementValue(n), this.setMeasurementText(e);
    }
    this._finalized = !0;
  }
  setUnitMultiplier(n) {
    this._unitMultiplier = n;
  }
  isValid() {
    return this._positions.length > 2;
  }
  getMeasurementText() {
    return this._textShape.getTextString();
  }
  /** Calculates the screen position for each point in the polygon */
  _updateProjectedPoints() {
    const n = [];
    this._behindView = !1;
    for (const t of this._positions) {
      const e = this._viewer.view.projectPoint(t);
      e.z <= 0 && (this._behindView = !0), n.push(E.fromPoint3(e));
    }
    return n;
  }
  _updateTextBoxCorners() {
    const n = this._viewer.markupManager.getRenderer().measureTextBox(this._textShape), t = this._textShape.getPosition();
    this._textboxCorners[0].assign(t), this._textboxCorners[1].set(t.x + n.x, t.y), this._textboxCorners[2].set(t.x + n.x, t.y + n.y), this._textboxCorners[3].set(t.x, t.y + n.y);
  }
  /** Finds and returns the closest corner of the text box.  Used as the endpoint of the leader line. */
  _calculateLeaderEndpoint(n) {
    this._updateTextBoxCorners();
    const t = E.zero();
    let e = Number.MAX_VALUE;
    for (const i of this._textboxCorners) {
      const s = E.distance(n, i);
      s < e && (t.assign(i), e = s);
    }
    return t;
  }
  draw() {
    if (!this._visibility)
      return;
    const n = this._updateProjectedPoints();
    if (this._behindView || n.length === 0)
      return;
    const t = this._viewer.markupManager.getRenderer();
    if (n.length === 1)
      this._initialPoint.set(n[0], this.pointRadius), t.drawCircle(this._initialPoint);
    else {
      this._polygon.clearPoints();
      for (const r of n)
        this._polygon.pushPoint(r);
      this._finalized && this._polygon.pushPoint(n[0]);
      const e = E.fromPoint3(this._viewer.view.projectPoint(this.textPosition));
      this._textShape.setPosition(e), t.drawPolygon(this._polygon);
      const i = E.fromPoint3(this._viewer.view.projectPoint(this.leaderPosition)), s = this._calculateLeaderEndpoint(i);
      this._leaderLine.setP1(i), this._leaderLine.setP2(s), t.drawLine(this._leaderLine), t.drawTextBox(this._textShape), this._endpoints.clear(), this._endpoints.addCircle(n[0], this.pointRadius), this._endpoints.addCircle(n[n.length - 1], this.pointRadius), t.drawCircles(this._endpoints);
    }
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const n = [];
    for (const t of this._positions)
      n.push(t.toJson());
    return {
      name: this._name,
      points: n,
      textPoint: this.textPosition.toJson(),
      leaderPoint: this.leaderPosition.toJson(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      text: this._textShape.getTextString(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasurePolygonAreaMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new $c(t);
    return i._name = e.name, i._positions = fi._constructPointArray(e.points), i.textPosition = d.fromJson(e.textPoint), i.leaderPosition = d.fromJson(e.leaderPoint), i._measurementValue = e.measurementValue, i._unitMultiplier = e.unitMultiplier || 1, i._textShape.setTextString(e.text), i._finalized = !0, i;
  }
  /** This measurement only allows clicking on the text box portion of the markup. */
  hit(n) {
    const t = this._viewer.markupManager.getRenderer().measureTextBox(this._textShape), e = this._textShape.getPosition();
    return !(n.x < e.x || n.x > e.x + t.x || n.y < e.y || n.y > e.y + t.y);
  }
  getClassName() {
    return $c.className;
  }
};
let ra = $c;
ra.className = "Communicator.Markup.Measure.MeasurePolygonAreaMarkup";
Ui(ra.className, ra.fromJson);
class Hm extends xe {
  /** @hidden */
  constructor(t, e) {
    super(t), this._markupItem = null, this._cameraInteractionActive = !1, this._textShapeOffset = new E(10, -25), this._anchor = Pr.Last, this._dragPlane = null, this._measureManager = e, this._cursor = new ya(this._viewer), this._viewer.setCallbacks({
      beginInteraction: () => {
        this._onBeginInteraction();
      },
      endInteraction: () => {
        this._onEndInteraction();
      }
    });
  }
  /** @hidden */
  getMarkupItem() {
    return this._markupItem;
  }
  /** Sets the anchor type that will be set for markups created by this operator. */
  setAnchor(t) {
    this._anchor = t;
  }
  /**
   * Determine if the given mouse event should cause snapping. This is influenced by
   * the snap configuration enabled value.
   */
  _useSnapping(t) {
    return this._cursor.snappingConfig.enabled && !t.altDown();
  }
  _getLastSelectedPoint() {
    return this._markupItem ? this._markupItem.getLast() : null;
  }
  _createNewMarkupItem(t) {
    this._markupItem = new ra(this._viewer), this._markupItem.setUnitMultiplier(
      t.selectionItem.isNodeSelection() ? this._viewer.model.getNodeUnitMultiplier(t.selectionItem.getNodeId()) : 1
    ), this._markupItem.setName("MeasurePolygonAreaMarkup"), this._measureManager.addMeasurement(this._markupItem), this._markupItem.addPoint(t.worldPosition);
  }
  _updateMarkupItem(t, e) {
    if (this._markupItem === null || e.worldPosition == null)
      return;
    const i = this._markupItem.getPoints(), s = E.fromPoint3(this._viewer.view.projectPoint(i[0]));
    E.distance(s, t) < this._markupItem.pointRadius ? i.length > 2 && this._finalizeMeasurement() : this._markupItem.addPoint(e.worldPosition) && this._updateAnchor(t, e.worldPosition);
  }
  // Updates the cursor display and the measurement markup item based on a pointer position.
  async _updateMeasurementItem(t, e) {
    const i = this._getLastSelectedPoint(), s = await this._cursor.getSelectionCursorPoints(
      t,
      e,
      i
    );
    if (s === null || s.worldPosition === null) {
      this._cursor.activateCursorSprite(!1);
      return;
    } else
      this._cursor.activateCursorSprite(!0);
    this._markupItem === null ? this._createNewMarkupItem(s) : this._updateMarkupItem(t, s);
  }
  _isDraggingText() {
    return this._dragPlane !== null;
  }
  /** @hidden */
  onMouseDown(t) {
    if (super.onMouseDown(t), this._markupItem)
      return;
    const e = t.getPosition();
    this._pickExisting(e) && (this._dragPlane = this._calculateSelectionPlane(this._markupItem.leaderPosition), t.setHandled(!0));
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this._isDraggingText())
      this._dragMarkupText(t), t.setHandled(!0);
    else if (!this._cameraInteractionActive) {
      const e = this._getLastSelectedPoint();
      this._cursor.updateCursorSprite(
        t.getPosition(),
        this._useSnapping(t),
        e
      ), this._draw();
    }
  }
  /** @hidden */
  async onMouseUp(t) {
    if (!this.isActive())
      return;
    const e = t.getPosition();
    if (this._isDraggingText())
      this._markupItem = null, this._dragPlane = null;
    else if (this._ptFirst.equals(e)) {
      const i = this._useSnapping(t), s = e;
      await this._updateMeasurementItem(s, i);
    }
    super.onMouseUp(t);
  }
  /** @hidden */
  onDoubleClick(t) {
    this._finalizeMeasurement();
  }
  _dragMarkupText(t) {
    if (this._markupItem === null || this._dragPlane === null)
      return;
    const e = this._viewer.view.raycastFromPoint(t.getPosition());
    this._dragPlane.intersectsRay(e, this._markupItem.textPosition), this._draw();
  }
  _finalizeMeasurement() {
    if (this._markupItem)
      if (this._markupItem.isValid()) {
        const t = this._markupItem;
        this._markupItem = null, t.finalize(), this._measureManager.finalizeMeasurement(t);
      } else
        this._clearMeasurement();
  }
  _updateAnchor(t, e) {
    if (!this._markupItem)
      return;
    const i = this._markupItem.getPoints();
    if (i.length !== 1)
      switch (this._anchor) {
        case Pr.Last:
          this._calculateAnchorPos(t, e);
          break;
        case Pr.First: {
          if (i.length !== 2)
            return;
          const s = this._viewer.view.projectPoint(i[0]);
          this._calculateAnchorPos(E.fromPoint3(s), i[0]);
          break;
        }
        case Pr.Midpoint: {
          let s;
          const r = this._markupItem.getMeasurementValue() / 2;
          let o = 0;
          for (let l = 1; l < i.length; l++) {
            const c = d.subtract(i[l], i[l - 1]), h = c.length(), u = o + h;
            if (u > r) {
              const m = (r - o) / h;
              c.scale(m), s = d.add(i[l - 1], c);
              break;
            }
            o = u;
          }
          const a = this._viewer.view.projectPoint(s);
          this._calculateAnchorPos(E.fromPoint3(a), s);
          break;
        }
      }
  }
  _calculateSelectionPlane(t) {
    const e = this._viewer.view.getCamera(), i = d.subtract(e.getPosition(), t);
    return i.normalize(), je.createFromPointAndNormal(t, i);
  }
  _calculateAnchorPos(t, e) {
    const i = this._viewer.view.getCamera();
    d.subtract(i.getPosition(), e).normalize();
    const r = this._calculateSelectionPlane(e), o = this._viewer.view.raycastFromPoint(
      E.add(t, this._textShapeOffset)
    );
    o && (r.intersectsRay(o, this._markupItem.textPosition), this._markupItem.leaderPosition.assign(e));
  }
  // Cancels the currently measurement being created or removes the last created measurement
  _clearMeasurement() {
    this._markupItem !== null ? (this._measureManager.removeMeasurement(this._markupItem), this._markupItem = null) : this._measureManager.removeLastMeasurement();
  }
  _draw() {
    this._viewer.markupManager.refreshMarkup();
  }
  _pickExisting(t) {
    const e = this._viewer.markupManager.pickMarkupItem(t);
    return e && e.getClassName() === "Communicator.MeasurePolygonAreaMarkup" ? (this._markupItem = e, !0) : !1;
  }
  /** @hidden */
  onActivate() {
    this._cursor.onOperatorActivate();
  }
  /** @hidden */
  onDeactivate() {
    this._cursor.onOperatorDeactivate();
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Ut.Escape && this._clearMeasurement();
  }
  _onBeginInteraction() {
    this._cameraInteractionActive = !0, this._cursor.activateCursorSprite(!1);
  }
  _onEndInteraction() {
    this._cameraInteractionActive = !1;
  }
}
const th = class extends fi {
  constructor(n) {
    super(n), this._polyline = new fr(), this._initialPoint = new qn(), this._leaderLine = new Wi(), this._endpoints = new Mh(), this._textboxCorners = [
      E.zero(),
      E.zero(),
      E.zero(),
      E.zero()
    ], this.textPosition = d.zero(), this.leaderPosition = d.zero(), this.isLoop = !1, this.pointRadius = 2.5, this._viewer = n;
    const t = this._viewer.measureManager.getMeasurementColor();
    this._initialPoint.setFillColor(t), this._initialPoint.setStrokeColor(t), this._polyline.setStrokeColor(t), this._polyline.setStrokeWidth(2), this._leaderLine.setStrokeColor(t), this._endpoints.setFillColor(t), this._endpoints.setStrokeColor(t), this._endpoints.setFillOpacity(1), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(it.white());
  }
  /** Adds a point to the pointlist and updates the calculated polyline distance */
  addPoint(n) {
    if (this._positions.push(n.copy()), this._positions.length > 1) {
      const t = d.subtract(
        this._positions[this._positions.length - 1],
        this._positions[this._positions.length - 2]
      ).length();
      this._setMeasurementValue(this._measurementValue + t);
    }
  }
  getPoints() {
    return this._positions;
  }
  getlast() {
    return this._positions.length === 0 ? null : this._positions[this._positions.length - 1].copy();
  }
  // finalizes the measurement and sets the final distance if the polyline is a loop
  finalize() {
    if (this.isLoop && this._positions.length > 2) {
      const n = d.subtract(
        this._positions[this._positions.length - 1],
        this._positions[0]
      ).length();
      this._setMeasurementValue(this._measurementValue + n);
    }
    this._finalized = !0;
  }
  setUnitMultiplier(n) {
    this._unitMultiplier = n;
  }
  isValid() {
    return this._positions.length > 1;
  }
  getMeasurementText() {
    return this._textShape.getTextString();
  }
  /** Calculates the screen position for each point in the polyline */
  _updateProjectedPoints() {
    const n = [];
    this._behindView = !1, this._behindView = !1;
    for (const t of this._positions) {
      const e = this._viewer.view.projectPoint(t);
      e.z <= 0 && (this._behindView = !0), n.push(E.fromPoint3(e));
    }
    return n;
  }
  _updateTextBoxCorners() {
    const n = this._viewer.markupManager.getRenderer().measureTextBox(this._textShape), t = this._textShape.getPosition();
    this._textboxCorners[0].assign(t), this._textboxCorners[1].set(t.x + n.x, t.y), this._textboxCorners[2].set(t.x + n.x, t.y + n.y), this._textboxCorners[3].set(t.x, t.y + n.y);
  }
  /** Finds and returns the closest corner of the text box.  Used as the endpoint of the leader line. */
  _calculateLeaderEndpoint(n) {
    this._updateTextBoxCorners();
    const t = E.zero();
    let e = Number.MAX_VALUE;
    for (const i of this._textboxCorners) {
      const s = E.distance(n, i);
      s < e && (t.assign(i), e = s);
    }
    return t;
  }
  draw() {
    if (!this._visibility)
      return;
    const n = this._updateProjectedPoints();
    if (this._behindView || n.length === 0)
      return;
    const t = this._viewer.markupManager.getRenderer();
    if (n.length === 1)
      this._initialPoint.set(n[0], this.pointRadius), t.drawCircle(this._initialPoint);
    else {
      this._polyline.clearPoints();
      for (const r of n)
        this._polyline.pushPoint(r);
      this._finalized && this.isLoop && this._polyline.pushPoint(n[0]);
      const e = E.fromPoint3(this._viewer.view.projectPoint(this.textPosition));
      this._textShape.setPosition(e), t.drawPolyline(this._polyline);
      const i = E.fromPoint3(this._viewer.view.projectPoint(this.leaderPosition)), s = this._calculateLeaderEndpoint(i);
      this._leaderLine.setP1(i), this._leaderLine.setP2(s), t.drawLine(this._leaderLine), t.drawTextBox(this._textShape), this._endpoints.clear(), this.isLoop || (this._endpoints.addCircle(n[0], this.pointRadius), this._endpoints.addCircle(n[n.length - 1], this.pointRadius), t.drawCircles(this._endpoints));
    }
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const n = [];
    for (const t of this._positions)
      n.push(t.toJson());
    return {
      name: this._name,
      points: n,
      textPoint: this.textPosition.toJson(),
      leaderPoint: this.leaderPosition.toJson(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      isLoop: this.isLoop,
      text: this._textShape.getTextString(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasurePolylineDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new th(t);
    return i._name = e.name, i._positions = fi._constructPointArray(e.points), i.textPosition = d.fromJson(e.textPoint), i.leaderPosition = d.fromJson(e.leaderPoint), i.isLoop = e.isLoop, i._measurementValue = e.measurementValue, i._unitMultiplier = e.unitMultiplier || 1, i._textShape.setTextString(e.text), i._finalized = !0, i;
  }
  /** This measurement only allows clicking on the text box portion of the markup. */
  hit(n) {
    const t = this._viewer.markupManager.getRenderer().measureTextBox(this._textShape), e = this._textShape.getPosition();
    return !(n.x < e.x || n.x > e.x + t.x || n.y < e.y || n.y > e.y + t.y);
  }
  getClassName() {
    return th.className;
  }
};
let oa = th;
oa.className = "Communicator.Markup.Measure.MeasurePolylineDistanceMarkup";
Ui(
  oa.className,
  oa.fromJson
);
class Um extends xe {
  /** @hidden */
  constructor(t, e) {
    super(t), this._markupItem = null, this._cameraInteractionActive = !1, this._textShapeOffset = new E(10, -25), this._anchor = Vr.Last, this._dragPlane = null, this._measureManager = e, this._cursor = new ya(this._viewer), this._viewer.setCallbacks({
      beginInteraction: () => {
        this._onBeginInteraction();
      },
      endInteraction: () => {
        this._onEndInteraction();
      }
    });
  }
  /** @hidden */
  getMarkupItem() {
    return this._markupItem;
  }
  /** Sets the anchor type that will be set for markups created by this operator. */
  setAnchor(t) {
    this._anchor = t;
  }
  /**
   * Determine if the given mouse event should cause snapping. This is influenced by
   * the snap configuration enabled value.
   */
  _useSnapping(t) {
    return this._cursor.snappingConfig.enabled && !t.altDown();
  }
  _getLastSelectedPoint() {
    return this._markupItem ? this._markupItem.getlast() : null;
  }
  _createNewMarkupItem(t) {
    this._markupItem = new oa(this._viewer), this._markupItem.setUnitMultiplier(
      t.selectionItem.isNodeSelection() ? this._viewer.model.getNodeUnitMultiplier(t.selectionItem.getNodeId()) : 1
    ), this._markupItem.setName("MeasurePolylineDistanceMarkup"), this._measureManager.addMeasurement(this._markupItem), this._markupItem.addPoint(t.worldPosition);
  }
  _updateMarkupItem(t, e) {
    if (this._markupItem === null || e.worldPosition == null)
      return;
    const i = this._markupItem.getPoints(), s = E.fromPoint3(this._viewer.view.projectPoint(i[0]));
    E.distance(s, t) < this._markupItem.pointRadius ? i.length > 2 && (this._markupItem.isLoop = !0, this._finalizeMeasurement()) : (this._markupItem.addPoint(e.worldPosition), this._updateAnchor(t, e.worldPosition));
  }
  // Updates the cursor display and the measurement markup item based on a pointer position.
  async _updateMeasurementItem(t, e) {
    const i = this._getLastSelectedPoint(), s = await this._cursor.getSelectionCursorPoints(
      t,
      e,
      i
    );
    if (s === null || s.worldPosition === null) {
      this._cursor.activateCursorSprite(!1);
      return;
    } else
      this._cursor.activateCursorSprite(!0);
    this._markupItem === null ? this._createNewMarkupItem(s) : this._updateMarkupItem(t, s);
  }
  _isDraggingText() {
    return this._dragPlane !== null;
  }
  /** @hidden */
  onMouseDown(t) {
    if (super.onMouseDown(t), this._markupItem)
      return;
    const e = t.getPosition();
    this._pickExisting(e) && (this._dragPlane = this._calculateSelectionPlane(this._markupItem.leaderPosition), t.setHandled(!0));
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this._isDraggingText())
      this._dragMarkupText(t), t.setHandled(!0);
    else if (!this._cameraInteractionActive) {
      const e = this._getLastSelectedPoint();
      this._cursor.updateCursorSprite(
        t.getPosition(),
        this._useSnapping(t),
        e
      ), this._draw();
    }
  }
  /** @hidden */
  async onMouseUp(t) {
    if (!this.isActive())
      return;
    const e = t.getPosition();
    if (this._isDraggingText())
      this._markupItem = null, this._dragPlane = null;
    else if (this._ptFirst.equals(e)) {
      const i = this._useSnapping(t), s = e;
      await this._updateMeasurementItem(s, i);
    }
    super.onMouseUp(t);
  }
  /** @hidden */
  onDoubleClick(t) {
    this._finalizeMeasurement();
  }
  _dragMarkupText(t) {
    if (this._markupItem === null || this._dragPlane === null)
      return;
    const e = this._viewer.view.raycastFromPoint(t.getPosition());
    this._dragPlane.intersectsRay(e, this._markupItem.textPosition), this._draw();
  }
  _finalizeMeasurement() {
    if (this._markupItem)
      if (this._markupItem.isValid()) {
        const t = this._markupItem;
        this._markupItem = null, t.finalize(), this._measureManager.finalizeMeasurement(t);
      } else
        this._clearMeasurement();
  }
  _updateAnchor(t, e) {
    if (!this._markupItem)
      return;
    const i = this._markupItem.getPoints();
    if (i.length !== 1)
      switch (this._anchor) {
        case Vr.Last:
          this._calculateAnchorPos(t, e);
          break;
        case Vr.First: {
          if (i.length !== 2)
            return;
          const s = this._viewer.view.projectPoint(i[0]);
          this._calculateAnchorPos(E.fromPoint3(s), i[0]);
          break;
        }
        case Vr.Midpoint: {
          let s;
          const r = this._markupItem.getMeasurementValue() / 2;
          let o = 0;
          for (let l = 1; l < i.length; l++) {
            const c = d.subtract(i[l], i[l - 1]), h = c.length(), u = o + h;
            if (u > r) {
              const m = (r - o) / h;
              c.scale(m), s = d.add(i[l - 1], c);
              break;
            }
            o = u;
          }
          const a = this._viewer.view.projectPoint(s);
          this._calculateAnchorPos(E.fromPoint3(a), s);
          break;
        }
      }
  }
  _calculateSelectionPlane(t) {
    const e = this._viewer.view.getCamera(), i = d.subtract(e.getPosition(), t);
    return i.normalize(), je.createFromPointAndNormal(t, i);
  }
  _calculateAnchorPos(t, e) {
    const i = this._viewer.view.getCamera();
    d.subtract(i.getPosition(), e).normalize();
    const r = this._calculateSelectionPlane(e), o = this._viewer.view.raycastFromPoint(
      E.add(t, this._textShapeOffset)
    );
    o && (r.intersectsRay(o, this._markupItem.textPosition), this._markupItem.leaderPosition.assign(e));
  }
  // Cancels the currently measurement being created or removes the last created measurement
  _clearMeasurement() {
    this._markupItem !== null ? (this._measureManager.removeMeasurement(this._markupItem), this._markupItem = null) : this._measureManager.removeLastMeasurement();
  }
  _draw() {
    this._viewer.markupManager.refreshMarkup();
  }
  _pickExisting(t) {
    const e = this._viewer.markupManager.pickMarkupItem(t);
    return e && e.getClassName() === "Communicator.MeasurePolylineDistanceMarkup" ? (this._markupItem = e, !0) : !1;
  }
  /** @hidden */
  onActivate() {
    this._cursor.onOperatorActivate();
  }
  /** @hidden */
  onDeactivate() {
    this._cursor.onOperatorDeactivate();
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Ut.Escape && this._clearMeasurement();
  }
  _onBeginInteraction() {
    this._cameraInteractionActive = !0, this._cursor.activateCursorSprite(!1);
  }
  _onEndInteraction() {
    this._cameraInteractionActive = !1;
  }
}
const Q_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MeasureBodyBodyDistanceOperator: Km,
  MeasureEdgeLengthOperator: Am,
  MeasureFaceFaceAngleOperator: Dm,
  MeasureFaceFaceDistanceOperator: zm,
  MeasureLineLineAngleOperator: Bm,
  MeasurePointPointDistanceOperator: jm,
  MeasurePolygonAreaAnchor: Pr,
  MeasurePolygonAreaOperator: Hm,
  MeasurePolylineDistanceAnchor: Vr,
  MeasurePolylineDistanceOperator: Um,
  PointCursor: ya,
  SelectionPoints: Jm,
  Stage: tn,
  worldPointToScreenPoint: Ba
}, Symbol.toStringTag, { value: "Module" })), q_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MeasureBodyBodyDistanceMarkup: $o,
  MeasureCircleEdgeLengthMarkup: ta,
  MeasureFaceFaceAngleMarkup: ea,
  MeasureFaceFaceDistanceMarkup: ia,
  MeasureLengthMarkup: Bl,
  MeasureLineLineAngleMarkup: na,
  MeasureMarkup: fi,
  MeasurePointPointDistanceMarkup: sa,
  MeasurePolygonAreaMarkup: ra,
  MeasurePolylineDistanceMarkup: oa,
  MeasureStraightEdgeLengthMarkup: pl
}, Symbol.toStringTag, { value: "Module" })), ja = class extends _s {
  constructor(n, t, e, i, s) {
    super(), this._uniqueId = Qi(), this._noteElementId = null, this._position = d.zero(), this._text = "", this._color = it.white(), this._sphereRadius = 0.03, this._deleted = !1, this._active = !1, this._callbacks = null, this._viewer = n, this._noteTextManager = t, this._selectionPosition = e, this._selectionNormal = i, this._partId = s, this._noteTextManager.addNote(this), this._init();
  }
  async _init() {
    const n = this._createPinTransformationMatrix(
      this._selectionPosition,
      this._selectionNormal
    ), [t, e] = await Promise.all([
      this._createPinStemInstance(n),
      this._createPinSphereInstance(n)
    ]);
    this._stemInstanceId = t, this._sphereInstanceId = e, await this._restore(!1), this._callbacks = {
      visibilityChanged: () => {
        this._matchPartVisibility();
      }
    }, this._viewer.setCallbacks(this._callbacks), this._viewer.trigger("noteTextCreated", this);
  }
  _matchPartVisibility() {
    if (this._sphereInstanceId === void 0 || this._stemInstanceId === void 0)
      return;
    const n = this._viewer.model, t = n.getNodeVisibility(this._partId), e = n.getNodeVisibility(this._sphereInstanceId);
    t !== e && !this._noteTextManager.getExplodeActive() && n.setNodesVisibility([this._stemInstanceId, this._sphereInstanceId], t);
    const i = this._noteTextManager.getActiveItem();
    i !== null && i.getStemInstanceId() === this._stemInstanceId && !t && this.hide();
  }
  async updatePosition() {
    if (this._sphereInstanceId === void 0)
      return;
    const n = await this._viewer.model.getNodeRealBounding(this._sphereInstanceId);
    this._pinBoundingBox = n, this._position = this._pinBoundingBox.center(), this.setText(this._text);
  }
  async _restore(n) {
    this._noteTextManager.setActiveItemHandle(this._viewer.markupManager.registerMarkup(this)), this._noteTextManager.setActiveItem(this), this._show(n), this._updateColor(), await this.draw();
  }
  async restore() {
    return this._restore(!0);
  }
  setText(n) {
    this._text = n, this._noteTextManager.getNoteTextElement().setText(n);
  }
  saveTextValue() {
    this._text = this._noteTextManager.getNoteTextElement().getText();
  }
  async draw() {
    if (this._deleted || !this._active)
      return;
    this._behindView = !1, await this.updatePosition();
    const n = this._viewer.view.projectPoint(this._position);
    if (n.z <= 0 && (this._behindView = !0), this._behindView)
      this._noteElementId !== null && document.getElementById(this._noteElementId) !== null && (this._viewer.markupManager.removeMarkupElement(this._noteElementId), this._noteElementId = null);
    else {
      const t = new E(n.x, n.y), e = this._noteTextManager.getNoteTextElement();
      e.setPosition(t), this._noteElementId === null && (this._noteElementId = this._viewer.markupManager.addMarkupElement(
        e.getHtmlContainer()
      ));
    }
  }
  hit(n) {
    return this.hitWithTolerance(n, 0);
  }
  hitWithTolerance(n, t) {
    if (!this._active)
      return !1;
    const e = this._noteTextManager.getNoteTextElement(), i = e.getPosition(), s = e.getSize();
    return Uu(n, i, s, t);
  }
  getClassName() {
    return ja.className;
  }
  getUniqueId() {
    return this._uniqueId;
  }
  getSphereInstanceId() {
    return this._sphereInstanceId;
  }
  getStemInstanceId() {
    return this._stemInstanceId;
  }
  onSelect() {
    this._noteTextManager.getNoteTextElement().focus();
  }
  onDeselect() {
    this._noteTextManager.getNoteTextElement().blur();
  }
  hide() {
    const n = this._noteTextManager.getNoteTextElement();
    n.hide(), this.setText(n.getText()), this._noteTextManager.setActiveItem(null), this._active = !1, this._viewer.trigger("noteTextHidden", this);
  }
  _show(n) {
    this._noteTextManager.getNoteTextElement().show(this), this._active = !0, n && this._viewer.trigger("noteTextShown", this);
  }
  show() {
    this._show(!0);
  }
  async remove() {
    if (this.getRemoved() === !0)
      return;
    this._callbacks !== null && (this._viewer.unsetCallbacks(this._callbacks), this._callbacks = null);
    const n = this._viewer.model, t = [];
    this._stemInstanceId !== void 0 && t.push(n.deleteMeshInstances([this._stemInstanceId])), this._sphereInstanceId !== void 0 && t.push(n.deleteMeshInstances([this._sphereInstanceId])), this.hide(), this._noteTextManager.removeNote(this), this._deleted = !0, await zt(t), super.remove();
  }
  getRemoved() {
    return this._deleted;
  }
  setColor(n) {
    return this._color = n, this._updateColor(), Promise.resolve();
  }
  getColor() {
    return this._color;
  }
  getPartId() {
    return this._partId;
  }
  _updateColor() {
    this._sphereInstanceId !== void 0 && this._viewer.model.setNodesFaceColor([this._sphereInstanceId], this._color);
  }
  // pin methods
  _createPinTransformationMatrix(n, t) {
    let e = 0, i = t.x;
    Math.abs(t.y) < Math.abs(i) && (i = t.y, e = 1), Math.abs(t.z) < Math.abs(i) && (e = 2);
    const s = [0, 0, 0];
    s[e] = 1;
    const r = d.createFromArray(s), o = d.cross(t, r).normalize(), a = d.cross(t, o);
    let l = new Q();
    return l.m = [
      t.x,
      t.y,
      t.z,
      0,
      o.x,
      o.y,
      o.z,
      0,
      a.x,
      a.y,
      a.z,
      0,
      0,
      0,
      0,
      1
    ], l = Q.multiply(
      l,
      new Q().setScaleComponent(this._sphereRadius, this._sphereRadius, this._sphereRadius)
    ), l.setTranslationComponent(n.x, n.y, n.z), l;
  }
  async _createPinStemInstance(n) {
    const t = this._noteTextManager.getPinStemMeshId();
    if (t === null)
      throw new Mt("stem mesh hasn't been created yet");
    const e = new bn(
      t,
      n,
      "pin-stem-instance",
      void 0,
      it.black()
    );
    e.setOpacity(1);
    const i = xt.SuppressCameraScale | xt.DoNotCut | xt.DoNotExplode | xt.DoNotXRay | xt.ExcludeBounding | xt.OverrideSceneVisibility | xt.AlwaysDraw;
    return e.setCreationFlags(i), this._viewer.model.createMeshInstance(e, void 0, !0, !0);
  }
  async _createPinSphereInstance(n) {
    const t = this._noteTextManager.getPinSphereMeshId();
    if (t === null)
      throw new Mt("sphere mesh hasn't been created yet");
    const e = new bn(
      t,
      n,
      "pin-sphere-instance",
      it.white(),
      void 0
    );
    e.setOpacity(1);
    const i = xt.SuppressCameraScale | xt.DoNotCut | xt.DoNotExplode | xt.DoNotXRay | xt.ExcludeBounding | xt.OverrideSceneVisibility | xt.AlwaysDraw;
    return e.setCreationFlags(i), this._viewer.model.createMeshInstance(e, void 0, !0, !0);
  }
  // Serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      uniqueId: this._uniqueId,
      className: this.getClassName(),
      selectionPosition: this._selectionPosition.toJson(),
      selectionNormal: this._selectionNormal.toJson(),
      text: this._text,
      color: this._color,
      partId: this._partId
    };
  }
  static _fromJson(n, t, e) {
    const i = n;
    if (!e.findById(i.uniqueId)) {
      const s = d.fromJson(i.selectionPosition), r = d.fromJson(i.selectionNormal), o = i.partId, a = new ja(
        t,
        e,
        s,
        r,
        o
      );
      return a._uniqueId = i.uniqueId, a.setText(i.text), a.setColor(it.fromJson(i.color)), a;
    }
    return null;
  }
  /**
   * Creates a new [[NoteText]] from an object given by [[toJson]].
   * @param An object given by [[toJson]].
   * @returns The prepared object.
   */
  static async fromJson(n, t, e) {
    return ja._fromJson(n, t, e);
  }
};
let zr = ja;
zr.className = "Communicator.Markup.Note.NoteText";
Ui(zr.className, zr.fromJson);
class Qm {
  constructor() {
    this._positionOffset = E.zero(), this._position = E.zero(), this._activeNoteText = null, this._createTextBox();
  }
  _createTextBox() {
    this._container = document.createElement("div"), this._container.className = "noteTextElement", this._textArea = document.createElement("textarea"), this._textArea.oninput = () => {
      this._activeNoteText !== null && this._activeNoteText.saveTextValue();
    }, this._container.appendChild(this._textArea);
    const t = ["blue", "red", "green", "white", "black"];
    let e = 7;
    t.forEach((s) => {
      const r = document.createElement("button");
      r.className = `noteButton color ${s}`, r.style.top = `${e}px`, e += 25, r.id = `${s}_button`;
      let o;
      switch (s) {
        case "blue":
          o = it.blue();
          break;
        case "red":
          o = it.red();
          break;
        case "green":
          o = it.green();
          break;
        case "white":
          o = it.white();
          break;
        case "black":
          o = it.black();
          break;
        default:
          o = it.white();
          break;
      }
      r.onmousedown = () => {
        this._activeNoteText !== null && this._activeNoteText.setColor(o);
      }, this._container.appendChild(r);
    });
    const i = document.createElement("button");
    i.className = "noteButton trash", i.style.top = `${e}px`, i.onmousedown = async () => {
      this._activeNoteText !== null && await this._activeNoteText.remove();
    }, this._container.appendChild(i);
  }
  /**
   * Sets the corner offset position of the HTML container.
   * @param positionOffset
   */
  setPositionOffset(t) {
    this._positionOffset = t;
  }
  /**
   * @returns the current HTML container offset position.
   */
  getPositionOffset() {
    return this._positionOffset.copy();
  }
  /**
   * Sets the position of the HTML container, taking into account the position offset.
   * @param position
   */
  setPosition(t) {
    this._position = E.add(t, this._positionOffset), this._container.style.left = `${this._position.x}px`, this._container.style.top = `${this._position.y}px`;
  }
  /**
   * @returns the position of the HTML container, taking into account the position offset.
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Sets the text in the HTML container text area.
   * @param text
   */
  setText(t) {
    const e = this._container.querySelector("textarea");
    e !== null && (e.value = t);
  }
  /**
   * @returns the current text in the HTML container text area.
   */
  getText() {
    const t = this._container.querySelector("textarea");
    return t !== null ? t.value : "";
  }
  /**
   * Sets the size of the HTML container.
   * @param size
   */
  setSize(t) {
    this._container.style.width = `${t.x}px`, this._container.style.height = `${t.y}px`;
  }
  /**
   * @returns the size of the HTML container.
   */
  getSize() {
    const t = this._container.getBoundingClientRect();
    return new E(t.width, t.height);
  }
  /**
   * Puts the cursor focus in the HTML container text area.
   */
  focus() {
    this._textArea.focus(), this._textArea.style.pointerEvents = "auto";
  }
  /**
   * Removes the cursor focus from the HTML container text area.
   */
  blur() {
    this._container.blur();
  }
  /**
   * Hides the HTML container.
   */
  hide() {
    this._container.style.visibility = "hidden", this._activeNoteText = null;
  }
  /**
   * Sets the active NoteText and shows the HTML container.
   * @param noteText
   */
  show(t) {
    this._container.style.visibility = "visible", this._activeNoteText = t;
  }
  /**
   * @returns the HTML container element.
   */
  getHtmlContainer() {
    return this._container;
  }
  /**
   * Sets the HTML container element.
   * @param container
   */
  setHtmlContainer(t) {
    this._container = t;
  }
}
class jl {
  /**
   * @returns JSON Array containing markup data.
   */
  exportMarkup() {
    return [];
  }
  /**
   * Loads JSON markup data
   * @param jsonData JSON Array containing markup data.
   */
  loadData(t) {
    return Promise.resolve([]);
  }
}
const Qs = class extends jl {
  constructor(n) {
    super(), this._pinSphereMeshId = null, this._pinStemMeshId = null, this._noteTextList = [], this._activeItemHandle = null, this._activeItem = null, this._explodeActive = !1, this._isolateActive = !1, this._stemLength = 2, this._sphereIterations = 2, this._viewer = n, this._noteTextElement = new Qm(), this._noteTextElement.setPositionOffset(new E(12, -24));
    const t = {
      sceneReady: async () => {
        await this._init();
      }
    };
    this._viewer.setCallbacks(t);
  }
  async _init() {
    Qs._globalPinSphereMeshData === null && (Qs._globalPinSphereMeshData = this._createPinSphereMeshData()), Qs._globalPinStemMeshData === null && (Qs._globalPinStemMeshData = this._createPinStemMeshData());
    const n = this._viewer.model, t = n.createMesh(Qs._globalPinSphereMeshData), e = n.createMesh(Qs._globalPinStemMeshData), i = await Promise.all([t, e]);
    this._pinSphereMeshId = i[0], this._pinStemMeshId = i[1];
  }
  _createPinStemMeshData() {
    const n = new Hi();
    return n.addPolyline([0, 0, 0, this._stemLength, 0, 0]), n;
  }
  _createPinSphereMeshData() {
    const n = (1 + Math.sqrt(5)) / 2, t = Math.sqrt(10 + 2 * Math.sqrt(5)) / (4 * n), e = t / 2, i = t / (2 * n), s = [];
    s[0] = new d(-i, e, 0), s[1] = new d(i, e, 0), s[2] = new d(-i, -e, 0), s[3] = new d(i, -e, 0), s[4] = new d(0, -i, e), s[5] = new d(0, i, e), s[6] = new d(0, -i, -e), s[7] = new d(0, i, -e), s[8] = new d(e, 0, -i), s[9] = new d(e, 0, i), s[10] = new d(-e, 0, -i), s[11] = new d(-e, 0, i);
    for (const h of s)
      h.normalize();
    let r = [
      [0, 11, 5],
      [0, 5, 1],
      [0, 1, 7],
      [0, 7, 10],
      [0, 10, 11],
      [1, 5, 9],
      [5, 11, 4],
      [11, 10, 2],
      [10, 7, 6],
      [7, 1, 8],
      [3, 9, 4],
      [3, 4, 2],
      [3, 2, 6],
      [3, 6, 8],
      [3, 8, 9],
      [4, 9, 5],
      [2, 4, 11],
      [6, 2, 10],
      [8, 6, 7],
      [9, 8, 1]
    ], o = 12;
    for (let h = 0; h < this._sphereIterations; h++) {
      const u = [];
      r.map((p) => {
        const m = s[p[0]], g = s[p[1]], _ = s[p[2]];
        s[o++] = new d(m.x + g.x, m.y + g.y, m.z + g.z).scale(0.5).normalize(), s[o++] = new d(g.x + _.x, g.y + _.y, g.z + _.z).scale(0.5).normalize(), s[o++] = new d(_.x + m.x, _.y + m.y, _.z + m.z).scale(0.5).normalize(), u.push([p[0], o - 3, o - 1]), u.push([o - 3, o - 2, o - 1]), u.push([o - 3, p[1], o - 2]), u.push([o - 2, p[2], o - 1]);
      }), r = u;
    }
    const a = [], l = [];
    for (const h of r)
      for (let u = 0; u < 3; u++) {
        const p = h[u], m = s[p];
        a.push(m.x + this._stemLength + 1), a.push(m.y), a.push(m.z);
        const g = m.normalize();
        l.push(g.x), l.push(g.y), l.push(g.z);
      }
    const c = new Hi();
    return c.addFaces(a, l), c.setFaceWinding(yn.CounterClockwise), c;
  }
  /**
   * Retrieves the mesh id of the stem of the note pin, if there is one
   * @returns MeshId of the note pin stem, or null if there is none
   */
  getPinStemMeshId() {
    return this._pinStemMeshId;
  }
  /**
   * Retrieves the mesh id of the spherical head of the note pin, if there is one
   * @returns MeshId of the note pin sphere, or null if there is none
   */
  getPinSphereMeshId() {
    return this._pinSphereMeshId;
  }
  /**
   * Retrieves the note text element
   * @returns note text element
   */
  getNoteTextElement() {
    return this._noteTextElement;
  }
  /**
   * Sets the note text element
   * @param noteTextElement
   */
  setNoteTextElement(n) {
    this._noteTextElement.hide(), this._noteTextElement = n;
  }
  /**
   * Gets an array of all NoteText items that have been added to the manager
   * @returns array of all NoteText items
   */
  getNoteTextList() {
    return this._noteTextList;
  }
  /**
   * Adds a note and makes it active
   * @param note NoteText to be added to the manager
   */
  addNote(n) {
    this._noteTextList.push(n), this._activeItem = n;
  }
  /**
   * Removes a note from the manager
   * @param note NoteText to be removed from the manager
   */
  removeNote(n) {
    const t = this._noteTextList.indexOf(n);
    this._noteTextList.splice(t, 1);
  }
  /**
   * Updates note pin visibility based on manager state (namely the current explode state)
   */
  async updatePinVisibility() {
    if (this._noteTextList.length > 0) {
      const n = [];
      for (const e of this._noteTextList) {
        const i = e.getSphereInstanceId(), s = e.getStemInstanceId();
        i !== void 0 && n.push(i), s !== void 0 && n.push(s);
      }
      const t = this._viewer.model.setNodesVisibility(n, !this._explodeActive);
      return this._explodeActive && this._noteTextElement.hide(), t;
    }
  }
  /**
   * Sets manager explode state based on explosion magnitude. Active explosion hides note pins
   * @param magnitude Explosion magnitude
   */
  explode(n) {
    return this._explodeActive = n > 0, this.updatePinVisibility();
  }
  /**
   * Gets managers explosion state. Active explosion hides note pins
   */
  getExplodeActive() {
    return this._explodeActive;
  }
  /**
   * Sets whether an isolate is currently active or not
   * @param isolateActive
   */
  setIsolateActive(n) {
    this._isolateActive = n;
  }
  /**
   * Gets whether an isolate is currently active or not
   * @returns isolate status
   */
  getIsolateActive() {
    return this._isolateActive;
  }
  /**
   * Get the currently active note text
   * @returns Currently active note text
   */
  getActiveItem() {
    return this._activeItem;
  }
  /**
   * Sets a new currently active note text
   * @param activeItem note text to be marked as currently active
   */
  setActiveItem(n) {
    this._activeItem = n;
  }
  /**
   * Get the active handle string, such as the one returned by [[MarkupManager.registerMarkup]]
   * @returns Active handle string
   */
  getActiveItemHandle() {
    return this._activeItemHandle;
  }
  /**
   * Set the active handle string, should be provided by [[MarkupManager.registerMarkup]]
   * @param activeItemHandle Active handle string
   */
  setActiveItemHandle(n) {
    this._activeItemHandle = n;
  }
  /**
   * Attempts to set the active note to the one associated with the
   * pins elected by the provided [[SelectionItem]]
   * @param selection SelectionItem to attempt to find note from
   */
  selectPin(n) {
    this._activeItem && this._activeItem.hide();
    const t = n.getNodeId();
    if (t !== null) {
      const e = this._getNoteTextFromNodeId(t);
      if (e !== null)
        return e.restore(), !0;
    }
    return !1;
  }
  /**
   * Checks if a nodeId is part of a note pin
   * @param nodeId NodeId to be checked
   */
  checkPinInstance(n) {
    return this._getNoteTextFromNodeId(n) !== null;
  }
  _getNoteTextFromNodeId(n) {
    for (const t of this._noteTextList)
      if (t.getSphereInstanceId() === n || t.getStemInstanceId() === n)
        return t;
    return null;
  }
  /**
   * Checks if a UUID is associated with any existing notes
   * @param id UUID to check
   */
  findById(n) {
    for (const t of this._noteTextList)
      if (n === t.getUniqueId())
        return !0;
    return !1;
  }
  /**
   * Loads notes from an iterable of JSON data like that returned by [[exportMarkup]]
   * @param notes JSON note data iterable
   */
  loadData(n) {
    const t = [];
    for (const e of n) {
      const i = zr.fromJson(e, this._viewer, this).then((s) => s !== null);
      t.push(i);
    }
    return Promise.all(t);
  }
  /**
   * Exports note texts to an array of JSON Objects that can be restored via [[loadData]]
   * @returns Array of JSON objects representing notes
   */
  exportMarkup() {
    const n = [];
    for (const t of this._noteTextList)
      n.push(t.toJson());
    return n;
  }
};
let Hl = Qs;
Hl._globalPinSphereMeshData = null;
Hl._globalPinStemMeshData = null;
const $_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NoteText: zr,
  NoteTextElement: Qm,
  NoteTextManager: Hl
}, Symbol.toStringTag, { value: "Module" }));
class Io {
  constructor(t, e, i, s, r, o) {
    this.vector = e, this.matrix = i, this.nodeId = s, this.position = t, this.handleType = r, this.translation = d.zero(), this.groupId = o;
  }
}
class qm {
  constructor() {
    this.axis = null, this.plane = null, this.viewPlane = null, this.rotate = null;
  }
}
const $t = class extends _s {
  constructor(n) {
    super(), this._meshIds = new qm(), this._scaleModifier = 1, this._id = 0, this._handleData = /* @__PURE__ */ new Map(), this._translationFromInitialHandlePosition = d.zero(), this._groupIdRotationMatrix = /* @__PURE__ */ new Map(), this._viewer = n, this._callbacks = {
      camera: () => {
        this._updateCamera();
      },
      _assemblyTreeReady: async () => {
        this._updateViewport(), this._hideOverlay();
        const t = this._createMeshId(this._getAxisMeshData()).then((r) => {
          this._meshIds.axis = r;
        }), e = this._createMeshId(this._getPlaneMeshData()).then((r) => {
          this._meshIds.plane = r;
        }), i = this._createMeshId(this._getViewPlaneMeshData()).then((r) => {
          this._meshIds.viewPlane = r;
        }), s = this._createMeshId(this._getRotateMeshData()).then((r) => {
          this._meshIds.rotate = r;
        });
        await Promise.all([t, e, i, s]);
      },
      modelSwitchStart: () => {
        this.removeHandles();
      }
    }, this._viewer.setCallbacks(this._callbacks);
  }
  remove() {
    this._callbacks !== null && (this._viewer.unsetCallbacks(this._callbacks), this._callbacks = null), super.remove();
  }
  _getAxisMeshData() {
    return _h(
      $t._cylinderRadius,
      $t._segmentCount,
      $t._cylinderHeight,
      $t._coneBaseRadius,
      $t._capHeight,
      $t._taperHeight
    );
  }
  _getPlaneMeshData() {
    const n = new d($t._planeOffset, 0, $t._planeOffset), t = new d(
      $t._planeOffset + $t._planeLength,
      0,
      $t._planeOffset
    ), e = new d(
      $t._planeOffset + $t._planeLength,
      0,
      $t._planeOffset + $t._planeLength
    ), i = new d(
      $t._planeOffset,
      0,
      $t._planeOffset + $t._planeLength
    ), s = [
      n.x,
      n.y,
      n.z,
      t.x,
      t.y,
      t.z,
      e.x,
      e.y,
      e.z,
      n.x,
      n.y,
      n.z,
      e.x,
      e.y,
      e.z,
      i.x,
      i.y,
      i.z
    ], r = new d(0, -1, 0), o = [
      r.x,
      r.y,
      r.z,
      r.x,
      r.y,
      r.z,
      r.x,
      r.y,
      r.z,
      r.x,
      r.y,
      r.z,
      r.x,
      r.y,
      r.z,
      r.x,
      r.y,
      r.z
    ], a = new Hi();
    return a.addFaces(s, o), a.setBackfacesEnabled(!0), a.addPolyline([n.x, n.y, n.z, t.x, t.y, t.z]), a.addPolyline([t.x, t.y, t.z, e.x, e.y, e.z]), a.addPolyline([e.x, e.y, e.z, i.x, i.y, i.z]), a.addPolyline([i.x, i.y, i.z, n.x, n.y, n.z]), a;
  }
  _getViewPlaneMeshData() {
    return Sd();
  }
  _getRotateMeshData(n = 35, t = 12, e = 0.5) {
    const i = n * Math.PI / 180, s = 0.1, r = 0.5 * i, o = [];
    for (let h = -r; h <= r; h += s) {
      const u = Math.sin(h) * t, p = Math.cos(h) * t;
      o.push(p), o.push(0), o.push(u);
    }
    const a = new d(0, 0, 1), c = Cd(o, a, 10, e);
    return c.setBackfacesEnabled(!0), c;
  }
  async setAxisMeshData(n) {
    if (this._meshIds.axis === null) {
      const t = await this._createMeshId(n);
      this._meshIds.axis = t;
    } else
      return this._viewer.model.replaceMesh(this._meshIds.axis, n);
  }
  async setPlaneMeshData(n) {
    if (this._meshIds.plane === null) {
      const t = await this._createMeshId(n);
      this._meshIds.plane = t;
    } else
      return this._viewer.model.replaceMesh(this._meshIds.plane, n);
  }
  async setViewPlaneMeshData(n) {
    if (this._meshIds.viewPlane === null) {
      const t = await this._createMeshId(n);
      this._meshIds.viewPlane = t;
    } else
      return this._viewer.model.replaceMesh(this._meshIds.viewPlane, n);
  }
  async setRotateMeshData(n) {
    if (this._meshIds.rotate === null) {
      const t = await this._createMeshId(n);
      this._meshIds.rotate = t;
    } else
      return this._viewer.model.replaceMesh(this._meshIds.rotate, n);
  }
  /**
   * Gets the associated overlay id
   */
  getOverlayId() {
    return Gt.Handles;
  }
  _hideOverlay() {
    this._viewer.overlayManager.setVisibility(Gt.Handles, !1);
  }
  hideOverlay() {
    return this._hideOverlay(), Promise.resolve();
  }
  _showOverlay() {
    this._viewer.overlayManager.setVisibility(Gt.Handles, !0), this._updateCamera();
  }
  showOverlay() {
    return this._showOverlay(), Promise.resolve();
  }
  _updateViewport() {
    this._viewer.overlayManager.setViewport(
      Gt.Handles,
      Jt.UpperLeftCorner,
      0,
      Bt.ProportionOfCanvas,
      0,
      Bt.ProportionOfCanvas,
      1,
      Bt.ProportionOfCanvas,
      1,
      Bt.ProportionOfCanvas
    );
  }
  updateViewport() {
    return this._updateViewport(), Promise.resolve();
  }
  async addHandles(n, t, e) {
    this._scaleModifier = t, this._translationFromInitialHandlePosition.assign(d.zero()), await this.createDefaultHandles(n, e), this._showOverlay();
  }
  _updateCamera() {
    this._viewer.overlayManager.setCamera(
      Gt.Handles,
      this._viewer.view.getCamera()
    );
  }
  getVector(n) {
    const t = this._handleData.get(n);
    if (t !== void 0) {
      const e = t.vector;
      if (e !== null)
        return e.copy();
    }
    return null;
  }
  getHandleType(n) {
    const t = this._handleData.get(n);
    return t === void 0 ? null : t.handleType;
  }
  getHandleGroupId(n) {
    const t = this._handleData.get(n);
    return t === void 0 ? $t.defaultGroupId : t.groupId;
  }
  getPosition(n) {
    const t = this._handleData.get(n);
    if (t) {
      const e = t.translation.copy();
      return t.position.copy().add(this._translationFromInitialHandlePosition).add(e);
    } else
      return null;
  }
  getHandleNodeIds(n = null) {
    let t = [];
    return this._handleData.forEach((e, i) => {
      t.push([i, e]);
    }), n !== null && (t = t.filter((e) => e[1].groupId === n)), t.map((e) => e[0]);
  }
  async removeHandles(n = null) {
    const t = this.getHandleNodeIds(n);
    n === null ? (this._handleData.clear(), this._groupIdRotationMatrix.clear()) : (t.forEach((e) => {
      this._handleData.delete(e);
    }), this._groupIdRotationMatrix.delete(n)), this._handleData.size === 0 && (this._id = 0, this._hideOverlay()), await this._viewer.model.deleteMeshInstances(t);
  }
  isEmpty() {
    return this._handleData.size === 0;
  }
  async createDefaultHandles(n, t) {
    const e = [];
    e.push(this.addViewPlaneHandle(n, $t._viewPlaneColor, t)), e.push(
      this.addAxisTranslationHandle(
        n,
        new d(1, 0, 0),
        $t._xColor,
        null,
        t
      )
    ), e.push(
      this.addAxisTranslationHandle(
        n,
        new d(0, 1, 0),
        $t._yColor,
        null,
        t
      )
    ), e.push(
      this.addAxisTranslationHandle(
        n,
        new d(0, 0, 1),
        $t._zColor,
        null,
        t
      )
    ), e.push(
      this.addPlaneTranslationHandle(
        n,
        new d(1, 0, 0),
        $t._zColor,
        it.black(),
        new d(0, -1, 0),
        t
      )
    ), e.push(
      this.addPlaneTranslationHandle(
        n,
        new d(0, 1, 0),
        $t._xColor,
        it.black(),
        new d(0, 0, -1),
        t
      )
    ), e.push(
      this.addPlaneTranslationHandle(
        n,
        new d(0, 0, 1),
        $t._yColor,
        it.black(),
        new d(-1, 0, 0),
        t
      )
    ), e.push(
      this.addRotateHandle(
        n,
        new d(1, 0, 0),
        $t._zColor,
        new d(0, -1, 0),
        t
      )
    ), e.push(
      this.addRotateHandle(
        n,
        new d(0, 1, 0),
        $t._xColor,
        new d(0, 0, -1),
        t
      )
    ), e.push(
      this.addRotateHandle(
        n,
        new d(0, 0, 1),
        $t._yColor,
        new d(-1, 0, 0),
        t
      )
    ), await Promise.all(e);
  }
  async _createMeshId(n) {
    return await this._viewer.model.createMesh(n, { doNotDelete: !0 });
  }
  async addAxisTranslationHandle(n, t, e, i, s) {
    this._meshIds.axis === null && (this._meshIds.axis = await this._createMeshId(this._getAxisMeshData()));
    const r = `handle-axis-translation-${this._id++}`, o = this._getRotationMatrixFromVector(t, i), a = await this._createMeshInstance(
      this._meshIds.axis,
      r,
      e,
      null,
      n.copy(),
      o.copy()
    );
    return this._handleData.set(
      a,
      new Io(
        n.copy(),
        t.copy(),
        o.copy(),
        a,
        Jn.Axis,
        s
      )
    ), a;
  }
  async addViewPlaneHandle(n, t, e) {
    this._meshIds.viewPlane === null && (this._meshIds.viewPlane = await this._createMeshId(this._getViewPlaneMeshData()));
    const i = await this._createMeshInstance(
      this._meshIds.viewPlane,
      "handle-sphere-instance",
      t,
      null,
      n,
      new Q()
    );
    return this._handleData.set(
      i,
      new Io(n.copy(), null, new Q(), i, Jn.ViewPlane, e)
    ), i;
  }
  async addPlaneTranslationHandle(n, t, e, i, s, r) {
    this._meshIds.plane === null && (this._meshIds.plane = await this._createMeshId(this._getPlaneMeshData()));
    const o = `handle-plane-translation-${this._id++}`, a = this._getRotationMatrixFromVector(t, s), l = await this._createMeshInstance(
      this._meshIds.plane,
      o,
      e,
      i,
      n,
      a
    );
    return this._handleData.set(
      l,
      new Io(
        n.copy(),
        t.copy(),
        a.copy(),
        l,
        Jn.Plane,
        r
      )
    ), l;
  }
  async addRotateHandle(n, t, e, i, s) {
    this._meshIds.rotate === null && (this._meshIds.rotate = await this._createMeshId(this._getRotateMeshData()));
    const r = `handle-rotate-${this._id++}`, o = this._getRotationMatrixFromVector(t, i), a = await this._createMeshInstance(
      this._meshIds.rotate,
      r,
      e,
      null,
      n,
      o
    );
    return this._handleData.set(
      a,
      new Io(
        n.copy(),
        t.copy(),
        o.copy(),
        a,
        Jn.Rotate,
        s
      )
    ), a;
  }
  _getRotationMatrixFromVector(n, t) {
    t || (t = new d(1, 0, 0), d.cross(t, n).squaredLength() < 1e-3 && (t = new d(0, 1, 0)));
    const e = d.cross(t, n).normalize(), i = d.cross(e, n).normalize();
    n.normalize();
    const s = new Q();
    return s.m[0] = e.x, s.m[1] = e.y, s.m[2] = e.z, s.m[3] = 0, s.m[4] = n.x, s.m[5] = n.y, s.m[6] = n.z, s.m[7] = 0, s.m[8] = i.x, s.m[9] = i.y, s.m[10] = i.z, s.m[11] = 0, s.m[12] = 0, s.m[13] = 0, s.m[14] = 0, s.m[15] = 1, s;
  }
  async _createMeshInstance(n, t, e, i, s, r) {
    let o = this._createTransformationMatrix(s, new Q());
    o = Q.multiply(r, o);
    const a = new bn(
      n,
      o,
      t,
      e ?? void 0,
      i ?? void 0
    );
    return a.setOpacity(1), a.setCreationFlags(
      xt.SuppressCameraScale | xt.DoNotCut | xt.DoNotExplode | xt.ExcludeBounding | xt.DoNotXRay | xt.OverrideSceneVisibility | xt.AlwaysDraw
    ), a.setOverlayIndex(Gt.Handles), this._viewer.model.createMeshInstance(a, void 0, !0, !0);
  }
  _createTransformationMatrix(n, t) {
    const e = $t._defaultScale * this._scaleModifier;
    let i = new Q().setScaleComponent(e, e, e);
    return i = Q.multiply(i, t), i.setTranslationComponent(n.x, n.y, n.z), i;
  }
  _getHandlePosition(n) {
    let t = null;
    return this._handleData.forEach((e) => {
      e.groupId === n && (t = e.position.copy());
    }), t;
  }
  getGroupIdRotationMatrix(n) {
    const t = this._groupIdRotationMatrix.get(n);
    return t === void 0 ? new Q() : t.copy();
  }
  async updatePosition(n, t, e, i, s) {
    const r = this._viewer.model, o = [], a = /* @__PURE__ */ new Map(), l = this._getHandlePosition(i);
    l !== null && (this._handleData.forEach((c, h) => {
      const u = c.groupId, p = s.get(u) !== void 0;
      if (!(u === i) && !p)
        return;
      const g = c.position.copy();
      g.add(n.copy());
      const _ = c.translation.copy();
      g.add(_);
      const y = Q.multiply(
        this.getGroupIdRotationMatrix(u),
        t
      ), b = Q.multiply(c.matrix, y);
      if (p) {
        const v = d.subtract(g, l);
        t.transform(v, g), g.add(l);
      }
      const w = this._createTransformationMatrix(g, b);
      e && (c.position.assign(g), a.set(
        u,
        Q.multiply(this.getGroupIdRotationMatrix(u), t)
      )), o.push(r.setNodeMatrix(h, w));
    }), a.forEach((c, h) => {
      this._groupIdRotationMatrix.set(h, c.copy());
    }), await Promise.all(o));
  }
  resetTranslation() {
    this._translationFromInitialHandlePosition && (this._handleData.forEach((n) => {
      n.translation.add(this._translationFromInitialHandlePosition);
    }), this._translationFromInitialHandlePosition.assign(d.zero()));
  }
  getTranslation() {
    return this._translationFromInitialHandlePosition;
  }
};
let _i = $t;
_i.className = "Communicator.Markup.HandleMarkup";
_i.defaultGroupId = -1;
_i._defaultScale = 0.02;
_i._cylinderRadius = 0.5;
_i._coneBaseRadius = 0.9;
_i._cylinderHeight = 7;
_i._capHeight = 1.2;
_i._taperHeight = 0.2;
_i._segmentCount = 20;
_i._planeOffset = 1;
_i._planeLength = 2.5;
_i._xColor = new it(168, 56, 59);
_i._yColor = new it(96, 166, 50);
_i._zColor = new it(41, 81, 185);
_i._viewPlaneColor = it.white();
const ty = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CursorMarkup: Lh,
  HandleData: Io,
  HandleMarkup: _i,
  HandleMeshIds: qm,
  Measure: q_,
  Note: $_,
  Redline: T_
}, Symbol.toStringTag, { value: "Module" }));
class ba extends xe {
  /** @hidden */
  constructor(t) {
    super(t), this._activeRedlineItem = null, this._newRedlineItem = null, this._viewer = t;
  }
  // Interface method for derived operators to implement
  /** @hidden */
  createRedlineItem(t) {
    return null;
  }
  // Interface method for derived operators to implement
  /** @hidden */
  updateRedlineItem(t) {
  }
  // Interface method for derived operators to implement
  /** @hidden */
  finalizeRedlineItem(t) {
    return null;
  }
  // Default behavior for redline operators
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && ((t.getButton() === Kt.Left || this._primaryTouchId !== null) && this._redlineOperatorStart(), t.setHandled(!0));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this.isActive() && (this._redlineOperatorMove(), t.setHandled(!0));
  }
  /** @hidden */
  onMouseUp(t) {
    this.isActive() && ((t.getButton() === Kt.Left || this._primaryTouchId !== null) && this._redlineOperatorEnd(), t.setHandled(!0)), super.onMouseUp(t);
  }
  /** @hidden */
  onMousewheel(t) {
    t.setHandled(!0);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  setHandled() {
    return !0;
  }
  _isRedlineItem(t) {
    return Object.getPrototypeOf(t) instanceof Qr;
  }
  /** @hidden */
  onKeyUp(t) {
    const e = t.getKeyCode();
    if (e === Ut.Backspace || e === Ut.Delete) {
      const i = this._viewer.markupManager, s = i.getSelectedMarkup(), r = i.getActiveMarkupView();
      s !== null && this._isRedlineItem(s) && r !== null && (r.removeMarkup(s), i.selectMarkup(null));
    }
  }
  _removeRedlineTextIfInvalid(t) {
    const e = t;
    if (!e.isValid()) {
      const i = this._viewer.markupManager.getActiveMarkupView();
      i !== null && (i.removeMarkup(e), this._viewer.trigger("redlineDeleted", e)), e.remove();
    }
  }
  // Generic behavior to handle dragging of redline
  _redlineOperatorStart() {
    const t = this._viewer.markupManager, e = t.pickMarkupItem(this._ptFirst), i = t.getSelectedMarkup();
    e ? (this._activeRedlineItem = e, this._dragging && this._activeRedlineItem.onDragStart(this._ptFirst) && t.refreshMarkup()) : (i != null && i.onDeselect(), t.selectMarkup(null), this._markupIsTextArea(i) ? this._removeRedlineTextIfInvalid(i) : this._newRedlineItem = this.createRedlineItem(this._ptFirst));
  }
  _redlineOperatorMove() {
    this._activeRedlineItem ? this._dragging && this._activeRedlineItem.onDragMove(this._ptCurrent) && this._viewer.markupManager.refreshMarkup() : this.updateRedlineItem(this._ptCurrent);
  }
  _redlineOperatorEnd() {
    const t = this._viewer.markupManager;
    if (this._activeRedlineItem)
      this._ptFirst.equals(this._ptCurrent) ? t.selectMarkup(this._activeRedlineItem) : (this._viewer.trigger("redlineUpdated", this._activeRedlineItem), this._dragging && this._activeRedlineItem.onDragEnd(this._ptCurrent) && t.refreshMarkup());
    else if (this._newRedlineItem) {
      const e = this.finalizeRedlineItem(this._ptCurrent);
      e && this._attachNewMarkupToView(e);
    }
    this._activeRedlineItem = null, this._newRedlineItem = null;
  }
  async _attachNewMarkupToView(t) {
    const e = this._viewer, i = e.model, s = e.markupManager;
    let r = s.getActiveMarkupView(), o = !1;
    if (r === null) {
      const a = i.getAbsoluteRootNode(), l = await i.getVisibilityState(a), c = await i.getNodeColorMap(i.getAbsoluteRootNode(), vt.Faces), h = s.createMarkupView(void 0, !1, l, c, null);
      r = s.getMarkupView(h), o = !0;
    }
    r !== null && (r.addMarkupItem(t), s.selectMarkup(t)), o && r !== null && this._viewer.trigger("viewCreated", r), this._viewer.trigger("redlineCreated", t);
  }
  _markupIsTextArea(t) {
    return t ? t.getClassName() === Rs.className : !1;
  }
}
class $m extends ba {
  /** @hidden */
  constructor(t) {
    super(t), this._redlineCircle = null, this._previewHandle = null, this._centerSet = !1;
  }
  /** @hidden */
  createRedlineItem(t) {
    const e = this._viewer.view;
    this._redlineCircle = new dr(this._viewer), this._previewHandle = this._viewer.markupManager.registerMarkup(this._redlineCircle);
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return i !== null && (this._centerSet = !0, this._redlineCircle.setCenter(i), this._redlineCircle.setRadiusPoint(i)), this._redlineCircle;
  }
  /** @hidden */
  updateRedlineItem(t) {
    const e = this._viewer.view;
    if (this._redlineCircle) {
      const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
      i !== null && (this._centerSet || (this._centerSet = !0, this._redlineCircle.setCenter(i)), this._redlineCircle.setRadiusPoint(i), this._viewer.markupManager.refreshMarkup());
    }
  }
  /** @hidden */
  finalizeRedlineItem(t) {
    const e = this._viewer.markupManager;
    let i = null;
    return this._redlineCircle && (this._redlineCircle.isValid() && (i = this._redlineCircle), this._redlineCircle = null, this._previewHandle !== null && (e.unregisterMarkup(this._previewHandle), this._previewHandle = null), e.refreshMarkup()), i;
  }
}
class tp extends ba {
  /** @hidden */
  constructor(t) {
    super(t), this._redlinePolyline = null, this._previewHandle = null;
  }
  /** @hidden */
  createRedlineItem(t) {
    const e = this._viewer.view;
    this._redlinePolyline = new Kr(this._viewer), this._previewHandle = this._viewer.markupManager.registerMarkup(this._redlinePolyline);
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return i !== null && this._redlinePolyline.addPoint(i), this._redlinePolyline;
  }
  /** @hidden */
  updateRedlineItem(t) {
    if (this._redlinePolyline) {
      const e = this._viewer.view, i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
      i !== null && (this._redlinePolyline.addPoint(i), this._viewer.markupManager.refreshMarkup());
    }
  }
  /** @hidden */
  finalizeRedlineItem(t) {
    const e = this._viewer.markupManager;
    let i = null;
    return this._redlinePolyline && (this._redlinePolyline.isValid() && (i = this._redlinePolyline), this._redlinePolyline = null, this._previewHandle !== null && (e.unregisterMarkup(this._previewHandle), this._previewHandle = null), e.refreshMarkup()), i;
  }
}
class ep extends ba {
  /** @hidden */
  constructor(t) {
    super(t), this._redlineRectangle = null, this._previewHandle = null;
  }
  /** @hidden */
  createRedlineItem(t) {
    const e = this._viewer.view, i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return this._redlineRectangle = new mr(this._viewer), i !== null && (this._redlineRectangle.setPoint1(i), this._redlineRectangle.setPoint2(i)), this._previewHandle = this._viewer.markupManager.registerMarkup(this._redlineRectangle), this._redlineRectangle;
  }
  /** @hidden */
  updateRedlineItem(t) {
    if (this._redlineRectangle) {
      const e = this._viewer.view, i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
      i !== null && this._redlineRectangle.setPoint2(i), this._viewer.markupManager.refreshMarkup();
    }
  }
  /** @hidden */
  finalizeRedlineItem(t) {
    let e = null;
    if (this._redlineRectangle && this._previewHandle) {
      const i = this._viewer.markupManager;
      this._redlineRectangle.isValid() && (e = this._redlineRectangle), i.unregisterMarkup(this._previewHandle), this._previewHandle = null, this._redlineRectangle = null, i.refreshMarkup();
    }
    return e;
  }
}
class ip extends ba {
  /** @hidden */
  constructor(t) {
    super(t), this._redlineText = null;
  }
  /** @hidden */
  createRedlineItem(t) {
    return this._redlineText = new Rs(this._viewer), this._redlineText;
  }
  /** @hidden */
  finalizeRedlineItem(t) {
    if (this._redlineText === null)
      return null;
    const e = this._viewer.view, i = this._redlineText, s = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return s !== null && i.setPosition(s), this._redlineText = null, i;
  }
}
const ey = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RedlineCircleOperator: $m,
  RedlineOperator: ba,
  RedlinePolylineOperator: tp,
  RedlineRectangleOperator: ep,
  RedlineTextOperator: ip
}, Symbol.toStringTag, { value: "Module" }));
class np extends xe {
  /** @hidden */
  constructor(t) {
    super(t), this._forceEffectiveSceneVisibilityMask = Xt.None, this._rectangleMarkup = new Rh(t, !1), this._incrementalSelection = _a.create("SelectionManager", t), t.setCallbacks({
      _resetAssemblyTreeBegin: async () => (await this.clearSelection(), this.waitForIdle())
    });
  }
  /**
   * Gets the mask used for forcing effective scene visibility during selection.
   */
  getForceEffectiveSceneVisibilityMask() {
    return this._forceEffectiveSceneVisibilityMask;
  }
  /**
   * Sets the mask used for forcing effective scene visibility during selection.
   */
  setForceEffectiveSceneVisibilityMask(t) {
    this._forceEffectiveSceneVisibilityMask = t;
  }
  hasActiveSelection() {
    return !this._incrementalSelection.isIdle();
  }
  async waitForIdle() {
    return this._incrementalSelection.waitForIdle();
  }
  async clearSelection() {
    return this._incrementalSelection.clearSelection();
  }
  _allowSelection(t, e) {
    return !(t.x === e.x || t.y === e.y);
  }
  _createBeginConfig(t, e, i) {
    const s = new Al();
    return s.forceEffectiveSceneVisibilityMask = this._forceEffectiveSceneVisibilityMask, s.ignoreCuttingSections = !1, s.ignoreUnrequestedInstances = !0, i && (s.mustBeFullyContained = !0), {
      pickConfig: s,
      areaCssMin: t,
      areaCssMax: e
    };
  }
  async _performSelection(t) {
    const e = this._rectangleMarkup.min.copy(), i = this._rectangleMarkup.max.copy(), s = this._rectangleMarkup.initialPosition.x < this._rectangleMarkup.currentPosition.x;
    if (t && await this.clearSelection(), !this._allowSelection(e, i))
      return;
    const r = this._createBeginConfig(e, i, s);
    try {
      return await this._incrementalSelection.performSelection(r);
    } catch (o) {
      if (!(o instanceof as))
        throw o;
    }
  }
  ///////////////////////////////////////////////////////////////////////////////////
  /** @hidden */
  setHandled() {
    return !0;
  }
  /** @hidden */
  onKeyUp(t) {
    t.getKeyCode() === Ut.Escape && this.clearSelection();
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && (t.setHandled(!0), this._rectangleMarkup.isActive() && this._rectangleMarkup.deactivate(), this._rectangleMarkup.activate(t.getPosition()));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this.isActive() && this._rectangleMarkup.isActive() && (t.setHandled(!0), this._rectangleMarkup.updateCurrentPosition(t.getPosition()), this._viewer.markupManager.refreshMarkup());
  }
  /** @hidden */
  onMouseUp(t) {
    if (this.isActive() && this._rectangleMarkup.isActive()) {
      t.setHandled(!0), this._rectangleMarkup.updateCurrentPosition(t.getPosition());
      const e = !t.controlDown();
      this._performSelection(e);
    }
    this._rectangleMarkup.isActive() && this._rectangleMarkup.deactivate(), super.onMouseUp(t);
  }
}
class sp extends xe {
  /** @hidden */
  constructor(t) {
    super(t), this._axisTriad = t.view.getAxisTriad(), this._pickConfig = new be(Xt.Face), this._pickConfig.restrictToOverlays = !0;
  }
  /** @hidden */
  async onMouseUp(t) {
    if (this._axisTriad.getEnabled() && E.subtract(this._ptFirst, this._ptCurrent).squaredLength() < 25 && this._axisTriad.insideOverlay(t.getPosition())) {
      const e = await this._viewer.view.pickFromPoint(this._ptFirst, this._pickConfig);
      await this._axisTriad.onClickSelection(e);
    }
    super.onMouseUp(t);
  }
}
class rp {
  constructor(t, e, i, s, r) {
    this.section = t, this.node = e, this.planeIndex = i, this.plane = s, this.selectionPosition = r, this.origPlaneD = s.d;
  }
}
class op extends xe {
  constructor(t, e) {
    super(t), this._context = null, this._cuttingManager = e;
  }
  async onMouseDown(t) {
    super.onMouseDown(t), this._context === null && this.isActive() && this._cuttingManager.hasActiveCuttingSection() && (await this._startSelection(t), t.setHandled(this._context !== null));
  }
  async onMouseMove(t) {
    super.onMouseMove(t);
    const e = this._context;
    this.isActive() && e !== null && (t.setHandled(!0), await this._updatePlane(t.getPosition(), e, !1), this._viewer.trigger("cuttingPlaneDrag", e.section, e.planeIndex));
  }
  async _updatePlane(t, e, i) {
    const s = e.selectionPosition, r = e.plane.normal.copy().add(e.selectionPosition), o = this._viewer.view.unprojectPoint(t, 0), a = this._viewer.view.unprojectPoint(t, 0.5);
    if (o !== null && a !== null) {
      const l = ju(s, r, o, a);
      if (l !== null) {
        const c = d.subtract(l, e.selectionPosition), h = d.dot(c, e.plane.normal) < 0 ? c.length() : -c.length();
        e.plane.d = e.origPlaneD + h;
        const u = e.plane.normal.copy().scale(-h), p = new Q().setTranslationComponent(u.x, u.y, u.z);
        await e.section.updatePlane(
          e.planeIndex,
          e.plane,
          p,
          i,
          !1
        );
      }
      this._cuttingManager.delayCapping();
    }
  }
  async onMouseUp(t) {
    const e = this._context;
    this.isActive() && e !== null && (t.setHandled(!0), await this._updatePlane(t.getPosition(), e, !0), this._viewer.trigger("cuttingPlaneDragEnd", e.section, e.planeIndex)), this._context = null, super.onMouseUp(t);
  }
  setHandled() {
    return this.isActive() && this._context !== null;
  }
  /**
   * Perform the selection operation. If successful, the cutting plane context will be properly
   * setup, otherwise the cutting plane context will be null.
   */
  async _startSelection(t) {
    this._context = null;
    const e = t.getPosition(), i = Xt.Face | Xt.Line, s = new be(i);
    s.ignoreCappingGeometry = !0, s.forceEffectiveSceneVisibilityMask = Xt.Face;
    const o = (await this._viewer.view.compositePickFromPoint(e, s)).fetchMostRelevant(i);
    if (o === null)
      return;
    const a = o.getNodeId(), l = this._cuttingManager.getCuttingSectionFromNodeId(a);
    if (l !== null) {
      const c = l.getPlaneIndexByNodeId(a);
      this._context = new rp(
        l,
        a,
        c,
        l.getPlane(c),
        o.getPosition()
      ), this._cuttingManager.delayCapping(), this._viewer.trigger("cuttingPlaneDragStart", l, c);
    }
  }
}
class ap extends xe {
  /** @hidden */
  constructor(t) {
    super(t), this._draggingAvatar = !1, this._restrictToAvatar = !0, this._floorLocked = !1, this._manager = t.floorplanManager;
  }
  /** @hidden */
  async onMouseDown(t) {
    if (super.onMouseDown(t), !this._manager.isActive())
      return;
    const e = t.getPosition();
    let i;
    if (!this._restrictToAvatar)
      i = this._manager.insideOverlay(e);
    else {
      const s = new be();
      s.restrictToOverlays = !0, i = (await this._viewer.view.pickFromPoint(e, s)).getNodeId() === this._manager.getAvatarNodeId();
    }
    i && (this._draggingAvatar = !0, this._floorLocked = this._manager.getFloorLock(), await this._manager.setFloorLock(!0), this._manager.snapAvatarToPoint(e), t.setHandled(!0));
  }
  /** @hidden */
  async onMouseUp(t) {
    super.onMouseUp(t), this._draggingAvatar && await this._manager.setFloorLock(this._floorLocked), this._draggingAvatar = !1;
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), !!this._manager.isActive() && this._draggingAvatar) {
      t.setHandled(!0);
      const e = t.getPosition();
      this._manager.insideOverlay(e) && this._manager.snapAvatarToPoint(e);
    }
  }
  /**
   * Set whether or not dragging is restricted to the avatar. If true the operator will only function if
   * the selection begins on the avatar
   */
  restrictToAvatar(t) {
    this._restrictToAvatar = t;
  }
}
class lp extends xe {
  constructor(t) {
    super(t), this._draggingHandle = !1, this._newRotationMatrix = new Q(), this._translation = d.zero(), this._newTranslation = d.zero(), this._nodeIdGroupMap = /* @__PURE__ */ new Map(), this._groupIdCount = 0, this._activeChildrenGroupIds = /* @__PURE__ */ new Map(), this._initialLocalNodeMatrices = [], this._newLocalNodeMatrices = [], this._trackedPoints = [], this._trackedPointsPositions = [], this._trackedPointCount = 0, this._previousContextClick = !1, this._overlayIndex = null, this._activeHandleNodeId = null, this._handleEventType = ws.Translate, this._highlightedHandleId = null, this._handleSize = 1, this._explodeActive = !1, this._measureActive = !1, this._settingMatrixInProgress = !1, this._handleMarkup = new _i(t), this._pickConfig = new be(Xt.Face), this._pickConfig.restrictToOverlays = !0, t.setCallbacks({
      explode: (e) => {
        this._explodeActive = e > 0, this._explodeActive && this.removeHandles();
      },
      measurementBegin: () => {
        this._measureActive = !0, this.removeHandles();
      },
      measurementCreated: () => {
        this._measureActive = !1;
      },
      measurementDeleted: () => {
        this._measureActive = !1;
      }
    });
  }
  /**
   * Sets the mesh data for axis handles.
   * @param meshData
   */
  setAxisMeshData(t) {
    return this._handleMarkup.setAxisMeshData(t);
  }
  /**
   * Sets the mesh data for plane handles.
   * @param meshData
   */
  setPlaneMeshData(t) {
    return this._handleMarkup.setPlaneMeshData(t);
  }
  /**
   * Sets the mesh data for view plane handles.
   * @param meshData
   */
  setViewPlaneMeshData(t) {
    return this._handleMarkup.setViewPlaneMeshData(t);
  }
  /**
   * Sets the mesh data for rotation handles.
   * @param meshData
   */
  setRotateMeshData(t) {
    return this._handleMarkup.setRotateMeshData(t);
  }
  /**
   * Add a point to the tracked points list. When the handle moves, these points will update in world space.
   * @param point
   * @returns point index
   */
  addTrackedPoint(t) {
    const e = this._trackedPointCount;
    return this._trackedPoints[e] = t.copy(), this._trackedPointsPositions[e] = t.copy(), ++this._trackedPointCount, e;
  }
  /**
   * Gets the tracked point list.
   */
  getTrackedPoints() {
    return this._trackedPointsPositions;
  }
  /**
   * Clear the list of tracked points.
   */
  clearTrackedPoints() {
    this._trackedPoints.length = 0, this._trackedPointsPositions.length = 0, this._trackedPointCount = 0;
  }
  /**
   * Returns a boolean value indicating if handles are available to be added to the scene
   * If there is an active explode, active measure, or the model is a 2d drawing.
   * this will be false.
   */
  isEnabled() {
    return !this._explodeActive && !this._measureActive && !this._viewer.sheetManager.isDrawingSheetActive();
  }
  _guardEnabled() {
    if (!this.isEnabled()) {
      const t = (() => this._explodeActive ? "Handles are not enabled when the model is exploded" : this._measureActive ? "Handles are not enabled while a measurement is in progress." : this._viewer.sheetManager.isDrawingSheetActive() ? "Handles are not enabled for 2d drawings." : "Handles are not enabled.")();
      throw new Mt(t);
    }
  }
  /**
   * Takes a scale value to change the handle size with 1 representing the default size
   * @param size
   */
  setHandleSize(t) {
    this._handleSize = t;
  }
  /**
   * Adds all handles into the scene, oriented along the primary axes
   * @param nodeIds corresponding to the parts that will move with the handles
   * @param position world space coordinates the the handle position
   */
  async addHandles(t, e = null, i = null) {
    if (this._previousContextClick = !1, this._guardEnabled(), !e) {
      const r = await this._viewer.model.getNodesBounding(t);
      return this.addHandles(t, r.center());
    }
    const s = this._findGroupId(t);
    return i === null && (i = s !== null ? s : this.generateGroupId()), this._nodeIdGroupMap.set(i, t), s !== null && await this._handleMarkup.removeHandles(i), this._handleMarkup.addHandles(e, this._handleSize, i);
  }
  /**
   * Returns the group id associated to the given group of node ids, returns null if does not exist
   * @param nodeIds
   */
  _findGroupId(t) {
    let e = null;
    return this._nodeIdGroupMap.forEach((i, s) => {
      i.length === t.length && i.every((r) => t.indexOf(r) !== -1) && (e = s);
    }), e;
  }
  /**
   * This will generate a unique id to associate a group of handles with a group of NodeIds.
   */
  generateGroupId() {
    return this._groupIdCount++;
  }
  _massageGroupId(t) {
    return t ?? _i.defaultGroupId;
  }
  /**
   * Adds a handle that moves along an axis.
   * @param position center of the handle.
   * @param axis axis to move along
   * @param color color of the handle geometry
   * @param positionNormal optional vector to control the orientation of the handle geometry.
   * @param groupId optional parameter to associate this handle with a group of NodeIds
   */
  async addAxisTranslationHandle(t, e, i, s = null, r = null) {
    return this._previousContextClick = !1, this._guardEnabled(), this._handleMarkup.addAxisTranslationHandle(
      t,
      e,
      i,
      s,
      this._massageGroupId(r)
    );
  }
  /**
   * Adds a handle that rotates around an axis
   * @param position center of the handle.
   * @param axis axis to rotate around
   * @param color color of the handle geometry
   * @param positionNormal optional vector to control the orientation of the handle geometry.
   * @param groupId optional parameter to associate this handle with a group of NodeIds
   */
  async addAxisRotationHandle(t, e, i, s = null, r = null) {
    return this._previousContextClick = !1, this._guardEnabled(), this._handleMarkup.addRotateHandle(
      t,
      e,
      i,
      s,
      this._massageGroupId(r)
    );
  }
  /**
   * Adds a handle that restricts movement to a plane.
   * @param position center of the handle.
   * @param normal normal of the plane
   * @param faceColor face color of the handle geometry
   * @param lineColor outline color of the handle geometry
   * @param positionNormal optional vector to control the orientation of the handle geometry.
   * @param groupId optional parameter to associate this handle with a group of NodeIds
   */
  async addPlaneTranslationHandle(t, e, i, s, r = null, o = null) {
    return this._previousContextClick = !1, this._guardEnabled(), this._handleMarkup.addPlaneTranslationHandle(
      t,
      e,
      i,
      s,
      r,
      this._massageGroupId(o)
    );
  }
  /**
   * Adds a handle that restricts movement to the viewplane.
   * @param position center of the handle
   * @param color geometry color
   * @param groupId optional parameter to associate this handle with a group of NodeIds
   */
  async addViewPlaneTranslationHandle(t, e, i = null) {
    return this._previousContextClick = !1, this._guardEnabled(), this._handleMarkup.addViewPlaneHandle(t, e, this._massageGroupId(i));
  }
  /**
   * Sets the NodeIds that any handles in the scene will move.
   * @param nodeIds
   * @param groupId optional parameter that associates a group of NodeIds with a group of handles.
   */
  setNodeIds(t, e = null) {
    this._nodeIdGroupMap.set(this._massageGroupId(e), t);
  }
  /**
   * Gets the NodeIds that the handles in the scene will move.
   * @param groupId optional paramater that specifies if the NodeIds to retrieve are part of a group.
   */
  getNodeIds(t = null) {
    const e = this._nodeIdGroupMap.get(this._massageGroupId(t));
    return e === void 0 ? [] : e.slice();
  }
  /**
   * Shows any handles that have been added to the scene.
   */
  showHandles() {
    this._handleMarkup.showOverlay();
  }
  /**
   * Updates the current handle position.
   * @param translation additional translation
   * @param rotation additional rotation
   * @param finalizePosition keep translation and rotation. If true, added translation and rotation
   * will not reset the next time the position is updated.
   */
  updatePosition(t, e, i, s = null) {
    return this._handleMarkup.updatePosition(
      t,
      e,
      i,
      this._massageGroupId(s),
      this._activeChildrenGroupIds
    );
  }
  /**
   * @returns the current handle position or null if not currently active.
   */
  getPosition() {
    const t = this._handleMarkup.getHandleNodeIds();
    if (t.length > 0) {
      const e = this._handleMarkup.getPosition(t[0]);
      if (e !== null)
        return e.copy();
    }
    return null;
  }
  /**
   * Removes all handles from the scene.
   */
  removeHandles() {
    return this._newRotationMatrix = new Q(), this._translation = d.zero(), this._highlightedHandleId = null, this._nodeIdGroupMap.clear(), this._groupIdCount = 0, this._handleMarkup.removeHandles();
  }
  /**
   * @returns the total translation applied to the handles.
   */
  getTranslation() {
    return this._translation;
  }
  _initLocalNodeMatrices(t) {
    const e = this._viewer.model;
    this._initialLocalNodeMatrices = [];
    for (const i of t)
      this._initialLocalNodeMatrices.push(e.getNodeMatrix(i));
  }
  _getHandleEventType(t) {
    return this._handleMarkup.getHandleType(t) === Jn.Rotate ? ws.Rotate : ws.Translate;
  }
  async _rotate(t, e, i, s) {
    if (!this._draggingHandle || this._settingMatrixInProgress)
      return;
    const r = this.getNodeIds(s);
    await this._genericTransform(
      t,
      e,
      d.zero(),
      i,
      r,
      s
    ), this._viewer.trigger(
      "handleEvent",
      ws.Rotate,
      r,
      this._initialLocalNodeMatrices,
      this._newLocalNodeMatrices
    );
  }
  async _translate(t, e, i) {
    if (!this._draggingHandle || this._settingMatrixInProgress)
      return;
    const s = this.getNodeIds(i);
    await this._genericTransform(d.zero(), 0, t, e, s, i), this._viewer.trigger(
      "handleEvent",
      ws.Translate,
      s,
      this._initialLocalNodeMatrices,
      this._newLocalNodeMatrices
    );
  }
  async _genericTransform(t, e, i, s, r, o) {
    this._settingMatrixInProgress = !0;
    const a = this._viewer.model;
    let l = new Q();
    this._newTranslation = i, t.squaredLength() > 0 && (l = this._getRotationMatrix(t, d.zero(), e), this._newRotationMatrix = l.copy());
    const c = [];
    c.push(this.updatePosition(this._newTranslation, this._newRotationMatrix, !1, o)), this._newLocalNodeMatrices = [];
    for (let u = 0; u < r.length; u++) {
      const p = this._newTranslation.copy(), m = r[u];
      let g = this._initialLocalNodeMatrices[u].copy();
      const _ = t.copy(), y = s.copy();
      let b;
      const w = a.getNodeParent(m);
      if (w !== null) {
        b = a.getNodeNetMatrix(w);
        const v = Q.inverse(b);
        v !== null && (v.transform(y, y), v.setTranslationComponent(0, 0, 0), v.transform(_, _), v.transform(p, p));
      } else
        b = null;
      t.squaredLength() > 0 && (l = this._getRotationMatrix(
        _,
        y,
        b && b.upperLeft3x3Determinant() < 0 ? -e : e
      ), g = Q.multiply(g, l)), g.setTranslationComponent(
        g.m[12] + p.x,
        g.m[13] + p.y,
        g.m[14] + p.z
      ), c.push(a.setNodeMatrix(m, g)), this._newLocalNodeMatrices.push(g);
    }
    const h = this._newRotationMatrix.copy();
    h.setTranslationComponent(i.x, i.y, i.z);
    for (let u = 0; u < this._trackedPoints.length; ++u) {
      const p = this._trackedPoints[u].copy(), m = d.subtract(p, s);
      h.transform(m, m);
      const g = d.add(m, s);
      this._trackedPointsPositions[u] = g;
    }
    await zt(c), this._settingMatrixInProgress = !1;
  }
  /** @hidden */
  async _testRotate(t, e, i = null) {
    i = this._massageGroupId(i);
    const s = this._getActiveNodeIdByGroupId(i);
    if (s !== null) {
      const r = this._handleMarkup.getPosition(s);
      if (r === null)
        return;
      this._startDragging(s, ws.Rotate), await this._rotate(t, e, r, i), await this._stopDragging();
    }
  }
  /** @hidden */
  async _testTranslate(t, e = null) {
    e = this._massageGroupId(e);
    const i = this._getActiveNodeIdByGroupId(e);
    i !== null && (this._startDragging(i, ws.Translate), await this._translate(t, d.zero(), e), await this._stopDragging());
  }
  _getActiveNodeIdByGroupId(t) {
    const e = this._handleMarkup.getHandleNodeIds();
    for (let i = 0; i < e.length; ++i) {
      const s = e[i];
      if (this._handleMarkup.getHandleGroupId(s) === t)
        return s;
    }
    return null;
  }
  _startDragging(t, e) {
    this._activeHandleNodeId = t, this._handleEventType = e;
    const i = this._handleMarkup.getHandleGroupId(t), s = this.getNodeIds(i), r = /* @__PURE__ */ new Map();
    this._nodeIdGroupMap.forEach((o, a) => {
      a !== i && o.forEach((l) => {
        let c = this._viewer.model.getNodeParent(l);
        for (; c !== null; ) {
          if (s.indexOf(c) !== -1) {
            r.set(a, l);
            break;
          }
          c = this._viewer.model.getNodeParent(c);
        }
      });
    }), this._activeChildrenGroupIds = r, s.length > 0 && (this._initLocalNodeMatrices(s), this._viewer.trigger(
      "handleEventStart",
      this._handleEventType,
      s,
      this._initialLocalNodeMatrices
    ), this._draggingHandle = !0);
  }
  async _stopDragging() {
    if (this._draggingHandle = !1, this._activeHandleNodeId !== null) {
      const t = this._handleMarkup.getHandleGroupId(this._activeHandleNodeId);
      await this.updatePosition(this._newTranslation, this._newRotationMatrix, !0, t);
      const e = this.getNodeIds(t);
      this._activeHandleNodeId = null, this._activeChildrenGroupIds.clear(), this._viewer.trigger(
        "handleEventEnd",
        this._handleEventType,
        e,
        this._initialLocalNodeMatrices,
        this._newLocalNodeMatrices
      ), this._newRotationMatrix = new Q(), this._handleMarkup.resetTranslation(), this._translation.add(this._newTranslation), this._newTranslation = d.zero(), this._trackedPoints = this._trackedPointsPositions.slice();
    }
  }
  /** @hidden */
  async onMouseDown(t) {
    super.onMouseDown(t), this._overlayIndex = null;
    const e = await this._viewer.view.pickFromPoint(t.getPosition(), this._pickConfig);
    if (e.isNodeEntitySelection()) {
      const i = e.getNodeId(), s = this._viewer.model.getNodeName(i);
      if (s !== null && s.slice(0, 7) === "handle-") {
        t.setHandled(!0);
        const r = this._getHandleEventType(i);
        this._startDragging(i, r);
      }
    }
  }
  _onHandleDrag() {
    if (this._activeHandleNodeId === null)
      return;
    const e = this._viewer.view.getCamera();
    let i = 0, s = d.zero(), r = d.zero();
    const o = this._handleMarkup.getHandleType(this._activeHandleNodeId), a = this._handleMarkup.getVector(this._activeHandleNodeId), l = this._handleMarkup.getPosition(this._activeHandleNodeId);
    if (o === null || l === null)
      return;
    const c = this._handleMarkup.getHandleGroupId(this._activeHandleNodeId);
    switch (o) {
      case Jn.Axis:
        a !== null && (r = this._getTranslationComponent(
          l,
          a,
          0,
          c
        ), this._translate(r, l, c));
        break;
      case Jn.Plane:
        a !== null && (r = this._getTranslationComponent(
          l,
          a,
          1,
          c
        ), this._translate(r, l, c));
        break;
      case Jn.ViewPlane:
        {
          const h = e.getTarget(), u = e.getPosition(), p = d.subtract(u, h).normalize();
          r = this._getTranslationComponent(
            l,
            p,
            2,
            c
          ), this._translate(r, l, c);
        }
        break;
      case Jn.Rotate:
        a !== null && (s = a, this._handleMarkup.getGroupIdRotationMatrix(c).copy().setTranslationComponent(0, 0, 0).transform(s, s), i = this._getRotationAngle(l, s), this._rotate(s, i, l, c));
        break;
      default:
        $n();
    }
  }
  /** @hidden */
  async onMouseMove(t) {
    if (super.onMouseMove(t), this._draggingHandle && this._activeHandleNodeId !== null)
      this._onHandleDrag();
    else {
      const e = await this._viewer.view.pickFromPoint(
        t.getPosition(),
        this._pickConfig
      );
      await this._highlightHandle(e);
    }
  }
  /** @hidden */
  onMouseUp(t) {
    !this._draggingHandle && this._dragCount < 3 && t.getButton() !== Kt.Right && !this._previousContextClick && !this._viewer.getContextMenuStatus() && (this._overlayIndex === 0 || this._overlayIndex === null) && this.removeHandles(), this._previousContextClick = t.getButton() === Kt.Right || this._viewer.getContextMenuStatus(), this._draggingHandle && this._stopDragging(), super.onMouseUp(t);
  }
  /** @hidden */
  setHandled() {
    return this._draggingHandle;
  }
  _getClosestPoint(t, e, i) {
    const s = t.copy(), r = t.copy().add(e), o = this._viewer.view.unprojectPoint(i, 0), a = this._viewer.view.unprojectPoint(i, 0.5);
    return o !== null && a !== null ? ju(s, r, o, a) : null;
  }
  _getTranslationComponent(t, e, i, s) {
    i !== 2 && this._handleMarkup.getGroupIdRotationMatrix(s).copy().setTranslationComponent(0, 0, 0).transform(e, e);
    let r = null, o = null;
    return i === 1 || i === 2 ? (r = this._getPlaneIntersectionPoint(t, e, this._ptFirst), r !== null && (o = this._getPlaneIntersectionPoint(r, e, this._ptCurrent))) : i === 0 && (r = this._getClosestPoint(t, e, this._ptFirst), r !== null && (o = this._getClosestPoint(r, e, this._ptCurrent))), o !== null && r !== null ? d.subtract(o, r) : d.zero();
  }
  async _clearHighlightedHandle() {
    this._highlightedHandleId !== null && (await this._viewer.model.unsetNodesFaceColor([this._highlightedHandleId]), this._highlightedHandleId = null);
  }
  async _highlightHandle(t) {
    if (t.isNodeEntitySelection() && t.overlayIndex() === Gt.Handles) {
      const e = this._viewer.model, i = e.getNodeName(t.getNodeId());
      if (i !== null && i.slice(0, 7) === "handle-") {
        const s = t.getNodeId();
        if (this._highlightedHandleId === s)
          return;
        await this._clearHighlightedHandle(), this._highlightedHandleId = s, e.setNodesFaceColor([this._highlightedHandleId], it.green());
        return;
      }
    }
    return this._clearHighlightedHandle();
  }
  _getPlaneIntersectionPoint(t, e, i) {
    const s = this._viewer.view.unprojectPoint(i, 0), r = this._viewer.view.unprojectPoint(i, 0.5);
    if (s === null || r === null)
      return null;
    const o = new Gn(s, r.copy().subtract(s)), a = je.createFromPointAndNormal(t, e), l = d.zero();
    return a.intersectsRay(o, l) ? l : null;
  }
  _getRotationAngle(t, e) {
    console.assert(t !== null);
    const i = this._getPlaneIntersectionPoint(
      t,
      e,
      this._ptFirst
    ), s = this._getPlaneIntersectionPoint(
      t,
      e,
      this._ptCurrent
    );
    if (i === null || s === null)
      return 0;
    const r = d.subtract(i, t).normalize(), o = d.subtract(s, t).normalize(), a = d.dot(r, o);
    let l = Math.acos(a) * 180 / Math.PI;
    return d.dot(d.cross(r, o), e) < 0 && (l = -l), l;
  }
  _getRotationMatrix(t, e, i) {
    const s = new Q().setTranslationComponent(
      -e.x,
      -e.y,
      -e.z
    ), r = Q.createFromOffAxisRotation(t, i), o = new Q().setTranslationComponent(
      e.x,
      e.y,
      e.z
    );
    return Q.multiply(
      Q.multiply(s, r),
      o
    );
  }
}
class cp extends xe {
  /** @hidden */
  constructor(t) {
    super(t), this._navCube = t.view.getNavCube(), this._pickConfig = new be(Xt.Face), this._pickConfig.restrictToOverlays = !0;
  }
  /** @hidden */
  async onMouseMove(t) {
    super.onMouseMove(t);
    const e = t.getPosition(), i = this._dragging && this._dragCount > 1;
    if (this._navCube.getEnabled() && !i && this._navCube.insideOverlay(e)) {
      const s = await this._viewer.view.pickFromPoint(e, this._pickConfig);
      this._navCube.onMoveSelection(s);
    }
  }
  /** @hidden */
  async onMouseUp(t) {
    if (this._navCube.getEnabled() && E.subtract(this._ptFirst, this._ptCurrent).squaredLength() < 25) {
      const e = await this._viewer.view.pickFromPoint(this._ptFirst, this._pickConfig);
      await this._navCube.onClickSelection(e);
    }
    super.onMouseUp(t);
  }
}
class hp extends xe {
  /** @hidden */
  constructor(t, e) {
    super(t), this._insertNoteButton = Kt.Left, this._callbackFlag = !1, this._noteTextManager = e;
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && (this._callbackFlag || (this._viewer.setCallbacks({
      explode: async (e) => {
        await this._noteTextManager.explode(e);
      }
    }), this._callbackFlag = !0), this._dragging = !1);
  }
  /** @hidden */
  onMouseUp(t) {
    if (this.isActive()) {
      const e = new be(Xt.Face);
      (this._ptFirst.equals(this._ptCurrent) && t.getButton() === this._insertNoteButton || this._primaryTouchId !== null) && this._viewer.view.pickFromPoint(t.getPosition(), e).then((i) => {
        if (!this._noteTextManager.selectPin(i) && !this._noteTextManager.getExplodeActive() && !this._noteTextManager.getIsolateActive() && i.overlayIndex() === 0) {
          if (i.isFaceSelection())
            return new zr(
              this._viewer,
              this._noteTextManager,
              i.getPosition(),
              i.getFaceEntity().getNormal(),
              i.getNodeId()
            );
          t.setHandled(!0);
        }
        return null;
      });
    }
    super.onMouseUp(t);
  }
  /**
   * @returns a NoteTextElement that can be used to configure the NoteText HTML container.
   */
  getNoteTextElement() {
    return this._noteTextManager.getNoteTextElement();
  }
  /**
   * @param noteTextElement
   */
  setNoteTextElement(t) {
    this._noteTextManager.setNoteTextElement(t);
  }
  /**
   * Returns true if the nodeId is the id of a note pin instance.
   * @param nodeId
   */
  checkPinInstance(t) {
    return this._noteTextManager.checkPinInstance(t) !== null;
  }
}
class up extends xe {
  /** @hidden */
  constructor(t) {
    super(t), this._selectionButton = Kt.Left, this._ignoreTransparency = !1, this._forceEffectiveSceneVisibilityMask = Xt.None, this._incrementalSelection = _a.create("SelectionManager", t), t.setCallbacks({
      _resetAssemblyTreeBegin: async () => (await this.clearSelection(), this.waitForIdle()),
      selectionArray: (e) => {
        e.length === 0 && this._incrementalSelection.stopSelection();
      }
    });
  }
  /**
   * Gets the mask used for forcing effective scene visibility during selection.
   */
  getForceEffectiveSceneVisibilityMask() {
    return this._forceEffectiveSceneVisibilityMask;
  }
  /**
   * Sets the mask used for forcing effective scene visibility during selection.
   */
  setForceEffectiveSceneVisibilityMask(t) {
    this._forceEffectiveSceneVisibilityMask = t;
  }
  setIgnoreTransparency(t) {
    this._ignoreTransparency = t;
  }
  getIgnoreTransparency() {
    return this._ignoreTransparency;
  }
  hasActiveSelection() {
    return !this._incrementalSelection.isIdle();
  }
  async waitForIdle() {
    return this._incrementalSelection.waitForIdle();
  }
  async clearSelection() {
    return this._incrementalSelection.clearSelection();
  }
  _createBeginConfig(t) {
    const e = new Al();
    return e.forceEffectiveSceneVisibilityMask = this._forceEffectiveSceneVisibilityMask, e.ignoreUnrequestedInstances = !0, {
      pickConfig: e,
      rayCssOrigin: t,
      rayCssBoxRadius: 10
    };
  }
  async _selectionPredicate(t) {
    const e = this._viewer.model, i = t.getNodeId();
    if (i === null)
      return !1;
    const [s] = await e.getNodesHaveTransparency([i]);
    return !s;
  }
  async _performSelection(t) {
    const e = this._createBeginConfig(t), i = this._ignoreTransparency ? (s) => this._selectionPredicate(s) : null;
    return this._incrementalSelection.performSelection(e, i);
  }
  ///////////////////////////////////////////////////////////////////////////////////
  /** @hidden */
  setHandled() {
    return !0;
  }
  /** @hidden */
  onKeyUp(t) {
    t.getKeyCode() === Ut.Escape && this.clearSelection();
  }
  /** @hidden */
  onMouseUp(t) {
    this.isActive() && (async () => (t.getButton() === this._selectionButton || this._primaryTouchId !== null) && E.subtract(this._ptFirst, this._ptCurrent).squaredLength() < 25 && (t.controlDown() || await this.clearSelection(), await this._performSelection(t.getPosition())))(), super.onMouseUp(t);
  }
}
class dp extends xe {
  /** @hidden */
  constructor(t, e) {
    super(t), this._selectionButton = Kt.Left, this._pickConfig = new be(Xt.Face | Xt.Line), this._forceEffectiveSceneVisibilityMask = null, this._doubleClickFitWorld = !0, this._noteTextManager = e;
  }
  /** Sets the [[PickConfig]] that will be passed to [[View.pickFromPoint]]. */
  setPickConfig(t) {
    this._pickConfig = t.copy();
  }
  /** Returns the [[PickConfig]] that will be passed to [[View.pickFromPoint]]. */
  getPickConfig() {
    return this._pickConfig.copy();
  }
  /**
   * Gets the button used for selection.
   * @returns Button
   */
  getSelectionButton() {
    return this._selectionButton;
  }
  /**
   * Sets the button used for selection
   * @param button
   */
  setSelectionButton(t) {
    this._selectionButton = t;
  }
  /** @hidden */
  onKeyUp(t) {
    t.getKeyCode() === Ut.Escape && this._viewer.selectionManager.clear();
  }
  /** @hidden */
  onMouseUp(t) {
    if (this.isActive() && E.subtract(this._ptFirst, this._ptCurrent).length() < 5 && (t.getButton() === this._selectionButton || this._primaryTouchId !== null)) {
      const i = this._viewer.view;
      let s = this._pickConfig;
      this._forceEffectiveSceneVisibilityMask !== null && (s = s.copy(), s.forceEffectiveSceneVisibilityMask = this._forceEffectiveSceneVisibilityMask), i.pickFromPoint(this._ptCurrent, s).then((r) => {
        const a = this._viewer.cuttingManager.getCuttingSectionFromNodeId(r.getNodeId()) !== null, l = this._noteTextManager.selectPin(r), c = this._viewer.markupManager.pickMarkupItem(this._ptCurrent);
        c instanceof Rs && this._viewer.markupManager.selectMarkup(c), !l && !a && c === null && (r.isNodeSelection() ? this._processSelectionClick(t, r) : this._isDoubleClick || this._viewer.selectionManager.clear());
      });
    }
    super.onMouseUp(t);
  }
  /** @hidden */
  async onDoubleClick() {
    if (this._doubleClickFitWorld)
      return this._viewer.view.fitWorld();
  }
  /**
   * When enabled, a double click will fit the view to the model bounding box.
   * @param doubleClickFitWorld
   */
  setDoubleClickFitWorldEnabled(t) {
    this._doubleClickFitWorld = t;
  }
  // helper function to get the parent selection item if the part is already selected
  _getSelectionOrParentIfSelected(t) {
    const e = this._viewer.selectionManager;
    if (!e.getSelectParentIfSelected())
      return t;
    const i = this._viewer.model, s = t.getNodeId();
    if (!i.isNodeLoaded(s) || i.getNodeType(s) === At.PmiBody)
      return t;
    const o = e.containsParent(t);
    if (o !== null) {
      const a = de.create(i.getNodeParent(o.getNodeId()));
      return a.isNodeSelection() ? a : t;
    } else if (e.contains(t)) {
      const a = de.create(i.getNodeParent(s));
      return a.isNodeSelection() ? a : t;
    } else
      return t;
  }
  _processSelectionClick(t, e) {
    const i = e.overlayIndex();
    if (i !== 0 && i !== null)
      return;
    const s = this._viewer.selectionManager;
    if (t.controlDown() || t.commandDown())
      s.toggle(e);
    else {
      const r = this._getSelectionOrParentIfSelected(e);
      s.set(r);
    }
  }
}
const iy = `/**
 * @license 3DconnexionJS
 *
 * Copyright (c) 2013-2020 3Dconnexion. All rights reserved.
 * License:
 *   This file is licensed under the terms of the "3Dconnexion
 *   Software Development Kit" license agreement:
 *   http://www.3dconnexion.com/service/software-developer/licence-agreement.html
 *   All rights not expressly granted by 3Dconnexion are reserved.
 *
 * $Revision: 17564 $
 */
var when, CryptoJS, AUTOBAHNJS_VERSION, global;
var _3Dconnexion = function (n) {
  'use strict';
  this.version = '0.6.1';
  this.client = n;
  this.session = null;
  this.defport = 8181;
  this.connected = !1;
  this.connexion = null;
  this._3dcontroller = null;
  this.viewport = null;
  this.host = '127.51.68.120';
  this.nlRpcUri = null;
  this.nlResourceUri = null;
  this._EVENT_TYPEID_RPC = 0;
  this.V3DK_FIT = 31;
  this.V3DK_MENU = 30;
  this.fnUpdate = {
    motion: this.onMotion.bind(this),
    'events.keyPress': this.onKeyPress.bind(this),
    'events.keyRelease': this.onKeyRelease.bind(this),
  };
  this.clientFnRead = {
    'view.affine': n.getViewMatrix,
    'view.constructionPlane': n.getConstructionPlane,
    'view.extents': n.getViewExtents,
    'view.fov': n.getFov,
    'view.frustum': n.getViewFrustum,
    'view.perspective': n.getPerspective,
    'view.target': n.getViewTarget,
    'view.rotatable': n.getViewRotatable,
    'model.extents': n.getModelExtents,
    'pivot.position': n.getPivotPosition,
    'hit.lookat': n.getLookAt,
    'selection.affine': n.getSelectionAffine,
    'selection.empty': n.getSelectionEmpty,
    'selection.extents': n.getSelectionExtents,
    'pointer.position': n.getPointerPosition,
    coordinateSystem: n.getCoordinateSystem,
    'views.front': n.getFrontView,
    'frame.timingSource': n.getFrameTimingSource,
    'frame.time': n.getFrameTime,
  };
  this.clientFnUpdate = {
    motion: n.setMoving,
    transaction: n.setTransaction,
    'view.affine': n.setViewMatrix,
    'view.extents': n.setViewExtents,
    'view.fov': n.setFov,
    'view.target': n.setTarget,
    'commands.activeCommand': n.setActiveCommand,
    'pivot.position': n.setPivotPosition,
    'pivot.visible': n.setPivotVisible,
    'hit.lookfrom': n.setLookFrom,
    'hit.direction': n.setLookDirection,
    'hit.aperture': n.setLookAperture,
    'hit.selectionOnly': n.setSelectionOnly,
    'selection.affine': n.setSelectionAffine,
    'events.keyPress': n.setKeyPress,
    'events.keyRelease': n.setKeyRelease,
    'settings.changed': n.setSettingsChanged,
  };
  this.debug = !1;
  window.hasOwnProperty('_3DCONNEXION_DEBUG') && (this.debug = window._3DCONNEXION_DEBUG);
  this.blur = this.blur.bind(this);
  this.focus = this.focus.bind(this);
};
typeof module == 'object' && (module.exports = _3Dconnexion);
_3Dconnexion.prototype = { constructor: _3Dconnexion };
Object.freeze((_3Dconnexion.nlOptions = { none: 0, rowMajorOrder: 2 }));
_3Dconnexion.prototype.connect = function () {
  'use strict';
  var n = this,
    e = this.client,
    u = 1,
    t = new XMLHttpRequest(),
    f,
    r,
    i;
  if (!e.onConnect) throw 'onConnect handler required!';
  i = 'https://' + n.host + ':' + n.defport + '/3dconnexion/nlproxy';
  t.onreadystatechange = function () {
    if (t.readyState === 4 && t.status === 200) {
      n.debug && console.log(t.responseText);
      n.nlRpcUri = 'wss://' + n.host + '/3dconnexion#';
      n.nlResourceUri = 'wss://' + n.host + '/3dconnexion';
      try {
        f = JSON.parse(t.responseText).port;
        r = 'wss://' + n.host + ':' + f;
        n.debug && console.log('Connecting to ' + r + ' ...');
        window.hasOwnProperty('AUTOBAHN_DEBUG') &&
          window.AUTOBAHN_DEBUG &&
          window.ab.debug(!0, !0, !0);
        window.ab.connect(
          r,
          function (t) {
            n.session = t;
            n.connected = !0;
            n.debug && console.log('Connected!');
            t.prefix('3dx_rpc', n.nlRpcUri);
            t.prefix('3dconnexion', n.nlResourceUri);
            t.prefix('self', window.location.href);
            n.client.onConnect();
          },
          function (t, i) {
            if (n.client.onDisconnect !== undefined) n.client.onDisconnect(i);
            n.delete3dmouse();
            n.connected = !1;
            n.session = null;
            n.debug && console.log('Socket closed!', i);
          },
          { maxRetries: 3, retryDelay: 500 }
        );
      } catch (i) {
        console.error(i);
      }
    }
  };
  t.onerror = function () {
    n.debug && console.log('_3Dconnexion.connect: No response from local 3dmouse server ' + i);
  };
  t.ontimeout = function () {
    n.debug && console.log('_3Dconnexion.connect: Timeout querying local 3dmouse server ' + i);
  };
  try {
    t.open('GET', i, !0);
    t.setRequestHeader('Accept', 'application/json; charset=utf-8');
    t.msCaching = 'disabled';
    t.timeout = 0;
    t.send();
  } catch (o) {
    u = 0;
    console.error(o.toString());
  }
  return u;
};
_3Dconnexion.prototype.create3dmouse = function (n, t, i) {
  'use strict';
  i = typeof i != 'undefined' ? i : _3Dconnexion.nlOptions.none;
  var r = this;
  r.viewport = n;
  r.debug && console.log('create3dmouse ' + r.viewport.id);
  r.viewport.addEventListener('focus', r.focus);
  r.viewport.addEventListener('blur', r.blur);
  r.session.call('3dx_rpc:create', '3dconnexion:3dmouse', r.version).then(
    function (n) {
      r.connexion = n.connexion;
      var u = {
        version: parseFloat(r.version),
        name: t,
        rowMajorOrder: (i & _3Dconnexion.nlOptions.rowMajorOrder) != 0,
      };
      r.session.call('3dx_rpc:create', '3dconnexion:3dcontroller', r.connexion, u).then(
        function (n) {
          r._3dcontroller = n.instance;
          r.session.subscribe('3dconnexion:3dcontroller/' + r._3dcontroller, r.onEvent.bind(r));
          document.hasFocus() &&
            (document.activeElement === document.body || document.activeElement === null
              ? (r.viewport.focus(), window === r.viewport && r.focus())
              : r.viewport.contains(document.activeElement) &&
                (r.focus(), r.debug && console.log('self.viewport has focus')));
          r.client.on3dmouseCreated && r.client.on3dmouseCreated();
        },
        function (n) {
          console.log('3dx_rpc:create 3dconnexion:3dcontroller ' + n);
        }
      );
    },
    function (n) {
      console.log('3dx_rpc:create ' + n);
    }
  );
};
_3Dconnexion.prototype.blur = function () {
  'use strict';
  var n = this;
  n.debug && console.log('blur on ');
  n.session && n._3dcontroller && n.update3dcontroller({ focus: !1 });
};
_3Dconnexion.prototype.focus = function () {
  'use strict';
  var n = this;
  n.debug && console.log('focus on ');
  n.session && n._3dcontroller && n.update3dcontroller({ focus: !0 });
};
_3Dconnexion.prototype.onKeyPress = function (n) {
  'use strict';
  var t = this;
  t.debug && console.log('onKeyPress ' + n);
};
_3Dconnexion.prototype.onKeyRelease = function (n) {
  'use strict';
  var t = this;
  t.debug && console.log('onKeyRelease ' + n);
};
_3Dconnexion.prototype.onMotion = function (n) {
  'use strict';
  var t = this;
  n === !0
    ? t.client.onStartMotion !== undefined && t.client.onStartMotion()
    : t.client.onStopMotion !== undefined && t.client.onStopMotion();
};
_3Dconnexion.prototype.onEvent = function (n, t) {
  'use strict';
  var i = this,
    f = null,
    r = null,
    u = null;
  if ((i.debug && (console.log(n), console.log(t)), t[0] === window.ab._MESSAGE_TYPEID_CALL)) {
    if (t[2] === 'self:read')
      if (((r = i.clientFnRead[t[4]]), r !== undefined)) f = r.bind(i.client)();
      else {
        u = [
          window.ab._MESSAGE_TYPEID_CALL_ERROR,
          t[1],
          t[2] + '#generic',
          t[4] + ' unknown property',
        ];
        i.session._send(u);
        return;
      }
    else if (t[2] === 'self:update')
      if (((r = i.fnUpdate[t[4]]), r !== undefined)) f = r(t[5]);
      else if (((r = i.clientFnUpdate[t[4]]), r !== undefined)) f = r.bind(i.client)(t[5]);
      else {
        u = [
          window.ab._MESSAGE_TYPEID_CALL_ERROR,
          t[1],
          t[2] + '#generic',
          t[4] + ' unknown property',
        ];
        i.session._send(u);
        return;
      }
    else {
      u = [window.ab._MESSAGE_TYPEID_CALL_ERROR, t[1], t[2] + '#generic', 'unknown procedure'];
      i.session._send(u);
      return;
    }
    u = [window.ab._MESSAGE_TYPEID_CALL_RESULT, t[1], f];
    i.session._send(u);
  }
};
_3Dconnexion.prototype.read3dcontroller = function (n, t) {
  'use strict';
  var i = this;
  i.debug && console.log('read3dcontroller ' + i._3dcontroller);
  try {
    i.session.call('3dx_rpc:read', '3dconnexion:3dcontroller/' + i._3dcontroller, n).then(
      function (n) {
        t && t(n);
      },
      function (t) {
        console.log('3dx_rpc:read 3dconnexion:3dcontroller/' + i._3dcontroller + ' ' + n + ' ' + t);
      }
    );
  } catch (r) {
    console.error(r);
  }
};
_3Dconnexion.prototype.update3dcontroller = function (n) {
  'use strict';
  var t = this;
  t.debug && console.log('update3dmouse ' + t._3dcontroller);
  try {
    if (!t._3dcontroller) throw 'exception 3dx_rpc:update: 3dcontroller not initialized';
    t.session.call('3dx_rpc:update', '3dconnexion:3dcontroller/' + t._3dcontroller, n).then(
      function () {
        return;
      },
      function (n) {
        console.log('3dx_rpc:update 3dconnexion:3dcontroller/' + t._3dcontroller + ' ' + n);
      }
    );
  } catch (i) {
    console.error(i);
  }
};
_3Dconnexion.prototype.delete3dmouse = function () {
  'use strict';
  var n = this,
    t = n.connexion;
  n.debug && console.log('delete3dmouse ');
  n.connexion = null;
  n._3dcontroller = null;
  n.viewport !== null &&
    (n.viewport.removeEventListener('focus', n.focus),
    n.viewport.removeEventListener('blur', n.blur));
  n.session &&
    n.session.call('3dx_rpc:delete', '3dconnexion:3dmouse/' + t).then(
      function () {
        n.debug && console.log('deleted connexion ' + t);
      },
      function (n) {
        console.log('3dx_rpc:delete ' + t + ' ' + n);
      }
    );
};
Object.freeze(
  (_3Dconnexion.SiActionNodeType_t = {
    SI_ACTIONSET_NODE: 0,
    SI_CATEGORY_NODE: 1,
    SI_ACTION_NODE: 2,
  })
);
_3Dconnexion.ActionNode = function (n, t, i) {
  return (this.id = n), (this.label = t || n), (this.type = i), this;
};
_3Dconnexion.ActionNode.prototype = {
  constructor: _3Dconnexion.ActionNode,
  id: { value: null, enumerable: !0 },
  label: { value: null, writable: !0, enumerable: !0 },
  type: { value: null, enumerable: !0 },
};
_3Dconnexion.Action = function (n, t, i) {
  return (
    _3Dconnexion.ActionNode.call(this, n, t, _3Dconnexion.SiActionNodeType_t.SI_ACTION_NODE),
    (this.description = i || ''),
    this
  );
};
_3Dconnexion.Action.prototype = Object.create(_3Dconnexion.ActionNode.prototype, {
  constructor: { value: _3Dconnexion.Action },
  description: { value: '', writable: !0, enumerable: !0 },
});
_3Dconnexion.ActionTreeNode = function () {
  return (this.nodes = []), this;
};
_3Dconnexion.ActionTreeNode.prototype = Object.create(_3Dconnexion.ActionNode.prototype, {
  constructor: { value: _3Dconnexion.ActionTreeNode },
  nodes: { value: null, writable: !0, enumerable: !0 },
  push: {
    value: function (n) {
      return this.nodes.push(n), n;
    },
  },
});
_3Dconnexion.ActionSet = function (n, t) {
  return (
    _3Dconnexion.ActionNode.call(this, n, t, _3Dconnexion.SiActionNodeType_t.SI_ACTIONSET_NODE),
    _3Dconnexion.ActionTreeNode.call(this),
    this
  );
};
_3Dconnexion.ActionSet.prototype = Object.create(_3Dconnexion.ActionTreeNode.prototype, {
  constructor: { value: _3Dconnexion.ActionSet },
});
_3Dconnexion.Category = function (n, t) {
  return (
    _3Dconnexion.ActionNode.call(this, n, t, _3Dconnexion.SiActionNodeType_t.SI_CATEGORY_NODE),
    _3Dconnexion.ActionTreeNode.call(this),
    this
  );
};
_3Dconnexion.Category.prototype = Object.create(_3Dconnexion.ActionTreeNode.prototype, {
  constructor: { value: _3Dconnexion.Category },
});
_3Dconnexion.ActionTree = function () {
  return (this.nodes = []), this;
};
_3Dconnexion.ActionTree.prototype = Object.create(null, {
  constructor: { value: _3Dconnexion.ActionTree },
  nodes: { value: null, writable: !0, enumerable: !0 },
  push: {
    value: function (n) {
      return this.nodes.push(n), n;
    },
  },
});
_3Dconnexion.ImageItem = function () {};
Object.freeze(
  (_3Dconnexion.SiImageType_t = {
    e_none: 0,
    e_image_file: 1,
    e_resource_file: 2,
    e_image: 3,
  })
);
_3Dconnexion.ImageItem.prototype = {
  constructor: _3Dconnexion.ImageItem,
  id: { value: '', writable: !0 },
  type: { value: 'e_none', enumerable: !0 },
};
_3Dconnexion.ImageItem.fromImage = function (n, t) {
  var i = new _3Dconnexion.ImageItem();
  return Object.defineProperties(i, {
    id: { value: t || '', writable: !0, enumerable: !0 },
    type: { value: _3Dconnexion.SiImageType_t.e_image, enumerable: !0 },
    index: { value: 0, writable: !0, enumerable: !0 },
    data: {
      value: _3Dconnexion.ImageItem.base64FromArrayBuffer(n),
      enumerable: !0,
    },
    status: { value: 200 },
  });
};
_3Dconnexion.ImageItem.fromURL = function (n, t) {
  var r = new _3Dconnexion.ImageItem(),
    i;
  return (
    Object.defineProperties(r, {
      id: { value: t || '', writable: !0, enumerable: !0 },
      type: { value: _3Dconnexion.SiImageType_t.e_image, enumerable: !0 },
      index: { value: 0, writable: !0, enumerable: !0 },
      buffer: { value: null, writable: !0 },
      data: {
        get: function () {
          return this.buffer;
        },
        set: function (n) {
          r.buffer = n;
          r.onload();
        },
        enumerable: !0,
      },
      status: { value: 100, writable: !0 },
      onload: { value: function () {}, writable: !0 },
    }),
    (i = new XMLHttpRequest()),
    i.overrideMimeType('text/plain; charset=x-user-defined'),
    i.open('GET', n, !0),
    (i.responseType = 'arraybuffer'),
    (i.onload = function () {
      if (((r.status = i.status), i.status === 200 && i.response !== null)) {
        r.data = _3Dconnexion.ImageItem.base64FromArrayBuffer(i.response);
        return;
      }
      r.status = 404;
      r.data = null;
    }),
    (i.onerror = function () {
      r.status = i.status;
      r.data = null;
    }),
    i.send(null),
    r
  );
};
_3Dconnexion.ImageItem.base64FromArrayBuffer = function (n) {
  for (
    var u = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
      t = new Uint8Array(n),
      e = t.length % 3,
      f = t.length - e,
      i = '',
      r = 0;
    r < f;
    r += 3
  )
    (i += u[t[r] >> 2]),
      (i += u[((t[r] & 3) << 4) | (t[r + 1] >> 4)]),
      (i += u[((t[r + 1] & 15) << 2) | (t[r + 2] >> 6)]),
      (i += u[t[r + 2] & 63]);
  return (
    e !== 0 &&
      ((i += u[t[f] >> 2]),
      e === 2
        ? ((i += u[((t[f] & 3) << 4) | (t[f + 1] >> 4)]),
          (i += u[(t[f + 1] & 15) << 2]),
          (i += '='))
        : ((i += u[(t[f] & 3) << 4]), (i += '=='))),
    i
  );
};
_3Dconnexion.ImageCache = function () {
  this.images = [];
  this.outstanding_requests = 0;
};
_3Dconnexion.ImageCache.prototype = {
  constructor: _3Dconnexion.ImageCache,
  images: { value: null, writable: !0, enumerable: !0 },
  outstanding_requests: { value: 0, writable: !0 },
  push: function (n) {
    var t = this;
    if (n.status === 100)
      ++t.outstanding_requests,
        (n.onload = function () {
          var n = this,
            i;
          n.onload = function () {};
          n.status !== 200 && ((i = t.images.indexOf(n)), i > -1 && t.images.splice(i, 1));
          --t.outstanding_requests;
          t.outstanding_requests === 0 && t.onload();
        }.bind(n));
    else if (n.data === null) return;
    t.images.push(n);
  },
  onload: function () {},
};
/** @license AutobahnJS - http://autobahn.ws
 *
 * Copyright (C) 2011-2014 Tavendo GmbH.
 * Licensed under the MIT License.
 * See license text at http://www.opensource.org/licenses/mit-license.php
 *
 * AutobahnJS includes code from:
 *
 * when - http://cujojs.com
 *
 * (c) copyright B Cavalier & J Hann
 * Licensed under the MIT License at:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * Crypto-JS - http://code.google.com/p/crypto-js/
 *
 * (c) 2009-2012 by Jeff Mott. All rights reserved.
 * Licensed under the New BSD License at:
 * http://code.google.com/p/crypto-js/wiki/License
 *
 * console-normalizer - https://github.com/Zenovations/console-normalizer
 *
 * (c) 2012 by Zenovations.
 * Licensed under the MIT License at:
 * http://www.opensource.org/licenses/mit-license.php
 *
 */
(function (n) {
  n ||
    (n = window.console =
      {
        log: function () {},
        info: function () {},
        warn: function () {},
        error: function () {},
      });
  Function.prototype.bind ||
    (Function.prototype.bind = function (n) {
      var t = this,
        i = Array.prototype.slice.call(arguments, 1);
      return function () {
        return t.apply(n, Array.prototype.concat.apply(i, arguments));
      };
    });
  typeof n.log == 'object' &&
    ((n.log = Function.prototype.call.bind(n.log, n)),
    (n.info = Function.prototype.call.bind(n.info, n)),
    (n.warn = Function.prototype.call.bind(n.warn, n)),
    (n.error = Function.prototype.call.bind(n.error, n)));
  'group' in n ||
    (n.group = function (t) {
      n.info('\\n--- ' + t + ' ---\\n');
    });
  'groupEnd' in n ||
    (n.groupEnd = function () {
      n.log('\\n');
    });
  'time' in n ||
    (function () {
      var t = {};
      n.time = function (n) {
        t[n] = new Date().getTime();
      };
      n.timeEnd = function (i) {
        var r = new Date().getTime(),
          u = i in t ? r - t[i] : 0;
        n.info(i + ': ' + u + 'ms');
      };
    })();
})(window.console);
/** @license MIT License (c) copyright 2011-2013 original author or authors */
when = (function (n) {
  'use strict';
  function t(n, t, i, r) {
    return at(n).then(t, i, r);
  }
  function e(n) {
    return new f(n, h.PromiseStatus && h.PromiseStatus());
  }
  function f(n, t) {
    function c() {
      return f ? f.inspect() : ii();
    }
    function l(n, t, r, u, e) {
      function o(i) {
        i._when(n, t, r, u, e);
      }
      i
        ? i.push(o)
        : y(function () {
            o(f);
          });
    }
    function o(n) {
      if (i) {
        var r = i;
        i = u;
        y(function () {
          f = pt(e, n);
          t && bt(f, t);
          w(r, f);
        });
      }
    }
    function s(n) {
      o(new r(n));
    }
    function a(n) {
      if (i) {
        var t = i;
        y(function () {
          w(t, new b(n));
        });
      }
    }
    var e,
      f,
      i = [];
    e = this;
    this._status = t;
    this.inspect = c;
    this._when = l;
    try {
      n(o, s, a);
    } catch (h) {
      s(h);
    }
  }
  function at(n) {
    return n instanceof f ? n : o(n);
  }
  function o(n) {
    return e(function (t) {
      t(n);
    });
  }
  function vt(n) {
    return t(n, function (n) {
      return new r(n);
    });
  }
  function yt() {
    function f(u, f, e) {
      n.resolve = n.resolver.resolve = function (n) {
        return t ? o(n) : ((t = !0), u(n), i);
      };
      n.reject = n.resolver.reject = function (n) {
        return t ? o(new r(n)) : ((t = !0), f(n), i);
      };
      n.notify = n.resolver.notify = function (n) {
        return e(n), n;
      };
    }
    var n, i, t;
    return (
      (n = {
        promise: u,
        resolve: u,
        reject: u,
        notify: u,
        resolver: { resolve: u, reject: u, notify: u },
      }),
      (n.promise = i = e(f)),
      n
    );
  }
  function w(n, t) {
    for (var i = 0; i < n.length; i++) n[i](t);
  }
  function pt(n, t) {
    if (t === n) return new r(new TypeError());
    if (t instanceof f) return t;
    try {
      var i = t === Object(t) && t.then;
      return typeof i == 'function' ? wt(i, t) : new c(t);
    } catch (u) {
      return new r(u);
    }
  }
  function wt(n, t) {
    return e(function (i, r) {
      d(n, t, i, r);
    });
  }
  function c(n) {
    this.value = n;
  }
  function r(n) {
    this.value = n;
  }
  function b(n) {
    this.value = n;
  }
  function bt(n, t) {
    function i() {
      t.fulfilled();
    }
    function r(n) {
      t.rejected(n);
    }
    n.then(i, r);
  }
  function rt(n) {
    return n && typeof n.then == 'function';
  }
  function ut(n, i, r, u, f) {
    return t(n, function (n) {
      function o(r, u, f) {
        function y(n) {
          c(n);
        }
        function w(n) {
          h(n);
        }
        var o, v, s, a, h, c, l, e;
        if (
          ((l = n.length >>> 0),
          (o = Math.max(0, Math.min(i, l))),
          (s = []),
          (v = l - o + 1),
          (a = []),
          o)
        )
          for (
            c = function (n) {
              a.push(n);
              --v || ((h = c = p), u(a));
            },
              h = function (n) {
                s.push(n);
                --o || ((h = c = p), r(s));
              },
              e = 0;
            e < l;
            ++e
          )
            e in n && t(n[e], w, y, f);
        else r(s);
      }
      return e(o).then(r, u, f);
    });
  }
  function kt(n, t, i, r) {
    function u(n) {
      return t ? t(n[0]) : n[0];
    }
    return ut(n, 1, u, i, r);
  }
  function ft(n, t, i, r) {
    return l(n, p).then(t, i, r);
  }
  function dt() {
    return l(arguments, p);
  }
  function gt(n) {
    return l(n, et, ot);
  }
  function ni(n, t) {
    return l(n, t);
  }
  function l(n, i, r) {
    return t(n, function (n) {
      function u(u, f, e) {
        function l(n, o) {
          t(n, i, r).then(
            function (n) {
              s[o] = n;
              --h || u(s);
            },
            f,
            e
          );
        }
        var s, c, h, o;
        if (((h = c = n.length >>> 0), (s = []), !h)) {
          u(s);
          return;
        }
        for (o = 0; o < c; o++) o in n ? l(n[o], o) : --h;
      }
      return new f(u);
    });
  }
  function ti(n, i) {
    var r = d(k, arguments, 1);
    return t(n, function (n) {
      var u;
      return (
        (u = n.length),
        (r[0] = function (n, r, f) {
          return t(n, function (n) {
            return t(r, function (t) {
              return i(n, t, f, u);
            });
          });
        }),
        st.apply(n, r)
      );
    });
  }
  function et(n) {
    return { state: 'fulfilled', value: n };
  }
  function ot(n) {
    return { state: 'rejected', reason: n };
  }
  function ii() {
    return { state: 'pending' };
  }
  function y(n) {
    v.push(n) === 1 && s(lt);
  }
  function lt() {
    w(v);
    v = [];
  }
  function p(n) {
    return n;
  }
  function ri(n) {
    typeof h.reportUnhandled == 'function'
      ? h.reportUnhandled()
      : y(function () {
          throw n;
        });
    throw n;
  }
  t.promise = e;
  t.resolve = o;
  t.reject = vt;
  t.defer = yt;
  t.join = dt;
  t.all = ft;
  t.map = ni;
  t.reduce = ti;
  t.settle = gt;
  t.any = kt;
  t.some = ut;
  t.isPromise = rt;
  t.isPromiseLike = rt;
  i = f.prototype;
  i.then = function (n, t, i) {
    var r = this;
    return new f(function (u, f, e) {
      r._when(u, e, n, t, i);
    }, this._status && this._status.observed());
  };
  i['catch'] = i.otherwise = function (n) {
    return this.then(u, n);
  };
  i['finally'] = i.ensure = function (n) {
    function t() {
      return o(n());
    }
    return typeof n == 'function' ? this.then(t, t)['yield'](this) : this;
  };
  i.done = function (n, t) {
    this.then(n, t)['catch'](ri);
  };
  i['yield'] = function (n) {
    return this.then(function () {
      return n;
    });
  };
  i.tap = function (n) {
    return this.then(n)['yield'](this);
  };
  i.spread = function (n) {
    return this.then(function (t) {
      return ft(t, function (t) {
        return n.apply(u, t);
      });
    });
  };
  i.always = function (n, t) {
    return this.then(n, n, t);
  };
  a =
    Object.create ||
    function (n) {
      function t() {}
      return (t.prototype = n), new t();
    };
  c.prototype = a(i);
  c.prototype.inspect = function () {
    return et(this.value);
  };
  c.prototype._when = function (n, t, i) {
    try {
      n(typeof i == 'function' ? i(this.value) : this.value);
    } catch (u) {
      n(new r(u));
    }
  };
  r.prototype = a(i);
  r.prototype.inspect = function () {
    return ot(this.value);
  };
  r.prototype._when = function (n, t, i, u) {
    try {
      n(typeof u == 'function' ? u(this.value) : this);
    } catch (f) {
      n(new r(f));
    }
  };
  b.prototype = a(i);
  b.prototype._when = function (n, t, i, r, u) {
    try {
      t(typeof u == 'function' ? u(this.value) : this.value);
    } catch (f) {
      t(f);
    }
  };
  var i, a, st, k, d, s, v, g, nt, tt, h, ht, it, ct, u;
  if (
    ((it = n),
    (v = []),
    (h = typeof console != 'undefined' ? console : t),
    typeof process == 'object' && process.nextTick)
  )
    s = process.nextTick;
  else if (
    (ct =
      (typeof MutationObserver == 'function' && MutationObserver) ||
      (typeof WebKitMutationObserver == 'function' && WebKitMutationObserver))
  )
    s = (function (n, t, i) {
      var r = n.createElement('div');
      return (
        new t(i).observe(r, { attributes: !0 }),
        function () {
          r.setAttribute('x', 'x');
        }
      );
    })(document, ct, lt);
  else
    try {
      s = it('vertx').runOnLoop || it('vertx').runOnContext;
    } catch (ui) {
      ht = setTimeout;
      s = function (n) {
        ht(n, 0);
      };
    }
  return (
    (g = Function.prototype),
    (nt = g.call),
    (d = g.bind
      ? nt.bind(nt)
      : function (n, t) {
          return n.apply(t, k.call(arguments, 2));
        }),
    (tt = []),
    (k = tt.slice),
    (st =
      tt.reduce ||
      function (n) {
        var i, u, r, f, t;
        if (((t = 0), (i = Object(this)), (f = i.length >>> 0), (u = arguments), u.length <= 1))
          for (;;) {
            if (t in i) {
              r = i[t++];
              break;
            }
            if (++t >= f) throw new TypeError();
          }
        else r = u[1];
        for (; t < f; ++t) t in i && (r = n(r, i[t], t, i));
        return r;
      }),
    t
  );
})();
(CryptoJS =
  CryptoJS ||
  (function (n, t) {
    var u = {},
      f = (u.lib = {}),
      i = (f.Base = (function () {
        function n() {}
        return {
          extend: function (t) {
            n.prototype = this;
            var i = new n();
            return (
              t && i.mixIn(t),
              i.hasOwnProperty('init') ||
                (i.init = function () {
                  i.$super.init.apply(this, arguments);
                }),
              (i.init.prototype = i),
              (i.$super = this),
              i
            );
          },
          create: function () {
            var n = this.extend();
            return n.init.apply(n, arguments), n;
          },
          init: function () {},
          mixIn: function (n) {
            for (var t in n) n.hasOwnProperty(t) && (this[t] = n[t]);
            n.hasOwnProperty('toString') && (this.toString = n.toString);
          },
          clone: function () {
            return this.init.prototype.extend(this);
          },
        };
      })()),
      r = (f.WordArray = i.extend({
        init: function (n, i) {
          n = this.words = n || [];
          this.sigBytes = i != t ? i : n.length * 4;
        },
        toString: function (n) {
          return (n || h).stringify(this);
        },
        concat: function (n) {
          var i = this.words,
            r = n.words,
            u = this.sigBytes,
            f = n.sigBytes,
            e,
            t;
          if ((this.clamp(), u % 4))
            for (t = 0; t < f; t++)
              (e = (r[t >>> 2] >>> (24 - (t % 4) * 8)) & 255),
                (i[(u + t) >>> 2] |= e << (24 - ((u + t) % 4) * 8));
          else if (r.length > 65535) for (t = 0; t < f; t += 4) i[(u + t) >>> 2] = r[t >>> 2];
          else i.push.apply(i, r);
          return (this.sigBytes += f), this;
        },
        clamp: function () {
          var i = this.words,
            t = this.sigBytes;
          i[t >>> 2] &= 4294967295 << (32 - (t % 4) * 8);
          i.length = n.ceil(t / 4);
        },
        clone: function () {
          var n = i.clone.call(this);
          return (n.words = this.words.slice(0)), n;
        },
        random: function (t) {
          for (var i = [], u = 0; u < t; u += 4) i.push((n.random() * 4294967296) | 0);
          return new r.init(i, t);
        },
      })),
      e = (u.enc = {}),
      h = (e.Hex = {
        stringify: function (n) {
          for (var r, u = n.words, f = n.sigBytes, i = [], t = 0; t < f; t++)
            (r = (u[t >>> 2] >>> (24 - (t % 4) * 8)) & 255),
              i.push((r >>> 4).toString(16)),
              i.push((r & 15).toString(16));
          return i.join('');
        },
        parse: function (n) {
          for (var i = n.length, u = [], t = 0; t < i; t += 2)
            u[t >>> 3] |= parseInt(n.substr(t, 2), 16) << (24 - (t % 8) * 4);
          return new r.init(u, i / 2);
        },
      }),
      o = (e.Latin1 = {
        stringify: function (n) {
          for (var r, u = n.words, f = n.sigBytes, i = [], t = 0; t < f; t++)
            (r = (u[t >>> 2] >>> (24 - (t % 4) * 8)) & 255), i.push(String.fromCharCode(r));
          return i.join('');
        },
        parse: function (n) {
          for (var i = n.length, u = [], t = 0; t < i; t++)
            u[t >>> 2] |= (n.charCodeAt(t) & 255) << (24 - (t % 4) * 8);
          return new r.init(u, i);
        },
      }),
      c = (e.Utf8 = {
        stringify: function (n) {
          try {
            return decodeURIComponent(escape(o.stringify(n)));
          } catch (t) {
            throw new Error('Malformed UTF-8 data');
          }
        },
        parse: function (n) {
          return o.parse(unescape(encodeURIComponent(n)));
        },
      }),
      s = (f.BufferedBlockAlgorithm = i.extend({
        reset: function () {
          this._data = new r.init();
          this._nDataBytes = 0;
        },
        _append: function (n) {
          typeof n == 'string' && (n = c.parse(n));
          this._data.concat(n);
          this._nDataBytes += n.sigBytes;
        },
        _process: function (t) {
          var e = this._data,
            h = e.words,
            c = e.sigBytes,
            o = this.blockSize,
            a = o * 4,
            u = c / a,
            i,
            s,
            f,
            l;
          if (
            ((u = t ? n.ceil(u) : n.max((u | 0) - this._minBufferSize, 0)),
            (i = u * o),
            (s = n.min(i * 4, c)),
            i)
          ) {
            for (f = 0; f < i; f += o) this._doProcessBlock(h, f);
            l = h.splice(0, i);
            e.sigBytes -= s;
          }
          return new r.init(l, s);
        },
        clone: function () {
          var n = i.clone.call(this);
          return (n._data = this._data.clone()), n;
        },
        _minBufferSize: 0,
      })),
      a = (f.Hasher = s.extend({
        cfg: i.extend(),
        init: function (n) {
          this.cfg = this.cfg.extend(n);
          this.reset();
        },
        reset: function () {
          s.reset.call(this);
          this._doReset();
        },
        update: function (n) {
          return this._append(n), this._process(), this;
        },
        finalize: function (n) {
          n && this._append(n);
          return this._doFinalize();
        },
        blockSize: 16,
        _createHelper: function (n) {
          return function (t, i) {
            return new n.init(i).finalize(t);
          };
        },
        _createHmacHelper: function (n) {
          return function (t, i) {
            return new l.HMAC.init(n, i).finalize(t);
          };
        },
      })),
      l = (u.algo = {});
    return u;
  })(Math)),
  (function () {
    var n = CryptoJS,
      t = n.lib,
      i = t.WordArray,
      r = n.enc,
      u = (r.Base64 = {
        stringify: function (n) {
          var u = n.words,
            e = n.sigBytes,
            o = this._map,
            i,
            t,
            r,
            f;
          for (n.clamp(), i = [], t = 0; t < e; t += 3) {
            var s = (u[t >>> 2] >>> (24 - (t % 4) * 8)) & 255,
              h = (u[(t + 1) >>> 2] >>> (24 - ((t + 1) % 4) * 8)) & 255,
              c = (u[(t + 2) >>> 2] >>> (24 - ((t + 2) % 4) * 8)) & 255,
              l = (s << 16) | (h << 8) | c;
            for (r = 0; r < 4 && t + r * 0.75 < e; r++)
              i.push(o.charAt((l >>> (6 * (3 - r))) & 63));
          }
          if (((f = o.charAt(64)), f)) while (i.length % 4) i.push(f);
          return i.join('');
        },
        parse: function (n) {
          var o = n.length,
            u = this._map,
            s = u.charAt(64),
            f,
            e,
            r,
            t,
            h,
            c;
          for (s && ((f = n.indexOf(s)), f != -1 && (o = f)), e = [], r = 0, t = 0; t < o; t++)
            t % 4 &&
              ((h = u.indexOf(n.charAt(t - 1)) << ((t % 4) * 2)),
              (c = u.indexOf(n.charAt(t)) >>> (6 - (t % 4) * 2)),
              (e[r >>> 2] |= (h | c) << (24 - (r % 4) * 8)),
              r++);
          return i.create(e, r);
        },
        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
      });
  })(),
  (function () {
    var n = CryptoJS,
      t = n.lib,
      i = t.Base,
      r = n.enc,
      u = r.Utf8,
      f = n.algo,
      e = (f.HMAC = i.extend({
        init: function (n, t) {
          var r, f, i;
          n = this._hasher = new n.init();
          typeof t == 'string' && (t = u.parse(t));
          r = n.blockSize;
          f = r * 4;
          t.sigBytes > f && (t = n.finalize(t));
          t.clamp();
          var e = (this._oKey = t.clone()),
            o = (this._iKey = t.clone()),
            s = e.words,
            h = o.words;
          for (i = 0; i < r; i++) (s[i] ^= 1549556828), (h[i] ^= 909522486);
          e.sigBytes = o.sigBytes = f;
          this.reset();
        },
        reset: function () {
          var n = this._hasher;
          n.reset();
          n.update(this._iKey);
        },
        update: function (n) {
          return this._hasher.update(n), this;
        },
        finalize: function (n) {
          var t = this._hasher,
            i = t.finalize(n);
          return t.reset(), t.finalize(this._oKey.clone().concat(i));
        },
      }));
  })(),
  (function (n) {
    var i = CryptoJS,
      f = i.lib,
      s = f.WordArray,
      r = f.Hasher,
      h = i.algo,
      e = [],
      o = [],
      t,
      u;
    (function () {
      function u(t) {
        for (var r = n.sqrt(t), i = 2; i <= r; i++) if (!(t % i)) return !1;
        return !0;
      }
      function r(n) {
        return ((n - (n | 0)) * 4294967296) | 0;
      }
      for (var i = 2, t = 0; t < 64; )
        u(i) && (t < 8 && (e[t] = r(n.pow(i, 1 / 2))), (o[t] = r(n.pow(i, 1 / 3))), t++), i++;
    })();
    t = [];
    u = h.SHA256 = r.extend({
      _doReset: function () {
        this._hash = new s.init(e.slice(0));
      },
      _doProcessBlock: function (n, i) {
        for (
          var r = this._hash.words,
            f = r[0],
            s = r[1],
            h = r[2],
            y = r[3],
            e = r[4],
            a = r[5],
            v = r[6],
            p = r[7],
            u = 0;
          u < 64;
          u++
        ) {
          if (u < 16) t[u] = n[i + u] | 0;
          else {
            var c = t[u - 15],
              b = ((c << 25) | (c >>> 7)) ^ ((c << 14) | (c >>> 18)) ^ (c >>> 3),
              l = t[u - 2],
              k = ((l << 15) | (l >>> 17)) ^ ((l << 13) | (l >>> 19)) ^ (l >>> 10);
            t[u] = b + t[u - 7] + k + t[u - 16];
          }
          var d = (e & a) ^ (~e & v),
            g = (f & s) ^ (f & h) ^ (s & h),
            nt = ((f << 30) | (f >>> 2)) ^ ((f << 19) | (f >>> 13)) ^ ((f << 10) | (f >>> 22)),
            tt = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7) | (e >>> 25)),
            w = p + tt + d + o[u] + t[u],
            it = nt + g;
          p = v;
          v = a;
          a = e;
          e = (y + w) | 0;
          y = h;
          h = s;
          s = f;
          f = (w + it) | 0;
        }
        r[0] = (r[0] + f) | 0;
        r[1] = (r[1] + s) | 0;
        r[2] = (r[2] + h) | 0;
        r[3] = (r[3] + y) | 0;
        r[4] = (r[4] + e) | 0;
        r[5] = (r[5] + a) | 0;
        r[6] = (r[6] + v) | 0;
        r[7] = (r[7] + p) | 0;
      },
      _doFinalize: function () {
        var r = this._data,
          t = r.words,
          u = this._nDataBytes * 8,
          i = r.sigBytes * 8;
        return (
          (t[i >>> 5] |= 128 << (24 - (i % 32))),
          (t[(((i + 64) >>> 9) << 4) + 14] = n.floor(u / 4294967296)),
          (t[(((i + 64) >>> 9) << 4) + 15] = u),
          (r.sigBytes = t.length * 4),
          this._process(),
          this._hash
        );
      },
      clone: function () {
        var n = r.clone.call(this);
        return (n._hash = this._hash.clone()), n;
      },
    });
    i.SHA256 = r._createHelper(u);
    i.HmacSHA256 = r._createHmacHelper(u);
  })(Math),
  (function () {
    var n = CryptoJS,
      i = n.lib,
      r = i.Base,
      u = i.WordArray,
      t = n.algo,
      f = t.SHA1,
      e = t.HMAC,
      o = (t.PBKDF2 = r.extend({
        cfg: r.extend({ keySize: 4, hasher: f, iterations: 1 }),
        init: function (n) {
          this.cfg = this.cfg.extend(n);
        },
        compute: function (n, t) {
          for (
            var s = this.cfg,
              r = e.create(s.hasher, n),
              f = u.create(),
              l = u.create([1]),
              p = f.words,
              w = l.words,
              a = s.keySize,
              b = s.iterations,
              o,
              c,
              y,
              i;
            p.length < a;

          ) {
            o = r.update(t).finalize(l);
            r.reset();
            var v = o.words,
              k = v.length,
              h = o;
            for (c = 1; c < b; c++)
              for (h = r.finalize(h), r.reset(), y = h.words, i = 0; i < k; i++) v[i] ^= y[i];
            f.concat(o);
            w[0]++;
          }
          return (f.sigBytes = a * 4), f;
        },
      }));
    n.PBKDF2 = function (n, t, i) {
      return o.create(i).compute(n, t);
    };
  })();
/** @license MIT License (c) 2011-2013 Copyright Tavendo GmbH. */
AUTOBAHNJS_VERSION = '0.8.2.1';
(global = this),
  (function (n, t) {
    n.ab = t(n, n.when);
  })(global, function (n, t) {
    'use strict';
    var i = {};
    return (
      (i._version = AUTOBAHNJS_VERSION),
      (function () {
        Array.prototype.indexOf ||
          (Array.prototype.indexOf = function (n) {
            var u, r, t, i;
            if (this === null) throw new TypeError();
            if (
              ((u = new Object(this)), (r = u.length >>> 0), r === 0) ||
              ((t = 0),
              arguments.length > 0 &&
                ((t = Number(arguments[1])),
                t !== t
                  ? (t = 0)
                  : t !== 0 &&
                    t !== Infinity &&
                    t !== -Infinity &&
                    (t = (t > 0 || -1) * Math.floor(Math.abs(t)))),
              t >= r)
            )
              return -1;
            for (i = t >= 0 ? t : Math.max(r - Math.abs(t), 0); i < r; i++)
              if (i in u && u[i] === n) return i;
            return -1;
          });
        Array.prototype.forEach ||
          (Array.prototype.forEach = function (n, t) {
            var u, i, r, f, e;
            if (this === null) throw new TypeError(' this is null or not defined');
            if (
              ((r = new Object(this)),
              (f = r.length >>> 0),
              {}.toString.call(n) !== '[object Function]')
            )
              throw new TypeError(n + ' is not a function');
            for (t && (u = t), i = 0; i < f; ) i in r && ((e = r[i]), n.call(u, e, i, r)), i++;
          });
      })(),
      (i._sliceUserAgent = function (n, t, i) {
        var s = [],
          r = navigator.userAgent,
          h = r.indexOf(n),
          f = r.indexOf(t, h),
          e,
          o,
          u;
        for (
          f < 0 && (f = r.length), e = r.slice(h, f).split(i), o = e[1].split('.'), u = 0;
          u < o.length;
          ++u
        )
          s.push(parseInt(o[u], 10));
        return { name: e[0], version: s };
      }),
      (i.getBrowser = function () {
        var n = navigator.userAgent;
        return n.indexOf('Chrome') > -1
          ? i._sliceUserAgent('Chrome', ' ', '/')
          : n.indexOf('Safari') > -1
          ? i._sliceUserAgent('Safari', ' ', '/')
          : n.indexOf('Firefox') > -1
          ? i._sliceUserAgent('Firefox', ' ', '/')
          : n.indexOf('MSIE') > -1
          ? i._sliceUserAgent('MSIE', ';', ' ')
          : null;
      }),
      (i.getServerUrl = function (t, i) {
        if (n.location.protocol === 'file:') return i ? i : 'ws://127.0.0.1/ws';
        var r = n.location.protocol === 'https:' ? 'wss://' : 'ws://',
          u = n.location.port !== '' ? ':' + n.location.port : '',
          f = t ? t : 'ws';
        return r + n.location.hostname + u + '/' + f;
      }),
      (i.browserNotSupportedMessage = 'Browser does not support WebSockets (RFC6455)'),
      (i.deriveKey = function (n, t) {
        if (t && t.salt) {
          var i = t.salt,
            r = t.keylen || 32,
            u = t.iterations || 1e4,
            f = CryptoJS.PBKDF2(n, i, {
              keySize: r / 4,
              iterations: u,
              hasher: CryptoJS.algo.SHA256,
            });
          return f.toString(CryptoJS.enc.Base64);
        }
        return n;
      }),
      (i._idchars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'),
      (i._idlen = 16),
      (i._subprotocol = 'wamp'),
      (i._newid = function () {
        for (var n = '', t = 0; t < i._idlen; t += 1)
          n += i._idchars.charAt(Math.floor(Math.random() * i._idchars.length));
        return n;
      }),
      (i._newidFast = function () {
        return Math.random().toString(36);
      }),
      (i.log = function () {
        if (arguments.length > 1) {
          console.group('Log Item');
          for (var n = 0; n < arguments.length; n += 1) console.log(arguments[n]);
          console.groupEnd();
        } else console.log(arguments[0]);
      }),
      (i._debugrpc = !1),
      (i._debugpubsub = !1),
      (i._debugws = !1),
      (i._debugconnect = !1),
      (i.debug = function (t, r, u) {
        if ('console' in n)
          (i._debugrpc = t), (i._debugpubsub = t), (i._debugws = r), (i._debugconnect = u);
        else throw 'browser does not support console object';
      }),
      (i.version = function () {
        return i._version;
      }),
      (i.PrefixMap = function () {
        var n = this;
        n._index = {};
        n._rindex = {};
      }),
      (i.PrefixMap.prototype.get = function (n) {
        var t = this;
        return t._index[n];
      }),
      (i.PrefixMap.prototype.set = function (n, t) {
        var i = this;
        i._index[n] = t;
        i._rindex[t] = n;
      }),
      (i.PrefixMap.prototype.setDefault = function (n) {
        var t = this;
        t._index[''] = n;
        t._rindex[n] = '';
      }),
      (i.PrefixMap.prototype.remove = function (n) {
        var t = this,
          i = t._index[n];
        i && (delete t._index[n], delete t._rindex[i]);
      }),
      (i.PrefixMap.prototype.resolve = function (n, t) {
        var u = this,
          i = n.indexOf(':'),
          r;
        return i >= 0 && ((r = n.substring(0, i)), u._index[r])
          ? u._index[r] + n.substring(i + 1)
          : t === !0
          ? n
          : null;
      }),
      (i.PrefixMap.prototype.shrink = function (n, t) {
        for (var u, r, f = this, i = n.length; i > 0; i -= 1)
          if (((u = n.substring(0, i)), (r = f._rindex[u]), r)) return r + ':' + n.substring(i);
        return t === !0 ? n : null;
      }),
      (i._MESSAGE_TYPEID_WELCOME = 0),
      (i._MESSAGE_TYPEID_PREFIX = 1),
      (i._MESSAGE_TYPEID_CALL = 2),
      (i._MESSAGE_TYPEID_CALL_RESULT = 3),
      (i._MESSAGE_TYPEID_CALL_ERROR = 4),
      (i._MESSAGE_TYPEID_SUBSCRIBE = 5),
      (i._MESSAGE_TYPEID_UNSUBSCRIBE = 6),
      (i._MESSAGE_TYPEID_PUBLISH = 7),
      (i._MESSAGE_TYPEID_EVENT = 8),
      (i.CONNECTION_CLOSED = 0),
      (i.CONNECTION_LOST = 1),
      (i.CONNECTION_RETRIES_EXCEEDED = 2),
      (i.CONNECTION_UNREACHABLE = 3),
      (i.CONNECTION_UNSUPPORTED = 4),
      (i.CONNECTION_UNREACHABLE_SCHEDULED_RECONNECT = 5),
      (i.CONNECTION_LOST_SCHEDULED_RECONNECT = 6),
      (i.Deferred = t.defer),
      (i._construct = function (t, i) {
        return 'WebSocket' in n
          ? i
            ? new WebSocket(t, i)
            : new WebSocket(t)
          : 'MozWebSocket' in n
          ? i
            ? new MozWebSocket(t, i)
            : new MozWebSocket(t)
          : null;
      }),
      (i.Session = function (n, t, r, u) {
        var f = this;
        if (
          ((f._wsuri = n),
          (f._options = u),
          (f._websocket_onopen = t),
          (f._websocket_onclose = r),
          (f._websocket = null),
          (f._websocket_connected = !1),
          (f._session_id = null),
          (f._wamp_version = null),
          (f._server = null),
          (f._calls = {}),
          (f._subscriptions = {}),
          (f._prefixes = new i.PrefixMap()),
          (f._txcnt = 0),
          (f._rxcnt = 0),
          (f._websocket =
            f._options && f._options.skipSubprotocolAnnounce
              ? i._construct(f._wsuri)
              : i._construct(f._wsuri, [i._subprotocol])),
          !f._websocket)
        ) {
          if (r !== undefined) {
            r(i.CONNECTION_UNSUPPORTED);
            return;
          }
          throw i.browserNotSupportedMessage;
        }
        f._websocket.onmessage = function (n) {
          var t, r, h, e, c, s, v, y, p, w;
          if (
            (i._debugws &&
              ((f._rxcnt += 1),
              console.group('WS Receive'),
              console.info(f._wsuri + '  [' + f._session_id + ']'),
              console.log(f._rxcnt),
              console.log(n.data),
              console.groupEnd()),
            (t = JSON.parse(n.data)),
            t[1] in f._calls)
          ) {
            if (t[0] === i._MESSAGE_TYPEID_CALL_RESULT) {
              if (((r = f._calls[t[1]]), (h = t[2]), i._debugrpc && r._ab_callobj !== undefined)) {
                for (
                  console.group('WAMP Call', r._ab_callobj[2]),
                    console.timeEnd(r._ab_tid),
                    console.group('Arguments'),
                    e = 3;
                  e < r._ab_callobj.length;
                  e += 1
                )
                  if (((c = r._ab_callobj[e]), c !== undefined)) console.log(c);
                  else break;
                console.groupEnd();
                console.group('Result');
                console.log(h);
                console.groupEnd();
                console.groupEnd();
              }
              r.resolve(h);
            } else if (t[0] === i._MESSAGE_TYPEID_CALL_ERROR) {
              var u = f._calls[t[1]],
                l = t[2],
                a = t[3],
                o = t[4];
              if (i._debugrpc && u._ab_callobj !== undefined) {
                for (
                  console.group('WAMP Call', u._ab_callobj[2]),
                    console.timeEnd(u._ab_tid),
                    console.group('Arguments'),
                    s = 3;
                  s < u._ab_callobj.length;
                  s += 1
                )
                  if (((v = u._ab_callobj[s]), v !== undefined)) console.log(v);
                  else break;
                console.groupEnd();
                console.group('Error');
                console.log(l);
                console.log(a);
                o !== undefined && console.log(o);
                console.groupEnd();
                console.groupEnd();
              }
              o !== undefined
                ? u.reject({ uri: l, desc: a, detail: o })
                : u.reject({ uri: l, desc: a });
            }
            delete f._calls[t[1]];
          } else if (t[0] === i._MESSAGE_TYPEID_EVENT)
            (y = f._prefixes.resolve(t[1], !0)),
              y in f._subscriptions &&
                ((p = t[1]),
                (w = t[2]),
                i._debugpubsub &&
                  (console.group('WAMP Event'),
                  console.info(f._wsuri + '  [' + f._session_id + ']'),
                  console.log(p),
                  console.log(w),
                  console.groupEnd()),
                f._subscriptions[y].forEach(function (n) {
                  n(p, w);
                }));
          else if (t[0] === i._MESSAGE_TYPEID_WELCOME)
            if (f._session_id === null)
              (f._session_id = t[1]),
                (f._wamp_version = t[2]),
                (f._server = t[3]),
                (i._debugrpc || i._debugpubsub) &&
                  (console.group('WAMP Welcome'),
                  console.info(f._wsuri + '  [' + f._session_id + ']'),
                  console.log(f._wamp_version),
                  console.log(f._server),
                  console.groupEnd()),
                f._websocket_onopen !== null && f._websocket_onopen();
            else throw 'protocol error (welcome message received more than once)';
        };
        f._websocket.onopen = function () {
          if (f._websocket.protocol !== i._subprotocol)
            if (typeof f._websocket.protocol == 'undefined')
              i._debugws &&
                (console.group('WS Warning'),
                console.info(f._wsuri),
                console.log(
                  'WebSocket object has no protocol attribute: WAMP subprotocol check skipped!'
                ),
                console.groupEnd());
            else if (f._options && f._options.skipSubprotocolCheck)
              i._debugws &&
                (console.group('WS Warning'),
                console.info(f._wsuri),
                console.log(
                  'Server does not speak WAMP, but subprotocol check disabled by option!'
                ),
                console.log(f._websocket.protocol),
                console.groupEnd());
            else {
              f._websocket.close(1e3, 'server does not speak WAMP');
              throw "server does not speak WAMP (but '" + f._websocket.protocol + "' !)";
            }
          i._debugws &&
            (console.group('WAMP Connect'),
            console.info(f._wsuri),
            console.log(f._websocket.protocol),
            console.groupEnd());
          f._websocket_connected = !0;
        };
        f._websocket.onerror = function () {};
        f._websocket.onclose = function (n) {
          i._debugws &&
            (f._websocket_connected
              ? console.log(
                  'Autobahn connection to ' +
                    f._wsuri +
                    ' lost (code ' +
                    n.code +
                    ", reason '" +
                    n.reason +
                    "', wasClean " +
                    n.wasClean +
                    ').'
                )
              : console.log(
                  'Autobahn could not connect to ' +
                    f._wsuri +
                    ' (code ' +
                    n.code +
                    ", reason '" +
                    n.reason +
                    "', wasClean " +
                    n.wasClean +
                    ').'
                ));
          f._websocket_onclose !== undefined &&
            (f._websocket_connected
              ? n.wasClean
                ? f._websocket_onclose(i.CONNECTION_CLOSED, 'WS-' + n.code + ': ' + n.reason)
                : f._websocket_onclose(i.CONNECTION_LOST)
              : f._websocket_onclose(i.CONNECTION_UNREACHABLE));
          f._websocket_connected = !1;
          f._wsuri = null;
          f._websocket_onopen = null;
          f._websocket_onclose = null;
          f._websocket = null;
        };
        f.log = function () {
          f._options && 'sessionIdent' in f._options
            ? console.group(
                "WAMP Session '" + f._options.sessionIdent + "' [" + f._session_id + ']'
              )
            : console.group('WAMP Session [' + f._session_id + ']');
          for (var n = 0; n < arguments.length; ++n) console.log(arguments[n]);
          console.groupEnd();
        };
      }),
      (i.Session.prototype._send = function (t) {
        var r = this,
          u;
        if (!r._websocket_connected) throw 'Autobahn not connected';
        switch (!0) {
          case n.Prototype && typeof top.root.__prototype_deleted == 'undefined':
          case typeof t.toJSON == 'function':
            u = t.toJSON();
            break;
          default:
            u = JSON.stringify(t);
        }
        r._websocket.send(u);
        r._txcnt += 1;
        i._debugws &&
          (console.group('WS Send'),
          console.info(r._wsuri + '  [' + r._session_id + ']'),
          console.log(r._txcnt),
          console.log(u),
          console.groupEnd());
      }),
      (i.Session.prototype.close = function () {
        var n = this;
        n._websocket_connected && n._websocket.close();
      }),
      (i.Session.prototype.sessionid = function () {
        var n = this;
        return n._session_id;
      }),
      (i.Session.prototype.wsuri = function () {
        var n = this;
        return n._wsuri;
      }),
      (i.Session.prototype.shrink = function (n, t) {
        var i = this;
        return t === undefined && (t = !0), i._prefixes.shrink(n, t);
      }),
      (i.Session.prototype.resolve = function (n, t) {
        var i = this;
        return t === undefined && (t = !0), i._prefixes.resolve(n, t);
      }),
      (i.Session.prototype.prefix = function (n, t) {
        var r = this,
          u;
        r._prefixes.set(n, t);
        (i._debugrpc || i._debugpubsub) &&
          (console.group('WAMP Prefix'),
          console.info(r._wsuri + '  [' + r._session_id + ']'),
          console.log(n),
          console.log(t),
          console.groupEnd());
        u = [i._MESSAGE_TYPEID_PREFIX, n, t];
        r._send(u);
      }),
      (i.Session.prototype.call = function () {
        for (var t = this, n = new i.Deferred(), r, e, u, f; ; )
          if (((r = i._newidFast()), !(r in t._calls))) break;
        for (
          t._calls[r] = n,
            e = t._prefixes.shrink(arguments[0], !0),
            u = [i._MESSAGE_TYPEID_CALL, r, e],
            f = 1;
          f < arguments.length;
          f += 1
        )
          u.push(arguments[f]);
        return (
          t._send(u),
          i._debugrpc &&
            ((n._ab_callobj = u),
            (n._ab_tid = t._wsuri + '  [' + t._session_id + '][' + r + ']'),
            console.time(n._ab_tid),
            console.info()),
          n.promise.then ? n.promise : n
        );
      }),
      (i.Session.prototype.subscribe = function (n, t) {
        var r = this,
          u = r._prefixes.resolve(n, !0),
          f,
          e;
        if (
          (u in r._subscriptions ||
            (i._debugpubsub &&
              (console.group('WAMP Subscribe'),
              console.info(r._wsuri + '  [' + r._session_id + ']'),
              console.log(n),
              console.log(t),
              console.groupEnd()),
            (f = [i._MESSAGE_TYPEID_SUBSCRIBE, n]),
            r._send(f),
            (r._subscriptions[u] = [])),
          (e = r._subscriptions[u].indexOf(t)),
          e === -1)
        )
          r._subscriptions[u].push(t);
        else throw 'callback ' + t + ' already subscribed for topic ' + u;
      }),
      (i.Session.prototype.unsubscribe = function (n, t) {
        var r = this,
          u = r._prefixes.resolve(n, !0),
          f,
          e,
          o;
        if (u in r._subscriptions) {
          if (t !== undefined)
            if (((e = r._subscriptions[u].indexOf(t)), e !== -1))
              (f = t), r._subscriptions[u].splice(e, 1);
            else throw 'no callback ' + t + ' subscribed on topic ' + u;
          else (f = r._subscriptions[u].slice()), (r._subscriptions[u] = []);
          r._subscriptions[u].length === 0 &&
            (delete r._subscriptions[u],
            i._debugpubsub &&
              (console.group('WAMP Unsubscribe'),
              console.info(r._wsuri + '  [' + r._session_id + ']'),
              console.log(n),
              console.log(f),
              console.groupEnd()),
            (o = [i._MESSAGE_TYPEID_UNSUBSCRIBE, n]),
            r._send(o));
        } else throw 'not subscribed to topic ' + u;
      }),
      (i.Session.prototype.publish = function () {
        var o = this,
          t = arguments[0],
          r = arguments[1],
          f = null,
          n = null,
          e = null,
          u = null;
        if (arguments.length > 3) {
          if (!(arguments[2] instanceof Array)) throw 'invalid argument type(s)';
          if (!(arguments[3] instanceof Array)) throw 'invalid argument type(s)';
          n = arguments[2];
          e = arguments[3];
          u = [i._MESSAGE_TYPEID_PUBLISH, t, r, n, e];
        } else if (arguments.length > 2)
          if (typeof arguments[2] == 'boolean')
            (f = arguments[2]), (u = [i._MESSAGE_TYPEID_PUBLISH, t, r, f]);
          else if (arguments[2] instanceof Array)
            (n = arguments[2]), (u = [i._MESSAGE_TYPEID_PUBLISH, t, r, n]);
          else throw 'invalid argument type(s)';
        else u = [i._MESSAGE_TYPEID_PUBLISH, t, r];
        i._debugpubsub &&
          (console.group('WAMP Publish'),
          console.info(o._wsuri + '  [' + o._session_id + ']'),
          console.log(t),
          console.log(r),
          f !== null
            ? console.log(f)
            : n !== null && (console.log(n), e !== null && console.log(e)),
          console.groupEnd());
        o._send(u);
      }),
      (i.Session.prototype.authreq = function (n, t) {
        return this.call('http://api.wamp.ws/procedure#authreq', n, t);
      }),
      (i.Session.prototype.authsign = function (n, t) {
        return t || (t = ''), CryptoJS.HmacSHA256(n, t).toString(CryptoJS.enc.Base64);
      }),
      (i.Session.prototype.auth = function (n) {
        return this.call('http://api.wamp.ws/procedure#auth', n);
      }),
      (i._connect = function (t) {
        var r = new i.Session(
          t.wsuri,
          function () {
            t.connects += 1;
            t.retryCount = 0;
            t.onConnect(r);
          },
          function (r, u) {
            var f = null;
            switch (r) {
              case i.CONNECTION_CLOSED:
                t.onHangup(r, 'Connection was closed properly [' + u + ']');
                break;
              case i.CONNECTION_UNSUPPORTED:
                t.onHangup(r, 'Browser does not support WebSocket.');
                break;
              case i.CONNECTION_UNREACHABLE:
                if (((t.retryCount += 1), t.connects === 0))
                  t.onHangup(r, 'Connection could not be established.');
                else if (t.retryCount <= t.options.maxRetries)
                  if (
                    ((f = t.onHangup(
                      i.CONNECTION_UNREACHABLE_SCHEDULED_RECONNECT,
                      'Connection unreachable - scheduled reconnect to occur in ' +
                        t.options.retryDelay / 1e3 +
                        ' second(s) - attempt ' +
                        t.retryCount +
                        ' of ' +
                        t.options.maxRetries +
                        '.',
                      {
                        delay: t.options.retryDelay,
                        retries: t.retryCount,
                        maxretries: t.options.maxRetries,
                      }
                    )),
                    f)
                  ) {
                    i._debugconnect &&
                      console.log('Connection unreachable - retrying stopped by app');
                    t.onHangup(
                      i.CONNECTION_RETRIES_EXCEEDED,
                      'Number of connection retries exceeded.'
                    );
                  } else
                    i._debugconnect &&
                      console.log('Connection unreachable - retrying (' + t.retryCount + ') ..'),
                      n.setTimeout(function () {
                        i._connect(t);
                      }, t.options.retryDelay);
                else
                  t.onHangup(
                    i.CONNECTION_RETRIES_EXCEEDED,
                    'Number of connection retries exceeded.'
                  );
                break;
              case i.CONNECTION_LOST:
                if (((t.retryCount += 1), t.retryCount <= t.options.maxRetries))
                  if (
                    ((f = t.onHangup(
                      i.CONNECTION_LOST_SCHEDULED_RECONNECT,
                      'Connection lost - scheduled ' +
                        t.retryCount +
                        'th reconnect to occur in ' +
                        t.options.retryDelay / 1e3 +
                        ' second(s).',
                      {
                        delay: t.options.retryDelay,
                        retries: t.retryCount,
                        maxretries: t.options.maxRetries,
                      }
                    )),
                    f)
                  ) {
                    i._debugconnect && console.log('Connection lost - retrying stopped by app');
                    t.onHangup(i.CONNECTION_RETRIES_EXCEEDED, 'Connection lost.');
                  } else
                    i._debugconnect &&
                      console.log('Connection lost - retrying (' + t.retryCount + ') ..'),
                      n.setTimeout(function () {
                        i._connect(t);
                      }, t.options.retryDelay);
                else t.onHangup(i.CONNECTION_RETRIES_EXCEEDED, 'Connection lost.');
                break;
              default:
                throw 'unhandled close code in ab._connect';
            }
          },
          t.options
        );
      }),
      (i.connect = function (n, t, r, u) {
        var f = {};
        if (
          ((f.wsuri = n),
          (f.options = u ? u : {}),
          f.options.retryDelay === undefined && (f.options.retryDelay = 5e3),
          f.options.maxRetries === undefined && (f.options.maxRetries = 10),
          f.options.skipSubprotocolCheck === undefined && (f.options.skipSubprotocolCheck = !1),
          f.options.skipSubprotocolAnnounce === undefined &&
            (f.options.skipSubprotocolAnnounce = !1),
          t)
        )
          f.onConnect = t;
        else throw 'onConnect handler required!';
        f.onHangup = r
          ? r
          : function (n, t, r) {
              i._debugconnect && console.log(n, t, r);
            };
        f.connects = 0;
        f.retryCount = 0;
        i._connect(f);
      }),
      (i.launch = function (n, t, r) {
        i.connect(
          n.wsuri,
          function (r) {
            n.appkey && n.appkey !== ''
              ? r.authreq(n.appkey, n.appextra).then(function (u) {
                  var f = null,
                    e;
                  typeof n.appsecret == 'function'
                    ? (f = n.appsecret(u))
                    : ((e = i.deriveKey(n.appsecret, JSON.parse(u).authextra)),
                      (f = r.authsign(u, e)));
                  r.auth(f).then(function () {
                    t ? t(r) : i._debugconnect && r.log('Session opened.');
                  }, r.log);
                }, r.log)
              : r.authreq().then(function () {
                  r.auth().then(function () {
                    t ? t(r) : i._debugconnect && r.log('Session opened.');
                  }, r.log);
                }, r.log);
          },
          function (n, t, u) {
            r ? r(n, t, u) : i._debugconnect && i.log('Session closed.', n, t, u);
          },
          n.sessionConfig
        );
      }),
      i
    );
  });
ab._UA_FIREFOX = new RegExp('.*Firefox/([0-9+]*).*');
ab._UA_CHROME = new RegExp('.*Chrome/([0-9+]*).*');
ab._UA_CHROMEFRAME = new RegExp('.*chromeframe/([0-9]*).*');
ab._UA_WEBKIT = new RegExp('.*AppleWebKit/([0-9+.]*)w*.*');
ab._UA_WEBOS = new RegExp('.*webOS/([0-9+.]*)w*.*');
ab._matchRegex = function (n, t) {
  var i = t.exec(n);
  return i ? i[1] : i;
};
ab.lookupWsSupport = function () {
  var n = navigator.userAgent,
    t;
  return n.indexOf('MSIE') > -1
    ? n.indexOf('MSIE 10') > -1
      ? [!0, !0, !0]
      : n.indexOf('chromeframe') > -1
      ? ((t = parseInt(ab._matchRegex(n, ab._UA_CHROMEFRAME))), t >= 14)
        ? [!0, !1, !0]
        : [!1, !1, !1]
      : n.indexOf('MSIE 8') > -1 || n.indexOf('MSIE 9') > -1
      ? [!0, !0, !0]
      : [!1, !1, !1]
    : n.indexOf('Firefox') > -1
    ? ((t = parseInt(ab._matchRegex(n, ab._UA_FIREFOX))), t)
      ? t >= 7
        ? [!0, !1, !0]
        : t >= 3
        ? [!0, !0, !0]
        : [!1, !1, !0]
      : [!1, !1, !0]
    : n.indexOf('Safari') > -1 && n.indexOf('Chrome') == -1
    ? ((t = ab._matchRegex(n, ab._UA_WEBKIT)), t)
      ? n.indexOf('Windows') > -1 && t == '534+'
        ? [!0, !1, !0]
        : n.indexOf('Macintosh') > -1 &&
          ((t = t.replace('+', '').split('.')),
          (parseInt(t[0]) == 535 && parseInt(t[1]) >= 24) || parseInt(t[0]) > 535)
        ? [!0, !1, !0]
        : n.indexOf('webOS') > -1
        ? ((t = ab._matchRegex(n, ab._UA_WEBOS).split('.')), parseInt(t[0]) == 2)
          ? [!1, !0, !0]
          : [!1, !1, !1]
        : [!0, !0, !0]
      : [!1, !1, !1]
    : n.indexOf('Chrome') > -1
    ? ((t = parseInt(ab._matchRegex(n, ab._UA_CHROME))), t)
      ? t >= 14
        ? [!0, !1, !0]
        : t >= 4
        ? [!0, !0, !0]
        : [!1, !1, !0]
      : [!1, !1, !1]
    : n.indexOf('Android') > -1
    ? n.indexOf('Firefox') > -1
      ? [!0, !1, !0]
      : n.indexOf('CrMo') > -1
      ? [!0, !1, !0]
      : n.indexOf('Opera') > -1
      ? [!1, !1, !0]
      : n.indexOf('CrMo') > -1
      ? [!0, !0, !0]
      : [!1, !1, !1]
    : n.indexOf('iPhone') > -1 || n.indexOf('iPad') > -1 || n.indexOf('iPod') > -1
    ? [!1, !1, !0]
    : [!1, !1, !1];
};
`;
window.eval(iy);
class mp extends xe {
  constructor(t) {
    super(t), this._modelBounding = new ni(), this._selectionBounding = new ni(), this._pivot = d.zero(), this._hitRayOrigin = null, this._hitRayDirection = null, this._hitRayAperture = 0, this._hitRaySelectionOnly = !1, this._hitRaySelectionItem = null, this._client = {
      onConnect: () => {
        if (this._connexion === null)
          return;
        const e = this._viewer.getViewElement();
        e.addEventListener("focusin", () => {
          this._connexion !== null && this._connexion.update3dcontroller({ focus: !0 });
        }), e.addEventListener("focusout", () => {
          this._connexion !== null && this._connexion.update3dcontroller({ focus: !1 });
        }), this._connexion.create3dmouse(e, "WebViewer");
      },
      on3dmouseCreated: () => {
        this._3dMouseInitialized = !0, this._connexion !== null && (this._updateModelBounding(), this._connexion.update3dcontroller({ focus: !0 }));
      },
      onDisconnect: (e) => {
        console.log(`3Dconnexion NL-Server disconnected ${e}`);
      },
      getCoordinateSystem: () => [
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        1
      ],
      getConstructionPlane: () => null,
      getFov: () => {
        const e = this._viewer.view.getCamera(), i = e.getWidth(), s = d.subtract(e.getTarget(), e.getPosition()).length();
        return _l(2 * Math.atan(i / (2 * s)));
      },
      setFov: (e) => {
        const i = this._viewer.view.getCamera(), s = cs(e), r = Math.tan(s / 2), a = d.subtract(i.getTarget(), i.getPosition()).length() * r, l = i.getHeight() / i.getWidth();
        i.setWidth(a), i.setHeight(a * l), this._viewer.view.setCamera(i);
      },
      getPerspective: () => this._viewer.view.getCamera().getProjection() === te.Perspective,
      getViewExtents: () => {
        const e = this._viewer.view.getCamera(), i = e.getPosition(), s = e.getTarget(), r = e.getWidth() / 2, o = e.getHeight() / 2, a = d.subtract(i, s), l = e.getNearLimit(), c = a.z / l;
        return [-r, -o, c, r, o, l];
      },
      setViewExtents: (e) => {
        const i = new E(e[0], e[4]), s = new E(e[3], e[4]), r = new E(e[3], e[1]), o = E.distance(i, s), a = E.distance(s, r), l = this._viewer.view.getCamera();
        l.setWidth(o), l.setHeight(a), this._viewer.view.setCamera(l);
      },
      getViewFrustum: () => {
        const e = this._viewer.view.getCamera(), i = e.getWidth(), s = d.subtract(e.getTarget(), e.getPosition()).length(), r = 2 * Math.atan(i / (2 * s)), o = e.getWidth() / e.getHeight(), a = e.getNearLimit(), l = Math.tan(r * 0.5) * a, c = -l, h = o * c, u = o * l, p = d.distance(e.getPosition(), e.getTarget());
        return [h, u, c, l, a, p];
      },
      getViewMatrix: () => {
        const e = this._viewer.view.getCamera(), i = e.getUp().normalize(), s = d.subtract(e.getTarget(), e.getPosition()).normalize(), r = d.cross(s, i).normalize(), o = e.getPosition();
        return [
          r.x,
          r.y,
          r.z,
          0,
          i.x,
          i.y,
          i.z,
          0,
          -s.x,
          -s.y,
          -s.z,
          0,
          o.x,
          o.y,
          o.z,
          1
        ];
      },
      setViewMatrix: (e) => {
        const i = this._viewer.view.getCamera(), s = new d(e[4], e[5], e[6]), r = new d(-e[8], -e[9], -e[10]), o = new d(e[12], e[13], e[14]), a = d.subtract(i.getPosition(), i.getTarget()).length(), l = o.copy().add(r.copy().scale(a));
        i.setTarget(l), i.setPosition(o), i.setUp(s), this._viewer.view.setCamera(i);
      },
      getViewRotatable: () => !this._viewer.model.isDrawing(),
      getViewTarget: () => {
        const e = this._viewer.view.getCamera().getTarget();
        return [e.x, e.y, e.z];
      },
      getFrontView: () => [
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        1
      ],
      getPivotPosition: () => [this._pivot.x, this._pivot.y, this._pivot.z],
      setPivotPosition: (e) => {
        this._pivot = d.createFromArray(e);
      },
      setPivotVisible: (e) => {
        this._pivotMarkup.enable(e);
      },
      getPointerPosition: () => {
        const e = this._viewer.view.unprojectPoint(this._ptCurrent, 0);
        return e === null ? [0, 0, 0] : [e.x, e.y, e.z];
      },
      getModelExtents: () => [
        this._modelBounding.min.x,
        this._modelBounding.min.y,
        this._modelBounding.min.z,
        this._modelBounding.max.x,
        this._modelBounding.max.y,
        this._modelBounding.max.z
      ],
      setLookFrom: (e) => {
        this._hitRayOrigin = d.createFromArray(e), this._updateHitTest();
      },
      setLookDirection: (e) => {
        this._hitRayDirection = d.createFromArray(e);
      },
      setLookAperture: (e) => {
        this._hitRayAperture = e;
      },
      setSelectionOnly: (e) => {
        this._hitRaySelectionOnly = e, this._updateHitTest();
      },
      getLookAt: () => {
        if (this._hitRaySelectionItem === null)
          return null;
        const e = this._hitRaySelectionItem.getPosition();
        return e === null ? null : [e.x, e.y, e.z];
      },
      getSelectionEmpty: () => this._viewer.selectionManager.getFirst() === null,
      getSelectionExtents: () => [
        this._selectionBounding.min.x,
        this._selectionBounding.min.y,
        this._selectionBounding.min.z,
        this._selectionBounding.max.x,
        this._selectionBounding.max.y,
        this._selectionBounding.max.z
      ]
    }, this._connexion = null, this._3dMouseInitialized = !1, this._pivotMarkup = new Lh(t), this._viewer.setCallbacks({
      modelStructureReady: () => {
        this._updateModelBounding();
      },
      subtreeLoaded: () => {
        this._updateModelBounding();
      },
      subtreeDeleted: () => {
        this._updateModelBounding();
      },
      selectionArray: () => {
        this._updateSelectionBounding();
      },
      frameDrawn: () => {
        let e = this._viewer.view.projectPoint(this._pivot);
        if (this._hitRaySelectionItem !== null) {
          const s = this._hitRaySelectionItem.getPosition();
          s !== null && (e = s);
        }
        const i = new E(e.x, e.y);
        this._pivotMarkup.setPosition(i), this._pivotMarkup.draw();
      }
    });
  }
  async _updateModelBounding() {
    if (this._connexion === null || !this._3dMouseInitialized)
      return;
    this._modelBounding = await this._viewer.model.getModelBounding(!0, !0);
    const t = this._modelBounding.center();
    this._connexion.update3dcontroller({
      pivot: {
        position: [t.x, t.y, t.z]
      }
    }), this._pivot = t;
  }
  async _updateSelectionBounding() {
    if (this._connexion === null || !this._3dMouseInitialized)
      return;
    const t = this._viewer.selectionManager.getResults().map((e) => e.getNodeId());
    if (t.length === 0) {
      this._selectionBounding = new ni();
      return;
    }
    this._selectionBounding = await this._viewer.model.getNodesBounding(t);
  }
  async _updateHitTest() {
    this._hitRayAperture;
    const t = this._viewer;
    if (this._hitRayOrigin === null || this._hitRayDirection === null)
      return;
    const e = new Gn(this._hitRayOrigin, this._hitRayDirection), i = new be(), s = await t.view.pickFromRay(e, i), r = s.getNodeId();
    if (r === null) {
      this._hitRaySelectionItem = null;
      return;
    }
    if (this._hitRaySelectionOnly && !t.selectionManager.isNodeSelected(r)) {
      this._hitRaySelectionItem = null;
      return;
    }
    this._hitRaySelectionItem = s;
  }
  /**
   * Connect to the space mouse. To be successful, this method
   * should be called in the sceneReady callback. If you want to
   * connect at a later time, the canvas where the mouse is
   * to be used must have focus.
   *
   * Note: If this is called but the 3d connexion software is not running,
   * a connection error will be shown in the console.
   */
  connect() {
    this._connexion = new _3Dconnexion(this._client), this._connexion.connect();
  }
}
const j0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AreaSelectionOperator: np,
  AxisTriadOperator: sp,
  ButtonModifier: Jc,
  Camera: U_,
  CuttingPlaneOperator: op,
  CuttingPlaneOperatorContext: rp,
  FloorplanOperator: ap,
  HandleOperator: lp,
  Markup: ty,
  Measure: Q_,
  NavCubeOperator: cp,
  NoteOperator: hp,
  OperatorBase: xe,
  RayDrillSelectionOperator: up,
  Redline: ey,
  SelectionOperator: dp,
  SelectionRectangleMarkup: Rh,
  SpaceMouseOperator: mp
}, Symbol.toStringTag, { value: "Module" }));
var eh = /* @__PURE__ */ ((n) => (n[n.Cutoff = 476837158203125e-21] = "Cutoff", n))(eh || {});
class _u {
  constructor() {
    this.plane = new je(), this.referenceGeometry = null, this.meshId = null, this.instanceNodeId = null, this.color = it.createFromFloat(0.65, 0.65, 0.65), this.lineColor = it.black(), this.opacity = 0.35, this.matrix = new Q();
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {
      plane: {
        normal: this.plane.normal,
        d: this.plane.d
      },
      referenceGeometry: this.referenceGeometry
    };
  }
  fromJson(t) {
    const e = Lo(t), i = e.plane;
    this.plane = new je();
    const s = i.normal;
    this.plane.normal = new d(s.x, s.y, s.z), this.plane.d = i.d;
    const r = e.referenceGeometry;
    if (Array.isArray(r))
      for (let o = 0; o < r.length; ++o)
        r[o] = d.fromJson(r[o]);
    this.referenceGeometry = r;
  }
  getMatrix() {
    return this.matrix.copy();
  }
  setMatrix(t) {
    this.matrix = t.copy();
  }
  setReferenceGeometry(t) {
    if (t) {
      this.referenceGeometry = [];
      for (const e of t)
        this.referenceGeometry.push(e.copy());
    } else
      this.referenceGeometry = null;
  }
  getReferenceGeometry() {
    if (this.referenceGeometry) {
      const t = [];
      for (const e of this.referenceGeometry)
        t.push(e.copy());
      return t;
    } else
      return null;
  }
  createMeshData() {
    const t = this.referenceGeometry;
    if (t === null)
      return null;
    const e = new Hi(), i = [], s = [];
    i.push(t[0].x, t[0].y, t[0].z), i.push(t[1].x, t[1].y, t[1].z), i.push(t[3].x, t[3].y, t[3].z), i.push(t[1].x, t[1].y, t[1].z), i.push(t[2].x, t[2].y, t[2].z), i.push(t[3].x, t[3].y, t[3].z);
    const o = je.createFromPoints(t[0], t[1], t[2]).normal;
    for (let a = 0; a < 6; a++)
      s.push(o.x, o.y, o.z);
    return e.addFaces(i, s), e.addPolyline([t[0].x, t[0].y, t[0].z, t[1].x, t[1].y, t[1].z]), e.addPolyline([t[1].x, t[1].y, t[1].z, t[2].x, t[2].y, t[2].z]), e.addPolyline([t[2].x, t[2].y, t[2].z, t[3].x, t[3].y, t[3].z]), e.addPolyline([t[3].x, t[3].y, t[3].z, t[0].x, t[0].y, t[0].z]), e;
  }
}
class ny {
  /** @hidden */
  constructor(t, e, i, s, r) {
    this._cuttingPlanes = [], this._isActive = !1, this._viewer = t, this._model = e, this._callbackManager = i, this._cuttingManager = s, this._engine = r;
  }
  /**
   * Adds a plane to the cutting section.
   * @param plane The plane to be used for cutting.
   * @param referenceGeometry An optional list of four points representing a quad to be used as reference geometry for the cutting plane. Pass null to use no reference geometry for this cutting plane.
   */
  async addPlane(t, e = null) {
    const i = this._engine.getCuttingSectionLimits();
    if (this._cuttingPlanes.length >= i.maxCuttingPlanesPerSection)
      return !1;
    const s = new _u();
    return s.plane = t.copy(), s.setReferenceGeometry(e), this._cuttingPlanes.push(s), this._isActive && (await this._resetCuttingPlane(s), await this._engine.updateCuttingSection(this)), !0;
  }
  /**
   * Sets a plane currently in the cutting section at a given index.
   * @param index The index of the cutting plane to replace.
   * @param plane The plane to be used for cutting.
   * @param referenceGeometry a list of four points representing a quad to be used as reference geometry for the cutting plane. Pass null to use no reference geometry for this cutting plane.
   */
  async setPlane(t, e, i = null) {
    const s = this._cuttingPlanes[t];
    if (s !== void 0 && (s.plane = e.copy(), s.setReferenceGeometry(i), this._isActive))
      return await this._resetCuttingPlane(s), this._engine.updateCuttingSection(this);
  }
  /**
   * Updates the position of a cutting plane and stand-in geometry if present.
   * @param index The index of the cutting plane.
   * @param plane The plane to use for cutting.
   * @param geometryMatrix A matrix that is multiplied by the previous position matrix to update the geometry position.
   * @param finalizePosition If true, sets the result of the geometry matrix multiplication as the new position matrix.
   * @param resetTranslation If true, uses the provided geometry matrix for the geometry position.
   */
  async updatePlane(t, e, i = new Q(), s = !1, r = !1) {
    const o = this._cuttingPlanes[t];
    if (o !== void 0 && (o.plane = e.copy(), this._isActive))
      if (o.instanceNodeId !== null) {
        this._engine.pauseRendering();
        let a = o.getMatrix();
        r && (a = new Q());
        const l = Q.multiply(a, i);
        s && o.setMatrix(l), await Promise.all([
          this._model.setNodeMatrix(o.instanceNodeId, l),
          this._engine.updateCuttingSection(this)
        ]), this._engine.resumeRendering();
      } else
        return this._engine.updateCuttingSection(this);
  }
  /**
   * Removes the cutting plane at the specified index.
   * @param index The index of the cutting plane to remove.
   */
  removePlane(t) {
    const e = [], i = this._cuttingPlanes[t];
    return i !== void 0 && (i.meshId !== null && i.instanceNodeId !== null && e.push(this._destroyMeshes([i.meshId], [i.instanceNodeId])), this._cuttingPlanes.splice(t, 1)), this._isActive && e.push(this._engine.updateCuttingSection(this)), zt(e);
  }
  /**
   * Gets the plane for the item at the given index. In the case of an invalid index, null will be returned.
   * @param index The index of the cutting plane.
   * @returns Plane that is used for cutting at the given index or null.
   */
  getPlane(t) {
    const e = this._cuttingPlanes[t];
    return e !== void 0 ? e.plane.copy() : null;
  }
  /**
   * Gets the [[NodeId]] for the reference geometry for the cutting plane at the given index.
   * In the case of an invalid index or a cutting plane with no reference geometry, null will be returned.
   * @param index the index of the cutting plane.
   * @returns [[NodeId]] of the reference geometry for the cutting plane at the given index or null.
   */
  getNodeId(t) {
    const e = this._cuttingPlanes[t];
    return e !== void 0 ? e.instanceNodeId : null;
  }
  /**
   * Gets the reference geometry for the item at the given index. In the case of an invalid index, null will be returned
   * @param index The index of the cutting plane.
   * @returns A list of four points representing a quad to be used as reference geometry for the cutting plane, or null if there is no reference geometry.
   */
  getReferenceGeometry(t) {
    const e = this._cuttingPlanes[t];
    return e !== void 0 ? e.getReferenceGeometry() : null;
  }
  /**
   * Gets the index of a plane for the corresponding node id. In the case of an invalid id, null will be returned.
   * @param id The [[NodeId]] for the plane reference geometry.
   * @returns The index of a plane associated with the provided [[NodeId]], or null if no plane is found.
   */
  getPlaneIndexByNodeId(t) {
    for (let e = 0; e < this._cuttingPlanes.length; e++)
      if (this._cuttingPlanes[e].instanceNodeId === t)
        return e;
    return null;
  }
  /**
   * Gets the opacity for the plane at the given index.
   * @param index The index of the cutting plane.
   */
  getPlaneOpacity(t) {
    const e = this._cuttingPlanes[t];
    if (e)
      return e.opacity;
  }
  /**
   * Sets the opacity for the plane at the given index.
   *
   * Equivalent to `section.applyPlaneOpacity(index, opacity)`
   *
   * @param index The index of the cutting plane.
   * @param opacity A number between 0 and 1.
   */
  setPlaneOpacity(t, e) {
    this.applyPlaneOpacity(t, e);
  }
  /**
   * Apply the opacity factor to the plane.
   *
   * @param index The index of the cutting plane.
   * @param opacity The value used to change the opacity if needed
   */
  applyPlaneOpacity(t, e) {
    const i = this._cuttingPlanes[t];
    i !== void 0 && (e && (i.opacity = e), i.instanceNodeId !== null && this._model.setNodesOpacity([i.instanceNodeId], i.opacity));
  }
  /**
   * Reapply the opacity of the cutting planes to the engine
   * This function must be explicitly called after _resetOpacity has been emitted by the engine
   */
  resetPlanesOpacity() {
    this._cuttingPlanes.forEach((t, e) => {
      this.applyPlaneOpacity(e);
    });
  }
  /**
   * Sets the color for all planes in the cutting section
   * @param color Color to set
   * @returns Promise that resolves when the operation has completed.
   */
  setColor(t) {
    const e = [];
    for (const i of this._cuttingPlanes)
      i.color.assign(t), i.instanceNodeId !== null && e.push(i.instanceNodeId);
    return this._model.setNodesFaceColor(e, t), Promise.resolve();
  }
  /**
   * Sets the opacity for all planes in the cutting section
   * @param opacity opacity to set
   */
  setOpacity(t) {
    const e = [];
    for (const i of this._cuttingPlanes)
      i.opacity = t, i.instanceNodeId !== null && e.push(i.instanceNodeId);
    this._model.setNodesOpacity(e, t);
  }
  /**
   * Gets the number of planes in this cutting secton.
   * @returns the number of planes in this cutting section
   */
  getCount() {
    return this._cuttingPlanes.length;
  }
  /**
   * Removes all planes from this cutting section. This will also deactivate the cutting section.
   */
  async clear() {
    await this.deactivate(), this._cuttingPlanes.length = 0;
  }
  /**
   * Activates a cutting section for use. A cutting section must have at least one plane to be activated.
   * @returns a promise if the cutting section was activated.
   */
  async activate() {
    if (!this._isActive) {
      if (this._isActive = !0, this._cuttingPlanes.length > 0) {
        this._cuttingManager.hasActiveCuttingSection() || this._engine.setDefaultDepthRange(0, 1 - eh.Cutoff);
        const t = [], e = [];
        for (const i of this._cuttingPlanes)
          t.push(
            this._createCuttingPlaneGeometry(i).then((s) => {
              s !== null && e.push(s);
            })
          );
        await zt(t), this._initCuttingPlanesByNodeId(e);
      }
      return this._engine.addCuttingSection(this);
    }
  }
  /**
   * Removes a cutting section from use.
   */
  async deactivate() {
    if (this._isActive) {
      this._isActive = !1;
      const t = [];
      return t.push(this._destroyGeometry()), t.push(this._engine.removeCuttingSection(this)), this._cuttingManager.hasActiveCuttingSection() || this._engine.setDefaultDepthRange(0, 1), zt(t);
    }
  }
  /**
   * Gets whether a cutting section is active
   * @returns boolean value indicating whether this cutting section is active
   */
  isActive() {
    return this._isActive;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (let e = 0; e < this._cuttingPlanes.length; e++)
      t[e] = this._cuttingPlanes[e].toJson();
    return {
      planes: t
    };
  }
  async fromJson(t) {
    await this.clear();
    const i = Lo(t).planes;
    for (const s of i) {
      const r = new _u();
      r.fromJson(s), this._cuttingPlanes.push(r);
    }
    return this.activate();
  }
  _initCuttingPlanesByNodeId(t) {
    this._model.setInstanceModifier(Xe.DoNotCut, t, !0), this._model.setInstanceModifier(Xe.DoNotExplode, t, !0), this._cuttingManager.getStandinGeometryPickable() || this._model.setInstanceModifier(Xe.DoNotSelect, t, !0);
  }
  _destroyGeometry() {
    const t = [], e = [];
    for (const i of this._cuttingPlanes)
      i.meshId !== null && t.push(i.meshId), i.instanceNodeId !== null && e.push(i.instanceNodeId), i.meshId = null, i.instanceNodeId = null;
    return this._destroyMeshes(t, e);
  }
  /** @hidden */
  _getInstanceNodeIds() {
    const t = [];
    for (const e of this._cuttingPlanes) {
      const i = e.instanceNodeId;
      i !== null && t.push(i);
    }
    return t;
  }
  async _resetCuttingPlane(t) {
    if (t.meshId !== null && t.instanceNodeId !== null) {
      const e = this._destroyMeshes([t.meshId], [t.instanceNodeId]);
      return t.meshId = null, t.instanceNodeId = null, await e, this._createInstanceGeometry(t);
    } else if (t.referenceGeometry !== null)
      return this._createInstanceGeometry(t);
  }
  async _createInstanceGeometry(t) {
    const e = [], i = await this._createCuttingPlaneGeometry(t);
    i !== null && e.push(i), this._initCuttingPlanesByNodeId(e);
  }
  async _destroyMeshes(t, e) {
    const i = [];
    i.push(this._model.deleteMeshInstances(e)), i.push(this._model.deleteMeshes(t)), await zt(i);
    for (const s of e)
      this._viewer.selectionManager._incrementalBlacklistedInstanceNodes.delete(s);
  }
  async _createCuttingPlaneGeometry(t) {
    const e = t.createMeshData();
    if (e === null)
      return null;
    e.setBackfacesEnabled(!0);
    const i = await this._model.createMesh(e);
    t.meshId = i;
    const s = xt.OverrideSceneVisibility | xt.ExcludeBounding | xt.DoNotXRay, r = t.plane.copy(), o = r.normal.copy().scale(-r.d), a = new Q().setTranslationComponent(o.x, o.y, o.z);
    t.setMatrix(a.copy());
    const l = new bn(
      i,
      a,
      null,
      t.color,
      null,
      null,
      s
    );
    l.setLineColor(t.lineColor), this._engine.pauseRendering();
    const c = await this._model.createMeshInstance(l, void 0, !0, !0);
    return t.instanceNodeId = c, this._viewer.selectionManager._incrementalBlacklistedInstanceNodes.add(c), this._model.setDepthRange([c], eh.Cutoff, 1), this._model.setNodesOpacity([c], t.opacity), this._engine.resumeRendering(), c;
  }
}
const Ki = class {
  /** @hidden */
  constructor(n) {
    this._position = new Xs(0, Bt.Pixels, 0, Bt.Pixels), this._viewportSize = new Xs(
      1,
      Bt.ProportionOfOtherDimension,
      0.2,
      Bt.ProportionOfCanvas
    ), this._anchor = Jt.LowerLeftCorner, this._instanceKeys = [], this._enabled = !1, this._sceneReadyCompleted = ye(), this._geometryCreated = !1, this._viewer = n, this._viewer.setCallbacks({
      sceneReady: async () => {
        this._createViewport(), this._updateVisibility(), await this._createGeometry(), this._sceneReadyCompleted.resolve();
      },
      _assemblyTreeReady: async () => {
        await this._sceneReadyCompleted;
        const t = this._viewer.model;
        for (const e of this._instanceKeys) {
          const i = t._getNodeFromInstanceInc(!0, ve.Local, e, !0);
          t._preventNodeDeletion(i);
        }
      },
      _firstAttachment: async () => {
        await this._onCameraUpdate(), this._updateVisibility();
      },
      overlayViewportSet: (t) => {
        t === Gt.AxisTriad && this._onViewportSet();
      }
    });
  }
  /**
   * Sets the color of one axis on this [[AxisTriad]]
   * @param axis The axis that will change color
   * @param color The color to set
   */
  async setAxisColor(n, t) {
    await this._sceneReadyCompleted;
    let e, i;
    switch (n) {
      case Ht.X:
        e = this._instanceKeys[0], i = this._instanceKeys[3];
        break;
      case Ht.Y:
        e = this._instanceKeys[1], i = this._instanceKeys[4];
        break;
      case Ht.Z:
        e = this._instanceKeys[2], i = this._instanceKeys[5];
        break;
      default:
        return;
    }
    const s = this._getScEngine();
    s.setPartColor([ve.Local, e], vt.Faces, t), s.setPartColor([ve.Local, i], vt.Lines, t);
  }
  /**
   * Sets the anchor position for this [[AxisTriad]].
   * @param anchor The anchor position.
   * @returns A promise that resolves on completion.
   */
  async setAnchor(n) {
    return this._anchor = n, await this._sceneReadyCompleted, this._updateViewport();
  }
  /**
   * Gets the anchor position for this [[AxisTriad]].
   * Default position is in the lower left corner.
   * @returns The overlay anchor value of the triad.
   */
  getAnchor() {
    return this._anchor;
  }
  /**
   * Enables this [[AxisTriad]].
   * @returns A promise that resolves on completion.
   */
  enable() {
    return this._enabled = !0, this._updateVisibility(), Promise.resolve();
  }
  /**
   * Disables this [[AxisTriad]].
   * @returns A promise that resolves on completion.
   */
  disable() {
    return this._enabled = !1, this._updateVisibility(), Promise.resolve();
  }
  /**
   * Updates the visibility of this [[AxisTriad]] based on the enabled status.
   * @returns A promise that resolves on completion.
   */
  _updateVisibility() {
    this._enabled ? this._showOverlay() : this._hideOverlay();
  }
  /**
   * Hides the overlay window.
   * @returns A promise that resolves on completion.
   */
  _hideOverlay() {
    this._viewer.overlayManager.setVisibility(Gt.AxisTriad, !1);
  }
  /**
   * Shows the overlay window.
   * @returns A promise that resolves on completion.
   */
  _showOverlay() {
    this._viewer.overlayManager.setVisibility(Gt.AxisTriad, !0);
  }
  /**
   * Gets the current state of this [[AxisTriad]].
   * @returns `true` if enabled and `false` otherwise.
   */
  getEnabled() {
    return this._enabled;
  }
  /**
   * Gets the overlay id. This id should be considered reserved and not be used by client applications.
   * @returns The overlay id used by this [[AxisTriad]].
   */
  getOverlayId() {
    return Gt.AxisTriad;
  }
  _updateViewport() {
    this._viewer.overlayManager.setViewport(
      Gt.AxisTriad,
      this._anchor,
      this._position.x,
      Bt.Pixels,
      this._position.y,
      Bt.Pixels,
      this._viewportSize.x,
      this._viewportSize.xUnit,
      this._viewportSize.y,
      this._viewportSize.yUnit
    );
  }
  _createViewport() {
    const n = this._viewer.overlayManager;
    this._updateViewport();
    const t = new ci();
    t.setPosition(new d(0, 0, 10)), t.setTarget(d.zero()), t.setUp(new d(0, 1, 0)), t.setWidth(Ki._fieldSize), t.setHeight(Ki._fieldSize), t.setProjection(te.Orthographic), n.setCamera(Gt.AxisTriad, t);
  }
  _onViewportSet() {
    const n = this._viewer.overlayManager, t = n._getViewportPosition(Gt.AxisTriad), e = n._getViewportSize(Gt.AxisTriad), i = n.getViewportAnchor(Gt.AxisTriad);
    t === null || e === null || i === null || (this._position = t, this._viewportSize = e, this._anchor = i);
  }
  async _createGeometry() {
    if (this._geometryCreated)
      return;
    const n = [
      this._createAxis(Ki._xRotMatrix, 0, Ki._xColor),
      this._createAxis(Ki._yRotMatrix, 1, Ki._yColor),
      this._createAxis(Ki._zRotMatrix, 2, Ki._zColor),
      this._createAxisLabel(Ht.X, Ki._xColor, 3),
      this._createAxisLabel(Ht.Y, Ki._yColor, 4),
      this._createAxisLabel(Ht.Z, Ki._zColor, 5)
    ], t = await Promise.all(n);
    this._onCameraUpdate();
    const e = [];
    for (const s of t)
      e.push(ve.Local, s);
    this._getScEngine().setPartVisibility(e, !0, !0), this._createGeomCallbacks(), this._geometryCreated = !0;
  }
  _createGeomCallbacks() {
    this._viewer.setCallbacks({
      camera: () => {
        this._onCameraUpdate();
      }
    });
  }
  /** @hidden */
  _geometryHasBeenCreated() {
    return this._geometryCreated;
  }
  /**
   * Determines whether or not a point is inside the axis triad overlay
   * @param mousePos
   * @returns Boolean indicating whether the provided point is inside the axis triad overlay
   */
  insideOverlay(n) {
    const t = this._viewer.overlayManager._toPixelPoint(this._viewportSize), e = this._getOverlayOffset();
    return n.x >= e.x && n.y >= e.y && n.x <= e.x + t.x && n.y <= e.y + t.y;
  }
  /** @hidden */
  _getOverlayOffset() {
    const n = this._viewer.overlayManager._toPixelPoint(this._viewportSize);
    return this._viewer.overlayManager._getOverlayOffset(this._anchor, n);
  }
  /** @hidden */
  _getViewportSize() {
    return this._viewportSize;
  }
  /** @hidden */
  _getViewportPixelSize() {
    return this._viewer.overlayManager._toPixelPoint(this._viewportSize);
  }
  /**
   * Checks if a selection is part of the axis triad, and return the corresponding axis.
   * @param selectionItem selection item to check.
   * @returns Axis if selected, null otherwise.
   */
  getSelectionAxis(n) {
    if (console.assert(this._enabled), n === null || !n.isFaceSelection() || n.overlayIndex() !== Gt.AxisTriad)
      return null;
    const t = this._viewer.model, e = n.getNodeId(), i = t._gatherInstanceIncsFromNodeIds([e], bt.BodyInstance);
    if (i.length !== 2 || i[0] !== ve.Local)
      return null;
    const s = i[1];
    for (let r = 0; r < this._instanceKeys.length; ++r)
      if (this._instanceKeys[r] === s)
        switch (r % 3) {
          case 0:
            return Ht.X;
          case 1:
            return Ht.Y;
          case 2:
            return Ht.Z;
        }
    return null;
  }
  /**
   * Called when the axis triad is clicked. Realigns the view along the axis selected by `selection`
   * or does nothing if no axis is selected.
   * @param selection
   */
  async onClickSelection(n) {
    const t = this.getSelectionAxis(n);
    if (t === null)
      return;
    const e = this._viewer.model, i = this._viewer.view;
    let s;
    switch (t) {
      case Ht.X:
        s = ao.EyeX_UpY;
        break;
      case Ht.Y:
        s = ao.EyeY_UpZ;
        break;
      case Ht.Z:
        s = ao.EyeZ_UpX;
        break;
    }
    const r = await e.getModelBounding(!0, !1), o = i.getCamera();
    let a = this._alignedFitBounding(s, !1, !1, r);
    o.equals(a) && (a = this._alignedFitBounding(s, !0, !1, r)), await i._setCameraPromise(a, Ri);
    const l = this._viewer.model.getAbsoluteRootNode();
    if (this._viewer.model.getNodeChildren(l).length === 0)
      return this._viewer._getScEngine().markCameraAsEmpty();
  }
  _getScEngine() {
    return this._viewer._getScEngine();
  }
  async _createInstance(n, t, e, i, s, r) {
    const o = await this._viewer.model.createMesh(n), a = new bn(o);
    a.setCreationFlags(
      r | xt.DoNotCut | xt.DoNotExplode | xt.ExcludeBounding | xt.Invisible
    ), a.setOverlayIndex(Gt.AxisTriad), a.setFaceColor(e), a.setLineColor(i), a.setMatrix(s);
    const h = (await this._getScEngine().createMeshInstance(a))[1];
    return this._instanceKeys[t] = h, h;
  }
  _createAxis(n, t, e) {
    const i = _h(
      dn.CylinderRadius,
      dn.SegmentCount,
      dn.StemHeight,
      dn.ConeBaseRadius,
      dn.CapHeight,
      dn.TaperHeight
    );
    return this._createInstance(
      i,
      t,
      e,
      it.black(),
      n,
      xt.None
    );
  }
  _createAxisLabel(n, t, e) {
    const i = new Hi();
    i.setFaceWinding(yn.Clockwise);
    const s = 0.5 * dn.LetterWidth, r = 0.5 * dn.LetterHeight, o = dn.StemHeight + dn.CapHeight + dn.LetterOffsetPos, a = new Q();
    return n === Ht.X ? (i.addPolyline([s, r, 0, -s, -r, 0]), i.addPolyline([-s, r, 0, s, -r, 0]), a.setTranslationComponent(o, 0, 0)) : n === Ht.Y ? (i.addPolyline([-s, r, 0, 0, 0, 0]), i.addPolyline([0, 0, 0, s, r, 0]), i.addPolyline([0, 0, 0, 0, -1.25 * r, 0]), a.setTranslationComponent(0, o, 0)) : n === Ht.Z && (i.addPolyline([-s, r, 0, s, r, 0]), i.addPolyline([s, r, 0, -s, -r, 0]), i.addPolyline([-s, -r, 0, s, -r, 0]), a.setTranslationComponent(0, 0, o)), this._createInstance(
      i,
      e,
      it.black(),
      t,
      a,
      xt.ScreenOriented
    );
  }
  _onCameraUpdate() {
    const n = new ci(), t = this._viewer.view.getCamera();
    n.setPosition(
      t.getPosition().subtract(t.getTarget()).normalize()
    ), n.setTarget(d.zero()), n.setUp(t.getUp()), n.setProjection(te.Orthographic), n.setWidth(Ki._fieldSize), n.setHeight(Ki._fieldSize), this._viewer.overlayManager.setCamera(Gt.AxisTriad, n);
  }
  _alignedFitBounding(n, t, e, i) {
    const s = d.subtract(i.max, i.min).length(), r = d.add(d.scale(i.min, 0.5), d.scale(i.max, 0.5)), o = new d(r.x, r.y, r.z + s), a = d.subtract(r, o);
    let l = -a.length();
    const c = e ? -1 : 1;
    let h, u;
    n === ao.None ? (h = a, u = new d(0, c, 0), t && h.negate()) : (t && (l = -l), n & Ea.X ? h = new d(l, 0, 0) : n & Ea.Y ? h = new d(0, l, 0) : (console.assert((n & Ea.Z) !== 0), h = new d(0, 0, l)), n & Na.X ? u = new d(c, 0, 0) : n & Na.Y ? u = new d(0, c, 0) : (console.assert((n & Na.Z) !== 0), u = new d(0, 0, c)));
    const p = d.subtract(r, h), m = this._viewer.view.getCamera();
    return ci.create(
      p,
      r,
      u,
      m.getProjection(),
      s,
      s,
      m.getNearLimit()
    );
  }
};
let As = Ki;
As._xRotMatrix = Q.createFromOffAxisRotation(new d(0, 0, 1), -90);
As._yRotMatrix = new Q();
As._zRotMatrix = Q.createFromOffAxisRotation(new d(1, 0, 0), 90);
As._xColor = new it(168, 56, 59);
As._yColor = new it(96, 166, 50);
As._zColor = new it(41, 81, 185);
As._fieldSize = 8;
class sy {
  /** @hidden */
  constructor(t, e, i, s) {
    this._cuttingSections = [], this._isInit = !1, this._standinGeometryPickable = !0, this._cappingFaceColor = it.createFromFloat(0.5, 0.5, 0.5), this._cappingLineColor = it.createFromFloat(0.5, 0.5, 0.5), this._cappingIdleCallbackEnabled = !1, this._cappingIdlePromise = null, this._conservativeIsCappingIdle = !1, this._viewer = t, this._model = e, this._callbackManager = i, this._engine = s, t.setCallbacks({
      cappingIdle: (r) => {
        this._conservativeIsCappingIdle = r, r && this._cappingIdlePromise !== null && (this._cappingIdlePromise.resolve(), this._cappingIdlePromise = null);
      },
      _resetAssemblyTreeBegin: () => (this._cappingIdlePromise !== null && (this._cappingIdlePromise.reject(new Mt("Model became reset.")), this._cappingIdlePromise = null), Promise.resolve()),
      _resetOpacity: () => {
        this._cuttingSections.forEach((r) => r.resetPlanesOpacity());
      }
    });
  }
  /**
   * generates reference geometry for a cutting plane.
   * @param axis axis for reference geometry.
   * @param modelBounding modelBounding for geometry size.
   */
  createReferenceGeometryFromAxis(t, e) {
    const i = [];
    switch (t) {
      case Ht.X:
        i.push(new d(0, e.max.y, e.min.z)), i.push(new d(0, e.max.y, e.max.z)), i.push(new d(0, e.min.y, e.max.z)), i.push(new d(0, e.min.y, e.min.z));
        break;
      case Ht.Y:
        i.push(new d(e.min.x, 0, e.min.z)), i.push(new d(e.max.x, 0, e.min.z)), i.push(new d(e.max.x, 0, e.max.z)), i.push(new d(e.min.x, 0, e.max.z));
        break;
      case Ht.Z:
        i.push(new d(e.min.x, e.max.y, 0)), i.push(new d(e.max.x, e.max.y, 0)), i.push(new d(e.max.x, e.min.y, 0)), i.push(new d(e.min.x, e.min.y, 0));
        break;
    }
    return i;
  }
  /**
   * Uses a selection normal and position to create reference geometry for a cutting plane.
   * @param normal face normal.
   * @param position face position.
   * @param modelBounding model bounding for geometry size.
   */
  createReferenceGeometryFromFaceNormal(t, e, i) {
    const s = [], r = new je().setFromPointAndNormal(e, t).d, o = e.copy().add(d.scale(t, r)), a = i.center(), l = d.add(
      a,
      d.scale(t, d.dot(t, d.subtract(o, a)))
    ), c = i.extents().length() / 2, h = d.subtract(l, o), u = d.cross(t, h), p = h.copy().scale(-1), m = u.copy().scale(-1), g = d.add(h, u).normalize().scale(c).add(l), _ = d.add(p, u).normalize().scale(c).add(l), y = d.add(p, m).normalize().scale(c).add(l), b = d.add(h, m).normalize().scale(c).add(l);
    return s.push(g), s.push(_), s.push(y), s.push(b), s;
  }
  /**
   * Activates all cutting sections, and restores any planes contained to the scene.
   */
  activateCuttingSections() {
    const t = [];
    for (const e of this._cuttingSections)
      t.push(e.activate());
    return zt(t);
  }
  /**
   * Deactivates all cutting sections.
   * Cutting planes are not removed from section and can be restored using [[activateCuttingSections]]
   */
  deactivateAllCuttingSections() {
    const t = [];
    for (const e of this._cuttingSections)
      t.push(e.deactivate());
    return zt(t);
  }
  /**
   * Clears all cutting sections.
   * This causes all cutting sections to be deactivated and all their cutting planes removed.
   */
  clearAllCuttingSections() {
    const t = [];
    for (const e of this._cuttingSections)
      t.push(e.clear());
    return zt(t);
  }
  /**
   * Sets the color for all cutting plane reference geometry.
   * @param color
   */
  setCuttingPlaneColor(t) {
    for (const e of this._cuttingSections)
      e.setColor(t);
    return Promise.resolve();
  }
  /**
   * Sets the color to be used for capping geometry faces. If null is passed in as the color object, no capping face will be shown.
   * @param color color to use for capping geometry faces.
   */
  setCappingFaceColor(t) {
    return this._cappingFaceColor = t ? t.copy() : null, this._engine.setCappingFaceColor(this._cappingFaceColor), Promise.resolve();
  }
  /**
   * Gets the color used for capping geometry faces.
   * @returns color used for capping geometry faces.
   */
  getCappingFaceColor() {
    return this._cappingFaceColor ? this._cappingFaceColor.copy() : null;
  }
  /**
   * Sets the color to be used for capping geometry lines. If null is passed in as the color object, no capping line will be shown.
   * @param color color to use for capping geometry lines.
   */
  setCappingLineColor(t) {
    return this._cappingLineColor = t ? t.copy() : null, this._engine.setCappingLineColor(this._cappingLineColor), Promise.resolve();
  }
  /**
   * Gets the color used for capping geometry lines.
   * @returns color used for capping geometry lines.
   */
  getCappingLineColor() {
    return this._cappingLineColor ? this._cappingLineColor.copy() : null;
  }
  /**
   * Gets a cutting section by index. Cutting sections are created automatically by the system and may be queried at any point during or after the sceneReady callback has been triggered.
   * @returns the cutting section for the given index.
   */
  getCuttingSection(t) {
    return this._isInit && t < this._cuttingSections.length ? this._cuttingSections[t] : null;
  }
  /**
   * Gets the total number of planes supported by each cutting section.
   * Cutting planes contained in the same cutting section will work together (an object is only cut if all cutting planes in a section would cut it).
   * Cutting planes in separate cutting sections do not work together when cutting (an object is cut if any one of the cutting sections would cut it).
   * @returns the number of planes each cutting section may contain.
   */
  getCuttingSectionCapacity() {
    return this._cuttingLimits !== void 0 ? this._cuttingLimits.maxCuttingPlanesPerSection : 0;
  }
  /**
   * Gets the total number of cutting sections supported by the system.
   * @returns the number of cutting sections supported by the system.
   */
  getCuttingSectionCount() {
    return this._cuttingLimits !== void 0 ? this._cuttingLimits.maxCuttingSections : 0;
  }
  /**
   * Gets the cutting section containing the cutting plane with the given node ID. If the supplied node ID is not contained by any cutting section null will be returned.
   * @param nodeId a node ID for cutting plane stand-in geometry.
   * @returns the CuttingSection that contains the plane with the given node id or null if none contain it.
   */
  getCuttingSectionFromNodeId(t) {
    if (t !== null) {
      for (const e of this._cuttingSections)
        if (e._getInstanceNodeIds().indexOf(t) >= 0)
          return e;
    }
    return null;
  }
  /**
   * Gets all nodes that have capping drawn for them.
   * @returns an array of node IDs that have capping drawn for them
   */
  async getNodesWithCapping() {
    const t = await this._engine.getCappedInstances(), e = [];
    for (let i = 0; i < t.length - 1; i += 2) {
      const s = this._model._getNodeFromInstanceInc(
        !1,
        t[i],
        t[i + 1],
        !1
      );
      e.push(s);
    }
    return e;
  }
  /**
   * Sets whether stand-in geometry for cutting sections should be pickable.
   * If this option is set to false, picking rays will pass though stand-in geometry for cutting planes.
   * The default value is not pickable.
   * @param pickable boolean value indicating whether stand-in geometry should be pickable in the scene.
   */
  setStandinGeometryPickable(t) {
    this._standinGeometryPickable = t;
    const e = this._gatherStandinGeometryIds();
    return this._model.setInstanceModifier(Xe.DoNotSelect, e, !t), Promise.resolve();
  }
  /**
   * Gets whether stand-in geometry for cutting sections is pickable.
   * @returns boolean value indicating whether stand-in geometry for cutting sections is pickable.
   */
  getStandinGeometryPickable() {
    return this._standinGeometryPickable;
  }
  /** @hidden */
  _setStandinGeometryVisible(t) {
    const e = this._gatherStandinGeometryIds(), i = this._model._gatherInstanceIncsFromNodeIds(e);
    this._engine.pauseRendering(() => {
      this._engine.setPartVisibility(i, t, !1);
    });
  }
  /**
   * Sets the delay used by delayCapping() in milliseconds.
   * @param delayInMilliseconds The delay amount.
   */
  setCappingDelay(t) {
    this._engine.setCappingDelay(t);
  }
  /**
   * Delays capping processing by a fixed time interval.
   */
  delayCapping() {
    this._engine.delayCapping();
  }
  /**
   * Enables or disables activation of "cappingIdle" callback event.
   * @param enable Enables or disables activation of "cappingIdle" callback event.
   * @returns A promise returning whether or not capping generation was idle when this call resolves.
   */
  enableCappingIdleCallback(t) {
    return t !== this._cappingIdleCallbackEnabled && (this._cappingIdleCallbackEnabled = t, this._conservativeIsCappingIdle = !1, !t && this._cappingIdlePromise !== null && (this._cappingIdlePromise.reject(
      new Mt("Capping idle callback became disabled.")
    ), this._cappingIdlePromise = null)), this._engine.enableCappingIdleCallback(t);
  }
  async waitForCappingIdle() {
    if (!this._cappingIdleCallbackEnabled)
      throw console.assert(this._cappingIdlePromise === null), new Mt("Capping idle callback is not enabled.");
    if (!this._conservativeIsCappingIdle)
      return this._cappingIdlePromise === null && (this._cappingIdlePromise = ye()), this._cappingIdlePromise;
  }
  /**
   * Sets whether capping geometry will show.
   * The default value is true.
   * @param cappingGeometryVisibility
   */
  setCappingGeometryVisibility(t) {
    return this._engine.setCappingGeometryVisibility(t), Promise.resolve();
  }
  /**
   * Gets whether capping geometry will show
   * @returns boolean value indicating whether capping geometry will show
   */
  getCappingGeometryVisibility() {
    return this._engine.getCappingGeometryVisibility();
  }
  /**
   * @returns the number of active cutting sections.
   */
  getActiveCuttingSectionCount() {
    let t = 0;
    if (this._cuttingLimits)
      for (let e = 0; e < this._cuttingLimits.maxCuttingSections; e++) {
        const i = this.getCuttingSection(e);
        i != null && i.isActive() && (t += i.getCount());
      }
    return t;
  }
  /** @hidden */
  _init() {
    if (!this._isInit) {
      this._cuttingLimits = this._engine.getCuttingSectionLimits();
      for (let t = 0; t < this._cuttingLimits.maxCuttingSections; t++) {
        const e = new ny(
          this._viewer,
          this._model,
          this._callbackManager,
          this,
          this._engine
        );
        this._cuttingSections.push(e);
      }
      this._isInit = !0;
    }
  }
  /** @hidden */
  _isInitialized() {
    return this._isInit;
  }
  /**
   * Updates all cutting plane geometry.
   */
  refreshPlaneGeometry() {
    const t = [];
    for (const e of this._cuttingSections)
      for (let i = 0; i < e.getCount(); i++) {
        const s = e.getPlane(i);
        s !== null && t.push(e.updatePlane(i, s, new Q(), !1, !1));
      }
    return zt(t);
  }
  /**
   * @returns true if there is an active cutting section.
   */
  hasActiveCuttingSection() {
    if (this._cuttingLimits)
      for (let t = 0; t < this._cuttingLimits.maxCuttingSections; t++) {
        const e = this.getCuttingSection(t);
        if (e !== null && e.isActive())
          return !0;
      }
    return !1;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (let e = 0; e < this._cuttingSections.length; e++)
      t[e] = this._cuttingSections[e].toJson();
    return {
      cuttingSections: t,
      cappingGeometryVisibility: this.getCappingGeometryVisibility(),
      cappingFaceColor: this.getCappingFaceColor(),
      cappingLineColor: this.getCappingLineColor(),
      pickable: this.getStandinGeometryPickable()
    };
  }
  /**
   * Removes any cutting planes in the scene, and restores cutting planes from a json object.
   * @param json
   */
  async fromJson(t) {
    const e = Lo(t), i = [], s = e.cuttingSections;
    for (let r = 0; r < s.length; r++) {
      const o = s[r], a = this._cuttingSections[r];
      i.push(a.fromJson(o));
    }
    this.setStandinGeometryPickable(e.pickable), i.push(this.setCappingGeometryVisibility(e.cappingGeometryVisibility)), i.push(this.setCappingFaceColor(it.fromJson(e.cappingFaceColor))), i.push(this.setCappingLineColor(it.fromJson(e.cappingLineColor))), await Promise.all(i), this._callbackManager.trigger("cuttingSectionsLoaded");
  }
  _gatherStandinGeometryIds() {
    const t = [];
    for (const e of this._cuttingSections) {
      const i = e._getInstanceNodeIds();
      for (const s of i)
        t.push(s);
    }
    return t;
  }
}
class ry {
  /** @hidden */
  constructor(t, e, i) {
    this._explodeActive = !1, this._explodeMagnitude = 0, this._model = t, this._engine = e, i.bind({
      _modelSwitched: async () => {
        this.stop();
      }
    });
  }
  /**
   * Starts an explode operation. This will cancel any currently active explode operation.
   * @param nodeIds an array of NodeId for the parts that should be exploded. If this parameter is omitted or is an empty array, the entire model will be considered for explosion.
   * @param explosionVector the vector to use for the center of the explosion.
   * @returns a promise that resolves when this operation is complete.
   */
  start(t, e) {
    return this.getActive() ? (this.stop(), this._doExplode(t, e)) : this._doExplode(t, e);
  }
  /**
   * Sets the explosion magnitude if there is an active explosion operation.
   * A value of 1.0 indicates that the distance between a part's exploded center, and exploded center will be double.
   * @param magnitude the magnitude for the explosion.
   * @returns a promise that resolves when this operation is complete.
   */
  async setMagnitude(t) {
    if (t > 0 && !this._explodeActive ? await this.start() : t === 0 && this._explodeActive && this.stop(), this._explodeActive)
      return this._explodeMagnitude = t, this._engine.setExplodeMagnitude(t);
  }
  /**
   * Terminates any active explode operation.
   * @returns a promise that resolves when this operation is complete.
   */
  stop() {
    return this._engine.stopExplode(), this._explodeMagnitude = 0, this._explodeActive = !1, this._engine.setExplodeMagnitude(0), Promise.resolve();
  }
  /**
   * Gets the current explode magnitude. This will always return 0 when there is no active explode operation.
   * @returns the current explode magnitude.
   */
  getMagnitude() {
    return this._explodeMagnitude;
  }
  /**
   * Indicates whether there is a currently active explode operation.
   * @returns boolean value indicating if there is an active explode operation.
   */
  getActive() {
    return this._explodeActive;
  }
  async _doExplode(t, e) {
    this._explodeActive = !0;
    let i;
    if (t !== void 0 && t.length > 0 ? i = this._model._gatherInstanceIncsFromNodeIds(t) : i = [], e)
      this._engine.startExplode(i, e);
    else {
      const s = await this._model.getModelBounding(!0, !1);
      this._engine.startExplode(i, s.center());
    }
  }
}
class oy {
  /**
   * @param type The light's type. See [[type]].
   * @param space The space in which a light is defined. See [[space]]
   * @param position The light's position. See [[position]].
   * @param color The light's color. See [[color]].
   */
  constructor(t, e, i, s) {
    this.type = t, this.space = e, this.position = i, this.color = s;
  }
}
class ay extends jl {
  /** @hidden */
  constructor(t, e) {
    super(), this._markupArray = [], this._viewer = t, this._callbackManager = e, this._callbackManager.bind({
      modelSwitched: () => {
        this.removeAllLines();
      }
    });
  }
  /**
   * Adds a new Line to the Line Manager
   * @param lineItem LineMarkup Object that will be added
   */
  async addLine(t) {
    this._markupArray.push(t), await t.updateLine(), this._callbackManager.trigger("lineCreated", t);
  }
  /**
   * Removes an existing line item.
   * @param lineItem the line item to remove.
   */
  async removeLine(t) {
    for (let e = 0; e < this._markupArray.length; e++)
      this._markupArray[e].getId() === t.getId() && (await t.removeLine(), this._markupArray.splice(e, 1), this._callbackManager.trigger("lineDeleted", t));
  }
  /**
   * Removes all line items.
   */
  removeAllLines() {
    const t = [];
    for (let e = this._markupArray.length - 1; e >= 0; e--) {
      const i = this._markupArray[e];
      t.push(
        i.removeLine().then(() => {
          this._callbackManager.trigger("lineDeleted", i);
        })
      ), this._markupArray.splice(e, 1);
    }
    return zt(t);
  }
  /**
   * Return an array of line items.
   * @returns array of all line items.
   */
  getAllLines() {
    return this._markupArray.slice(0);
  }
  /**
   * Removes the most recently added line item.
   */
  async removeLastLine() {
    this._markupArray.length > 0 && await this.removeLine(this._markupArray[this._markupArray.length - 1]);
  }
  /**
   * Gets a line markup item associated with a node id.
   * @param id
   */
  getLineByNodeId(t) {
    for (const e of this._markupArray) {
      const i = e.getNodeId();
      if (i !== null && i === t)
        return e;
    }
    return null;
  }
  /**
   * @returns JSON Array with line markup
   */
  exportMarkup() {
    const t = [];
    for (const e of this._markupArray)
      t.push(e.toJson());
    return t;
  }
  async _handleLoadLine(t) {
    return t instanceof Or ? (await this.addLine(t), this._callbackManager.trigger("lineLoaded", t), !0) : !1;
  }
  /**
   * Loads JSON markup data
   * @param lineData
   * @param viewer
   */
  loadData(t) {
    const e = [];
    for (const i of t) {
      if (!i.hasOwnProperty("className"))
        continue;
      const s = ph(i.className);
      if (s) {
        const r = s(i, this._viewer);
        r instanceof Promise ? e.push(
          r.then((o) => this._handleLoadLine(o))
        ) : e.push(this._handleLoadLine(r));
      }
    }
    return Promise.all(e);
  }
}
class ly extends jl {
  constructor(t, e, i, s, r, o) {
    super(), this._markupViews = /* @__PURE__ */ new Map(), this._defaultViewCounter = 1, this._markupItemManager = e, this._callbackManager = i, this._explodeManager = s, this._cuttingManager = r, this._viewer = t, this._sheetManager = o, this._initEvents();
  }
  _initEvents() {
    this._callbackManager.bind({
      modelSwitchStart: () => {
        this._markupItemManager.shutdown();
      }
    });
  }
  getView(t) {
    const e = this._markupViews.get(t);
    return e !== void 0 ? e : null;
  }
  getViewKeys() {
    const t = [];
    return this._markupViews.forEach((e, i) => {
      t.push(i);
    }), t;
  }
  async loadData(t) {
    const e = [];
    for (const i of t) {
      const s = qo._fromJson(i, this._viewer).then((r) => {
        if (!r.itemResults.every(Boolean))
          return !1;
        const o = r.markupView, a = o.getUniqueId();
        return this._markupViews.has(a) ? !1 : (this._markupViews.set(a, o), this._callbackManager.trigger("viewLoaded", o), !0);
      });
      e.push(s);
    }
    return Promise.all(e);
  }
  exportMarkup() {
    const t = [];
    return this._markupViews.forEach((e) => {
      t.push(e.toJson());
    }), t;
  }
  createView(t = this._createDefaultViewName(), e = !0, i = null, s = null, r = null, o = null) {
    const a = this._viewer.view, l = Qi(), c = new qo(
      l,
      t,
      a.getCamera(),
      this._explodeManager.getMagnitude(),
      this._cuttingManager.toJson(),
      i
    );
    return this._markupViews.set(l, c), c.setLineVisibility(a.getLineVisibility()), c.setFaceVisibility(a.getFaceVisibility()), s !== null && (c.setDefaultVisibility(s.defaultVisibility), c.setVisibilityExceptions(s.visibilityExceptions)), r !== null && c.setColorMap(r), o !== null && c.setSnapshotImage(o), this._markupItemManager.setActiveView(c), e && this._callbackManager.trigger("viewCreated", c), c;
  }
  async _activateSheet(t) {
    if (t !== null)
      return this._sheetManager.setActiveSheetId(t, !0, !1);
  }
  async _activateViewImpl(t, e) {
    await this._activateSheet(t.getSheetId());
    const i = this._viewer.view;
    i.setFaceVisibility(t.getFaceVisibility()), i.setLineVisibility(t.getLineVisibility()), e > 0 ? (await this._markupItemManager.setActiveView(null), await i._setCameraPromise(t.getCamera(), e)) : i.setCamera(t.getCamera()), await this._setActiveView(t);
  }
  _activateView(t, e) {
    const i = this._markupViews.get(t);
    if (i !== void 0) {
      const s = this._activateViewImpl(i, e);
      return os(!0, s);
    } else
      return os(!1, Promise.resolve());
  }
  async activateView(t, e = Ri) {
    return this._activateView(t, e);
  }
  /** This is a helper for `activateView`. */
  async _setActiveView(t) {
    if (this._viewer.model.isDrawing())
      if (t.getSheetId() === null)
        await this._viewer.sheetManager.deactivateSheets(!0, !0);
      else {
        const e = t.getVisibilityExceptions(), i = t.getDefaultVisibility();
        if (e.size > 0 && i) {
          const s = [];
          e.forEach((r) => {
            s.push(r);
          }), await this._viewer.model.setNodesVisibility(s, !1);
        }
      }
    else {
      const e = t.getDefaultVisibility(), i = t.getVisibilityExceptions();
      await this._viewer.model.setBodyNodesVisibility(
        this._viewer.model.getAbsoluteRootNode(),
        (s) => i.has(s) ? !e : e
      );
    }
    await this._markupItemManager.setActiveView(t), await this._cuttingManager.fromJson(t.getCuttingPlaneData()), await this._viewer.model.setNodesColors(t.getColorMap()), await this._explodeManager.setMagnitude(t.getExplodeMagnitude());
  }
  deleteView(t) {
    const e = this._markupViews.get(t);
    return e !== void 0 ? (this._callbackManager.trigger("viewDeleted", e), e === this._markupItemManager.getActiveView() && this._markupItemManager.setActiveView(null), this._markupViews.delete(t), !0) : !1;
  }
  _createDefaultViewName() {
    return `View ${this._defaultViewCounter++}`;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this.exportMarkup();
  }
}
class cy {
  /** @hidden */
  constructor(t, e, i, s, r, o, a) {
    this._markupTypeMap = /* @__PURE__ */ new Map(), this._domElements = t, this._callbackManager = s, this._viewer = a, this._sheetManager = r, this._sheetManager.setMarkupManager(this), this._noteTextManager = o, this._renderer = new xm(), this._itemManager = new ym(
      this._callbackManager,
      this._domElements,
      this._renderer
    ), this._viewManager = new ly(
      this._viewer,
      this._itemManager,
      this._callbackManager,
      a.explodeManager,
      a.cuttingManager,
      this._sheetManager
    ), this._measurementManager = e, this._lineManager = i;
  }
  /**
   * Registers a MarkupTypeManager to add markup to exported data.
   * @param markupTypeManager
   */
  registerMarkupTypeManager(t, e) {
    this._markupTypeMap.set(t, e);
  }
  /**
   * Creates a new view based on the current camera, line, and face visibility values.
   * @param name optional name for the view. If omitted or null, the system will generate a default name
   * @param triggerEvent optional parameter indicating whether a [[CallbackMap.viewCreated]] event should be triggered. This parameter defaults to true
   * @param visibilityState optional parameter
   * @returns Unique identifier for the new view
   */
  createMarkupView(t, e = !0, i = null, s = null, r = null) {
    const o = this._viewer.sheetManager.getActiveSheetId();
    return this._viewManager.createView(
      t,
      e,
      o,
      i,
      s,
      r
    ).getUniqueId();
  }
  /**
   * Gets a [[MarkupView]] object from the viewer.
   * @param uniqueId the handle for the view object to retreive
   * @returns [[MarkupView]] object for the corresponding ID or null if no view was found
   */
  getMarkupView(t) {
    return this._viewManager.getView(t);
  }
  /**
   * @returns an array of string keys for all markup views
   */
  getMarkupViewKeys() {
    return this._viewManager.getViewKeys();
  }
  /**
   * Activates a [[MarkupView]].
   * @param uniqueId the handle for the [[MarkupView]] object to activate
   * @param duration the time in milliseconds for the transition to this view
   */
  async activateMarkupViewWithPromise(t, e = Ri) {
    return this._viewManager.activateView(t, e);
  }
  /**
   * Returns the currently active [[MarkupView]].
   * @returns [[MarkupView]] object for the currently active view, or null if no view is active
   */
  getActiveMarkupView() {
    return this._itemManager.getActiveView();
  }
  /**
   * Deletes a [[MarkupView]] object.
   * @param uniqueId the handle for the view object to delete
   * @returns true if a [[MarkupView]] with the supplied uniqueId was deleted, false otherwise
   */
  deleteMarkupView(t) {
    return this._viewManager.deleteView(t);
  }
  /**
   * Registers a [[MarkupItem]] to be rendered with the 3D view.
   * @param markupItem the item to register
   * @returns unique handle to this [[MarkupItem]].
   */
  registerMarkup(t) {
    const e = this._itemManager.registerMarkupItem(t);
    return this.updateLater(), e;
  }
  /**
   * Unregisters a [[MarkupItem]]. It will no longer be rendered with the 3D view.
   * @param uniqueId unique handle to the object that was returned from [[registerMarkup]]
   */
  unregisterMarkup(t) {
    this._itemManager.unregisterMarkupItem(t), this.updateLater();
  }
  /**
   * Add an HTML element to the markup element layer. The element will have its ID set to a system generated unique identifier.
   * @param element the HTML Element to add
   * @returns system generated unique identifier which is the id of the passed in object
   */
  addMarkupElement(t) {
    const e = Qi();
    return t.id = e, this._domElements.getRedlineElement().appendChild(t), e;
  }
  /**
   * Removes a markup element from the markup element layer
   * @param uniqueId unique handle to the object that was returned from [[registerMarkup]]
   */
  removeMarkupElement(t) {
    const e = this._domElements.getRedlineElement();
    for (let i = 0; i < e.children.length; i++) {
      const s = e.children.item(i);
      s !== null && s.id === t && e.removeChild(s);
    }
  }
  /**
   * Redraws the markup without rendering the scene. Useful when markup is added or removed but the scene is not affected.
   */
  refreshMarkup() {
    this.updateLater();
  }
  updateLater() {
    this._itemManager.updateLater();
  }
  /**
   * Picks a [[MarkupItem]]. Tests scene based and markup attached to the active view (if any)
   * @param point position to pick against
   * @returns [[MarkupItem]] that was selected or null if none was picked
   */
  pickMarkupItem(t) {
    return this._itemManager.pick(t);
  }
  /**
   * Gets the pick tolerance in pixels for picking a [[MarkupItem]]
   * @returns Current tolerance
   */
  getPickTolerance() {
    return this._itemManager.getPickTolerance();
  }
  /**
   * Sets the pick tolerance in pixels for picking a [[MarkupItem]]
   * @param tolerance The new tolerance
   */
  setPickTolerance(t) {
    return this._itemManager.setPickTolerance(t);
  }
  /**
   * Selects a [[MarkupItem]]. Pass null to clear the selection.
   * @param markupItem The [[MarkupItem]] to select.
   */
  selectMarkup(t) {
    this._itemManager.select(t);
  }
  /**
   * Returns the currently selected [[MarkupItem]], or null if nothing is currently selected
   * @returns selected [[MarkupItem]]
   */
  getSelectedMarkup() {
    return this._itemManager.getSelected();
  }
  /**
   * export markup from the viewer
   * @returns Serialized markup objects
   */
  exportMarkup() {
    const t = {
      views: this._viewManager.exportMarkup(),
      notes: this._noteTextManager.exportMarkup(),
      measurement: this._measurementManager.exportMarkup(),
      lines: this._lineManager.exportMarkup()
    };
    return this._markupTypeMap.forEach((e, i) => {
      t[i] = e.exportMarkup();
    }), t;
  }
  /**
   * Loads markup data into the viewer.
   * @param data markup data to be loaded into the viewer
   */
  async loadMarkupData(t) {
    return typeof t == "string" && (t = JSON.parse(t)), this._loadMarkupData(t);
  }
  async _loadMarkupData(t) {
    const e = [];
    if (t.hasOwnProperty("views")) {
      const i = this._viewManager.loadData(t.views).then((s) => s.every(Boolean));
      e.push(i);
    }
    if (t.hasOwnProperty("notes")) {
      const i = this._noteTextManager.loadData(t.notes).then((s) => s.every(Boolean));
      e.push(i);
    }
    if (t.hasOwnProperty("measurement")) {
      const i = this._measurementManager.loadData(t.measurement).then((s) => s.every(Boolean));
      e.push(i);
    }
    if (t.hasOwnProperty("lines")) {
      const i = this._lineManager.loadData(t.lines).then((s) => s.every(Boolean));
      e.push(i);
    }
    return this._markupTypeMap.forEach((i, s) => {
      if (t.hasOwnProperty(s)) {
        const r = i.loadData(t[s]).then((o) => o.every(Boolean));
        e.push(r);
      }
    }), Promise.all(e).then((i) => i.every(Boolean));
  }
  /**
   * Returns a the interface to the [[MarkupRenderer]].
   * @returns [[MarkupRenderer]] interface
   */
  getRenderer() {
    return this._renderer;
  }
  /** @hidden */
  _shutdown() {
    this._itemManager.shutdown(), this._renderer._clear();
  }
  /** @hidden */
  _update() {
    this._itemManager.update();
  }
  /** @hidden */
  async _setActiveMarkupView(t) {
    return this._itemManager.setActiveView(t);
  }
  /** @hidden */
  _getItemManager() {
    return this._itemManager;
  }
}
class hy extends jl {
  /** @hidden */
  constructor(t, e) {
    super(), this._markupArray = [], this._color = new it(0, 0, 0), this._edgeColor = new it(0, 0, 0), this._viewer = t, this._callbackManager = e, this._callbackManager.bind({
      modelSwitched: () => {
        this.removeAllMeasurements();
      }
    });
  }
  /**
   * Adds a new Measurement to the Measure Manager
   * @param measurementItem MeasureMarkup Object that will be added
   */
  addMeasurement(t) {
    this._markupArray.push(t);
    const e = this._viewer.markupManager.registerMarkup(t);
    return t._setId(e), e;
  }
  /**
   * Triggers a measurementCreated callback
   * @param measureItem
   * @param triggerEvent boolean trigger a callback event
   */
  finalizeMeasurement(t) {
    this._callbackManager.trigger("measurementCreated", t);
  }
  /**
   * Removes an existing measurement item.
   * @param measurementItem the measurement item to remove.
   */
  removeMeasurement(t) {
    for (let e = 0; e < this._markupArray.length; e++)
      if (this._markupArray[e]._getId() === t._getId()) {
        this._markupArray.splice(e, 1), this._viewer.markupManager.unregisterMarkup(t._getId()), this._callbackManager.trigger("measurementDeleted", t);
        break;
      }
  }
  /**
   * Removes all measurement items.
   */
  removeAllMeasurements() {
    for (let t = this._markupArray.length - 1; t >= 0; t--) {
      const e = this._markupArray[t];
      this._viewer.markupManager.unregisterMarkup(e._getId()), this._markupArray.splice(t, 1), this._callbackManager.trigger("measurementDeleted", e);
    }
  }
  /**
   * Return an array of measurement items.
   * @returns array of all measurement items.
   */
  getAllMeasurements() {
    return this._markupArray.slice(0);
  }
  /**
   * Removes the most recently added measurement item.
   */
  removeLastMeasurement() {
    this._markupArray.length > 0 && this.removeMeasurement(this._markupArray[this._markupArray.length - 1]);
  }
  /**
   * Sets the current measurement color.
   * @param color the measurement color to set.
   */
  setMeasurementColor(t) {
    this._color.assign(t);
  }
  /**
   * Gets the current measurement color.
   * @returns color current measurement color.
   */
  getMeasurementColor() {
    return this._color.copy();
  }
  /**
   * Sets the current measurement edge color.
   * @param color the measurement edge color to set.
   */
  setMeasurementEdgeColor(t) {
    this._edgeColor.assign(t);
  }
  /**
   * Gets the current measurement edge color.
   * @returns color current measurement edge color.
   */
  getMeasurementEdgeColor() {
    return this._edgeColor.copy();
  }
  /**
   * @returns JSON Array with measurement markup
   */
  exportMarkup() {
    const t = [];
    for (const e of this._markupArray)
      e != null && e.isMarkupValid() && t.push(e.toJson());
    return t;
  }
  _handleLoadMeasurement(t) {
    return t instanceof fi ? (this.addMeasurement(t), this._callbackManager.trigger("measurementLoaded", t), !0) : !1;
  }
  /**
   * Loads JSON markup data
   * @param measurementData
   * @param viewer
   */
  loadData(t) {
    const e = [];
    for (const i of t) {
      if (!i.hasOwnProperty("className"))
        continue;
      const s = ph(i.className);
      if (s) {
        const r = s(i, this._viewer);
        r instanceof Promise ? e.push(
          r.then((o) => this._handleLoadMeasurement(o))
        ) : e.push(Promise.resolve(this._handleLoadMeasurement(r)));
      }
    }
    return Promise.all(e);
  }
}
const ih = class {
  /** @hidden */
  constructor(n) {
    this._position = new Xs(0, Bt.Pixels, 0, Bt.Pixels), this._viewportSize = new Xs(
      1,
      Bt.ProportionOfOtherDimension,
      0.2,
      Bt.ProportionOfCanvas
    ), this._anchor = Jt.UpperRightCorner, this._dimension = 3, this._fieldSize = 8, this._instanceKeys = [], this._enabled = !1, this._textImageId = null, this._selectionFaceColor = new it(76, 186, 240), this._outlineColor = new it(17, 94, 133), this._lastSelectedNodes = [], this._nodeIds = [], this._adjacentFaces = [], this._preserveModelUp = !0, this._cameraRotation = 0, this._lastOrientation = null, this._lastCamera = null, this._lastFaceIndex = null, this._textWidths = [], this._sceneReadyCompleted = ye(), this._texturesReady = !1, this._geometryCreated = !1, this._viewer = n, this._fontSize = 25, this._fontInfo = `${this._fontSize}px Arial`, this._textureSize = 512, this._viewer.setCallbacks({
      sceneReady: () => {
        (async () => (this._createViewport(), this._updateVisibility(), await this._createGeometry(), this._sceneReadyCompleted.resolve()))();
      },
      _assemblyTreeReady: async () => (await this._sceneReadyCompleted, this._setTextures()),
      _firstAttachment: async () => {
        this._onCameraUpdate(), this._updateVisibility();
      },
      camera: () => {
        this._onCameraUpdate();
      },
      overlayViewportSet: (t) => {
        t === Gt.NavCube && this._onViewportSet();
      },
      transitionEnd: () => {
        this._onCameraUpdate();
      },
      viewAxes: () => {
        this._updateOrientationMatrices();
      },
      _resetOpacity: () => {
        this._viewer.model.setNodesOpacity(this._nodeIds.slice(1), 0);
      },
      viewOrientation: (t) => {
        this._lastOrientation = t, this._cameraRotation = 0, this._lastCamera = this._viewer.view.getCamera();
      }
    });
  }
  /**
   * Sets the anchor position for the NavCube.
   * @param anchor the anchor position.
   */
  async setAnchor(n) {
    return this._anchor = n, await this._sceneReadyCompleted, this._updateViewport();
  }
  /**
   * Gets the anchor position for the NavCube. Default position is in the UpperRightCorner, see [[OverlayAnchor]] for more details.
   */
  getAnchor() {
    return this._anchor;
  }
  /**
   * Enables the NavCube.
   */
  enable() {
    return this._enabled = !0, this._updateVisibility(), Promise.resolve();
  }
  /**
   * Disables the NavCube.
   */
  disable() {
    return this._enabled = !1, this._updateVisibility(), Promise.resolve();
  }
  /**
   * Determines if model up or camera up will the preserved when navigating with the NavCube.
   * If model up is preserved, navigation with the NavCube will keep the model upright all the time.
   * If camera up is preserved, navigation with the NavCube will attempt to preserve the current up direction of
   * the camera as much as possible.
   * Defaults to `true`.
   * @param preserve If true, model up is preserved. Otherwise, camera up is preserved.
   */
  setPreserveModelUp(n) {
    this._preserveModelUp = n;
  }
  /**
   * Gets the NavCube preserveModelUp state.
   * @returns true if model up is preserved, false if camera up is preserved.
   */
  getPreserveModelUp() {
    return this._preserveModelUp;
  }
  /**
   * Sets the visibility for the NavCube based on the enabled and textures state.
   */
  _updateVisibility() {
    this._enabled && this._texturesReady ? this._showOverlay() : this._hideOverlay();
  }
  /**
   * Hides the overlay window
   */
  _hideOverlay() {
    this._viewer.overlayManager.setVisibility(Gt.NavCube, !1);
  }
  /**
   * Shows the overlay window
   */
  _showOverlay() {
    this._viewer.overlayManager.setVisibility(Gt.NavCube, !0);
  }
  /**
   * Gets whether the NavCube is currently enabled.
   */
  getEnabled() {
    return this._enabled;
  }
  /**
   * Gets the associated overlay id.
   */
  getOverlayId() {
    return Gt.NavCube;
  }
  async _setTextures() {
    if (!this._textImageId || this._nodeIds.length > 0 || this._instanceKeys.length <= 0)
      return;
    const n = this._viewer.model;
    for (const t of this._instanceKeys) {
      const e = n._getNodeFromInstanceInc(!0, ve.Local, t, !0);
      this._nodeIds.push(e), n._preventNodeDeletion(e);
    }
    n.setNodesOpacity(this._nodeIds.slice(1), 0), await n.setNodesTexture([this._nodeIds[0]], {
      imageId: this._textImageId
    }), this._texturesReady = !0, this._updateVisibility();
  }
  _updateViewport() {
    this._viewer.overlayManager.setViewport(
      Gt.NavCube,
      this._anchor,
      this._position.x,
      Bt.Pixels,
      this._position.y,
      Bt.Pixels,
      this._viewportSize.x,
      this._viewportSize.xUnit,
      this._viewportSize.y,
      this._viewportSize.yUnit
    );
  }
  _createViewport() {
    const n = this._viewer.overlayManager;
    this._updateViewport();
    const t = new ci();
    t.setPosition(new d(0, 0, 10)), t.setTarget(d.zero()), t.setUp(new d(0, 1, 0)), t.setWidth(this._fieldSize), t.setHeight(this._fieldSize), t.setProjection(te.Orthographic), n.setCamera(Gt.NavCube, t);
  }
  _onViewportSet() {
    const n = this._viewer.overlayManager, t = n._getViewportPosition(Gt.NavCube), e = n._getViewportSize(Gt.NavCube), i = n.getViewportAnchor(Gt.NavCube);
    t === null || e === null || i === null || (this._position = t, this._viewportSize = e, this._anchor = i);
  }
  async _createGeometry() {
    if (this._geometryCreated)
      return;
    const n = this._initializeTextures();
    let t = 0;
    const e = [];
    e.push(this._createCube(t++, this._dimension));
    const i = [];
    i.push(this._makeRotationMatrixX(-0.5 * Math.PI)), i.push(this._makeRotationMatrixX(0.5 * Math.PI)), i.push(this._makeRotationMatrixY(0.5 * Math.PI)), i.push(this._makeRotationMatrixY(-0.5 * Math.PI)), i.push(this._makeRotationMatrixZ(0.5 * Math.PI)), i.push(this._makeRotationMatrixZ(-0.5 * Math.PI));
    const s = this._dimension / 4, r = this._dimension / 2, o = -0.01, a = [], l = new d(0, 0, 0);
    let c = new d(0, 0, 0), h = new d(0, 0, 0);
    for (let _ = 0; _ < i.length; _++) {
      const y = this._dimension, b = i[_];
      let w = !1;
      _ === i.length - 1 && (w = !0, l.z += this._dimension + 0.02), c = new d(
        0.5 * y - s,
        -0.5 * y + s,
        -0.5 * y + o
      ), h = new d(c.x + s, c.y - s, c.z), e.push(
        this._createSelectionFace(
          t++,
          c,
          h,
          b,
          w,
          l,
          a
        )
      ), c = new d(-0.5 * y, -0.5 * y + s, -0.5 * y + o), h = new d(c.x + s, c.y - s, c.z), e.push(
        this._createSelectionFace(
          t++,
          c,
          h,
          b,
          w,
          l,
          a
        )
      ), c = new d(-0.5 * y, 0.5 * y, -0.5 * y + o), h = new d(c.x + s, c.y - s, c.z), e.push(
        this._createSelectionFace(
          t++,
          c,
          h,
          b,
          w,
          l,
          a
        )
      ), c = new d(0.5 * y - s, 0.5 * y, -0.5 * y + o), h = new d(c.x + s, c.y - s, c.z), e.push(
        this._createSelectionFace(
          t++,
          c,
          h,
          b,
          w,
          l,
          a
        )
      ), c = new d(-0.5 * y + s, 0.5 * y, -0.5 * y + o), h = new d(c.x + r, c.y - s, c.z), e.push(
        this._createSelectionFace(
          t++,
          c,
          h,
          b,
          w,
          l,
          a
        )
      ), c = new d(
        -0.5 * y + s,
        -0.5 * y + s,
        -0.5 * y + o
      ), h = new d(c.x + r, c.y - s, c.z), e.push(
        this._createSelectionFace(
          t++,
          c,
          h,
          b,
          w,
          l,
          a
        )
      ), c = new d(-0.5 * y, 0.5 * y - s, -0.5 * y + o), h = new d(c.x + s, c.y - r, c.z), e.push(
        this._createSelectionFace(
          t++,
          c,
          h,
          b,
          w,
          l,
          a
        )
      ), c = new d(0.5 * y - s, 0.5 * y - s, -0.5 * y + o), h = new d(c.x + s, c.y - r, c.z), e.push(
        this._createSelectionFace(
          t++,
          c,
          h,
          b,
          w,
          l,
          a
        )
      ), c = new d(
        -0.5 * y + s,
        0.5 * y - s,
        -0.5 * y + o
      ), h = new d(c.x + r, c.y - r, c.z), e.push(
        this._createSelectionFace(
          t++,
          c,
          h,
          b,
          w,
          l,
          a
        )
      );
    }
    const u = 9;
    for (let _ = 0; _ < a.length; _++) {
      const y = Math.floor(_ / u), b = [], w = a[_];
      for (let v = 0; v < w.length; v += 2) {
        const C = w[v], k = w[v + 1];
        for (let Y = 0; Y < a.length; Y++) {
          if (Math.floor(Y / u) === y)
            continue;
          const L = a[Y];
          for (let N = 0; N < L.length; N += 2) {
            const D = L[N], B = L[N + 1];
            this._isSameEdge(C, k, D, B) && b.push(Y);
          }
        }
      }
      this._adjacentFaces.push(b);
    }
    const p = await Promise.all(e);
    this._updateOrientationMatrices(), this._onCameraUpdate();
    const m = [];
    for (const _ of p)
      m.push(ve.Local, _);
    return this._getScEngine().setPartVisibility(m, !0, !0), this._geometryCreated = !0, n;
  }
  _createTexture(n, t) {
    const i = n.getImageData(0, 0, t, t).data, s = new ArrayBuffer(t * t * 3), r = new Uint8Array(s);
    let o = 0;
    for (let l = 0; l < i.length; l += 4)
      r[o] = i[l], r[o + 1] = i[l], r[o + 2] = i[l], o += 3;
    return this._viewer.model.createImage({
      format: Oi.Rgb24,
      data: r,
      width: this._textureSize,
      height: this._textureSize
    });
  }
  /** @hidden */
  _geometryHasBeenCreated() {
    return this._geometryCreated;
  }
  /**
   * Determines whether or not a point is inside the NavCube overlay.
   * @param mousePos
   * @returns Boolean indicating whether the provided point is inside the NavCube overlay
   */
  insideOverlay(n) {
    const t = this._viewer.overlayManager._toPixelPoint(this._viewportSize), e = this._getOverlayOffset();
    return n.x >= e.x && n.y >= e.y && n.x <= e.x + t.x && n.y <= e.y + t.y;
  }
  /** @hidden */
  _getOverlayOffset() {
    const n = this._viewer.overlayManager._toPixelPoint(this._viewportSize);
    return this._viewer.overlayManager._getOverlayOffset(this._anchor, n);
  }
  /** @hidden */
  _getViewportSize() {
    return this._viewportSize;
  }
  /** @hidden */
  _getViewportPixelSize() {
    return this._viewer.overlayManager._toPixelPoint(this._viewportSize);
  }
  /** @hidden */
  _onNoSelection() {
    this._enabled && this._lastSelectedNodes.length > 0 && (this._viewer.model.setNodesOpacity(this._lastSelectedNodes, 0), this._lastSelectedNodes.length = 0);
  }
  /**
   * Called when the NavCube is clicked. Realigns the view to the side/edge/corner
   * selected by `selection`, or rotates the view 90 degrees if the selection matches
   * the current view orientation, or does nothing if no side is selected.
   * @param selection
   */
  async onClickSelection(n) {
    if (console.assert(this._enabled), n === null || !n.isFaceSelection() || n.overlayIndex() !== Gt.NavCube) {
      this._onNoSelection();
      return;
    }
    const t = this._getFaceIndexFromNodeId(n.getNodeId());
    t < this._nodeIds.length && t > 0 && await this._setViewOrientation(t);
  }
  /**
   * Called when the NavCube is "moused over". Displays face/edge/corner that will be selected.
   * @param selection
   */
  onMoveSelection(n) {
    if (console.assert(this._enabled), n === null || !n.isFaceSelection() || n.overlayIndex() !== Gt.NavCube) {
      this._onNoSelection();
      return;
    }
    const t = n.getNodeId(), e = this._getFaceIndexFromNodeId(t) - 1;
    e >= 0 && t !== this._nodeIds[0] && this._viewer.pauseRendering(() => {
      const i = this._viewer.model;
      i.setNodesOpacity(this._lastSelectedNodes, 0), this._lastSelectedNodes.length = 0, this._lastSelectedNodes.push(t), console.assert(e < this._adjacentFaces.length);
      const s = this._adjacentFaces[e];
      for (const r of s) {
        const o = r + 1, a = this._getNodeIdFromFaceIndex(o);
        this._lastSelectedNodes.push(a);
      }
      i.setNodesOpacity(this._lastSelectedNodes, 1);
    });
  }
  /**
   * Returns the corresponding view orientation for each node index.
   * If the node indexes change in the future, this will need to be updated.
   */
  _getViewOrientationFromFaceIndex(n) {
    let t = et.Front;
    switch (n) {
      case 1:
        t = et.LeftBottomBack;
        break;
      case 2:
        t = et.LeftBottomFront;
        break;
      case 3:
        t = et.LeftTopFront;
        break;
      case 4:
        t = et.LeftTopBack;
        break;
      case 5:
        t = et.LeftTop;
        break;
      case 6:
        t = et.LeftBottom;
        break;
      case 7:
        t = et.LeftFront;
        break;
      case 8:
        t = et.LeftBack;
        break;
      case 9:
        t = et.Left;
        break;
      case 10:
        t = et.RightTopBack;
        break;
      case 11:
        t = et.RightTopFront;
        break;
      case 12:
        t = et.RightBottomFront;
        break;
      case 13:
        t = et.RightBottomBack;
        break;
      case 14:
        t = et.RightBottom;
        break;
      case 15:
        t = et.RightTop;
        break;
      case 16:
        t = et.RightFront;
        break;
      case 17:
        t = et.RightBack;
        break;
      case 18:
        t = et.Right;
        break;
      case 19:
        t = et.BackTopRight;
        break;
      case 20:
        t = et.BackBottomRight;
        break;
      case 21:
        t = et.BackBottomLeft;
        break;
      case 22:
        t = et.BackTopLeft;
        break;
      case 23:
        t = et.BackLeft;
        break;
      case 24:
        t = et.BackRight;
        break;
      case 25:
        t = et.BackBottom;
        break;
      case 26:
        t = et.BackTop;
        break;
      case 27:
        t = et.Back;
        break;
      case 28:
        t = et.FrontBottomRight;
        break;
      case 29:
        t = et.FrontTopRight;
        break;
      case 30:
        t = et.FrontTopLeft;
        break;
      case 31:
        t = et.FrontBottomLeft;
        break;
      case 32:
        t = et.FrontLeft;
        break;
      case 33:
        t = et.FrontRight;
        break;
      case 34:
        t = et.FrontTop;
        break;
      case 35:
        t = et.FrontBottom;
        break;
      case 36:
        t = et.Front;
        break;
      case 37:
        t = et.BottomRightFront;
        break;
      case 38:
        t = et.BottomLeftFront;
        break;
      case 39:
        t = et.BottomLeftBack;
        break;
      case 40:
        t = et.BottomRightBack;
        break;
      case 41:
        t = et.BottomBack;
        break;
      case 42:
        t = et.BottomFront;
        break;
      case 43:
        t = et.BottomLeft;
        break;
      case 44:
        t = et.BottomRight;
        break;
      case 45:
        t = et.Bottom;
        break;
      case 46:
        t = et.TopLeftBack;
        break;
      case 47:
        t = et.TopRightBack;
        break;
      case 48:
        t = et.TopRightFront;
        break;
      case 49:
        t = et.TopLeftFront;
        break;
      case 50:
        t = et.TopFront;
        break;
      case 51:
        t = et.TopBack;
        break;
      case 52:
        t = et.TopRight;
        break;
      case 53:
        t = et.TopLeft;
        break;
      case 54:
        t = et.Top;
        break;
      default:
        t = et.Front;
    }
    return t;
  }
  async _setViewOrientation(n) {
    const t = this._viewer.view, e = this._getViewOrientationFromFaceIndex(n), i = await t.getViewOrientationCamera(
      e,
      void 0,
      this._preserveModelUp
    );
    let s = !1;
    console.assert(n - 1 >= 0), console.assert(n - 1 < this._adjacentFaces.length);
    const r = this._adjacentFaces[n - 1];
    for (const c of r)
      if (c + 1 === this._lastFaceIndex) {
        s = !0;
        break;
      }
    this._lastFaceIndex = n;
    const o = this._lastCamera !== null && this._lastCamera.equals(t.getCamera());
    if ((this._lastOrientation === e || s) && o ? this._cameraRotation = this._preserveModelUp ? (this._cameraRotation + 90) % 360 : 90 : this._cameraRotation = 0, this._lastOrientation = e, this._cameraRotation > 0) {
      const c = d.subtract(i.getPosition(), i.getTarget()).normalize(), h = Q.createFromOffAxisRotation(c, this._cameraRotation), u = i.getUp();
      h.transform(u, u), i.setUp(u);
    }
    await t.fitWorld(Ri, i);
    const l = this._viewer.model.getAbsoluteRootNode();
    if (this._viewer.model.getNodeChildren(l).length === 0)
      return this._getScEngine().markCameraAsEmpty();
    this._lastCamera = t.getCamera();
  }
  _getScEngine() {
    return this._viewer._getScEngine();
  }
  async _createInstance(n, t) {
    const e = await this._viewer.model.createMesh(n), i = new bn(e);
    i.setCreationFlags(
      xt.DoNotCut | xt.DoNotExplode | xt.ExcludeBounding | xt.DoNotLight | xt.Invisible
    ), i.setOverlayIndex(Gt.NavCube);
    const o = (await this._getScEngine().createMeshInstance(i))[1];
    return this._instanceKeys[t] = o, o;
  }
  _createCube(n, t) {
    const e = [], i = [], s = [], r = [];
    let o = this._textWidths[0];
    for (const v of this._textWidths)
      v > o && (o = v);
    o += 10, e.push(new d(0.5 * t, 0.5 * t, 0.5 * t)), e.push(new d(-0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, 0.5 * t, 0.5 * t)), e.push(new d(0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(0.5 * t, 0.5 * t, 0.5 * t)), i.push(new d(0, 1, 0)), i.push(new d(0, 1, 0)), i.push(new d(0, 1, 0)), i.push(new d(0, 1, 0)), i.push(new d(0, 1, 0)), i.push(new d(0, 1, 0));
    const a = 60;
    let l = 22 / this._textureSize, c = (22 + a) / this._textureSize;
    l = 1 - l, c = 1 - c;
    let h = (o - this._textWidths[0]) / 2, u = -(h / this._textureSize), p = (this._textWidths[0] + h) / this._textureSize;
    s.push(new E(u, l)), s.push(new E(p, c)), s.push(new E(p, l)), s.push(new E(u, c)), s.push(new E(p, c)), s.push(new E(u, l)), r.push(new d(-0.5 * t, 0.5 * t, -0.5 * t)), r.push(new d(0.5 * t, 0.5 * t, -0.5 * t)), r.push(new d(0.5 * t, 0.5 * t, -0.5 * t)), r.push(new d(0.5 * t, 0.5 * t, 0.5 * t)), r.push(new d(0.5 * t, 0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, 0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, 0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, -0.5 * t, 0.5 * t)), e.push(new d(-0.5 * t, -0.5 * t, -0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, 0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, 0.5 * t)), e.push(new d(-0.5 * t, -0.5 * t, -0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, -0.5 * t)), i.push(new d(0, -1, 0)), i.push(new d(0, -1, 0)), i.push(new d(0, -1, 0)), i.push(new d(0, -1, 0)), i.push(new d(0, -1, 0)), i.push(new d(0, -1, 0)), l -= a / this._textureSize, c -= a / this._textureSize, h = (o - this._textWidths[1]) / 2, u = -(h / this._textureSize), p = (this._textWidths[1] + h) / this._textureSize, s.push(new E(u, l)), s.push(new E(u, c)), s.push(new E(p, l)), s.push(new E(p, l)), s.push(new E(u, c)), s.push(new E(p, c)), r.push(new d(-0.5 * t, -0.5 * t, -0.5 * t)), r.push(new d(0.5 * t, -0.5 * t, -0.5 * t)), r.push(new d(0.5 * t, -0.5 * t, -0.5 * t)), r.push(new d(0.5 * t, -0.5 * t, 0.5 * t)), r.push(new d(0.5 * t, -0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, -0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, -0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, -0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, 0.5 * t, 0.5 * t)), e.push(new d(-0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, -0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, 0.5 * t, 0.5 * t)), e.push(new d(-0.5 * t, -0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, -0.5 * t, 0.5 * t)), i.push(new d(-1, 0, 0)), i.push(new d(-1, 0, 0)), i.push(new d(-1, 0, 0)), i.push(new d(-1, 0, 0)), i.push(new d(-1, 0, 0)), i.push(new d(-1, 0, 0)), l -= a / this._textureSize, c -= a / this._textureSize, h = (o - this._textWidths[2]) / 2, u = -(h / this._textureSize), p = (this._textWidths[2] + h) / this._textureSize, s.push(new E(u, l)), s.push(new E(u, c)), s.push(new E(p, c)), s.push(new E(u, l)), s.push(new E(p, c)), s.push(new E(p, l)), r.push(new d(-0.5 * t, 0.5 * t, -0.5 * t)), r.push(new d(-0.5 * t, 0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, 0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, -0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, -0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, -0.5 * t, -0.5 * t)), r.push(new d(-0.5 * t, -0.5 * t, -0.5 * t)), r.push(new d(-0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(0.5 * t, 0.5 * t, 0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, -0.5 * t)), e.push(new d(0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(0.5 * t, 0.5 * t, 0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, 0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, -0.5 * t)), i.push(new d(1, 0, 0)), i.push(new d(1, 0, 0)), i.push(new d(1, 0, 0)), i.push(new d(1, 0, 0)), i.push(new d(1, 0, 0)), i.push(new d(1, 0, 0)), l -= a / this._textureSize, c -= a / this._textureSize, h = (o - this._textWidths[3]) / 2, u = -(h / this._textureSize), p = (this._textWidths[3] + h) / this._textureSize, s.push(new E(p, l)), s.push(new E(u, c)), s.push(new E(p, c)), s.push(new E(p, l)), s.push(new E(u, l)), s.push(new E(u, c)), r.push(new d(0.5 * t, 0.5 * t, -0.5 * t)), r.push(new d(0.5 * t, 0.5 * t, 0.5 * t)), r.push(new d(0.5 * t, 0.5 * t, 0.5 * t)), r.push(new d(0.5 * t, -0.5 * t, 0.5 * t)), r.push(new d(0.5 * t, -0.5 * t, 0.5 * t)), r.push(new d(0.5 * t, -0.5 * t, -0.5 * t)), r.push(new d(0.5 * t, -0.5 * t, -0.5 * t)), r.push(new d(0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, -0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, 0.5 * t, -0.5 * t)), i.push(new d(0, 0, -1)), i.push(new d(0, 0, -1)), i.push(new d(0, 0, -1)), i.push(new d(0, 0, -1)), i.push(new d(0, 0, -1)), i.push(new d(0, 0, -1)), l -= a / this._textureSize, c -= a / this._textureSize, h = (o - this._textWidths[4]) / 2, u = -(h / this._textureSize), p = (this._textWidths[4] + h) / this._textureSize, s.push(new E(u, l)), s.push(new E(u, c)), s.push(new E(p, c)), s.push(new E(p, l)), s.push(new E(u, l)), s.push(new E(p, c)), e.push(new d(-0.5 * t, 0.5 * t, 0.5 * t)), e.push(new d(-0.5 * t, -0.5 * t, 0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, 0.5 * t)), e.push(new d(-0.5 * t, 0.5 * t, 0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, 0.5 * t)), e.push(new d(0.5 * t, 0.5 * t, 0.5 * t)), i.push(new d(0, 0, 1)), i.push(new d(0, 0, 1)), i.push(new d(0, 0, 1)), i.push(new d(0, 0, 1)), i.push(new d(0, 0, 1)), i.push(new d(0, 0, 1)), l -= a / this._textureSize, c -= a / this._textureSize, h = (o - this._textWidths[5]) / 2, u = -(h / this._textureSize), p = (this._textWidths[5] + h) / this._textureSize, s.push(new E(u, c)), s.push(new E(p, c)), s.push(new E(p, l)), s.push(new E(u, c)), s.push(new E(p, l)), s.push(new E(u, l));
    const m = new Hi();
    m.setFaceWinding(yn.CounterClockwise);
    let g = [], _ = [], y = [], b = 0;
    for (let v = 0; v < e.length; v++) {
      const C = e[v];
      g.push(C.x), g.push(C.y), g.push(C.z);
      const k = i[v];
      _.push(k.x), _.push(k.y), _.push(k.z);
      const Y = s[v];
      if (y.push(Y.x), y.push(Y.y), g.length >= 18) {
        const L = [
          // y
          [0, 255, 0, 255],
          [0, 255, 0, 255],
          // x
          [255, 0, 0, 255],
          [255, 0, 0, 255],
          // z
          [0, 0, 255, 255],
          [0, 0, 255, 255]
        ][b], N = [];
        for (let D = 0; D < 6; D++)
          N.push(L[0]), N.push(L[1]), N.push(L[2]), N.push(L[3]);
        m.addFaces(g, _, new Uint8Array(N), y), g = [], _ = [], y = [], ++b;
      }
    }
    g = [];
    const w = new Uint8Array(4 * r.length);
    for (let v = 0; v < r.length; v++) {
      const C = r[v];
      g.push(C.x), g.push(C.y), g.push(C.z);
      const k = 4 * v;
      w[k] = this._outlineColor.r, w[k + 1] = this._outlineColor.g, w[k + 2] = this._outlineColor.b, w[k + 3] = 255;
    }
    return m.addPolyline(g, w), this._createInstance(m, n);
  }
  _onCameraUpdate() {
    const n = new ci(), t = this._viewer.view.getCamera();
    n.setPosition(
      t.getPosition().subtract(t.getTarget()).normalize()
    ), n.setTarget(d.zero()), n.setUp(t.getUp()), n.setProjection(te.Orthographic), n.setWidth(this._fieldSize), n.setHeight(this._fieldSize), this._viewer.overlayManager.setCamera(Gt.NavCube, n);
  }
  _updateOrientationMatrices() {
    const t = this._viewer.model.getViewAxes(), e = t.upVector.copy(), i = t.frontVector.copy(), s = d.cross(e, i.copy().scale(-1)), r = new Q();
    r.m[0] = -i.x, r.m[1] = -i.y, r.m[2] = -i.z, r.m[4] = s.x, r.m[5] = s.y, r.m[6] = s.z, r.m[8] = e.x, r.m[9] = e.y, r.m[10] = e.z;
    const o = this._getScEngine(), a = [];
    for (const l of this._instanceKeys)
      a.push(ve.Local, l);
    o.setInstancesMatrix(a, r);
  }
  _createSelectionFace(n, t, e, i, s, r, o) {
    const a = new Hi();
    a.setFaceWinding(yn.CounterClockwise);
    const l = [];
    this._createQuad(t, e, l, i, r, s);
    let c = [], h = [], u = [];
    for (const _ of l)
      c.push(_.x), c.push(_.y), c.push(_.z), h.push(0), h.push(0), h.push(-1), u.push(this._selectionFaceColor.r), u.push(this._selectionFaceColor.g), u.push(this._selectionFaceColor.b), u.push(128);
    const p = [], m = [
      this._outlineColor.r,
      this._outlineColor.g,
      this._outlineColor.b,
      255,
      this._outlineColor.r,
      this._outlineColor.g,
      this._outlineColor.b,
      255
    ];
    a.addFaces(c, h, new Uint8Array(u)), c = [], h = [], u = [];
    let g = [];
    return s ? (g.push(l[4].x, l[4].y, l[4].z), g.push(l[5].x, l[5].y, l[5].z)) : (g.push(l[0].x, l[0].y, l[0].z), g.push(l[1].x, l[1].y, l[1].z)), a.addPolyline(g, new Uint8Array(m)), p.push(
      new d(g[0], g[1], g[2]),
      new d(g[3], g[4], g[5])
    ), g = [], g.push(l[1].x, l[1].y, l[1].z), g.push(l[2].x, l[2].y, l[2].z), a.addPolyline(g, new Uint8Array(m)), p.push(
      new d(g[0], g[1], g[2]),
      new d(g[3], g[4], g[5])
    ), g = [], g.push(l[3].x, l[3].y, l[3].z), g.push(l[4].x, l[4].y, l[4].z), a.addPolyline(g, new Uint8Array(m)), p.push(
      new d(g[0], g[1], g[2]),
      new d(g[3], g[4], g[5])
    ), g = [], s ? (g.push(l[3].x, l[3].y, l[3].z), g.push(l[2].x, l[2].y, l[2].z)) : (g.push(l[5].x, l[5].y, l[5].z), g.push(l[3].x, l[3].y, l[3].z)), a.addPolyline(g, new Uint8Array(m)), p.push(
      new d(g[0], g[1], g[2]),
      new d(g[3], g[4], g[5])
    ), g = [], o.push(p), this._createInstance(a, n);
  }
  _createQuad(n, t, e, i, s, r = !1) {
    const o = new d(n.x, n.y, n.z), a = new d(t.x, t.y, t.z);
    s && (o.x += s.x, o.y += s.y, o.z += s.z, a.x += s.x, a.y += s.y, a.z += s.z);
    const l = e.length;
    let c = new d(a.x, a.y, o.z), h = i.transform(c);
    if (e.push(h), c = new d(o.x, a.y, o.z), h = i.transform(c), e.push(h), c = new d(o.x, o.y, o.z), h = i.transform(c), e.push(h), c = new d(a.x, o.y, o.z), h = i.transform(c), e.push(h), c = new d(a.x, a.y, o.z), h = i.transform(c), e.push(h), c = new d(o.x, o.y, o.z), h = i.transform(c), e.push(h), r)
      for (let u = 0; u < 3; u++) {
        const p = l + u, m = e[l + u], g = new d(m.x, m.y, m.z), _ = l + (6 - u - 1);
        e[p].x = e[_].x, e[p].y = e[_].y, e[p].z = e[_].z, e[_].x = g.x, e[_].y = g.y, e[_].z = g.z;
      }
  }
  _makeRotationMatrixX(n) {
    const t = Math.cos(n), e = Math.sin(n), i = new Q();
    return i.m[5] = t, i.m[6] = -e, i.m[9] = e, i.m[10] = t, i;
  }
  _makeRotationMatrixY(n) {
    const t = Math.cos(n), e = Math.sin(n), i = new Q();
    return i.m[0] = t, i.m[2] = e, i.m[8] = -e, i.m[10] = t, i;
  }
  _makeRotationMatrixZ(n) {
    const t = Math.cos(n), e = Math.sin(n), i = new Q();
    return i.m[0] = t, i.m[1] = -e, i.m[4] = e, i.m[5] = t, i;
  }
  _getFaceIndexFromNodeId(n) {
    for (let t = 0; t < this._nodeIds.length; t++)
      if (this._nodeIds[t] === n)
        return t;
    return -1;
  }
  _getNodeIdFromFaceIndex(n) {
    return this._nodeIds[n];
  }
  _isSameEdge(n, t, e, i) {
    const s = d.subtract(n, e).squaredLength() + d.subtract(t, i).squaredLength(), r = d.subtract(t, e).squaredLength() + d.subtract(n, i).squaredLength();
    return Math.min(s, r) < 0.03;
  }
  async _initializeTextures() {
    const n = document.createElement("canvas");
    n.width = this._textureSize, n.height = this._textureSize;
    const t = n.getContext("2d"), e = 2 * (this._fontSize + 5);
    t.beginPath(), t.rect(0, 0, this._textureSize, this._textureSize), t.fillStyle = "gray", t.fill(), t.fillStyle = "black", t.font = this._fontInfo;
    for (let s = 0; s < ih._faceTexts.length; s++) {
      const r = ih._faceTexts[s];
      t.fillText(r, 0, e * (s + 1));
      const o = t.measureText(r);
      this._textWidths.push(o.width);
    }
    const i = await this._createTexture(t, this._textureSize);
    this._textImageId = i;
  }
};
let pp = ih;
pp._faceTexts = [
  "LEFT",
  "RIGHT",
  "FRONT",
  "BACK",
  "BOTTOM",
  "TOP"
];
class uy {
  /** @hidden */
  constructor(t) {
    this._operatorStack = [], this._operators = /* @__PURE__ */ new Map(), this._customOperatorIdCount = 0, this._customOperatorIdIndex = 1e4, this._mergeableEvents = [
      kt.MouseMove,
      kt.Mousewheel,
      kt.TouchMove,
      kt.KeyUp,
      kt.KeyDown
    ], this._eventSequencePromise = Promise.resolve(), this._events = [], this._viewer = t, this._viewer.setCallbacks({
      _resetAssemblyTreeBegin: async () => {
        const e = [];
        return this._operators.forEach((i, s) => {
          let r;
          r = this._deactivateOperator(s), r !== void 0 && e.push(r), r = this._activateOperator(s), r !== void 0 && e.push(r);
        }), zt(e);
      }
    });
  }
  /** @hidden */
  _shutdown() {
    for (; this.pop() !== void 0; )
      ;
  }
  /** @hidden */
  _registerOperator(t, e) {
    this._operators.set(t, e);
  }
  /**
   * Registers a custom operator
   * @param operator
   * @returns operatorId
   */
  registerCustomOperator(t) {
    const e = this._customOperatorIdIndex + this._customOperatorIdCount++;
    return this._operators.set(e, t), e;
  }
  /**
   * Removes a custom operator from the registered operator list.
   * @param operatorId
   */
  unregisterCustomOperator(t) {
    t >= this._customOperatorIdIndex && this._operators.delete(t);
  }
  /**
   * Replaces the operator that the specified id refers to. Returns a boolean indicating success or failure.
   * @param previousOperatorId operator id for the operator to be replaced.
   * @param newOperatorId operator id for the new operator.
   */
  replaceOperator(t, e) {
    const i = this.getOperator(e);
    return i !== null ? (this._operators.set(t, i), !0) : !1;
  }
  /**
   * Returns the index of an operator on the stack
   * @param operatorId
   * @returns operator index or -1 if not found
   */
  indexOf(t) {
    for (let e = this.size() - 1; e >= 0; e--)
      if (this._operatorStack[e] === t)
        return e;
    return -1;
  }
  /**
   * Adds an operator on the stack if it's not already on the stack
   * @param operatorId id of the operator to add to the stack
   * @returns boolean indicating success or failure
   */
  push(t) {
    return this._isValid(t) && !this._contains(t) ? (this._operatorStack.push(t), this._activateOperator(t), !0) : !1;
  }
  /**
   * Sets a position on the stack to an operator if it's not already on the stack
   * If there is already an operator in that position, it is replaced.
   * @param operatorId id of the operator to add to the stack
   * @param position position on the stack to assign
   * @returns boolean indicating success or failure
   */
  set(t, e) {
    const i = this._operatorStack[e];
    return t === i ? !1 : this._isValid(t) && !this._contains(t) ? (this._deactivateOperator(i), this._activateOperator(t), this._operatorStack[e] = t, !0) : !1;
  }
  /**
   * Removes an operator from the top of the stack
   * @returns the operator id
   */
  pop() {
    const t = this._operatorStack.pop();
    return t !== void 0 && this._deactivateOperator(t), t;
  }
  /**
   * Removes an operator from the stack
   * @param operatorId id of the operator to remove from the stack
   */
  remove(t) {
    const e = this.indexOf(t);
    e !== -1 && (this._operatorStack.splice(e, 1), this._deactivateOperator(t));
  }
  /**
   * @returns the operator id at the top of the stack
   */
  peek() {
    return this.size() > 0 ? this._operatorStack[this.size() - 1] : Et.Invalid;
  }
  /**
   * Removes all operators from the stack
   */
  clear() {
    for (let t = this.size() - 1; t >= 0; t--)
      this.pop();
  }
  /**
   * @returns the operator stack size
   */
  size() {
    return this._operatorStack.length;
  }
  getOperator(t) {
    return this._operators.get(t) ?? null;
  }
  async _injectEvent(t, e) {
    for (let i = this.size() - 1; i >= 0; i--) {
      const s = this._operators.get(this._operatorStack[i]);
      if (s !== void 0)
        try {
          switch (e) {
            case kt.KeyDown:
              s.onKeyDown && await s.onKeyDown(t);
              break;
            case kt.KeyUp:
              s.onKeyUp && await s.onKeyUp(t);
              break;
            case kt.MouseDown:
              s.onMouseDown && await s.onMouseDown(t);
              break;
            case kt.MouseMove:
              s.onMouseMove && await s.onMouseMove(t);
              break;
            case kt.MouseUp:
              s.onMouseUp && await s.onMouseUp(t);
              break;
            case kt.Mousewheel:
              s.onMousewheel && await s.onMousewheel(t);
              break;
            case kt.TouchStart:
              s.onTouchStart && await s.onTouchStart(t);
              break;
            case kt.TouchMove:
              s.onTouchMove && await s.onTouchMove(t);
              break;
            case kt.TouchEnd:
              s.onTouchEnd && await s.onTouchEnd(t);
              break;
            case kt.ViewOrientationChange:
              s.onViewOrientationChange && await s.onViewOrientationChange();
              break;
            default:
              $n(e);
          }
        } catch (r) {
          r instanceof Ms || console.log(r);
        }
      if (t.getHandled()) {
        (e === kt.MouseUp || e === kt.TouchEnd) && await this._stopInteraction();
        break;
      }
    }
  }
  async injectEvent(t, e) {
    return this._addOrMergeEventToQueue(t, e), this._eventSequencePromise = this._eventSequencePromise.then(async () => {
      await this._injectNextEvent();
    }), this._eventSequencePromise;
  }
  _addOrMergeEventToQueue(t, e) {
    let i = !1;
    if (this._mergeableEvents.indexOf(e) !== -1)
      for (let s = 0; s < this._events.length; s++) {
        const r = this._events[s];
        if (e === r.eventType && !((e === kt.KeyDown || e === kt.KeyUp) && t.getKeyCode() !== r.event.getKeyCode()) && !(e === kt.TouchMove && t.getId() !== r.event.getId())) {
          r.event = t, i = !0;
          break;
        }
      }
    i || this._events.push({ event: t, eventType: e });
  }
  async _injectNextEvent() {
    const t = this._events.shift();
    t !== void 0 && await this._injectEvent(t.event, t.eventType);
  }
  async _stopInteraction() {
    const t = [];
    for (let e = this.size() - 1; e >= 0; e--) {
      const i = this._operators.get(this._operatorStack[e]);
      if (i != null && i.stopInteraction) {
        const s = i.stopInteraction();
        s !== void 0 && t.push(s);
      }
    }
    return zt(t);
  }
  /** @hidden */
  _injectViewOrientationChangeEvent() {
    for (let t = this.size() - 1; t >= 0; t--) {
      const e = this._operators.get(this._operatorStack[t]);
      e != null && e.onViewOrientationChange && e.onViewOrientationChange();
    }
  }
  _isValid(t) {
    return this._operators.has(t) || t === Et.None;
  }
  _contains(t) {
    return this.indexOf(t) !== -1;
  }
  _activateOperator(t) {
    const e = this._operators.get(t);
    if (e != null && e.onActivate)
      return e.onActivate();
  }
  _deactivateOperator(t) {
    const e = this._operators.get(t);
    if (e != null && e.onDeactivate)
      return e.onDeactivate();
  }
}
class dy {
  /* @hidden */
  constructor(t, e, i, s) {
    this._activeSheetId = null, this._backgroundSheetMeshId = null, this._sheetIds = [null, null, null], this._backgroundSheetEnabled = !1, this._backgroundSelectionEnabled = !1, this._backgroundColor = new it(180, 180, 180), this._sheetColor = it.white(), this._sheetShadowColor = new it(75, 75, 75), this._viewer = t, this._engine = e, this._callbackManager = i;
    const r = async () => {
      if (!this._viewer.model.isDrawing())
        return;
      const o = this._viewer.sheetManager.getActiveSheetId();
      if (o == null) {
        await this.deactivateSheets(!1);
        const a = this.getSheetIds();
        this.get3DNodes().length === 0 && a.length > 0 && await this.setActiveSheetId(a[0], !0, !0);
      } else
        await this._activateSheetId(o, !0, !0);
    };
    this._viewer.setCallbacks({
      _modelStructureHeaderParsed: async () => {
        if (this._viewer.model.isDrawing() && !s)
          return this.setBackgroundSheetEnabled(!0);
      },
      _firstModelLoaded: async () => {
        await r();
      },
      _resetAssemblyTreeBegin: async () => {
        await this.setBackgroundSheetEnabled(!1), await this.setBackgroundSelectionEnabled(!1), this._activeSheetId = null, this._backgroundSheetMeshId = null;
        const o = this._viewer.view, a = o.getBackgroundColor();
        o.setBackgroundColor(a.top, a.bottom);
      },
      _resetDrawing: async () => {
        await r();
      }
    });
  }
  /**
   * @returns an array of 2D [[SheetId]]s.
   */
  getSheetIds() {
    const t = this._viewer.model, e = (s) => {
      let r = [];
      const o = t.getNodeChildren(s);
      for (const a of o)
        r = r.concat(e(a));
      return t.getNodeType(s) === At.DrawingSheet && r.push(s), r;
    }, i = t.getAbsoluteRootNode();
    return e(i);
  }
  /**
   * Returns Ids of sheet nodes which contain 3D data.
   */
  get3DNodes() {
    const t = this._viewer.model, e = t.getAbsoluteRootNode(), i = t.getNodeChildren(e), s = t.getNodeChildren(i[0]), r = t.getNodeChildren(s[0]), o = [];
    for (const a of r)
      t.getNodeType(a) !== At.DrawingSheet && o.push(a);
    return o;
  }
  /**
   * Deactivate sheets and only display 3D content
   * @param triggerCallback triggers a "sheetDeactivated" callback if true
   * @param ignoreFitNodes camera will not fit nodes if true
   * @returns promise that resolves when the operation has completed
   */
  async deactivateSheets(t = !0, e = !1) {
    this._activeSheetId = null, this._viewer.pauseRendering();
    const i = this.get3DNodes(), s = e ? !1 : i.length > 0;
    await this._viewer.view.isolateNodes(i, 0, s), await this._refreshBackgroundSheets();
    const r = this._viewer.view, o = r.getBackgroundColor();
    r.setBackgroundColor(o.top, o.bottom), this._viewer.resumeRendering(), t && this._callbackManager.trigger("sheetDeactivated");
  }
  /**
   * Sets the id of the current active sheet
   * @param activeSheetId id of the sheet which will be activated.
   * @param isolateNodes indicates whether the nodes in the sheet should be isolated
   * @param fitNodes indicates whether a fit world should be performed after isolating the nodes.  Note: This parameter has no effect if `isolateNodes` is `false`.
   * @returns promise that resolves when the operation has completed
   */
  async setActiveSheetId(t, e = !0, i = !0) {
    this._activeSheetId !== t && (this._activeSheetId = t, await this._activateSheetId(t, e, i));
  }
  async _activateSheetId(t, e, i) {
    await this._markupManager._setActiveMarkupView(null), e && (this._viewer.pauseRendering(), await this._viewer.view.isolateNodes([t], 0, i), await this._refreshBackgroundSheets(), this._viewer.resumeRendering()), this._callbackManager.trigger("sheetActivated", this._activeSheetId);
  }
  /**
   * @returns gets the id of the current active sheet. null if none has been set.
   */
  getActiveSheetId() {
    return this._activeSheetId;
  }
  /**
   * @returns true if a drawing sheet is activated, false otherwise
   */
  isDrawingSheetActive() {
    return this._viewer.model.isDrawing() && this._activeSheetId !== null;
  }
  /** @hidden */
  setMarkupManager(t) {
    this._markupManager = t;
  }
  async _createBackgroundSheetMesh() {
    const t = [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      1,
      1,
      0
    ], e = [
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1
    ], i = new Hi();
    return i.addFaces(t, e), i.setBackfacesEnabled(!0), this._viewer.model.createMesh(i);
  }
  _createBackgroundSheetMatrix(t, e) {
    const i = t.min, s = t.max, r = this._viewer.view.getCamera(), o = r.getPosition(), a = r.getTarget(), l = d.subtract(a, o);
    let c = s.x - i.x, h = s.y - i.y;
    const u = Math.max(0.1 * c, 0.1 * (s.z - i.z)), p = i.x + 0.5 * c, m = i.y + 0.5 * h, g = 0.05, _ = Math.max(c * g, h * g);
    c += _, h += _;
    let y = p - 0.5 * c, b = m - 0.5 * h, w = l.z > 0 ? s.z + u : i.z - u;
    if (e) {
      const C = r.getUp();
      let k = 0.3 * _;
      y += k, C.y > 0 && (k = -k), b += k, w += l.z > 0 ? u : -u;
    }
    const v = new Q();
    return v.setTranslationComponent(y, b, w), v.setScaleComponent(c, h, 1), v;
  }
  async _createBackgroundSheetInstance(t, e, i, s, r, o) {
    let a = xt.DoNotExplode | xt.DoNotCut | xt.OverrideSceneVisibility | xt.DoNotLight | xt.DoNotOutlineHighlight | xt.AlwaysDraw | xt.ExcludeBounding;
    o || (a |= xt.DoNotSelect);
    const l = new bn(
      t,
      i,
      e,
      s,
      null,
      null,
      a
    ), c = await this._viewer.model.createMeshInstance(l, null, !1, !0);
    return this._viewer.model.setNodesOpacity([c], r), c;
  }
  /**
   * Deletes background sheets described by sheetTypes, but only if they exist.
   * @param sheetTypes An array with the sheets to delete. Omitting will delete all sheets.
   */
  async _deleteBackgroundSheetInstances(t = [
    0,
    2,
    1
    /* Shadow */
  ]) {
    const e = [];
    for (const i of t) {
      const s = this._sheetIds[i];
      s !== null && (this._sheetIds[i] = null, e.push(s));
    }
    if (e.length > 0)
      return this._viewer.model.deleteMeshInstances(e);
  }
  /**
   *  Creates the sheet-type into our array, or if the sheet already exists updates the necessary state values
   */
  async _createOrUpdateSheet(t, e, i, s, r, o) {
    const a = this._viewer.model;
    if (this._sheetIds[t] === null)
      return this._sheetIds[t] = await this._createBackgroundSheetInstance(
        this._backgroundSheetMeshId,
        e,
        i,
        s,
        r,
        o
      ), Promise.resolve();
    {
      const l = this._sheetIds[t];
      return a.setNodesFaceColor([l], s), a.setNodesOpacity([l], r), o !== null && a.setInstanceModifier(Xe.DoNotSelect, [l], !o), a.setNodeMatrix(l, i, !0);
    }
  }
  /**
   * Refreshes the background sheets used for 2D drawings.
   */
  async _refreshBackgroundSheets() {
    const t = this._viewer.model;
    if (!this.isDrawingSheetActive())
      return this._backgroundSelectionEnabled = !1, this._deleteBackgroundSheetInstances();
    this._backgroundSheetMeshId === null && (this._backgroundSheetMeshId = await this._createBackgroundSheetMesh());
    const e = await t.getModelBounding(!0, !1), i = this._createBackgroundSheetMatrix(e, !1), s = [];
    if (this._backgroundSelectionEnabled ? await this._createOrUpdateSheet(
      2,
      "2d_drawing_background_selection_sheet",
      i,
      it.black(),
      0,
      !0
    ) : s.push(
      2
      /* Selection */
    ), this._engine.setBackgroundGradient(this._backgroundColor, this._backgroundColor), this._backgroundSheetEnabled) {
      const r = this._createBackgroundSheetMatrix(e, !0);
      await this._createOrUpdateSheet(
        0,
        "2d_drawing_background_sheet",
        i,
        this._sheetColor,
        1,
        !1
      ), await this._createOrUpdateSheet(
        1,
        "2d_drawing_background_shadow_sheet",
        r,
        this._sheetShadowColor,
        1,
        !1
      );
    } else
      s.push(
        0,
        1
        /* Shadow */
      );
    if (s.length > 0)
      return this._deleteBackgroundSheetInstances(s);
  }
  /**
   * Sets custom sheet colors.
   * @param backgroundColor viewer background color.
   * @param sheetColor sheet background color.
   * @param sheetShadowColor sheet shadow effect color.
   */
  setSheetColors(t, e, i) {
    return this._backgroundColor = t.copy(), this._sheetColor = e.copy(), this._sheetShadowColor = i.copy(), this._refreshBackgroundSheets();
  }
  /**
   * Gets the sheet Background Color.
   */
  getSheetBackgroundColor() {
    return this._backgroundColor;
  }
  /**
   * Gets the Sheet Color.
   */
  getSheetColor() {
    return this._sheetColor;
  }
  /**
   * Gets the Sheet Shadow Color.
   */
  getSheetShadowColor() {
    return this._sheetShadowColor;
  }
  /**
   * Enables or disables the background sheet used for 2D drawings.
   */
  async setBackgroundSheetEnabled(t) {
    t !== this._backgroundSheetEnabled && (this._backgroundSheetEnabled = t, this._viewer.pauseRendering(), await this._refreshBackgroundSheets(), this._viewer.resumeRendering());
  }
  /**
   * Gets the current state of the background sheet.
   * @returns `true` if enabled and `false` otherwise.
   */
  getBackgroundSheetEnabled() {
    return this._backgroundSheetEnabled;
  }
  /**
   * Sets whether the background for 2D drawings is selectable. By default it is not.
   * 2D drawings have an invisible selection plane with a single face. Note that this setting
   * is unaffected by the background-sheet enable setting.
   */
  async setBackgroundSelectionEnabled(t) {
    this.isDrawingSheetActive() || (t = !1), t !== this._backgroundSelectionEnabled && (this._backgroundSelectionEnabled = t, this._viewer.pauseRendering(), await this._refreshBackgroundSheets(), this._viewer.resumeRendering());
  }
  /** Gets the current state of the background sheet.
   * @returns `true` if enabled and `false` otherwise.
   */
  getBackgroundSelectionEnabled() {
    return this._backgroundSelectionEnabled;
  }
  /**
   * Enables a visual comparison of two drawing sheets. The nodes specified
   * by `sheetId1` are filled with one color, the nodes specified by
   * `sheetId2` with another color, and overlapping areas are filled
   * with a third color.
   *
   * See [[endSheetComparison]], [[View.startComparison]].
   *
   * @param sheetId1 the drawing sheet to compare against `sheetId2`
   * @param sheetId2 the drawing sheet to compare against `sheetId1`
   * @param config settings controlling the behavior of the comparison
   */
  async startComparison(t, e, i) {
    const s = this._viewer.view;
    s.startComparison([t], [e], i), await this.setActiveSheetId(t, !1, !1), await s.isolateNodes([t, e], 0, !0), await this._refreshBackgroundSheets();
  }
  /**
   * Disables a visual comparison of two drawing sheets enabled by
   * [[startSheetComparison]]. The `Promise` returned by that function
   * should be waited upon before calling [[endSheetComparison]].
   */
  async endComparison() {
    this._activeSheetId !== null && (await this.setActiveSheetId(this._activeSheetId, !0, !1), this._viewer.view.endComparison());
  }
}
class my {
  /**
   * Creates a new SnapshotConfig object.
   */
  constructor(t = 0, e = 0, i = Yo.All) {
    this.width = t, this.height = e, this.layers = i;
  }
}
class yu {
  constructor() {
    this.svgXmlPrologEnabled = !0, this.svgBackgroundCssColor = "", this.silhouettesEnabled = !0, this.linesDrawModelLinesEnabled = !0, this.linesStrokeWidth = 20, this.linesCssColor = "#000000", this.linesClipProximityToPlane = 5.5, this.linesClipZNudgeFactor = 5.5, this.polygonsForceDrawCssColor = "", this.logProgress = !1, this.logDiagnostics = !1;
  }
}
class gp {
  constructor(t, e) {
    this.top = t, this.bottom = e;
  }
}
class py {
  static calculate(t, e, i, s) {
    let r;
    const o = 2 / (e + 2 * i + s);
    return t <= e ? r = this._PA(t, o, e) : t >= e && t <= e + i ? r = this._PA(t, o, e) : r = this._PC(t, o, e, i, s), r = Math.min(r, 1), r;
  }
  static _PA(t, e, i) {
    return t * t * 0.5 * e / i;
  }
  static _PB(t, e, i) {
    return this._PA(i, e, i) + (t - i) * e;
  }
  static _PC(t, e, i, s, r) {
    return this._PB(i + s, e, i) + (t - (i + s)) * e * (1 - 0.5 * (t - (i + s)) / r);
  }
}
class gy {
  constructor(t, e, i, s, r) {
    this._completeCallback = null, this._startTime = null, this._progress = 0, this._positionMoveDelta = null, this._targetMoveDelta = null, this._interpolationUsesRotation = !1, this._beginQuaternion = null, this._endQuaternion = null, this._viewVectorLength = 0, this._viewVectorLengthDelta = 0, this._fieldWidthDelta = 0, this._fieldHeightDelta = 0, this._beginCam = t.copy(), this._endCam = e.copy();
    const o = d.subtract(
      this._endCam.getTarget(),
      this._endCam.getPosition()
    ).normalize(), a = this._endCam.getUp().normalize(), l = d.cross(a, o), c = d.cross(o, l);
    this._endCam.setUp(c.normalize()), this._completeCallback = s, this._duration = i, this._view = r;
  }
  isComplete() {
    return this._progress >= 1;
  }
  getCallback() {
    return this._completeCallback;
  }
  stop() {
  }
  start() {
    this._startTime = Date.now(), this._progress = 0, this._init(), this._view.getProjectionMode() !== this._endCam.getProjection() && this._view.setProjectionMode(this._endCam.getProjection());
  }
  update() {
    if (this._startTime === null)
      return;
    let e = (Date.now() - this._startTime) / this._duration;
    e = Math.min(e, 1), e = Math.max(e, 0), e = py.calculate(e, 0.49, 0.02, 0.49), e = Math.min(e, 1), e = Math.max(e, 0);
    const i = d.scale(this._positionMoveDelta, e), s = d.scale(this._targetMoveDelta, e), r = this._beginCam.getUp();
    let o = d.add(this._beginCam.getPosition(), i);
    const a = d.add(this._beginCam.getTarget(), s), l = this._beginCam.getWidth() + e * this._fieldWidthDelta, c = this._beginCam.getHeight() + e * this._fieldHeightDelta;
    if (this._interpolationUsesRotation) {
      const u = this._viewVectorLength + this._viewVectorLengthDelta * e, p = Ti.interpolate(this._beginQuaternion, this._endQuaternion, e), m = Ti.toMatrix(p);
      o = new d(
        a.x - m.m[8] * u,
        a.y - m.m[9] * u,
        a.z - m.m[10] * u
      ), r.set(m.m[4], m.m[5], m.m[6]);
    }
    const h = ci.create(
      o,
      a,
      r,
      this._endCam.getProjection(),
      l,
      c,
      this._endCam.getNearLimit()
    );
    this._view.setCamera(h), this._progress = e, this._progress >= 1 && this._view.setCamera(this._endCam);
  }
  /**
   * Returns the transpose of the camera's view matrix without the
   * translation component and with the x- and z- axes flipped.
   *
   * Reproduced here because the public version is deprecated.
   */
  getMatrixFromCamera(t) {
    const e = d.subtract(t.getTarget(), t.getPosition()).normalize(), i = t.getUp().normalize(), s = d.cross(i, e), r = d.cross(e, s);
    return Q.createFromBasis(s, r, e);
  }
  _init() {
    const t = d.subtract(
      this._beginCam.getTarget(),
      this._beginCam.getPosition()
    ), e = d.subtract(this._endCam.getTarget(), this._endCam.getPosition()), i = t.length(), s = e.length() - i;
    t.normalize(), e.normalize();
    const r = d.subtract(t, e), o = d.subtract(this._endCam.getUp(), this._beginCam.getUp());
    let a = !0;
    r.length() < 1e-4 && o.length() < 1e-4 && (a = !1);
    let l = null, c = null;
    if (a) {
      const h = this.getMatrixFromCamera(this._beginCam), u = this.getMatrixFromCamera(this._endCam);
      l = Ti.createFromMatrix(h), c = Ti.createFromMatrix(u);
      const p = Ti.subtract(l, c).magnitudeSquared();
      Ti.add(l, c).magnitudeSquared() < p && c.negate();
    }
    this._interpolationUsesRotation = a, this._beginQuaternion = l, this._endQuaternion = c, this._viewVectorLength = i, this._viewVectorLengthDelta = s, this._positionMoveDelta = d.subtract(
      this._endCam.getPosition(),
      this._beginCam.getPosition()
    ), this._targetMoveDelta = d.subtract(this._endCam.getTarget(), this._beginCam.getTarget()), this._fieldWidthDelta = this._endCam.getWidth() - this._beginCam.getWidth(), this._fieldHeightDelta = this._endCam.getHeight() - this._beginCam.getHeight();
  }
}
class fy {
  constructor() {
    this._obscuredLineColor = it.black(), this._obscuredLineOpacity = 0.2, this._visibleLineColor = it.black(), this._visibleLineOpacity = 1, this._backgroundColorTop = it.white(), this._backgroundColorBottom = it.white();
  }
  /**
   * Returns the `Color` used for rendering obscured lines.
   * @returns The color used for obscured lines.
   */
  getObscuredLineColor() {
    return this._obscuredLineColor.copy();
  }
  /**
   * Sets the `Color` used for rendering obscured lines.
   * @param color The color used for obscured lines.
   */
  setObscuredLineColor(t) {
    this._obscuredLineColor.assign(t);
  }
  /**
   * Returns the opacity used for rendering obscured lines.
   * @returns The opacity used for obscured lines.
   */
  getObscuredLineOpacity() {
    return this._obscuredLineOpacity;
  }
  /**
   * Sets the opacity used for rendering obscured lines.
   * @param opacity The opacity used for obscured lines.
   */
  setObscuredLineOpacity(t) {
    0 <= t && t <= 1 && (this._obscuredLineOpacity = t);
  }
  /**
   * Gets the `Color` used for rendering visible lines.
   * @returns The color used for visible lines.
   */
  getVisibleLineColor() {
    return this._visibleLineColor.copy();
  }
  /**
   * Sets the `Color` used for rendering visible lines.
   * @param color The color used for visible lines.
   */
  setVisibleLineColor(t) {
    this._visibleLineColor.assign(t);
  }
  /**
   * Gets the opacity used for rendering visible lines.
   * @returns The opacity used for visible lines.
   */
  getVisibleLineOpacity() {
    return this._visibleLineOpacity;
  }
  /**
   * Sets the opacity used for rendering visible lines.
   * @param opacity The opacity used for visible lines.
   */
  setVisibleLineOpacity(t) {
    0 <= t && t <= 1 && (this._visibleLineOpacity = t);
  }
  /**
   * Gets the colors used for the background in hidden line rendering.
   * @returns The background colors used for hidden line.
   */
  getBackgroundColor() {
    const t = this._backgroundColorTop !== null ? this._backgroundColorTop.copy() : null, e = this._backgroundColorBottom !== null ? this._backgroundColorBottom.copy() : null;
    return new gp(t, e);
  }
  /**
   * Sets the background color in hidden line rendering to a gradient interpolating from the top to bottom color.
   * For a solid color, the top and bottom color should have the same values.
   * To enable a transparent background, pass null to the parameters of this function.
   *
   * @param top the top color for the the background gradient, null for transparent.
   * @param bottom the bottom color for the the background gradient, null for transparent.
   */
  setBackgroundColor(t = null, e = null) {
    this._backgroundColorTop = t !== null ? t.copy() : null, this._backgroundColorBottom = e !== null ? e.copy() : null;
  }
}
class _y {
  /** @hidden */
  constructor(t, e, i, s, r, o, a, l) {
    this._backfacesVisible = !1, this._initialCamera = null, this._lineVisibility = !0, this._faceVisibility = !0, this._boundingCalculationIgnoresInvisible = !0, this._backgroundColorTop = null, this._backgroundColorBottom = null, this._drawMode = Sn.WireframeOnShaded, this._ambientOcclusionEnabled = !1, this._ambientOcclusionRadius = 0.03, this._antiAliasingMode = Hd.SMAA, this._lightingEnabled = !0, this._ambientLightColor = it.black(), this._massageExtremeCameras = !0, this._bloomEnabled = !1, this._bloomThreshold = 0, this._bloomThresholdRampWidth = 0, this._bloomIntensityScale = 0, this._bloomLayers = [], this._simpleShadowEnabled = !1, this._simpleReflectionEnabled = !1, this._silhouetteEnabled = !1, this._hardEdgesEnabled = !1, this._imageBasedLightingEnabled = !0, this._lineJitterEnabled = !1, this._hiddenLineSettings = new fy(), this._projectionMode = te.Orthographic, this._drawStrategy = $d.FixedFramerate;
    const c = t.getCreationParameters();
    this._viewer = t, this._engine = e, this._callbackManager = i, this._interpolationManager = r, this._eventDispatcher = s, this._model = t.model, this._statistics = o, this._navCube = a, this._axisTriad = l, this._determineInitialAxes = vr(c.calculateDefaultViewAxes, !0), this._initEvents();
  }
  _initEvents() {
    this._callbackManager.bind({
      _resetAssemblyTreeBegin: async () => {
        this._initialCamera = null;
      },
      _firstAttachment: async (t) => {
        if (t === Di.Direct)
          return this._massageInitialCamera(!1);
      },
      _firstModelLoaded: (t, e) => e ? Promise.resolve() : this._massageInitialCamera(!1),
      _modelSwitched: async (t) => {
        if (!t)
          return await this._massageInitialCamera(!1), this._setInitialView(0);
      },
      hwfParseComplete: () => this._massageInitialCamera(!0),
      _modelStructureHeaderParsed: async () => {
        if (this._viewer.sheetManager.isDrawingSheetActive())
          return this._model.setViewAxes(new d(0, 0, 1), new d(0, 1, 0)), this.setViewOrientation(et.Front, 0);
      },
      _sessionStarted: async () => {
        this.setBloomIntensityScale(1), this.setBloomThreshold(0.65), this.setBloomThresholdRampWidth(0.1), this.setBloomLayers([
          {
            intensity: 0.5,
            blurSamples: 5,
            blurInterval: [1 / 400, mn.ProportionOfHeight]
          },
          {
            intensity: 0.5,
            blurSamples: 5,
            blurInterval: [1 / 200, mn.ProportionOfHeight]
          },
          {
            intensity: 0.5,
            blurSamples: 9,
            blurInterval: [1 / 100, mn.ProportionOfHeight]
          },
          {
            intensity: 1,
            blurSamples: 9,
            blurInterval: [1 / 50, mn.ProportionOfHeight]
          },
          {
            intensity: 2,
            blurSamples: 11,
            blurInterval: [1 / 25, mn.ProportionOfHeight]
          }
        ]), this.setGroundPlane({
          normal: new d(0, 0, 1),
          followViewAxes: !0
        }), this.setSimpleShadowColor(it.black()), this.setSimpleShadowOpacity(0.65), this.setSimpleShadowResolution(512), this.setSimpleShadowBlurSamples(5), this.setSimpleShadowBlurInterval(1), this.setSimpleShadowInteractiveUpdateEnabled(), this.setSimpleReflectionOpacity(0.65), this.setSimpleReflectionFadeAngle(10), this.setSimpleReflectionBlurSamples(9), this.setSimpleReflectionBlurInterval(1, mn.Pixels), this.setSimpleReflectionAttenuation(
          0,
          1,
          Pc.ProportionOfBoundingHeight
        ), this.setSilhouetteColor(it.black()), this.setSilhouetteOpacity(1), this.setSilhouetteThreshold(0.05), this.setSilhouetteThresholdRampWidth(0.025), this.setHardEdgeColor(it.black()), this.setHardEdgeOpacity(1), this.setHardEdgeThreshold(30), this.setHardEdgeThresholdRampWidth(20), this.setImageBasedLightingIntensity(1), this.setImageBasedLightingOrientation({
          matrix: new Q(),
          followViewAxes: !0
        }), this.setGoochBlue(0.55), this.setGoochYellow(0.3), this.setGoochBaseColorProminence(0.25), this.setGoochLuminanceShiftStrength(0.5), this.setLineJitterInstanceCount(4), this.setLineJitterFrequency(5), this.setLineJitterRadius(5e-3), this.setToonShadingBandCount(3), this.setToonShadingSpecularFactor(1);
      },
      viewAxes: (t, e) => {
        this._updateGroundPlane(t, e), this._updateImageBasedLightingOrientation(t, e);
      }
    });
  }
  async _massageInitialCamera(t) {
    this._initialCamera === null && (this._initialCamera = await this._engine.getCameraPromise(), this._projectionMode = this._initialCamera.getProjection(), this._determineInitialAxes && !this._viewer.sheetManager.isDrawingSheetActive() && !this._model.viewAxesHaveBeenSet() && this._determineViewAxes(this._initialCamera), t && (await this.fitWorld(), this._initialCamera = this.getCamera()));
  }
  /**
   * Sets the line visibility for the view.
   * @param lineVisibility indicates whether to draw lines.
   */
  setLineVisibility(t) {
    return this._setLineVisibility(t), Promise.resolve();
  }
  _setLineVisibility(t) {
    t !== this._lineVisibility && (this._lineVisibility = t, this._engine.setLineVisibility(t));
  }
  /**
   * Gets the line visibility for the view.
   * @returns whether lines are currently being drawn.
   */
  getLineVisibility() {
    return this._lineVisibility;
  }
  /**
   * Sets the face visibility for the view.
   * @param faceVisibility indicates whether to draw faces.
   */
  setFaceVisibility(t) {
    return this._setFaceVisibility(t), Promise.resolve();
  }
  _setFaceVisibility(t) {
    return t !== this._faceVisibility && (this._faceVisibility = t, this._engine.setFaceVisibility(t)), Promise.resolve();
  }
  /**
   * Gets the face visibility for the view.
   * @returns whether faces are currently being drawn.
   */
  getFaceVisibility() {
    return this._faceVisibility;
  }
  /**
   * Sets the projection mode.
   * @param projection the projection mode to set.
   */
  setProjectionMode(t) {
    this._projectionMode !== t && (this._projectionMode = t, this._engine.isInit() && this._engine.setProjection(t), this._eventDispatcher.injectViewOrientationChangeEvent());
  }
  /**
   * Gets the projection mode.
   * @returns The current projection mode.
   */
  getProjectionMode() {
    return this._projectionMode;
  }
  /**
   * Gets the draw strategy.
   * @returns The current draw strategy.
   */
  getDrawStrategy() {
    return this._drawStrategy;
  }
  /**
   * Gets the view matrix.
   * @returns The current view matrix.
   */
  getViewMatrix() {
    return this._engine.getViewMatrix();
  }
  /**
   * Gets the projection matrix.
   * @returns The current projection matrix.
   */
  getProjectionMatrix() {
    return this._engine.getProjectionMatrix();
  }
  /**
   * This is equivalent to (projectionMatrix * viewMatrix).
   * @returns The current full camera matrix.
   */
  getFullCameraMatrix() {
    return this._engine.getFullCameraMatrix();
  }
  /**
   * Creates a ray based on a viewport position.
   * @param point The (X, Y) viewport position.
   * @returns The ray if it was generated, otherwise null.
   */
  raycastFromPoint(t) {
    const e = this.getCanvasSize(), i = this._engine.getViewMatrix(), s = this._engine.getProjectionMatrix(), r = new d(t.x, e.y - t.y, 0), o = this._unproject(r, s, i, e);
    if (o === null)
      return null;
    r.z = 0.5;
    const a = this._unproject(r, s, i, e);
    if (a === null)
      return null;
    const l = d.subtract(a, o).normalize();
    return new Gn(o, l);
  }
  /**
   * @param source
   * @param projectionMatrix
   * @param viewMatrix
   * @param viewSize
   */
  _unproject(t, e, i, s) {
    const r = Q.multiply(i, e), o = Q.inverse(r);
    if (o === null)
      return null;
    const a = new jn(t.x, t.y, t.z, 1);
    a.x = a.x / s.x, a.y = a.y / s.y, a.x = a.x * 2 - 1, a.y = a.y * 2 - 1, a.z = a.z * 2 - 1;
    const l = o.transform4(a);
    return l.w === 0 ? null : (l.scale(1 / l.w), new d(l.x, l.y, l.z));
  }
  _rectifySelectionItem(t) {
    const e = t.getInclusionKey(), i = t.getNodeId(), s = this._model._getNodeFromInstanceInc(!1, e, i, !0);
    t._setNodeId(s);
  }
  // TODO:
  // Mark this as hidden and rename to have an underscore?
  // Or is it too late? It wouldn't be a bad thing
  // to expose this functionality as public.
  /** @hidden */
  isOutsideCanvasArea(t) {
    const e = this.getCanvasSize();
    return t.x < 0 || t.y < 0 || t.x >= e.x || t.y >= e.y;
  }
  /**
   * Performs a picking operation from the given position on the canvas. The best candidate entity is be returned.
   * This method does not trigger a selection event.
   * This method will reject if the point is outside the canvas area.
   * @param point Canvas position to pick from.
   * @param config The configuration object used for this picking operation.
   * @returns An object containing the result of the picking operation.
   */
  async pickFromPoint(t, e) {
    if (this.isOutsideCanvasArea(t))
      throw new Ms();
    const i = await this._engine.pickFromScreen(
      t,
      e,
      this._viewer.sheetManager.isDrawingSheetActive()
    );
    return i ? (this._rectifySelectionItem(i), i) : de.create();
  }
  /**
   * Performs a picking operation from the given position on the canvas. All candidate entities are returned.
   * This method does not trigger a selection event.
   * This method will reject if the point is outside the canvas area.
   * @param point Canvas position to pick from.
   * @param config The configuration object used for this picking operation.
   * @returns An object containing the result of the picking operation.
   */
  async pickAllFromPoint(t, e) {
    if (this.isOutsideCanvasArea(t))
      throw new Ms();
    const i = await this._engine.pickAllFromScreen(
      t,
      e,
      this._viewer.sheetManager.isDrawingSheetActive()
    );
    for (const s of i)
      this._rectifySelectionItem(s);
    return i;
  }
  /**
   * Performs a composite picking operation.  This operation will return all candidate Node entities according to the PickConfig.
   * @param point Canvas position to pick from.
   * @param config The configuration object used for this picking operation.
   * @returns An object containing the result of the picking operation.
   */
  async compositePickFromPoint(t, e) {
    if (this.isOutsideCanvasArea(t))
      throw new Ms();
    const { faceItem: i, lineItem: s, pointItem: r } = await this._engine.compositePickFromScreen(
      t,
      e,
      this._viewer.sheetManager.isDrawingSheetActive()
    ), o = new dl(i, s, r);
    return o.faceItem !== null && this._rectifySelectionItem(o.faceItem), o.lineItem !== null && this._rectifySelectionItem(o.lineItem), o.pointItem !== null && this._rectifySelectionItem(o.pointItem), new dl(
      o.faceItem,
      o.lineItem,
      o.pointItem
    );
  }
  /**
   * Performs a selection operation from the given world-space ray. The best candidate entity is be returned.
   * This method does not trigger a selection event.
   * @param ray The world-space ray to perform the selection with.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @returns An object containing the result of the picking operation.
   */
  async pickFromRay(t, e) {
    const i = await this._engine.pickFromRay(t, e);
    return i ? (this._rectifySelectionItem(i), i) : de.create();
  }
  /**
   * Performs a selection operation from the given world-space ray. All candidate entities are returned.
   * This method does not trigger a selection event.
   * @param ray The world-space ray to perform the selection with.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @returns An object containing the result of the picking operation.
   */
  async pickAllFromRay(t, e) {
    const i = await this._engine.pickAllFromRay(t, e);
    for (const s of i)
      this._rectifySelectionItem(s);
    return i;
  }
  /**
   * Creates a new and active selection context for the provided selection window.
   * @param areaCssMin The minimum coodinate in CSS pixel space for the selection window.
   * @param areaCssMax The maximum coodinate in CSS pixel space for the selection window.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  async beginScreenSelectByArea(t, e, i) {
    if (this.isOutsideCanvasArea(t) || this.isOutsideCanvasArea(e))
      throw new Ms();
    return this._engine.beginScreenAreaSelection(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection ray.
   * The ray is created at the supplied ray origin and is cast into the scene.
   * Faces are selected if they lie along the ray.
   * Lines and points are selected if they lie within the ray's box radius.
   *
   * Note: Somewhat confusingly ray drill selection is actually a selection by volume.
   * The provided ray origin and radius are used to create a frustum to preform the selection.
   * This has some consequences. For example, the `SelectionResult`s returned by advancing a
   * ray drill selection will not have selection positions, since they were not selected at
   * a single point.
   * @param rayCssOrigin The coordinate in CSS pixel space for the selection ray's origin.
   * @param rayCssBoxRadius The radius around the ray in CSS pixel space used for line and point selection proximity.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  async beginRayDrillSelection(t, e, i) {
    if (this.isOutsideCanvasArea(t))
      throw new Ms();
    return this._engine.beginRayDrillSelection(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection volume.
   * The selection volume is a convex polyhedron defined by the bounded intersection of its half-spaces.
   * @param volumePlanes The planes used to define volume. A point p is inside the volume if and only if (plane.determineSide(p) == true) for all supplied planes.
   * @param heuristicOrigin A point used to compute distances against for prioritizing returned results. This is typically (but not necessarily) the center of the volume.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  async beginConvexPolyhedronSelection(t, e, i) {
    return this._engine.beginConvexPolyhedronSelection(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection sphere.
   * @param sphereCenter The center of the selection sphere.
   * @param sphereRadius The radius of the selection sphere.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  async beginSphereSelection(t, e, i) {
    const s = Fr(t);
    return this._engine.beginSphereSelection(s, e, i);
  }
  /**
   * Deactivates and destroys the provided selection context.
   * @param handle The selection context to destroy.
   */
  endIncrementalSelection(t) {
    return this._endIncrementalSelection(t), Promise.resolve();
  }
  _endIncrementalSelection(t) {
    this._engine.endIncrementalSelection(t);
  }
  /**
   * Returns the next batch of geometry selected by the supplied selection context.
   * @param handle The handle to an active area selection context.
   * @returns Returns selected items. If the resulting list is null then there are no more items to select.
   */
  async advanceIncrementalSelection(t) {
    try {
      const e = await this._engine.advanceIncrementalSelection(t);
      if (e === null)
        return null;
      const i = this._viewer.selectionManager, s = [];
      for (const r of e) {
        this._rectifySelectionItem(r);
        const o = r, a = o.getNodeId();
        if (!a)
          continue;
        i._incrementalBlacklistedInstanceNodes.has(a) || s.push(o);
      }
      return s;
    } catch (e) {
      throw e.scFunction === "advanceVolumeSelection" ? new as() : e;
    }
  }
  /**
   * Projects a 3d world space point to a 3d screen space point.
   * @param point world space point to be projected.
   * @param camera if a camera is provided, its projection and view matrix will be used.
   * @returns point projected into 3d screen space.
   */
  projectPoint(t, e) {
    let i, s;
    e !== void 0 ? (i = e.getProjectionMatrix(this._viewer), s = e.getViewMatrix(this._viewer)) : (i = this._engine.getSynchedProjectionMatrix(), s = this._engine.getSynchedViewMatrix());
    const r = this.getCanvasSize(), o = this._project(t, i, s, r);
    return o.y = r.y - o.y, o;
  }
  /**
   * @param source
   * @param projectionMatrix
   * @param viewMatrix
   * @param viewSize
   */
  _project(t, e, i, s) {
    const r = new jn(t.x, t.y, t.z, 1);
    i.transform4(r, r), e.transform4(r, r);
    const o = r.w <= 0, a = r.w;
    return r.w <= 0 && (r.w = 1e-3), r.scale(1 / r.w), r.x = r.x * 0.5 + 0.5, r.y = r.y * 0.5 + 0.5, r.z = r.z * 0.5 + 0.5, r.x = r.x * s.x, r.y = r.y * s.y, o && (r.z = a), new d(r.x, r.y, r.z);
  }
  /**
   * Unprojects a 2d screen space point to a 3d world space point.
   * @param point 2d screen space
   * @param z z value, default 0
   * @returns point world space point
   */
  unprojectPoint(t, e) {
    const i = this.getCanvasSize(), s = this.getProjectionMatrix(), r = this.getViewMatrix(), o = new d(t.x, i.y - t.y, e);
    return this._unproject(o, s, r, i);
  }
  /**
   * Creates a normalized window position in the range of (-1, 1) for a given point in window space.
   * @returns the normalized window position
   */
  pointToWindowPosition(t) {
    const e = this._engine.getCanvasSize();
    return new E(t.x / e.x * 2 - 1, 1 - t.y / e.y * 2);
  }
  /**
   * Sets the camera that will be used for the initial camera view.
   * @param camera
   */
  setInitialCamera(t) {
    this._initialCamera = t.copy();
  }
  /**
   * Sets the current camera
   * @param camera the camera to set
   * @param duration camera transition time in milliseconds
   */
  setCamera(t, e = 0) {
    return t === null ? !1 : this._setCameraImpl(t, e).unsafeValue;
  }
  /** @hidden */
  _setCameraPromise(t, e) {
    return this._setCameraImpl(t, e).readyPromise;
  }
  _setCameraImpl(t, e) {
    if (e > 0)
      return this._interpolateCamera(t, e);
    if (this._engine.isInit()) {
      const i = t.getProjection();
      this._projectionMode !== i && this.setProjectionMode(i), this._engine.setCamera(t);
      let s;
      return this._markupManager ? s = this._markupManager._setActiveMarkupView(null) : s = Promise.resolve(), this._callbackManager.trigger("camera", t), os(!0, s);
    } else
      return os(!1, Promise.resolve());
  }
  _interpolateCamera(t, e) {
    if (this._engine.isInit()) {
      const i = this.getCamera();
      if (i.equals(t))
        return this._markupManager && this._markupManager._update(), os(!1, Promise.resolve());
      {
        this._callbackManager.trigger("transitionBegin", e);
        const s = ye(), r = () => {
          this._eventDispatcher.injectViewOrientationChangeEvent(), this._callbackManager.trigger("transitionEnd"), s.resolve();
        };
        return this._interpolationManager.start(
          new gy(i, t, e, r, this)
        ), os(!0, s);
      }
    } else
      return os(!1, Promise.resolve());
  }
  /**
   * Updates camera properties individually. This method should be used to incrementally update camera properties individually.
   * @param camera the camera to set.
   * @returns updated camera object.
   */
  updateCamera(t) {
    return t = this._engine.updateCamera(t), this._callbackManager.trigger("camera", t), t;
  }
  /**
   * Resets the camera to the initial view of the model when first loaded.
   * @param duration the amount of time in milliseconds that the camera transition between the current and initial view should take.
   */
  resetCamera(t = Ri) {
    return this._setInitialView(t);
  }
  /**
   * Gets the current camera
   * @returns the current camera
   */
  getCamera() {
    if (this._engine.isInit())
      return this._engine.getCamera();
    throw new Mt("getCamera() called before sceneReady");
  }
  /**
   * Returns a camera set to a ViewOrientation
   * @param orientation The desired view orientation for the camera.
   * @param bounding Optional bounding to fit the camera about. If not supplied, the model bounding will be used.
   */
  async getViewOrientationCamera(t, e, i = !0) {
    const s = this.getCamera(), r = s.getUp().copy().normalize(), o = this._model.getViewAxes(), a = o.upVector.copy(), l = o.frontVector.copy();
    e === void 0 ? e = await this._model.getModelBounding(
      this._boundingCalculationIgnoresInvisible,
      !1
    ) : this._fitCameraToBounding(s, e);
    const c = e.center();
    let h = c.copy();
    const u = c.copy(), p = d.subtract(s.getPosition(), s.getTarget()).length(), m = d.subtract(s.getPosition(), c).length();
    let g = new d(0, 0, 1), _ = new d(-1, 0, 0);
    a !== null && (g = a.copy()), l !== null && (_ = l.copy());
    const y = _.copy().scale(-1), b = _.copy(), w = g.copy(), v = g.copy().scale(-1), C = d.cross(w, y), k = C.copy().scale(-1), Y = (D) => {
      const B = d.subtract(u, D);
      let V = g;
      const X = Yn(B, g);
      (X === 0 || X === 180) && (V = _);
      const Z = d.cross(B, V), W = Z.copy().negate(), st = d.cross(B, Z), j = st.copy().negate(), gt = [Z, W, st, j];
      let U = 1 / 0, ht = Z;
      for (const z of gt) {
        const O = Yn(r, z);
        O <= U && (U = O, ht = z);
      }
      return ht.normalize();
    };
    let P = null;
    switch (t) {
      case et.Front:
        h = d.add(u, b);
        break;
      case et.Back:
        h = d.add(u, y);
        break;
      case et.Left:
        h = d.add(u, C);
        break;
      case et.Right:
        h = d.add(u, k);
        break;
      case et.Bottom:
        h = d.add(u, v), P = y.copy();
        break;
      case et.Top:
        h = d.add(u, w), P = y.copy();
        break;
      case et.FrontTop:
      case et.TopFront:
        h = d.add(u, d.add(b, w)), P = d.add(y, w).normalize();
        break;
      case et.FrontTopLeft:
      case et.LeftTopFront:
      case et.TopLeftFront:
        h = d.add(u, d.add(b, d.add(C, w))), P = d.add(y, d.add(k, w)).normalize();
        break;
      case et.Iso:
      case et.FrontTopRight:
      case et.RightTopFront:
      case et.TopRightFront:
        h = d.add(u, d.add(b, d.add(k, w))), P = d.add(y, d.add(C, w)).normalize();
        break;
      case et.FrontLeft:
      case et.LeftFront:
        h = d.add(u, d.add(b, C));
        break;
      case et.FrontRight:
      case et.RightFront:
        h = d.add(u, d.add(b, k));
        break;
      case et.FrontBottom:
      case et.BottomFront:
        h = d.add(u, d.add(b, v)), P = d.add(b, w).normalize();
        break;
      case et.FrontBottomLeft:
      case et.LeftBottomFront:
      case et.BottomLeftFront:
        h = d.add(u, d.add(b, d.add(C, v))), P = d.add(b, d.add(C, w)).normalize();
        break;
      case et.FrontBottomRight:
      case et.RightBottomFront:
      case et.BottomRightFront:
        h = d.add(u, d.add(b, d.add(k, v))), P = d.add(b, d.add(k, w)).normalize();
        break;
      case et.BackTop:
      case et.TopBack:
        h = d.add(u, d.add(y, w)), P = d.add(b, w).normalize();
        break;
      case et.BackTopLeft:
      case et.LeftTopBack:
      case et.TopLeftBack:
        h = d.add(u, d.add(y, d.add(C, w))), P = d.add(b, d.add(k, w)).normalize();
        break;
      case et.BackTopRight:
      case et.RightTopBack:
      case et.TopRightBack:
        h = d.add(u, d.add(y, d.add(k, w))), P = d.add(b, d.add(C, w)).normalize();
        break;
      case et.BackLeft:
      case et.LeftBack:
        h = d.add(u, d.add(y, C));
        break;
      case et.BackRight:
      case et.RightBack:
        h = d.add(u, d.add(y, k));
        break;
      case et.BackBottom:
      case et.BottomBack:
        h = d.add(u, d.add(y, v)), P = d.add(y, w).normalize();
        break;
      case et.BackBottomLeft:
      case et.LeftBottomBack:
      case et.BottomLeftBack:
        h = d.add(u, d.add(y, d.add(C, v))), P = d.add(y, d.add(C, w)).normalize();
        break;
      case et.BackBottomRight:
      case et.RightBottomBack:
      case et.BottomRightBack:
        h = d.add(u, d.add(y, d.add(k, v))), P = d.add(y, d.add(k, w)).normalize();
        break;
      case et.LeftBottom:
      case et.BottomLeft:
        h = d.add(u, d.add(C, v)), P = d.add(C, w).normalize();
        break;
      case et.LeftTop:
      case et.TopLeft:
        h = d.add(u, d.add(C, w)), P = d.add(k, w).normalize();
        break;
      case et.RightBottom:
      case et.BottomRight:
        h = d.add(u, d.add(k, v)), P = d.add(k, w).normalize();
        break;
      case et.RightTop:
      case et.TopRight:
        h = d.add(u, d.add(k, w)), P = d.add(C, w).normalize();
        break;
      default:
        $n();
    }
    i || (P = Y(h)), P === null && (P = g);
    const L = d.add(
      d.subtract(h, c).normalize().scale(m),
      c
    ), N = d.add(
      d.subtract(h, c).normalize().scale(m - p),
      c
    );
    return s.setPosition(L), s.setTarget(N), s.setUp(P), s;
  }
  /**
   * Sets the view to a standard orientation.
   * @param orientation The desired view orientation for the camera.
   * @param duration The number of milliseconds used to transition to the new camera.
   * @param bounding Optional bounding to fit the camera about. If not supplied, the model bounding will be used.
   * @param preserveModelUp Indicates whether the camera up will be set according to model up or current camera.
   */
  async setViewOrientation(t, e = Ri, i, s = !0) {
    const r = await this.getViewOrientationCamera(t, i, s);
    i === void 0 ? await this.fitWorld(e, r) : await this.fitBounding(i, e, r), this._callbackManager.trigger("viewOrientation", t);
  }
  /**
   * Centers the camera on a specified node id.
   * @param nodeId
   * @param duration the number of milliseconds to transition to the new camera.
   */
  async centerCameraOnNode(t, e = 0, i = this.getCamera()) {
    const r = (await this._model.getNodesBounding([t])).center(), o = i.getPosition(), a = i.getTarget(), l = d.subtract(a, r);
    if (o.subtract(l), i.setPosition(o), i.setTarget(r), e > 0)
      return this._setCameraPromise(i, e);
    this.setCamera(i);
  }
  /** @hidden */
  async _setInitialView(t) {
    if (!this._initialCamera)
      return this.fitWorld(t);
    if (t > 0)
      return this._setCameraPromise(this._initialCamera, t);
    this.setCamera(this._initialCamera), this._eventDispatcher.injectViewOrientationChangeEvent();
  }
  /**
   * Returns the size of the viewer canvas.
   * @returns the current size of the viewer canvas.
   */
  getCanvasSize() {
    return this._engine.getCanvasSize();
  }
  /**
   * @hidden
   * @param markupManager
   */
  _setMarkupManager(t) {
    this._markupManager = t;
  }
  /**
   * Sets the display for the default statistic overlay.
   * @param visible whether the default statistics overlay should be drawn.
   */
  async setStatisticsDisplayVisibility(t) {
    t ? await this._statistics.showDisplay() : this._statistics.hideDisplay();
  }
  /**
   * Returns the background colors of the canvas.
   * @returns the canvas background colors.
   */
  getBackgroundColor() {
    var i, s;
    const t = ((i = this._backgroundColorTop) == null ? void 0 : i.copy()) ?? null, e = ((s = this._backgroundColorBottom) == null ? void 0 : s.copy()) ?? null;
    return new gp(t, e);
  }
  /**
   * Sets the viewer background color to a gradient interpolating from the top to bottom color.
   * For a solid color, the top and bottom color should have the same values.
   * Background Transparency is only available with client-side rendering.
   * To re-enable a transparent background, pass null to the parameters of this function.
   *
   * When draw mode is set to {@link DrawMode.HiddenLine}, the background color is defined in {@link HiddenLineSettings HiddenLineSettings}.
   * See {@link HiddenLineSettings.setBackgroundColor HiddenLineSettings.setBackgroundColor}.
   * @param top the top color for the the background gradient.
   * @param bottom the bottom color for the the background gradient.
   * @returns a promise that resolves when the operation has completed.
   */
  setBackgroundColor(t = null, e = null) {
    return this._backgroundColorTop = t !== null ? t.copy() : null, this._backgroundColorBottom = e !== null ? e.copy() : null, this._drawMode !== Sn.HiddenLine && !this._viewer.sheetManager.isDrawingSheetActive() && this._engine.setBackgroundGradient(this._backgroundColorTop, this._backgroundColorBottom), Promise.resolve();
  }
  /**
   * Hides all nodes except those specified. Also fits the camera to those nodes' bounding box.
   * @param nodeIds An array of the node IDs to be isolated.
   * @param duration Time in milliseconds for the camera transition to the new camera view.
   * @param fitNodes If true, then the view is fitted around the isolated nodes.
   * @param initiallyHiddenStayHidden Controls whether or not initially hidden geometries stay hidden. Default behavior is driven by [[setBehaviorInitiallyHidden]].
   */
  async isolateNodes(t, e = Ri, i = !0, s = null) {
    const r = this._model.getAbsoluteRootNode(), o = /* @__PURE__ */ new Map();
    o.set(r, !1);
    for (const a of t)
      o.set(a, !0);
    if (await this._model.setNodesVisibilities(o, s), i)
      return this.fitNodes(t, e);
  }
  /**
   * Fits the camera to the bounding box containing the node ids.
   * @param nodeIds Array of node ids to fit the camera.
   * @param duration Time in milliseconds for the camera transition to the new camera view.
   * @returns A promise that will be resolved once the transition is complete.
   */
  async fitNodes(t, e = Ri) {
    const i = await this._model.getNodesBounding(t);
    return this.fitBounding(i, e);
  }
  /**
   * Fits the view to the model bounding box.
   * @param duration the number of milliseconds to transition to the new camera.
   * @returns A promise that will be resolved once the transition is complete.
   */
  async fitWorld(t = 0, e) {
    e || (e = this.getCamera());
    const i = await this._model.getModelBounding(
      this._boundingCalculationIgnoresInvisible,
      !1
    );
    await this.fitBounding(i, t, e);
  }
  _fitCameraToBounding(t, e) {
    if (this._viewer.sheetManager.isDrawingSheetActive()) {
      const i = e.extents(), s = e.center(), r = new d(s.x, s.y, e.min.z + i.length());
      t.setProjection(te.Orthographic), t.setPosition(r), t.setTarget(s), t.setWidth(i.x * 1.25), t.setHeight(i.y * 1.25);
    } else {
      const s = e.extents().length();
      if (s !== 0) {
        const r = t.getWidth(), o = d.subtract(t.getPosition(), t.getTarget()), a = o.length(), l = s * a / r, c = e.center(), h = d.add(c, o.normalize().scale(l));
        t.setTarget(c), t.setPosition(h), t.setWidth(s), t.setHeight(s);
      } else {
        const r = d.subtract(t.getPosition(), t.getTarget()), o = e.center(), a = d.add(o, r);
        t.setTarget(o), t.setPosition(a);
      }
    }
  }
  /**
   * Fits the camera to the bounding box.
   * @param bounding bounding box to fit the camera.
   * @param duration Time in milliseconds for the camera transition to the new camera view.
   * @returns A promise that will be resolved once the transition is complete.
   */
  async fitBounding(t, e = Ri, i = this.getCamera()) {
    if (t) {
      if (t.isDegenerate() || this._fitCameraToBounding(i, t), e > 0)
        return this._setCameraPromise(i, e);
      this.setCamera(i);
    }
  }
  /**
   * Sets whether backfaces should be rendered in the scene.
   * @param visible Boolean value indicating whether backfaces should be rendered.
   * @returns Promise that is resolved when this operation has completed.
   */
  setBackfacesVisible(t) {
    return this._backfacesVisible = t, this._engine.setBackFacesVisible(t), Promise.resolve();
  }
  /**
   * Gets whether backfaces are being rendered in the scene.
   * @returns Boolean value indicating whether backfaces are being rendered in the scene.
   */
  getBackfacesVisible() {
    return this._backfacesVisible;
  }
  /**
   * Sets the drawing mode for the scene.
   * @param drawMode The drawing mode to set.
   */
  setDrawMode(t) {
    return this._setDrawMode(t), Promise.resolve();
  }
  _setDrawMode(t) {
    switch (this._drawMode = t, this._drawMode !== Sn.HiddenLine && this.setBackgroundColor(this._backgroundColorTop, this._backgroundColorBottom), t) {
      case Sn.Wireframe:
        this._engine.setDrawMode(Dn.Highlight), this._setLineVisibility(!0), this._setFaceVisibility(!1);
        break;
      case Sn.Shaded:
        this._engine.setDrawMode(Dn.Highlight), this._setLineVisibility(!1), this._setFaceVisibility(!0);
        break;
      case Sn.WireframeOnShaded:
        this._engine.setDrawMode(Dn.Highlight), this._setLineVisibility(!0), this._setFaceVisibility(!0);
        break;
      case Sn.HiddenLine:
        {
          const e = this._hiddenLineSettings.getBackgroundColor();
          this._setLineVisibility(!0), this._setFaceVisibility(!0), this._engine.enableHiddenLineRendering(this._hiddenLineSettings), this._engine.setBackgroundGradient(e.top, e.bottom);
        }
        break;
      case Sn.XRay:
        this._engine.setDrawMode(Dn.XRay), this._setLineVisibility(!0), this._setFaceVisibility(!0);
        break;
      case Sn.Gooch:
        this._engine.setDrawMode(Dn.Gooch);
        break;
      case Sn.Toon:
        this._setLineVisibility(!1), this._engine.setDrawMode(Dn.Toon);
    }
  }
  /**
   * @returns The current draw mode
   */
  getDrawMode() {
    return this._drawMode;
  }
  /**
   * Sets the anti-aliasing mode for the scene.
   * @param antiAliasingMode
   */
  setAntiAliasingMode(t) {
    return this._setAntiAliasingMode(t), Promise.resolve();
  }
  _setAntiAliasingMode(t) {
    this._antiAliasingMode = t, this._engine.setAntiAliasingMode(t);
  }
  /**
   * Gets the anti-aliasing mode for the scene. The Default value is AntiAliasingMode.SMAA
   * @returns the current anti-aliasing mode.
   */
  getAntiAliasingMode() {
    return this._antiAliasingMode;
  }
  /**
   * @returns a [[HiddenLineSettings]] object.
   */
  getHiddenLineSettings() {
    return this._hiddenLineSettings;
  }
  /**
   * Sets whether ambient occlusion is enabled
   * @param enabled sets whether ambient occlusion will be enabled
   */
  setAmbientOcclusionEnabled(t = !0) {
    return this._setAmbientOcclusionEnabled(t), Promise.resolve();
  }
  _setAmbientOcclusionEnabled(t = !0) {
    this._ambientOcclusionEnabled = t, this._engine.setAmbientOcclusionEnabled(t);
  }
  /**
   * @returns boolean value indicating whether ambient occlusion is enabled
   */
  getAmbientOcclusionEnabled() {
    return this._ambientOcclusionEnabled;
  }
  /**
   * Sets the ambient occlusion radius. This value represents the maximum screen-proportional distance between two points such that one will cast a shadow on the other.
   * @param radius the ambient occlusion radius.
   */
  setAmbientOcclusionRadius(t) {
    return this._setAmbientOcclusionRadius(t), Promise.resolve();
  }
  _setAmbientOcclusionRadius(t) {
    this._ambientOcclusionRadius = t, this._engine.setAmbientOcclusionRadius(t);
  }
  /**
   * @returns the ambient occlusion radius
   */
  getAmbientOcclusionRadius() {
    return this._ambientOcclusionRadius;
  }
  /**
   * Sets whether lighting is enabled. When disabled, material colors
   * are drawn at full intensity.
   *
   * See also [[InstanceModifier.DoNotLight]], [[clearLights]].
   */
  setLightingEnabled(t = !0) {
    return this._setLightingEnabled(t), Promise.resolve();
  }
  _setLightingEnabled(t = !0) {
    this._lightingEnabled = t, this._engine.setLightingEnabled(t);
  }
  /**
   * Returns whether lighting is enabled.
   *
   * See also [[setLightingEnabled]].
   */
  getLightingEnabled() {
    return this._lightingEnabled;
  }
  /**
   * Sets how transparent objects are blended.
   */
  setTransparencyMode(t) {
    this._engine.setTransparencyMode(t);
  }
  /**
   * Sets the opacity of unselected items in x-ray mode.
   * @param opacity a number between 0 and 1
   * @param element the type of element to which the opacity will apply.
   * If unspecified, the opacity will apply to all element types.
   */
  setXRayOpacity(t, e) {
    return this._setXRayOpacity(t, e), Promise.resolve();
  }
  _setXRayOpacity(t, e) {
    this._engine.setXRayOpacity(t, e);
  }
  /**
   * Sets how transparent (unselected) objects are blended in x-ray mode.
   */
  setXRayTransparencyMode(t) {
    return this._setXRayTransparencyMode(t), Promise.resolve();
  }
  _setXRayTransparencyMode(t) {
    this._engine.setXRayTransparencyMode(t);
  }
  /**
   * Sets the color applied to nodes in x-ray mode.
   * By default, the color is unset.
   *
   * See [[unsetXRayColor]].
   *
   * @param element the type of geometry to apply the color to
   * @param color the color to apply
   * @param group the category of nodes that will be affected.
   * If unspecified, [[XRayGroup.Selected]] will be used.
   */
  setXRayColor(t, e, i = Qo.Selected) {
    return this._engine.setXRayColor(i, t, e), Promise.resolve();
  }
  /**
   * Unsets the color applied to selected items in x-ray mode.
   * Selected items will be displayed without overriding their colors.
   *
   * See [[setXRayColor]].
   *
   * @param element the type of geometry affected by the change
   * @param group the category of nodes that will be affected.
   * If unspecified, [[XRayGroup.Selected]] will be used.
   */
  unsetXRayColor(t, e = Qo.Selected) {
    return this._engine.unsetXRayColor(e, t);
  }
  /**
   * Sets the value to use as the blue tone in Gooch shading.
   * @param blue the blue tone.  This value should be in the range [0,1]
   */
  setGoochBlue(t) {
    this._goochBlue = t, this._engine.setGoochBlue(t);
  }
  /**
   * Gets the value to use as the blue tone in Gooch shading.
   */
  getGoochBlue() {
    return this._goochBlue;
  }
  /**
   * Sets the prominence of the object's base color in Gooch shading.
   * @param prominence this scalar value determines the amount of the object's base color is applied to the final shaded color.
   */
  setGoochBaseColorProminence(t) {
    this._goochBaseColorProminence = t, this._engine.setGoochBaseColorProminence(t);
  }
  /**
   * Gets the prominence of the object's base color in Gooch shading.
   */
  getGoochBaseColorProminence() {
    return this._goochBaseColorProminence;
  }
  /**
   * Sets the value to use as the yellow tone in Gooch shading.
   * @param yellow the yellow tone. This value should be in the range [0,1]
   *
   */
  setGoochYellow(t) {
    this._goochYellow = t, this._engine.setGoochYellow(t);
  }
  /**
   * Gets the value to use as the yellow tone in Gooch shading.
   */
  getGoochYellow() {
    return this._goochYellow;
  }
  /**
   * Sets the number of discrete shading bands that will be used when toon shading is enabled.  Each band represents a shade between dark and light which will control the final color of the pixel based on its light intensity.  The default band count is 3.
   */
  setToonShadingBandCount(t) {
    this._toonBandCount = t, this._engine.setToonShadingBandCount(t);
  }
  /**
   * Gets the current number of discrete shading bands that will be used when toon shading is enabled.
   */
  getToonShadingBandCount() {
    return this._toonBandCount;
  }
  /**
   * Sets a scale factor which controls the size of specular highlights when toon shading is enabled.  The default value is 1.0.
   */
  setToonShadingSpecularFactor(t) {
    this._toonSpecularFactor = t, this._engine.setToonShadingSpecularFactor(t);
  }
  /**
   * Gets the current toon shading specular scale factor.
   */
  getToonShadingSpecularFactor() {
    return this._toonSpecularFactor;
  }
  /**
   * Sets the strength of the luminance shift in Gooch shading.
   * @param shiftStrength this scalar values determines the amount of luminance shift that is applied to the object's base color
   */
  setGoochLuminanceShiftStrength(t) {
    this._goochLuminanceShiftStrength = t, this._engine.setGoochLuminanceShiftStrength(t);
  }
  /**
   * Gets the strength of the luminance shift in Gooch shading.
   */
  getGoochLuminanceShiftStrength() {
    return this._goochLuminanceShiftStrength;
  }
  /**
   * Sets the diameter of rendered points. (default: 1, ScreenPixels) See [[PointSizeUnit]].
   */
  setPointSize(t, e) {
    return this._setPointSize(t, e), Promise.resolve();
  }
  _setPointSize(t, e) {
    this._engine.setPointSize(t, e);
  }
  /**
   * Gets the diameter of rendered points. See [[PointSizeUnit]].
   */
  getPointSize() {
    return this._engine.getPointSize();
  }
  /**
   * Controls the appearance of rendered points. (default: Square) See [[PointShape]].
   */
  setPointShape(t) {
    return this._setPointShape(t), Promise.resolve();
  }
  _setPointShape(t) {
    this._engine.setPointShape(t);
  }
  /**
   * Gets the PointShape. See [[PointShape]]
   */
  getPointShape() {
    return this._engine.getPointShape();
  }
  /**
   * Enables or disables eye-dome lighting for point clouds. (default: disabled)
   */
  setEyeDomeLightingEnabled(t = !0) {
    return this._setEyeDomeLightingEnabled(t), Promise.resolve();
  }
  _setEyeDomeLightingEnabled(t = !0) {
    this._engine.setEyeDomeLightingEnabled(t);
  }
  /**
   * @returns boolean value indicating if eye-dome lighting is enabled or disabled.
   */
  getEyeDomeLightingEnabled() {
    return this._engine.getEyeDomeLightingEnabled();
  }
  /**
   * Sets the diameter of the blur filter used in eye-dome lighting for point clouds.
   * Setting the value to 0 will disable blurring. (default: 7)
   */
  setEyeDomeLightingBlurSamples(t) {
    return this._setEyeDomeLightingBlurSamples(t), Promise.resolve();
  }
  _setEyeDomeLightingBlurSamples(t) {
    this._engine.setEyeDomeLightingBlurSamples(t);
  }
  /**
   * Returns the diameter of the blur filter used in eye-dome lighting for point clouds.
   * A value of 0 means that blurring is disabled.
   */
  getEyeDomeLightingBlurSamples() {
    return this._engine.getEyeDomeLightingBlurSamples();
  }
  /**
   * Sets the distance in pixels between samples taken by the blur filter used in eye-dome lighting
   * for point clouds. (default: 1)
   */
  setEyeDomeLightingBlurInterval(t) {
    return this._setEyeDomeLightingBlurInterval(t), Promise.resolve();
  }
  _setEyeDomeLightingBlurInterval(t) {
    this._engine.setEyeDomeLightingBlurInterval(t);
  }
  /**
   * Returns the distance in pixels between samples taken by the blur filter used in eye-dome lighting
   * for point clouds.
   */
  getEyeDomeLightingBlurInterval() {
    return this._engine.getEyeDomeLightingBlurInterval();
  }
  /**
   * Controls the maximum Z-distance between samples taken by the blur filter used in eye-dome
   * lighting for point clouds. The value is taken as a proportion of the screen size.
   * Decreasing the value will result in sharper edges, and increasing the value will result
   * in softer edges. (default: .03)
   */
  setEyeDomeLightingBlurEdgeDistance(t) {
    return this._setEyeDomeLightingBlurEdgeDistance(t), Promise.resolve();
  }
  _setEyeDomeLightingBlurEdgeDistance(t) {
    this._engine.setEyeDomeLightingBlurEdgeDistance(t);
  }
  /**
   * Returns a value that controls the maximum Z-distance between samples taken by
   * the blur filter used in eye-dome lighting for point clouds.
   * The value is a proportion of the screen size.
   */
  getEyeDomeLightingBlurEdgeDistance() {
    return this._engine.getEyeDomeLightingBlurEdgeDistance();
  }
  /**
   * Controls the shading contrast in eye-dome lighting for point clouds. The value is taken
   * as a number of pixels. Increasing the value will result in overall lighter shading, and
   * decreasing the value will result in overall darker shading. (default: 2)
   */
  setEyeDomeLightingShadingEdgeDistance(t) {
    return this._setEyeDomeLightingShadingEdgeDistance(t), Promise.resolve();
  }
  _setEyeDomeLightingShadingEdgeDistance(t) {
    this._engine.setEyeDomeLightingShadingEdgeDistance(t);
  }
  /**
   * Returns a value that controls the shading contrast in eye-dome lighting for point clouds.
   * The value is a number of pixels.
   */
  getEyeDomeLightingShadingEdgeDistance() {
    return this._engine.getEyeDomeLightingShadingEdgeDistance();
  }
  /**
   * Sets the opacity of the shading rendered by eye-dome lighting for point clouds. (default: 1)
   * @param value A number in the range [0,1].
   */
  setEyeDomeLightingOpacity(t) {
    return this._setEyeDomeLightingOpacity(t), Promise.resolve();
  }
  _setEyeDomeLightingOpacity(t) {
    this._engine.setEyeDomeLightingOpacity(t);
  }
  /**
   * Returns the opacity of the shading rendered by eye-dome lighting for point clouds.
   * The value is in the range [0,1].
   */
  getEyeDomeLightingOpacity() {
    return this._engine.getEyeDomeLightingOpacity();
  }
  /**
   * Sets whether or not bounding calculations by this View object ignores invisible geometry.
   */
  setBoundingCalculationIgnoresInvisible(t) {
    this._boundingCalculationIgnoresInvisible = t;
  }
  /**
   * @returns whether or not bounding calculations by this View object ignores invisible geometry.
   */
  getBoundingCalculationIgnoresInvisible() {
    return this._boundingCalculationIgnoresInvisible;
  }
  /**
   * Sets whether intermediate frames of an incremental draw will be displayed. (default: true)
   *
   * If false, the image will only be displayed once completely drawn, except immediately
   * after certain operations, such as setting the camera. To disable these exceptions,
   * call [[setInteractiveDrawDelay]] with a value of 0.
   */
  setDisplayIncompleteFrames(t) {
    return this._setDisplayIncompleteFrames(t), Promise.resolve();
  }
  _setDisplayIncompleteFrames(t) {
    this._engine.setDisplayIncompleteFrames(t);
  }
  /**
   * Sets whether to change cad view cameras with extreme values to functionally identical cameras with
   * better behavior. This should be disabled if it is important that cameras have their authored values
   * Default: true
   * @param value Whether to modify cameras
   */
  setMassageExtremeCameras(t) {
    this._massageExtremeCameras = t;
  }
  getMassageExtremeCameras() {
    return this._massageExtremeCameras;
  }
  /**
   * Sets how long after certain operations, such as setting the camera, to wait before
   * starting a redraw. This delay exists in order to prevent flicker during continuous
   * interaction. The initial value is 200ms.
   * @param value The delay in milliseconds
   */
  setInteractiveDrawDelay(t) {
    return this._setInteractiveDrawDelay(t), Promise.resolve();
  }
  _setInteractiveDrawDelay(t) {
    this._engine.setInteractiveDrawDelay(t);
  }
  /**
   * Sets whether or not the viewer will periodically attempt to increase the amount drawn during interaction.
   * Setting this to `false` may improve periodic framerate dips caused by such adjustments.
   * @param enable
   */
  setInteractiveDrawLimitIncreaseEnabled(t) {
    this._engine.setInteractiveDrawLimitIncreaseEnabled(t);
  }
  /**
   * Gets whether or not the viewer will periodically attempt to increase the amount drawn during interaction.
   * @return boolean value indicating whether this feature is enabled or not
   */
  getInteractiveDrawLimitIncreaseEnabled() {
    return this._engine.getInteractiveDrawLimitIncreaseEnabled();
  }
  getNavCube() {
    return this._navCube;
  }
  get navCube() {
    return this._navCube;
  }
  getAxisTriad() {
    return this._axisTriad;
  }
  get axisTriad() {
    return this._axisTriad;
  }
  _determineViewAxes(t) {
    const e = t.getUp().normalize(), i = d.subtract(t.getTarget(), t.getPosition()).normalize();
    let s = iu(e), r = iu(i);
    s === null && r === null ? (s = new d(0, 1, 0), r = new d(0, 0, 1)) : s === null ? r.y === 0 ? s = new d(0, 1, 0) : s = new d(0, 0, 1) : r === null && (s.z === 0 ? r = new d(0, 0, 1) : r = new d(0, 1, 0));
    try {
      this._model.setViewAxes(r, s);
    } catch {
    }
  }
  /**
   * Sets the color of the ambient light applied to the scene.
   * This is a constant source of light that affects every point
   * in the scene in the same way regardless of position
   * or surface normal.
   *
   * See also [[getAmbientLightColor]].
   */
  setAmbientLightColor(t) {
    this._ambientLightColor = t, this._engine.setAmbientLightColor(t);
  }
  /**
   * Gets the color of the ambient light applied to the scene.
   *
   * See also [[setAmbientLightColor]].
   */
  getAmbientLightColor() {
    return this._ambientLightColor;
  }
  /**
   * Get the list of light keys in the scene.
   * @returns The list of light keys in the scene.
   */
  getLightKeys() {
    return this._engine.getLightKeys();
  }
  /**
   * Get a Light given its key if it exists.
   * @param key The key of the light to get.
   * @returns A Light given its key if it exists.
   */
  getLight(t) {
    return this._engine.getLight(t);
  }
  /**
   * Removes all lights from the scene. When there are no lights,
   * material colors are drawn at full intensity. This has the same
   * visual effect as calling `setLightingEnabled(false)`.
   *
   * See also:
   *  - [[InstanceModifier.DoNotLight]]
   *  - [[setLightingEnabled]]
   */
  clearLights() {
    this._engine.clearLights();
  }
  /**
   * Adds a light to the scene. The returned promise may be rejected if
   * there are too many lights in the scene. See [[Light]].
   *
   * See also:
   *  - [[clearLights]]
   *  - [[removeLight]]
   *  - [[updateLight]]
   *  - [[setAmbientLightColor]]
   */
  addLight(t) {
    return this._engine.addLight(t);
  }
  /**
   * removes a light from the scene. See [[Light]].
   *
   * See also:
   *  - [[addLight]]
   *  - [[clearLights]]
   *  - [[updateLight]]
   */
  removeLight(t) {
    this._engine.removeLight(t);
  }
  /**
   * Updates a light in the scene. See [[Light]].
   *
   * See also:
   *  - [[addLight]]
   *  - [[clearLights]]
   *  - [[removeLight]]
   */
  updateLight(t, e) {
    this._engine.updateLight(t, e);
  }
  /**
   * Sets whether bloom is enabled.
   *
   * See [[getBloomEnabled]].
   */
  setBloomEnabled(t = !0) {
    this._engine.setBloomEnabled(t), this._bloomEnabled = t;
  }
  /**
   * Returns whether bloom is enabled.
   *
   * See [[setBloomEnabled]].
   */
  getBloomEnabled() {
    return this._bloomEnabled;
  }
  /**
   * Sets the minimum luminance value a pixel must have for it to
   * contribute to bloom. The value should be in the range `[0,1]`.
   *
   * See [[getBloomThreshold]], [[setBloomThresholdRampWidth]].
   */
  setBloomThreshold(t) {
    this._engine.setBloomThreshold(t), this._bloomThreshold = t;
  }
  /**
   * Returns the minimum luminance value a pixel must have for it to
   * contribute to bloom.
   *
   * See [[setBloomThreshold]], [[getBloomThresholdRampWidth]].
   */
  getBloomThreshold() {
    return this._bloomThreshold;
  }
  /**
   * Sets how much greater than the threshold set by [[setBloomThreshold]]
   * a pixel's luminance value must be before it contributes fully to
   * the bloom effect.
   *
   * If the pixel's luminance value does not exceed
   * the threshold by at least the amount set by this function,
   * the pixel's contribution will be diminished based on how close
   * its luminance value is to the threshold.
   *
   * See [[getBloomThresholdRampWidth]].
   */
  setBloomThresholdRampWidth(t) {
    this._engine.setBloomThresholdRampWidth(t), this._bloomThresholdRampWidth = t;
  }
  /**
   * Returns how much greater than the threshold set by [[setBloomThreshold]]
   * a pixel's luminance value must be before it contributes fully to
   * the bloom effect.
   *
   * See [[setBloomThresholdRampWidth]].
   */
  getBloomThresholdRampWidth() {
    return this._bloomThresholdRampWidth;
  }
  /**
   * Sets the intensity of the bloom effect. This value is multiplied
   * by the intensities of the individual layers set by [[setBloomLayers]].
   *
   * See [[getBloomIntensityScale]].
   */
  setBloomIntensityScale(t) {
    this._engine.setBloomIntensityScale(t), this._bloomIntensityScale = t;
  }
  /**
   * Gets the intensity of the bloom effect.
   *
   * See [[setBloomIntensityScale]].
   */
  getBloomIntensityScale() {
    return this._bloomIntensityScale;
  }
  /**
   * Sets the number of layers in the bloom effect and the layers'
   * attributes.
   *
   * The bloom effect is achieved by applying a luminance filter to the
   * source image, then progressively downsampling, blurring, and adding
   * the results together. The result of each downsample/blur operation is
   * fed into the next, which is executed at half the resolution of the
   * previous. The number of stages and the behavior of each stage
   * are controlled by this function.
   *
   * See [[BloomLayerInfo]], [[getBloomLayers]].
   */
  setBloomLayers(t) {
    const e = Lo(t);
    for (const i of e)
      i.intensity === void 0 && (i.intensity = 1), i.blurSamples === void 0 && (i.blurSamples = 9), i.blurInterval === void 0 && (i.blurInterval = [1, mn.Pixels]);
    this._engine.setBloomLayers(e), this._bloomLayers = e;
  }
  /**
   * Returns an array of objects describing each layer in the bloom
   * effect.
   *
   * See [[setBloomLayers]].
   */
  getBloomLayers() {
    return Lo(this._bloomLayers);
  }
  /**
   * Enables a visual comparison of two sets of nodes. The nodes specified
   * by `nodeIdSet1` are filled with one color, the nodes specified by
   * `nodeIdSet2` with another color, and overlapping areas are filled
   * with a third color.
   *
   * See [[endComparison]].
   *
   * @param nodeIdSet1 the nodes to compare against `nodeIdSet2`
   * @param nodeIdSet2 the nodes to compare against `nodeIdSet1`
   * @param config settings controlling the behavior of the comparison
   */
  startComparison(t, e, i) {
    const s = this._model._getModelStructure(), r = s.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    ), o = s.gatherInstanceIncsFromNodeIds(
      e,
      bt.All,
      ft.None
    );
    this._engine.startComparison(r, o, i);
  }
  /**
   * Disables a visual comparison of two sets of nodes enabled by
   * [[startComparison]].
   */
  endComparison() {
    this._engine.endComparison();
  }
  /**
   * Enables or disables a full-scene shadow projected onto an
   * invisible ground plane.
   *
   * See also:
   *  - [[getSimpleShadowEnabled]]
   *  - [[setSimpleShadowColor]]
   *  - [[setSimpleShadowOpacity]]
   *  - [[setGroundPlane]]
   *  - [[setSimpleShadowResolution]]
   *  - [[setSimpleShadowInteractiveUpdateEnabled]]
   *
   * @param value Whether simple shadows should be enabled.
   */
  setSimpleShadowEnabled(t = !0) {
    this._simpleShadowEnabled = t, this._engine.setSimpleShadowEnabled(t);
  }
  /**
   * Returns whether simple shadows are enabled.
   *
   * See [[setSimpleShadowEnabled]].
   */
  getSimpleShadowEnabled() {
    return this._simpleShadowEnabled;
  }
  /**
   * Sets the color of simple shadows.
   *
   * See also:
   *  - [[getSimpleShadowColor]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param color The color to set.
   */
  setSimpleShadowColor(t) {
    this._simpleShadowColor = t.copy(), this._engine.setSimpleShadowColor(t);
  }
  /**
   * Returns the color of simple shadows.
   *
   * See also:
   *  - [[setSimpleShadowColor]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowColor() {
    return this._simpleShadowColor.copy();
  }
  /**
   * Sets the opacity of simple shadows.
   *
   * See also:
   *  - [[getSimpleShadowOpacity]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param opacity The opacity to set.
   */
  setSimpleShadowOpacity(t) {
    this._simpleShadowOpacity = t, this._engine.setSimpleShadowOpacity(t);
  }
  /**
   * Returns the opacity of simple shadows.
   *
   * See also:
   *  - [[setSimpleShadowOpacity]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowOpacity() {
    return this._simpleShadowOpacity;
  }
  /**
   * Defines the invisible ground plane onto which simple shadows
   * and reflections are projected.
   *
   * See also:
   *  - [[getGroundPlane]]
   *  - [[setSimpleShadowEnabled]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @param plane The plane to set.
   */
  setGroundPlane(t) {
    this._groundPlane = { ...t }, this._updateGroundPlane();
  }
  _updateGroundPlane(t, e) {
    if (!(this._groundPlane.followViewAxes && (t !== void 0 && e !== void 0 || this._model.viewAxesHaveBeenSet()))) {
      this._engine.setGroundPlane(this._groundPlane.normal, this._groundPlane.position);
      return;
    }
    if (t === void 0 || e === void 0) {
      const l = this._model.getViewAxes();
      t = l.frontVector, e = l.upVector;
    }
    const i = t.copy().negate(), s = e, r = d.cross(s, i), o = Q.createFromBasis(i, r, s), a = new d(0, 0, 0);
    o.transform(this._groundPlane.normal, a), this._engine.setGroundPlane(a, this._groundPlane.position);
  }
  /**
   * Returns information about the invisible ground plane onto which
   * simple shadows and reflections are projected.
   *
   * See also:
   *  - [[setGroundPlane]]
   */
  getGroundPlane() {
    return { ...this._groundPlane };
  }
  /**
   * Sets the width and height in pixels of the texture image into which
   * simple shadows are drawn.
   *
   * See also:
   *  - [[getSimpleShadowResolution]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param pixels The resolution to set.
   */
  setSimpleShadowResolution(t) {
    this._simpleShadowResolution = t, this._engine.setSimpleShadowResolution(t);
  }
  /**
   * Returns the width and height in pixels of the texture image
   * into which simple shadows are drawn.
   *
   * See also:
   *  - [[getSimpleShadowResolution]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowResolution() {
    return this._simpleShadowResolution;
  }
  /**
   * Sets the diameter of the blur filter used for simple shadows.
   * Setting the value to `0` will disable blurring.
   *
   * See also:
   *  - [[getSimpleShadowBlurSamples]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param value The number of samples.
   */
  setSimpleShadowBlurSamples(t) {
    this._simpleShadowBlurSamples = t, this._engine.setSimpleShadowBlurSamples(t);
  }
  /**
   * Returns the diameter of the blur filter used for simple shadows.
   *
   * See also:
   *  - [[setSimpleShadowBlurSamples]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowBlurSamples() {
    return this._simpleShadowBlurSamples;
  }
  /**
   * Sets the distance in pixels between samples taken by the blur filter
   * used for simple shadows.
   *
   * See also:
   *  - [[getSimpleShadowBlurInterval]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param value The interval to set.
   */
  setSimpleShadowBlurInterval(t) {
    this._simpleShadowBlurInterval = t, this._engine.setSimpleShadowBlurInterval(t);
  }
  /**
   * Returns the distance in pixels between samples taken by the blur
   * filter used for simple shadows.
   *
   * See also:
   *  - [[setSimpleShadowBlurInterval]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowBlurInterval() {
    return this._simpleShadowBlurInterval;
  }
  /**
   * Enables or disables updates to simple shadows during user
   * interaction.
   *
   * See also:
   *  - [[getSimpleShadowInteractiveUpdateEnabled]]
   *  - [[setSimpleShadowEnabled]]
   */
  setSimpleShadowInteractiveUpdateEnabled(t = !0) {
    this._simpleShadowInteractiveUpdateEnabled = t, this._engine.setSimpleShadowInteractiveUpdateEnabled(t);
  }
  /**
   * Returns whether simple shadows will be updated during user
   * interaction.
   *
   * See also:
   *  - [[setSimpleShadowInteractiveUpdateEnabled]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowInteractiveUpdateEnabled() {
    return this._simpleShadowInteractiveUpdateEnabled;
  }
  /**
   * Enables or disables silhouette edges.
   *
   * Silhouette edges are always enabled in hidden line mode.
   *
   * See also:
   * - [[getSilhouetteEnabled]]
   * - [[setSilhouetteColor]]
   * - [[setSilhouetteOpacity]]
   * - [[setSilhouetteThreshold]]
   * - [[setSilhouetteThresholdRampWidth]]
   *
   * @param value Whether silhouette edges should be enabled.
   */
  setSilhouetteEnabled(t = !0) {
    this._silhouetteEnabled = t, this._engine.setSilhouetteEnabled(t);
  }
  /**
   * Returns whether silhouette edges are enabled.
   *
   * Silhouette edges are always enabled in hidden line mode, regardless
   * of the return value.
   *
   * See [[setSilhouetteEnabled]].
   */
  getSilhouetteEnabled() {
    return this._silhouetteEnabled;
  }
  /**
   * Sets the color of silhouette edges.
   *
   * See also:
   * - [[getSilhouetteColor]]
   * - [[setSilhouetteEnabled]]
   *
   * @param value The color to set.
   */
  setSilhouetteColor(t) {
    this._silhouetteColor = t.copy(), this._engine.setSilhouetteColor(t);
  }
  /**
   * Returns the color of silhouette edges.
   *
   * See also:
   * - [[setSilhouetteColor]]
   * - [[setSilhouetteEnabled]]
   */
  getSilhouetteColor() {
    return this._silhouetteColor.copy();
  }
  /**
   * Sets the opacity of silhouette edges.
   *
   * See also:
   * - [[getSilhouetteOpacity]]
   * - [[setSilhouetteEnabled]]
   *
   * @param value The opacity to set.
   */
  setSilhouetteOpacity(t) {
    this._silhouetteOpacity = t, this._engine.setSilhouetteOpacity(t);
  }
  /**
   * Returns the opacity of silhouette edges.
   *
   * See also:
   * - [[setSilhouetteOpacity]]
   * - [[setSilhouetteEnabled]]
   */
  getSilhouetteOpacity() {
    return this._silhouetteOpacity;
  }
  /**
   * Sets the distance threshold for silhouette edges. This value
   * affects the minimum z-distance required between two pixels
   * for an edge to be drawn. A smaller value will result in more edges
   * being drawn on finer details.
   *
   * The value is a proportion of the canvas size and not a world-space
   * distance.
   *
   * See also:
   * - [[getSilhouetteThreshold]]
   * - [[setSilhouetteThresholdRampWidth]]
   * - [[setSilhouetteEnabled]]
   *
   * @param value The threshold to set.
   */
  setSilhouetteThreshold(t) {
    this._silhouetteThreshold = t, this._engine.setSilhouetteThreshold(t);
  }
  /**
   * Returns the distance threshold for silhouette edges. This value
   * affects the minimum z-distance required between two pixels
   * for an edge to be drawn. A smaller value will result in more edges
   * being drawn on finer details.
   *
   * The value is a proportion of the canvas size and not a world-space
   * distance.
   *
   * See also:
   * - [[setSilhouetteThreshold]]
   * - [[setSilhouetteThresholdRampWidth]]
   * - [[setSilhouetteEnabled]]
   *
   * @param value The threshold to set.
   */
  getSilhouetteThreshold() {
    return this._silhouetteThreshold;
  }
  /**
   * Controls how quickly edges fade as z-distance between pixels
   * decreases.
   *
   * This value is added to the one set by [[setSilhouetteThreshold]]
   * to create a secondary threshold. Distances greater than the
   * secondary threshold will result in edges with full opacity, and
   * distances between the two thresholds will result in edges with
   * reduced opacity.
   *
   * Setting this value to `0` will cause all edges to be drawn
   * at full opacity.
   *
   * See also:
   * - [[getSilhouetteThresholdRampWidth]]
   * - [[setSilhouetteEnabled]]
   */
  setSilhouetteThresholdRampWidth(t) {
    this._silhouetteThresholdRampWidth = t, this._engine.setSilhouetteThresholdRampWidth(t);
  }
  /**
   * Returns the value set by [[setSilhouetteThresholdRampWidth]].
   *
   * This value is added to the one set by [[setSilhouetteThreshold]]
   * to create a secondary threshold. Distances greater than the
   * secondary threshold will result in edges with full opacity, and
   * distances between the two thresholds will result in edges with
   * reduced opacity.
   *
   * A value of `0` means that all edges are drawn at full opacity.
   *
   * See also:
   * - [[setSilhouetteThresholdRampWidth]]
   * - [[setSilhouetteEnabled]]
   */
  getSilhouetteThresholdRampWidth() {
    return this._silhouetteThresholdRampWidth;
  }
  /**
   * Enables or disables hard edges. Hard edges are edges between two
   * faces whose normals diverge beyond a given angle.
   *
   * Hard edges are always enabled in hidden line mode.
   *
   * See also:
   * - [[getHardEdgesEnabled]]
   * - [[setHardEdgeColor]]
   * - [[setHardEdgeOpacity]]
   * - [[setHardEdgeThreshold]]
   * - [[setHardEdgeThresholdRampWidth]]
   *
   * @param value Whether hard edges should be enabled.
   */
  setHardEdgesEnabled(t = !0) {
    this._hardEdgesEnabled = t, this._engine.setHardEdgesEnabled(t);
  }
  /**
   * Returns whether hard edges are enabled. Hard edges are edges between
   * two faces whose normals diverge beyond a given angle.
   *
   * Hard edges are always enabled in hidden line mode, regardless of the
   * return value.
   *
   * See [[setHardEdgesEnabled]].
   */
  getHardEdgesEnabled() {
    return this._hardEdgesEnabled;
  }
  /**
   * Sets the color of hard edges.
   *
   * See also:
   * - [[getHardEdgeColor]]
   * - [[setHardEdgesEnabled]]
   *
   * @param value The color to set.
   */
  setHardEdgeColor(t) {
    this._hardEdgeColor = t.copy(), this._engine.setHardEdgeColor(t);
  }
  /**
   * Returns the color of hard edges.
   *
   * See also:
   * - [[setHardEdgeColor]]
   * - [[setHardEdgesEnabled]]
   */
  getHardEdgeColor() {
    return this._hardEdgeColor.copy();
  }
  /**
   * Sets the opacity of hard edges.
   *
   * See also:
   * - [[getHardEdgeOpacity]]
   * - [[setHardEdgesEnabled]]
   *
   * @param value The opacity to set.
   */
  setHardEdgeOpacity(t) {
    this._hardEdgeOpacity = t, this._engine.setHardEdgeOpacity(t);
  }
  /**
   * Returns the opacity of hard edges.
   *
   * See also:
   * - [[setHardEdgeOpacity]]
   * - [[setHardEdgesEnabled]]
   */
  getHardEdgeOpacity() {
    return this._hardEdgeOpacity;
  }
  /**
   * Sets the angle threshold for hard edges. Edges will be drawn between
   * two faces whose normals diverge beyond this angle.
   *
   * See also:
   * - [[getHardEdgeThreshold]]
   * - [[setHardEdgeThresholdRampWidth]]
   * - [[setHardEdgesEnabled]]
   *
   * @param degrees The threshold to set.
   */
  setHardEdgeThreshold(t) {
    this._hardEdgeThreshold = t, this._engine.setHardEdgeThreshold(t);
  }
  /**
   * Returns the angle threshold for hard edges. Edges will be drawn
   * between two faces whose normals diverge beyond this angle.
   *
   * See also:
   * - [[setHardEdgeThreshold]]
   * - [[setHardEdgeThresholdRampWidth]]
   * - [[setHardEdgesEnabled]]
   *
   * @param value The threshold to set.
   */
  getHardEdgeThreshold() {
    return this._hardEdgeThreshold;
  }
  /**
   * Controls how quickly edges fade as the angle between adjacent faces
   * decreases.
   *
   * This value is added to the one set by [[setHardEdgeThreshold]] to
   * create a secondary threshold. Angles greater than the secondary
   * threshold will result in edges with full opacity, and angles between
   * the two thresholds will result in edges with reduced opacity.
   *
   * Setting this value to `0` will cause all edges to be drawn at full
   * opacity.
   *
   * See also:
   * - [[getHardEdgeThresholdRampWidth]]
   * - [[setHardEdgesEnabled]]
   */
  setHardEdgeThresholdRampWidth(t) {
    this._hardEdgeThresholdRampWidth = t, this._engine.setHardEdgeThresholdRampWidth(t);
  }
  /**
   * Returns the value set by [[setHardEdgeThresholdRampWidth]].
   *
   * This value is added to the one set by [[setHardEdgeThreshold]] to
   * create a secondary threshold. Angles greater than the secondary
   * threshold will result in edges with full opacity, and angles between
   * the two thresholds will result in edges with reduced opacity.
   *
   * A value of `0` means that all edges are drawn at full opacity.
   *
   * See also:
   * - [[setHardEdgeThresholdRampWidth]]
   * - [[setHardEdgesEnabled]]
   */
  getHardEdgeThresholdRampWidth() {
    return this._hardEdgeThresholdRampWidth;
  }
  /**
   * Enables or disables simple reflections projected onto an
   * invisible ground plane.
   *
   * See also:
   * - [[getSimpleReflectionEnabled]]
   * - [[setSimpleReflectionOpacity]]
   * - [[setSimpleReflectionBlurSamples]]
   * - [[setSimpleReflectionBlurInterval]]
   * - [[setSimpleReflectionFadeAngle]]
   */
  setSimpleReflectionEnabled(t = !0) {
    this._simpleReflectionEnabled = t, this._engine.setSimpleReflectionEnabled(t);
  }
  /**
   * Returns whether simple reflections are enabled.
   *
   * See [[setSimpleReflectionEnabled]].
   */
  getSimpleReflectionEnabled() {
    return this._simpleReflectionEnabled;
  }
  /**
   * Sets the distance between samples taken by the blur filter used for
   * simple reflections.
   *
   * See also:
   *  - [[getSimpleReflectionBlurInterval]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @param value The interval to set.
   * @param unit The unit in which the `value` argument is specified.
   */
  setSimpleReflectionBlurInterval(t, e = mn.Pixels) {
    this._simpleReflectionBlurInterval = [t, e], this._engine.setSimpleReflectionBlurInterval(t, e);
  }
  /**
   * Returns the distance between samples taken by the blur filter used
   * for simple reflections.
   *
   * See also:
   *  - [[setSimpleReflectionBlurInterval]]
   *  - [[setSimpleReflectionEnabled]]
   */
  getSimpleReflectionBlurInterval() {
    return [this._simpleReflectionBlurInterval[0], this._simpleReflectionBlurInterval[1]];
  }
  /**
   * Sets the diameter of the blur filter used for simple reflections.
   * Setting the value less than or equal to `1` will disable blurring.
   *
   * See also:
   * - [[getSimpleReflectionBlurSamples]]
   * - [[setSimpleReflectionEnabled]]
   */
  setSimpleReflectionBlurSamples(t) {
    this._simpleReflectionBlurSamples = t, this._engine.setSimpleReflectionBlurSamples(t);
  }
  /**
   * Returns the diameter of the blur filter used for simple reflections.
   * A value less than or equal to `1` means that blurring is disabled.
   *
   * See also:
   * - [[setSimpleReflectionBlurSamples]]
   * - [[setSimpleReflectionEnabled]]
   */
  getSimpleReflectionBlurSamples() {
    return this._simpleReflectionBlurSamples;
  }
  /**
   * Sets the angle, in degrees, between the view vector and the ground
   * plane at which simple reflections begin to fade.
   *
   * Settings the value to `0` will disable the fading effect.
   *
   * Regardless of the value, simple reflections will not be drawn
   * if the camera is below the ground plane.
   *
   * See also:
   * - [[getSimpleReflectionFadeAngle]]
   * - [[setSimpleReflectionEnabled]]
   *
   * @param degrees The angle in degrees.
   */
  setSimpleReflectionFadeAngle(t) {
    this._simpleReflectionFadeAngle = t, this._engine.setSimpleReflectionFadeAngle(t);
  }
  /**
   * Returns the angle, in degrees, between the view vector and the ground
   * plane at which simple reflections begin to fade.
   *
   * A value to `0` means that the fading effect is disabled.
   *
   * Regardless of the value, simple reflections will not be drawn
   * if the camera is below the ground plane.
   *
   * See also:
   * - [[setSimpleReflectionFadeAngle]]
   * - [[setSimpleReflectionEnabled]]
   */
  getSimpleReflectionFadeAngle() {
    return this._simpleReflectionFadeAngle;
  }
  /**
   * Sets the opacity of simple reflections.
   *
   * See also:
   *  - [[getSimpleReflectionOpacity]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @param opacity The opacity to set.
   */
  setSimpleReflectionOpacity(t) {
    this._simpleReflectionOpacity = t, this._engine.setSimpleReflectionOpacity(t);
  }
  /**
   * Returns the opacity of simple reflections.
   *
   * See also:
   *  - [[setSimpleReflectionOpacity]]
   *  - [[setSimpleReflectionEnabled]]
   */
  getSimpleReflectionOpacity() {
    return this._simpleReflectionOpacity;
  }
  /**
   * Controls how objects drawn in simple reflections fade as they
   * move further from the ground plane.
   *
   * Attenuation begins at `nearDistance` and increases linearly
   * such that the model is not visible in the reflection beyond
   * `farDistance`.
   *
   * Attenuation is disabled if `farDistance` is less than or equal to
   * `nearDistance`.
   *
   * See also:
   *  - [[getSimpleReflectionAttenuation]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @param nearDistance The distance from the ground plane at which
   * objects begin to fade.
   * @param farDistance The distance from the ground plane at which
   * objects are completely faded.
   * @param unit The unit in which `nearDistance` and `farDistance` are
   * specified. If unspecified, [[SimpleReflectionAttenuationUnit.World]]
   * will be used.
   */
  setSimpleReflectionAttenuation(t, e, i = Pc.World) {
    this._simpleReflectionAttenuation = {
      nearDistance: t,
      farDistance: e,
      unit: i
    }, this._engine.setSimpleReflectionAttenuation(t, e, i);
  }
  /**
   * Returns properties that control how objects drawn in simple
   * reflections fade as they move further from the ground plane.
   *
   * Attenuation begins at `nearDistance` and increases linearly
   * such that the model is not visible in the reflection beyond
   * `farDistance`.
   *
   * Attenuation is disabled if `farDistance` is less than or equal to
   * `nearDistance`.
   *
   * See also:
   *  - [[setSimpleReflectionAttenuation]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @returns An object with the following properties:
   */
  // return type properties are listed by Typedoc
  getSimpleReflectionAttenuation() {
    return { ...this._simpleReflectionAttenuation };
  }
  /**
   * Tests whether the given points are visible by comparing them to
   * the depth buffer of the most-recently-drawn frame. Points that
   * are partially obscured by transparent objects are considered visible.
   *
   * If the test is to be run every time a frame is drawn,
   * [[setPointVisibilityTest]] should be used instead for proper
   * synchronization.
   *
   * @param points The points to test.
   * @returns A list of indices of the visible points.
   */
  testPointVisibility(t) {
    return this._engine.testPointVisibility(t);
  }
  /**
   * Sets a list of points whose visibility will be tested every time a
   * frame is drawn by comparing them to the frame's depth buffer. Points
   * that are partially obscured by transparent objects are considered
   * visible.
   *
   * The results are passed to the [[CallbackMap.frameDrawn]] callback so
   * that UI elements may be updated in sync with rendering.
   *
   * See also [[testPointVisibility]].
   *
   * @param points The points to test. An empty array will disable the test.
   */
  setPointVisibilityTest(t) {
    this._engine.setPointVisibilityTest(t);
  }
  /**
   * Sets whether image-based lighting is enabled for physically-based
   * materials.
   *
   * See also:
   * - [[getImageBasedLightingEnabled]]
   * - [[setImageBasedLightingIntensity]]
   * - [[setImageBasedLightingOrientation]]
   */
  setImageBasedLightingEnabled(t) {
    this._engine.setImageBasedLightingEnabled(t), this._imageBasedLightingEnabled = t;
  }
  /**
   * Returns whether image-based lighting is enabled for physically-based
   * materials.
   *
   * See also:
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingIntensity]]
   * - [[setImageBasedLightingOrientation]]
   */
  getImageBasedLightingEnabled() {
    return this._imageBasedLightingEnabled;
  }
  /**
   * Sets the intensity (brightness) of image-based lighting applied to
   * physically-based materials.
   *
   * The default value is 1.
   *
   * See also:
   * - [[getImageBasedLightingIntensity]]
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingOrientation]]
   */
  setImageBasedLightingIntensity(t) {
    this._engine.setImageBasedLightingIntensity(t), this._imageBasedLightingIntensity = t;
  }
  /**
   * Returns the intensity (brightness) of image-based lighting applied to
   * physically-based materials.
   *
   * The default value is 1.
   *
   * See also:
   * - [[setImageBasedLightingIntensity]]
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingOrientation]]
   */
  getImageBasedLightingIntensity() {
    return this._imageBasedLightingIntensity;
  }
  _copyImageBasedLightingOrientation(t) {
    return { ...t, matrix: t.matrix.copy() };
  }
  /**
   * Sets the orientation of the image-based lighting environment applied
   * to physically-based materials.
   *
   * See also:
   * - [[getImageBasedLightingOrientation]]
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingIntensity]]
   */
  setImageBasedLightingOrientation(t) {
    this._imageBasedLightingOrientation = this._copyImageBasedLightingOrientation(t), this._updateImageBasedLightingOrientation();
  }
  /**
   * Returns the orientation of the image-based lighting environment
   * applied to physically-based materials.
   *
   * See also:
   * - [[setImageBasedLightingOrientation]]
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingIntensity]]
   */
  getImageBasedLightingOrientation() {
    return this._copyImageBasedLightingOrientation(this._imageBasedLightingOrientation);
  }
  _updateImageBasedLightingOrientation(t, e) {
    let i;
    if (this._imageBasedLightingOrientation.followViewAxes) {
      if (t === void 0 || e === void 0)
        if (this._model.viewAxesHaveBeenSet()) {
          const r = this._model.getViewAxes();
          t = r.frontVector, e = r.upVector;
        } else
          t = new d(0, 0, 1), e = new d(0, 1, 0);
      const s = Q.createFromBasis(
        d.cross(e, t),
        e,
        t
      );
      i = Q.multiply(this._imageBasedLightingOrientation.matrix, s);
    } else
      i = this._imageBasedLightingOrientation.matrix;
    this._engine.setImageBasedLightingMatrix(i);
  }
  /**
   * Sets the environment image used by image-based lighting applied to
   * physically-based materials.
   *
   * Passing `null` will cause the default environment image to be used.
   *
   * The image should be a cube map in KTX2 format with a space-separated
   * list of spherical harmonics coefficients stored under the "sh"
   * metadata key.
   *
   * A compatible image can be created from an equirectangular source
   * image (such as those found at [HDRI Haven](https://hdrihaven.com))
   * with the following process:
   *
   * - cmgen: https://github.com/google/filament
   * - ktx2ktx2, ktx2sc: https://github.com/KhronosGroup/KTX-Software/
   *
   * ```
   * cmgen -x out --format=ktx --size=256 in.hdr
   * ktx2ktx2 -o uncompressed.ktx2 out/out_ibl.ktx
   * ktxsc --zcmp 20 -o out.ktx2 uncompressed.ktx2
   * ```
   */
  setImageBasedLightingEnvironment(t) {
    t != null ? this._engine.setImageBasedLightingEnvironment(t) : this._engine.setImageBasedLightingEnvironmentToDefault();
  }
  /**
   * Sets whether line jitter is enabled.
   *
   * Line jitter makes lines look 'sketchy' by drawing them multiple times
   * with randomized offsets applied to the vertices.
   *
   * See also:
   * - [[getLineJitterEnabled]]
   * - [[setLineJitterInstanceCount]]
   * - [[setLineJitterRadius]]
   * - [[setLineJitterFrequency]]
   */
  setLineJitterEnabled(t = !0) {
    this._engine.setLineJitterEnabled(t), this._lineJitterEnabled = t;
  }
  /**
   * Returns whether line jitter is enabled.
   *
   * Line jitter makes lines look 'sketchy' by drawing them multiple times
   * with randomized offsets applied to the vertices.
   *
   * See also:
   * - [[setLineJitterEnabled]]
   * - [[getLineJitterInstanceCount]]
   * - [[getLineJitterRadius]]
   * - [[getLineJitterFrequency]]
   */
  getLineJitterEnabled() {
    return this._lineJitterEnabled;
  }
  /**
   * Sets the number of times lines are drawn when line jitter is enabled.
   * The default value is 4.
   *
   * Increasing this number can make the lines look more 'sketchy.'
   *
   * See also:
   * - [[setLineJitterEnabled]]
   * - [[getLineJitterInstanceCount]]
   * - [[setLineJitterRadius]]
   * - [[setLineJitterFrequency]]
   */
  setLineJitterInstanceCount(t) {
    this._engine.setLineJitterInstanceCount(t), this._lineJitterInstanceCount = t;
  }
  /**
   * Returns the number of times lines are drawn when line jitter is
   * enabled. The default value is 4.
   *
   * See also:
   * - [[getLineJitterEnabled]]
   * - [[setLineJitterInstanceCount]]
   * - [[getLineJitterRadius]]
   * - [[getLineJitterFrequency]]
   */
  getLineJitterInstanceCount() {
    return this._lineJitterInstanceCount;
  }
  /**
   * Sets the radius of the random offset applied to line vertices when
   * line jitter is enabled. The default value is 0.005.
   *
   * The value is specified as a proportion of the canvas height, where 1
   * means the full height of the canvas.
   *
   * See also:
   * - [[setLineJitterEnabled]]
   * - [[setLineJitterInstanceCount]]
   * - [[getLineJitterRadius]]
   * - [[setLineJitterFrequency]]
   */
  setLineJitterRadius(t) {
    this._engine.setLineJitterRadius(t), this._lineJitterRadius = t;
  }
  /**
   * Returns the radius of the random offset applied to line vertices when
   * line jitter is enabled. The default value is 0.005.
   *
   * The value is specified as a proportion of the canvas height, where 1
   * means the full height of the canvas.
   *
   * See also:
   * - [[getLineJitterEnabled]]
   * - [[getLineJitterInstanceCount]]
   * - [[setLineJitterRadius]]
   * - [[getLineJitterFrequency]]
   */
  getLineJitterRadius() {
    return this._lineJitterRadius;
  }
  /**
   * Sets the frequency of the noise used to offset line vertices when
   * line jitter is enabled. The default value is 5.
   *
   * Decreasing this value causes lines to appear smoother, while
   * increasing it causes lines to look more noisy.
   *
   * See also:
   * - [[setLineJitterEnabled]]
   * - [[setLineJitterInstanceCount]]
   * - [[setLineJitterRadius]]
   * - [[getLineJitterFrequency]]
   */
  setLineJitterFrequency(t) {
    this._engine.setLineJitterFrequency(t), this._lineJitterFrequency = t;
  }
  /**
   * Returns the frequency of the noise used to offset line vertices when
   * line jitter is enabled. The default value is 5.
   *
   * See also:
   * - [[getLineJitterEnabled]]
   * - [[getLineJitterInstanceCount]]
   * - [[getLineJitterRadius]]
   * - [[setLineJitterFrequency]]
   */
  getLineJitterFrequency() {
    return this._lineJitterFrequency;
  }
}
class Cr {
  constructor() {
    this._remappedModelKeys = /* @__PURE__ */ new Map(), this._remappedInclusionKeys = /* @__PURE__ */ new Map();
  }
  remapModel(t, e) {
    this._remappedModelKeys.set(e, t), this._remappedInclusionKeys.has(t) || this._remappedInclusionKeys.set(t, /* @__PURE__ */ new Map());
  }
  remapInclusion(t, e, i) {
    const s = this._remappedInclusionKeys.get(t);
    console.assert(s !== void 0), s.set(i, e);
  }
  getEffectiveModelKey(t) {
    const e = this._remappedModelKeys.get(t);
    return e !== void 0 ? e : t;
  }
  getEffectiveInclusionKey(t, e) {
    const i = this._remappedInclusionKeys.get(e);
    if (i !== void 0) {
      const s = i.get(t);
      if (s !== void 0)
        return s;
    }
    return t;
  }
}
async function yy(n) {
  const t = [], i = {
    enterProductOccurrence: (s) => {
      s.hasPendingExternalModels() && t.push(s);
    }
  };
  return await yi.walk(i, n, ft.None), t;
}
class by {
  constructor() {
    this._currentTime = 0, this._stopTime = 0;
  }
  stop() {
    this._stopTime = this._currentTime;
  }
  isTicking() {
    return this._refreshCurrentTime(), this._remainingDuration() > 0;
  }
  tickFor(t) {
    this._refreshCurrentTime(), !(this._remainingDuration() >= t) && (this._stopTime = this._currentTime + t);
  }
  _remainingDuration() {
    return this._stopTime - this._currentTime;
  }
  _refreshCurrentTime() {
    this._currentTime = Date.now();
  }
}
const Iy = 4294967296;
class wy {
  constructor() {
    this.prototypes = /* @__PURE__ */ new Map(), this.partDefinitions = /* @__PURE__ */ new Map();
  }
}
class vy {
  constructor() {
    this.bodies = /* @__PURE__ */ new Map(), this.contexts = [];
  }
}
class xy {
  constructor(t, e, i, s, r, o) {
    this._centralQueueClock = new by(), this._productOccurrences = /* @__PURE__ */ new Map(), this._pmis = /* @__PURE__ */ new Map(), this._cadViews = /* @__PURE__ */ new Map(), this._bodyInstances = /* @__PURE__ */ new Map(), this._pmiBodies = /* @__PURE__ */ new Map(), this._viewFrames = /* @__PURE__ */ new Map(), this._partDefinitions = /* @__PURE__ */ new Map(), this._representationItems = /* @__PURE__ */ new Map(), this._partToInstance = /* @__PURE__ */ new Map(), this._filters = [], this._layers = /* @__PURE__ */ new Map(), this._layersIds = /* @__PURE__ */ new Map(), this._nextLayerId = 0, this._genericTypeToNodes = /* @__PURE__ */ new Map(), this._genericIdToNodes = /* @__PURE__ */ new Map(), this._cadConfigurations = /* @__PURE__ */ new Set(), this._modelContents = /* @__PURE__ */ new Map(), this._inclusionContents = /* @__PURE__ */ new Map(), this._nodeDeletionBlackList = /* @__PURE__ */ new Set(), this._meshDeletionBlackList = /* @__PURE__ */ new Set(), this._dynamicNodeIdSeed = en, this._currentNodeIdOffset = 0, this._initialEmptyNodeIdOffsetObtained = !1, this._activeCadView = null, this._activeCadConfiguration = null, this._defaultCadConfiguration = null, this._defaultCadViewsByConfiguration = /* @__PURE__ */ new Map(), this._firstProductOccurrenceWithView = null, this._containsDrawings = !1, this._isMeasurable = !1, this._automaticMeasurementUnitScaling = !0, this._initiallyHiddenStayHidden = !0, this._nextLoadId = 0, this._activeLoadIds = /* @__PURE__ */ new Set(), this._requestedNodes = /* @__PURE__ */ new Map(), this._unnamedProductCount = 0, this._unnamedGroupCount = 0, this._unnamedDrawingSheetCount = 0, this._unnamedDrawingViewCount = 0, this._isInitialized = !1, this._seenExternalModel = !1, this._config = { ...t }, this._engine = e, this._callbackManager = i, this._cuttingManager = s, this._view = r, this._model = o, this._isScs = this._engine.getSessionType() === Ke.Scs, console.assert(!this._isScs || this._engine.getRendererType() === Ho.Client);
  }
  initialize(t) {
    console.assert(this._rootLoadContext === void 0), console.assert(this._rootNode === void 0), console.assert(!this._isInitialized), this._isInitialized = !0, console.assert(this._centralQueue === void 0), this._centralQueue = new Ns(t.maxConcurrentAttachments(), !1), this._callbackManager.bind({
      _inputInteraction: (s, r) => {
        this._onUserInteraction(s, r);
      }
    }), this._rootLoadContext = new on(null, rr, null);
    const e = new hi(
      new Cr(),
      ar.OfInitialEmptyModel,
      !1,
      Hn.Local,
      this._rootLoadContext
    );
    this._rootLoadContext.addAttachContext(e);
    const i = new Si(
      this,
      e,
      ve.Local,
      Bi.Local
    );
    e.addInclusionContext(i), this._rootNode = Yt.createDynamic(
      this,
      i,
      "Models",
      null,
      null,
      !0
    ), i.addProductOccurrence(this._rootNode), console.assert(this._rootNode.isAbsoluteRoot()), this.preventNodeDeletion(this._rootLoadContext), this.preventNodeDeletion(e), this.preventNodeDeletion(i), this.preventNodeDeletion(this._rootNode), this._rootNode.markLoaded();
  }
  isInitialized() {
    return this._isInitialized;
  }
  getRootNode() {
    return this._rootNode;
  }
  getAbstractScEngine() {
    return this._engine;
  }
  generateDynamicNodeId() {
    return --this._dynamicNodeIdSeed;
  }
  newNodeIdOffset() {
    if (!this._initialEmptyNodeIdOffsetObtained)
      return this._initialEmptyNodeIdOffsetObtained = !0, console.assert(this._currentNodeIdOffset === 0), 0;
    const t = this._currentNodeIdOffset;
    return this._currentNodeIdOffset += Iy, t;
  }
  /**
   * Please don't use me. This was kept for legacy reasons with Erwan's tree, which
   * had fundamental design problems with NodeIds (because they could conflict).
   */
  getLowestAvailableNodeId() {
    return this._currentNodeIdOffset;
  }
  tryParseHeader(t) {
    const e = _n.parseBinary(t);
    return e === null ? null : (this._containsDrawings = this._containsDrawings || e.isDrawing, this._isMeasurable = this._isMeasurable || e.isMeasurable, this._callbackManager.promiseTrigger("_modelStructureHeaderParsed", null, e).then(() => (this._callbackManager.trigger(
      "modelStructureHeaderParsed",
      e.originalFileName,
      e.originalFileType
    ), e)));
  }
  _isRegistered(t) {
    return this._productOccurrences.has(t) || this._pmis.has(t) || this._cadViews.has(t) || this._bodyInstances.has(t) || this._pmiBodies.has(t) || this._viewFrames.has(t) || this._partDefinitions.has(t) || this._representationItems.has(t);
  }
  registerProductOccurrence(t) {
    if (!t.isMissing()) {
      const e = t.getRuntimeId();
      console.assert(!this._isRegistered(e)), this._productOccurrences.set(e, t);
      const i = jo(t);
      i !== null && this.registerGenericType(t, i);
      const s = t.getGenericId();
      s !== null && this.registerGenericGlobalId(t, s), t.isAConfigurationNode() && this._registerCadConfiguration(t), (t.isADrawingSheetNode() || t.isADrawingViewNode()) && (this._containsDrawings = !0);
    }
  }
  lookupProductOccurrence(t) {
    const e = this._productOccurrences.get(t);
    return e !== void 0 ? e : null;
  }
  registerPmi(t) {
    const e = t.getRuntimeId();
    console.assert(!this._isRegistered(e)), this._pmis.set(e, t);
  }
  lookupPmi(t) {
    const e = this._pmis.get(t);
    return e !== void 0 ? e : null;
  }
  registerCadView(t) {
    this._firstProductOccurrenceWithView === null && (this._firstProductOccurrenceWithView = t.getParent());
    const e = t.getRuntimeId();
    console.assert(!this._isRegistered(e)), this._cadViews.set(e, t), t.isDefaultView() && this._defaultCadViewsByConfiguration.set(this._firstProductOccurrenceWithView, t);
  }
  getFirstProductOccurrenceWithView() {
    return this._firstProductOccurrenceWithView;
  }
  lookupCadView(t) {
    const e = this._cadViews.get(t);
    return e !== void 0 ? e : null;
  }
  registerBodyInstance(t, e) {
    const i = t.getRuntimeId();
    console.assert(!this._isRegistered(i)), this._bodyInstances.set(i, t), this._registerAnyBodyByInstanceInc(t, e);
  }
  lookupBodyInstance(t) {
    const e = this._bodyInstances.get(t);
    return e !== void 0 ? e : null;
  }
  registerPmiBody(t, e) {
    const i = t.getRuntimeId();
    console.assert(!this._isRegistered(i)), this._pmiBodies.set(i, t), this._registerAnyBodyByInstanceInc(t, e);
  }
  lookupPmiBody(t) {
    const e = this._pmiBodies.get(t);
    return e !== void 0 ? e : null;
  }
  registerViewFrame(t, e) {
    const i = t.getRuntimeId();
    console.assert(!this._isRegistered(i)), this._viewFrames.set(i, t), this._registerAnyBodyByInstanceInc(t, e);
  }
  lookupViewFrame(t) {
    const e = this._viewFrames.get(t);
    return e !== void 0 ? e : null;
  }
  registerPartDefinition(t) {
    if (!t.isMissing()) {
      const e = t.getRuntimeId();
      console.assert(!this._isRegistered(e)), this._partDefinitions.set(e, t);
    }
  }
  lookupPartDefinition(t) {
    const e = this._partDefinitions.get(t);
    return e !== void 0 ? e : null;
  }
  registerRepresentationItem(t) {
    const e = t.getRuntimeId();
    console.assert(!this._isRegistered(e)), this._representationItems.set(e, t);
  }
  lookupRepresentationItem(t) {
    const e = this._representationItems.get(t);
    return e !== void 0 ? e : null;
  }
  lookupAnyBody(t) {
    return this.lookupBodyInstance(t) || this.lookupPmiBody(t) || this.lookupViewFrame(t);
  }
  lookupAnyTreeNode(t) {
    return this.lookupProductOccurrence(t) || this.lookupPmi(t) || this.lookupCadView(t) || this.lookupAnyBody(t);
  }
  lookupAnyNonTreeNode(t) {
    return this.lookupRepresentationItem(t) || this.lookupPartDefinition(t);
  }
  lookupAnyNode(t) {
    return this.lookupAnyTreeNode(t) || this.lookupAnyNonTreeNode(t);
  }
  _registerCadConfiguration(t) {
    console.assert(t.isAConfigurationNode()), console.assert(!this._cadConfigurations.has(t)), this._cadConfigurations.add(t), t.isADefaultNode() && this._defaultCadConfiguration === null && (this._defaultCadConfiguration = t);
  }
  getInstanceCountByInclusion(t) {
    return this._getInclusionContent(t).bodies.size;
  }
  lookupAnyBodyByInstanceInc(t, e) {
    const s = this._getInclusionContent(t).bodies.get(e);
    return s !== void 0 ? s : null;
  }
  _registerAnyBodyByInstanceInc(t, e) {
    const i = t.getInstanceInc(), s = this._getInclusionContent(e), r = s.bodies.get(i[1]);
    if (r !== void 0)
      if (console.assert(t.hasAuthoredId()), r.hasAuthoredId()) {
        console.assert(r.constructor === t.constructor);
        return;
      } else {
        const o = r;
        console.assert(o.constructor === Ve);
        const a = o.getRuntimeId();
        o.getParent().removeBodyInstance(o), t instanceof Ve ? this._bodyInstances.set(a, t) : t instanceof In ? this._pmiBodies.set(a, t) : this._viewFrames.set(a, t);
      }
    s.bodies.set(i[1], t);
  }
  _getInclusionContent(t) {
    console.assert(t !== ve.Invalid);
    let e = this._inclusionContents.get(t);
    return e === void 0 && (e = new vy(), this._inclusionContents.set(t, e)), e;
  }
  _getModelContent(t, e) {
    console.assert(e !== Bi.Invalid);
    let i = this._modelContents.get(t);
    i === void 0 && (i = /* @__PURE__ */ new Map(), this._modelContents.set(t, i));
    let s = i.get(e);
    return s === void 0 && (s = new wy(), i.set(e, s)), s;
  }
  registerPrototypeByDataId(t, e, i, s) {
    const r = this._getModelContent(t, e);
    console.assert(!r.prototypes.has(i)), r.prototypes.set(i, s);
  }
  registerPartDefinitionByDataId(t, e, i, s) {
    const r = this._getModelContent(t, e);
    console.assert(!r.partDefinitions.has(i)), r.partDefinitions.set(i, s);
  }
  lookupPrototypeByDataId(t, e, i) {
    const r = this._getModelContent(t, e).prototypes.get(i);
    return r !== void 0 ? r : null;
  }
  lookupPartDefinitionByDataId(t, e, i) {
    const r = this._getModelContent(t, e).partDefinitions.get(i);
    return r !== void 0 ? r : null;
  }
  registerInclusionContext(t) {
    const e = t.getInclusionKey();
    this._getInclusionContent(e).contexts.push(t);
  }
  getInclusionContexts(t) {
    return this._getInclusionContent(t).contexts;
  }
  _createLayer(t, e, i, s) {
    const r = new Ys(t, e, i, s);
    return console.assert(!this._layers.has(t)), this._layers.set(t, r), e !== null && this._updateNameToLayersMap(e, t), r;
  }
  _updateNameToLayersMap(t, e) {
    const i = this._layersIds.get(t);
    i !== void 0 ? i.push(e) : this._layersIds.set(t, [e]);
  }
  /**
   * Creates a new layer in the assembly tree. Also creates a mapping in the supplied assembly tree from
   * the authored layer id to the effective, runtime, id.
   * @param authoredLayerId The authored ID of the layer. Used to create the mapping in the assembly tree
   * @param layerName Name of the layer
   * @param loadContext Attach context of the node creating the layer. A layer mapping will be created in it
   */
  createLayer(t, e, i) {
    const s = this._nextLayerId++, r = this._createLayer(s, e, [], []);
    return i.addLayerIdToMap(s, t), r;
  }
  /**
   * Changes the name of an existing layer.
   * @param layerId Layer id to update
   * @param layerName Name to be set
   */
  updateLayerName(t, e) {
    const i = this._layers.get(t);
    i !== void 0 && (i.name = e, this._updateNameToLayersMap(e, t));
  }
  _registerNodeInLayer(t, e, i) {
    const s = gn(t);
    let r = s.getRuntimeLayerId(e);
    e === Ys.NoLayerId && r === null ? r = this.createLayer(Ys.NoLayerId, "No layer", s).id : r === null && (r = this._nextLayerId++, this._createLayer(r, null, [t], []), s.addLayerIdToMap(r, e));
    const o = this._layers.get(r);
    o !== void 0 ? i(o).push(t) : (console.assert(!1, "Layer has mapping in LoadContext but not represented in AssemblyTree"), this._createLayer(r, null, [t], []), s.addLayerIdToMap(r, e));
  }
  /**
   * Registers a node as part of a layer. This will create a layer if one doesn't exist.
   * @param node Node to be registered
   * @param authoredLayerId Authored id of the Layer
   */
  registerNodeInLayer(t, e) {
    return this._registerNodeInLayer(t, e, (i) => i.nodes);
  }
  /**
   * Registers a tree node as part of a layer. This will create a layer if one doesn't exist.
   * @param node Node to be registered
   * @param authoredLayerId Authored id of the Layer
   */
  registerTreeNodeInLayer(t, e) {
    return this._registerNodeInLayer(t, e, (i) => i.treeNodes);
  }
  addFilter(t, e) {
    this._filters.push({ filter: t, loadContext: e });
  }
  getFilters() {
    const t = /* @__PURE__ */ new Map();
    for (let e = 0; e < this._filters.length; e++) {
      const i = this.getFilterName(e) || "";
      t.set(e, i);
    }
    return t;
  }
  getFilterName(t) {
    if (t < this._filters.length) {
      const { filter: e } = this._filters[t];
      return e.name || "";
    }
    return null;
  }
  getFiltersWithNode(t) {
    const e = t.getAuthoredId(), i = this._filters, s = [];
    for (let r = 0; r < i.length; r++) {
      const { filter: o, loadContext: a } = i[r];
      if (o.layers !== null)
        for (const l of o.layers.authoredIds) {
          const c = a.getRuntimeLayerId(l);
          if (c === null)
            continue;
          const h = this.getNodesFromLayer(c);
          if (h !== null)
            for (const u of h)
              t === u && s.push(r);
        }
      if (o.entities !== null)
        for (const l of o.entities.ids)
          e === l && s.push(r);
    }
    return s;
  }
  getNodesFromFilterIds(t) {
    const e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
    let s = null;
    for (const r of t) {
      const { filter: o, loadContext: a } = this._filters[r], l = o.layers;
      if (l !== null) {
        const h = l.isInclusive;
        s === null && (s = h);
        for (const u of l.authoredIds) {
          const p = a.getRuntimeLayerId(u);
          if (p === null)
            continue;
          const m = this._layers.get(p);
          if (m && m.nodes !== null)
            for (const g of m.nodes) {
              const _ = g.getRuntimeId();
              h ? (e.add(_), i.delete(_)) : (e.delete(_), i.add(_));
            }
        }
      }
      const c = o.entities;
      if (c !== null) {
        const h = c.isInclusive;
        s === null && (s = h);
        for (const u of c.ids)
          h ? (e.add(u), i.delete(u)) : (e.delete(u), i.add(u));
      }
    }
    return s === null ? null : s ? new pu(!0, e) : new pu(!1, i);
  }
  getLayers() {
    const t = /* @__PURE__ */ new Map();
    return this._layers.forEach((e, i) => {
      const s = e.name || "";
      t.set(i, s);
    }), t;
  }
  getUniqueLayerNames() {
    const t = /* @__PURE__ */ new Set(), e = [];
    return this._layers.forEach((i) => {
      const s = i.name;
      s !== null && (t.has(s) || (t.add(s), e.push(s)));
    }), e;
  }
  getLayerName(t) {
    const e = this._layers.get(t);
    return e !== void 0 ? e.name || "" : null;
  }
  getLayersIdFromName(t) {
    const e = this._layersIds.get(t);
    return e !== void 0 ? e : null;
  }
  getNodesFromLayer(t, e) {
    const i = this._layers.get(t);
    return i !== void 0 ? e ? i.treeNodes : i.nodes : null;
  }
  getNodesFromLayers(t, e) {
    const i = [];
    for (const s of t) {
      const r = this.getNodesFromLayer(s, e);
      if (r !== null)
        for (const o of r)
          i.push(o);
    }
    return i;
  }
  getNodesFromLayerName(t, e) {
    const i = this._layersIds.get(t);
    return i !== void 0 ? this.getNodesFromLayers(i, e) : null;
  }
  generateProductName() {
    return `Product ${this._unnamedProductCount++}`;
  }
  generateGroupName() {
    return `Product ${this._unnamedGroupCount++}`;
  }
  generateDrawingSheetName() {
    return `Product ${this._unnamedDrawingSheetCount++}`;
  }
  generateDrawingViewName() {
    return `Product ${this._unnamedDrawingViewCount++}`;
  }
  forEachCadView(t) {
    this._cadViews.forEach(t);
  }
  forEachPmi(t) {
    this._pmis.forEach(t);
  }
  forEachCadConfiguration(t) {
    this._cadConfigurations.forEach(t);
  }
  hasActiveCadView() {
    return this._activeCadView !== null;
  }
  activateCadView(t, e, i) {
    return console.assert(this._activeCadView === null), this._activeCadView = t, t.activate(
      this,
      this._engine,
      this._callbackManager,
      this._cuttingManager,
      this._view,
      e,
      i,
      this._activeCadConfiguration
    );
  }
  async deactivateActiveCadView() {
    this._activeCadView !== null && (await this._activeCadView.deactivate(this._cuttingManager), console.assert(this._activeCadView !== null), this._activeCadView = null);
  }
  getDefaultCadView(t) {
    let e;
    return t === null ? this._defaultCadViewsByConfiguration.size === 1 && (e = this._defaultCadViewsByConfiguration.values().next().value) : e = this._defaultCadViewsByConfiguration.get(t), e !== void 0 ? e : null;
  }
  getCadViewPmis(t) {
    const e = [];
    return this._pmis.forEach((i) => {
      t.hasPmi(i) && e.push(i);
    }), e;
  }
  isMeasurable() {
    return this._isMeasurable;
  }
  containsDrawings() {
    return this._containsDrawings;
  }
  getCadConfigurations() {
    const t = [];
    return this._cadConfigurations.forEach((e) => {
      t.push(e);
    }), t;
  }
  getDefaultCadConfiguration() {
    return this._defaultCadConfiguration;
  }
  getActiveCadConfiguration() {
    return this._activeCadConfiguration;
  }
  activateCadConfiguration(t) {
    console.assert(t.isAConfigurationNode()), this._activeCadConfiguration = t;
  }
  massageAuthoredUserId(t, e) {
    if (e === null)
      return this.generateDynamicNodeId();
    {
      const i = t.toRuntimeId(e);
      return this.lookupAnyNode(i) !== null ? this.generateDynamicNodeId() : e;
    }
  }
  createNode(t, e, i, s, r, o = null) {
    const a = Yt.createDynamic(
      this,
      t,
      e,
      i,
      s,
      r,
      !1,
      o
    );
    return t.addProductOccurrence(a), a.markLoaded(), a;
  }
  createPart(t) {
    const e = Ei.createDynamic(this, t, null);
    return e.markLoaded(), e;
  }
  setPart(t, e) {
    e.addReferrer(t);
    let i = this._partToInstance.get(e);
    if (i === void 0) {
      const s = Ne(this._rootNode), r = () => {
        const a = {}, l = Ws.create(() => (console.assert(a.node !== void 0), new Ih(xi.create(a.node))));
        return a.instance = new Mr(l, s), a.node = Yt.createDynamic(
          this,
          a.instance,
          null,
          null,
          null,
          !0
        ), a.node.setPartDefinition(e), a.node.markLoaded(), a;
      }, { instance: o } = r();
      i = o;
    }
    t.setPrototype(i);
  }
  _createCadView(t, e, i, s, r, o, a, l) {
    const c = Ni.createDynamic(
      this,
      t,
      e,
      i,
      s,
      r,
      o,
      a,
      l
    );
    return t.addCadView(c), c.markLoaded(), c;
  }
  async _createCadViewInstance(t, e, i) {
    if (i !== null) {
      const [s, r] = await t.createMeshInstance(i), l = {
        nodeInfo: {
          nodeId: this.generateDynamicNodeId(),
          bits: We.IsShownSpecified | We.IsShown,
          name: null,
          localTransform: null,
          attributes: [],
          header: _n.dynamic,
          exchangeId: null,
          layerId: null,
          genericTypeId: null,
          genericId: null,
          userDatas: null
        },
        inclusionKey: s,
        instanceKey: r,
        bits: 0
      }, h = Ce(e).getMasterModelKey();
      console.assert(e.isLoaded());
      const u = ms.reify(this, h, e, l);
      e.setViewFrame(u), u.markLoaded();
    }
  }
  createCadView(t, e, i, s, r, o, a, l, c, h) {
    const u = this._createCadView(
      e,
      i,
      s,
      r,
      o,
      a,
      l,
      c
    );
    return h !== null && this._createCadViewInstance(t, u, h), u;
  }
  createMeshInstance(t, e, i, s, r, o, a, l, c, h) {
    let u = 0;
    c && (u |= We.InitiallyShown);
    let p = 0;
    a && (p |= zn.PreventFromResetting), l && (p |= zn.OutOfHierarchy), h && (p |= zn.ImplicitBody);
    const m = Ve.createDynamic(
      this,
      e,
      i,
      s,
      r,
      o,
      u,
      p
    );
    return o.addBodyInstance(m), t && m.markLoaded(), m;
  }
  createPmiInstance(t, e, i, s, r, o, a, l) {
    const c = Ne(r), p = {
      nodeInfo: {
        nodeId: this.massageAuthoredUserId(c, i),
        bits: We.InitiallyShown,
        name: s,
        localTransform: null,
        attributes: [],
        header: _n.dynamic,
        exchangeId: null,
        layerId: null,
        genericTypeId: null,
        genericId: null,
        userDatas: null
      },
      inclusionKey: t,
      instanceKey: e,
      bits: 0
    }, m = gi.createDynamic(
      this,
      c,
      r,
      s,
      o,
      a,
      [p],
      l
    );
    return r.addPmi(m), m.markLoaded(), m;
  }
  getRelationshipsOfItem(t, e) {
    const i = /* @__PURE__ */ new Map();
    let s = [];
    const r = this.lookupAnyTreeNode(t);
    if (r === null)
      return i;
    s = Ne(r).getRelationships();
    for (const a of s)
      if (a.relating !== null && a.relating.relationElt.id === e)
        tr.addFromRelatingElt(a, i);
      else {
        const l = a.related;
        let c = -1;
        l !== null && (c = tr.findIndexInRelated(e, l.relationships)), c >= 0 && tr.addFromRelatedElt(a, i);
      }
    return i;
  }
  getAutomaticMeasurementUnitScaling() {
    return this._automaticMeasurementUnitScaling;
  }
  setAutomaticMeasurementUnitScaling(t) {
    this._automaticMeasurementUnitScaling = t;
  }
  getInitiallyHiddenStayHidden() {
    return this._initiallyHiddenStayHidden;
  }
  setInitiallyHiddenStayHidden(t) {
    this._initiallyHiddenStayHidden = t;
  }
  async _removeIdMappingsRecursive(t) {
    const e = (l) => {
      const c = l.getGenericId();
      if (c !== null) {
        const u = this._genericIdToNodes.get(c);
        u !== void 0 && u.delete(l);
      }
      const h = jo(l);
      if (h !== null) {
        const u = this._genericTypeToNodes.get(h);
        u !== void 0 && u.delete(l);
      }
    }, i = (l) => {
      const c = /* @__PURE__ */ new Map();
      for (const h of l) {
        const u = h.getAuthoredLayerId();
        if (u === null)
          continue;
        const m = gn(h).getRuntimeLayerId(u);
        if (m === null)
          continue;
        const g = c.get(m);
        g === void 0 ? c.set(m, [h]) : g.push(h);
      }
      c.forEach((h, u) => {
        const p = this._layers.get(u);
        p.nodes = p.nodes.filter((m) => h.indexOf(m) === -1), p.treeNodes = p.treeNodes.filter(
          (m) => h.indexOf(m) === -1
        );
      });
    }, s = (l) => {
      const c = /* @__PURE__ */ new Set();
      l.forEach((h) => {
        const u = h.getInstanceInc();
        c.add(u[0]);
      }), c.forEach((h) => {
        const u = this._inclusionContents.get(h);
        if (u !== void 0)
          for (const p of l) {
            const m = p.getInstanceInc();
            m[0] === h && u.bodies.delete(m[1]);
          }
      });
    }, r = [], o = [], a = {
      enterProductOccurrence: (l) => {
        e(l), this._productOccurrences.delete(l.getRuntimeId()), r.push(l);
      },
      enterAnyBody: (l) => {
        e(l);
        const c = l.getRuntimeId();
        l instanceof Ve ? this._bodyInstances.delete(c) : l instanceof In ? this._pmiBodies.delete(c) : this._viewFrames.delete(c), r.push(l), o.push(l);
      },
      enterCadView: (l) => {
        this._cadViews.delete(l.getRuntimeId());
      },
      enterPmi: (l) => {
        this._pmis.delete(l.getRuntimeId());
      }
    };
    await yi.walk(a, t, ft.None), i(r), s(o);
  }
  async deleteNode(t) {
    if (!this._canDeleteNode(t)) {
      const i = t.getRuntimeId();
      throw new Mt(`Cannot delete node (${i})`);
    }
    const e = Oo(
      t,
      bt.All,
      !0,
      /* @__PURE__ */ new Set(),
      ft.None
    );
    if (this._engine.setPartVisibility(e, !1, !1), this._engine.setInstanceModifier(Xe.DoNotSelect, e, !0), t instanceof Yt) {
      this._cadConfigurations.delete(t) && (t === this._activeCadConfiguration && (this._activeCadConfiguration = null), t === this._defaultCadConfiguration && (this._defaultCadConfiguration = null));
      const i = t.getParent(), s = gn(i);
      if (console.assert(i !== null), i !== null) {
        let r;
        if (i instanceof Mr)
          r = i.removeReferrer(t);
        else if (i instanceof Si && i.getChildren().length === 1) {
          const o = i.getInclusionKey();
          this._inclusionContents.delete(o);
          const a = i.getModelKey(), l = this._modelContents.get(s);
          l.delete(a), l.size === 0 && this._modelContents.delete(s), r = i.removeProductOccurrence(t);
        } else
          r = i.removeProductOccurrence(t);
        console.assert(r);
      }
      return this._productOccurrences.delete(t.getRuntimeId()), await this._removeIdMappingsRecursive(t), s.getChildren().length === 0 ? s.purgeContents() : t.purgeContents();
    } else if (t instanceof gi)
      t.getParent().removePmi(t), this._pmis.delete(t.getRuntimeId());
    else {
      t.getParent().removeBodyInstance(t);
      const s = t.getInstanceInc();
      this._getInclusionContent(s[0]).bodies.delete(s[1]), this._bodyInstances.delete(t.getRuntimeId());
    }
  }
  _canDeleteNode(t) {
    return !this._nodeDeletionBlackList.has(t);
  }
  allowNodeDeletion(t) {
    this._nodeDeletionBlackList.delete(t);
  }
  preventNodeDeletion(t) {
    const e = t.getParent();
    if (e instanceof Mr)
      throw new re();
    if (e !== null) {
      if (console.assert(e === null || this._nodeDeletionBlackList.has(e)), t instanceof Yt)
        console.assert(!t.hasAuthoredId()), console.assert(!t.isOutOfHierarchy());
      else if (t instanceof Ve) {
        const i = t.getInstanceInc();
        console.assert(!t.hasAuthoredId()), console.assert(i[0] === ve.Local), console.assert(t.isOutOfHierarchy());
      }
    }
    this._nodeDeletionBlackList.add(t);
  }
  preventMeshDeletion(t) {
    this._meshDeletionBlackList.add(t);
  }
  async _resetContents() {
    if (this.hasActiveCadView())
      return await this.deactivateActiveCadView(), this._resetContents();
    await this._rootLoadContext.purgeContents(), this._productOccurrences.clear(), this._pmis.clear(), this._cadViews.clear(), this._bodyInstances.clear(), this._pmiBodies.clear(), this._viewFrames.clear(), this._partDefinitions.clear(), this._representationItems.clear(), this._partToInstance.clear(), this._filters.length = 0, this._layers.clear(), this._layersIds.clear(), this._genericTypeToNodes.clear(), this._genericIdToNodes.clear(), this._cadConfigurations.clear(), this._modelContents.clear(), this._inclusionContents.clear(), this._currentNodeIdOffset = 0, this._activeCadView = null, this._activeCadConfiguration = null, this._defaultCadConfiguration = null, this._firstProductOccurrenceWithView = null, this._containsDrawings = !1, this._isMeasurable = !1, this._requestedNodes.clear(), this._unnamedProductCount = 0, this._unnamedGroupCount = 0, this._unnamedDrawingSheetCount = 0, this._unnamedDrawingViewCount = 0, this._seenExternalModel = !1, this._rootNode.unsetMeasurementUnit(), this._nodeDeletionBlackList.forEach((t) => {
      if (t instanceof Yt) {
        const e = t.getRuntimeId();
        this._productOccurrences.set(e, t);
        const i = t.getParent();
        i instanceof Mr ? console.assert(!1) : i.addProductOccurrence(t), t.setVisibility(!0), t.unsetMeasurementUnit(), t.hasLocalTransformOverride() && t.removeLocalTransformOverride();
      } else if (t instanceof Ve) {
        const e = t.getRuntimeId();
        this._bodyInstances.set(e, t);
        const i = t.getInstanceInc(), s = i[0];
        console.assert(s === ve.Local), this._getInclusionContent(s).bodies.set(i[1], t), t.getParent().addBodyInstance(t);
      } else if (t instanceof gi) {
        const e = t.getRuntimeId();
        this._pmis.set(e, t), t.getParent().addPmi(t);
      } else if (t instanceof on) {
        const e = t.getParent();
        e !== null && e.addLoadContext(t);
      } else if (t instanceof hi) {
        const e = t.getParent();
        e instanceof Yt, e.addAttachContext(t);
      } else {
        const e = t.getInclusionKey();
        console.assert(e === ve.Local), this._getInclusionContent(e).contexts.push(t), t.getParent().addInclusionContext(t);
      }
    });
  }
  async reset() {
    await this._callbackManager.promiseTrigger("_resetAssemblyTreeBegin", null), await this._resetContents();
    const t = [];
    this._nodeDeletionBlackList.forEach((i) => {
      if (i instanceof Ve) {
        const s = i.getInstanceInc();
        console.assert(s[0] === ve.Local), t.push(s[1]);
      }
    });
    const e = [];
    this._meshDeletionBlackList.forEach((i) => {
      e.push(i);
    }), await this._engine.resetToEmpty(t, e), await this._resetContents();
  }
  setViewAxes(t, e) {
    this._model.setViewAxes(t, e);
  }
  async _requestIncsOfNodes(t) {
    if (this._config.streamingMode !== Ps.OnDemand)
      return;
    const e = /* @__PURE__ */ new Set(), i = [], s = [];
    for (const a of t) {
      const l = Fd(a, bt.All, !1, e).then((c) => {
        for (const h of c)
          i.push(h);
      });
      s.push(l);
    }
    await zt(s);
    const r = [], o = [];
    e.forEach((a) => {
      if (!a.isRequested()) {
        a.setRequested();
        const l = a.isInitiallyShown();
        l !== a.isVisible() && (l ? (a.setVisibility(!0), r.push(a.getRuntimeId())) : (a.setVisibility(!1), o.push(a.getRuntimeId())));
      }
    }), r.length + o.length > 0 && this._callbackManager.trigger("visibilityChanged", r, o), this._engine.requestMeshInstances(i);
  }
  async _requestExternalModelsLocal(t, e, i) {
    const s = await e.loadPendingExternalModels(t);
    return s.length !== 0 && (await er(s), await this._requestNodes(t, [e], i)), s;
  }
  async _requestExternalModelsNonLocal(t, e, i) {
    const s = await yy(e);
    if (s.length === 0)
      return [];
    const r = [];
    for (const a of s) {
      const l = this._requestExternalModelsLocal(t, a, i);
      r.push(l);
    }
    return (await Promise.all(r)).flat();
  }
  async _requestExternalModelsOfNodes(t, e, i) {
    const s = [];
    for (const o of e) {
      const a = this._requestExternalModelsNonLocal(t, o, i);
      s.push(a);
    }
    return (await Promise.all(s)).flat();
  }
  async _requestNodes(t, e, i) {
    if (!i) {
      const l = this._activeLoadIds.size !== 0, c = [];
      l && this._activeLoadIds.forEach((h) => {
        c.push(h);
      });
      for (const h of e)
        l && this._requestedNodes.set(h, c), h instanceof Yt && t.notifyDirectRequest(h);
    }
    const s = this._requestIncsOfNodes(e), r = this._requestExternalModelsOfNodes(
      t,
      e,
      i
    ), o = [s, r];
    return (await Promise.all(o))[1];
  }
  async requestNodes(t, e, i) {
    const s = await this._requestNodes(t, e, i), r = [];
    for (const o of s) {
      const a = o.getChildren();
      r.push(...a);
    }
    if (r.length > 0) {
      const o = r.map((a) => a.getRuntimeId());
      await this._callbackManager.promiseTrigger(
        "_subtreeLoaded",
        "subtreeLoaded",
        o,
        ps.LoadModel
      );
    }
  }
  isBeingRequested(t) {
    let e = t;
    const i = !1;
    do
      if (e instanceof Pi) {
        if (this._requestedNodes.has(e))
          return !0;
        e = e.getParent();
      } else if (e instanceof hi)
        e = e.getParent();
      else if (e instanceof Si)
        e = e.getParent();
      else if (e instanceof on) {
        const s = e.getParent();
        if (s === null)
          return !1;
        e = s;
      } else
        return console.assert(!1), !1;
    while (!i);
    return !1;
  }
  onDemandRequestsActive() {
    return this._requestedNodes.size !== 0;
  }
  onLoadBegin() {
    const t = this._nextLoadId++;
    return this._activeLoadIds.add(t), t;
  }
  onLoadEnd(t) {
    this._activeLoadIds.delete(t);
    const e = [];
    this._requestedNodes.forEach((i, s) => {
      let r = !0;
      for (const o of i)
        if (this._activeLoadIds.has(o)) {
          r = !1;
          break;
        }
      r && e.push(s);
    });
    for (const i of e)
      this._requestedNodes.delete(i);
  }
  markSeenExternalModel() {
    this._seenExternalModel = !0;
  }
  seenExternalModel() {
    return this._seenExternalModel;
  }
  getNodesByGenericId(t) {
    return this._genericIdToNodes.get(t) || null;
  }
  getNodesByGenericType(t) {
    return this._genericTypeToNodes.get(t) || null;
  }
  genericTypeToNodes() {
    return this._genericTypeToNodes;
  }
  registerGenericGlobalId(t, e) {
    let i = this._genericIdToNodes.get(e);
    i === void 0 && (i = /* @__PURE__ */ new Set()), i.add(t), this._genericIdToNodes.set(e, i);
  }
  registerGenericType(t, e) {
    let i = this._genericTypeToNodes.get(e);
    i === void 0 && (i = /* @__PURE__ */ new Set()), i.add(t), this._genericTypeToNodes.set(e, i);
  }
  disableAutomaticFitWorld() {
    return this._config.disableAutomaticFitWorld;
  }
  markImplicitNodesOutOfHierarchy() {
    return this._config.markImplicitNodesOutOfHierarchy;
  }
  async _throttleLoad() {
    this._engine.throttleLoad(200, 200), await this._engine.sleep(20);
  }
  /**
   * Enqueues an action that can be throttled by user interactions.
   */
  enqueue(t) {
    const e = typeof t == "function" ? ji.create(t) : t;
    return this._centralQueue.push(async () => {
      const i = this._isScs && this._centralQueueClock.isTicking();
      i && await this._throttleLoad();
      const s = await e.get();
      return i && await this._throttleLoad(), s;
    });
  }
  _onUserInteraction(t, e) {
    if (!this._isScs)
      return;
    let i = !1;
    switch (e) {
      case kt.MouseDown:
      case kt.MouseUp:
      case kt.Mousewheel:
      case kt.TouchStart:
      case kt.TouchMove:
      case kt.TouchEnd:
      case kt.KeyDown:
      case kt.KeyUp:
      case kt.ViewOrientationChange:
        i = !0;
        break;
      case kt.MouseMove:
        i = t.getButtons() !== Ai.None;
        break;
      default:
        $n();
    }
    i && this._centralQueueClock.tickFor(1e3);
  }
}
class bu {
  constructor(t, e) {
    this._inclusionsOf = /* @__PURE__ */ new Map(), this._masterModelKey = Hn.Invalid, this._prototypeInstanceCount = -1, this._attachScope = t, this._attachedInvisibly = e;
  }
  getAttachScope() {
    return this._attachScope;
  }
  getMasterModelKey() {
    return console.assert(this._masterModelKey !== Hn.Invalid), this._masterModelKey;
  }
  getModelKeys() {
    const t = [];
    return this._inclusionsOf.forEach((e, i) => {
      t.push(i);
    }), t;
  }
  hasInclusions() {
    return this._inclusionsOf.size > 0;
  }
  getAllInclusions() {
    const t = [];
    return this._inclusionsOf.forEach((e, i) => {
      for (const s of e)
        t.push(s, i);
    }), t;
  }
  getInclusionsOf(t) {
    t = t;
    const e = this._inclusionsOf.get(t);
    if (e === void 0)
      return [];
    const i = [];
    for (const s of e)
      i.push(s, t);
    return i;
  }
  hasModelIncluded(t) {
    return this._inclusionsOf.has(t);
  }
  attachedInvisibly() {
    return this._attachedInvisibly;
  }
  prototypeInstanceCount() {
    return console.assert(this._prototypeInstanceCount >= 0), this._prototypeInstanceCount;
  }
  registerInclusion(t, e) {
    const i = this._inclusionsOf.get(e);
    i === void 0 ? this._inclusionsOf.set(e, [t]) : i.push(t);
  }
  registerMasterModelKey(t) {
    console.assert(this._masterModelKey === Hn.Invalid), this._masterModelKey = t;
  }
  registerPrototypeInstanceCount(t) {
    console.assert(this._prototypeInstanceCount === -1), this._prototypeInstanceCount = t;
  }
}
class Sy {
  constructor() {
    this._calculatedCutoff = 0, this._requireBoundingInfo = !1, this._prevPriorityValue = 1, this._priorityProxies = /* @__PURE__ */ new Map();
  }
  getPriorityCompareValue(t) {
    if (typeof t == "number")
      return t;
    {
      const e = this._priorityProxies.get(t);
      return e.worldBounding !== null && console.assert(e.priorityHeuristic <= 1), e.priorityHeuristic;
    }
  }
  setRequireBoundingInfo(t) {
    this._requireBoundingInfo = t;
  }
  comparePriority(t, e) {
    const i = this.getPriorityCompareValue(t), s = this.getPriorityCompareValue(e);
    return i < s;
  }
  _updateHeuristicInfo(t, e) {
    var i;
    if (e.worldBounding !== null) {
      const s = Fr(e.worldBounding.center()), r = Fr(e.worldBounding.extents()), o = t.calculateAttachHeuristic(r, s);
      e.priorityHeuristic = o;
    }
    if ((i = e.xmlAttachInfo) != null && i.directlyRequested) {
      e.worldBounding === null && (e.priorityHeuristic = 0);
      const s = -1e6;
      e.priorityHeuristic += s;
    }
  }
  createPriority(t, e, i) {
    if (i === null)
      return ++this._prevPriorityValue, {};
    const s = /* @__PURE__ */ Object.create(null);
    let r, o;
    if (i.bounding !== null)
      r = e.transformBox(i.bounding), o = 0;
    else {
      if (this._requireBoundingInfo)
        throw new Error("WorldBounding must be specified when streamCutoff is enabled");
      r = null, o = ++this._prevPriorityValue;
    }
    const a = {
      xmlAttachInfo: i,
      worldBounding: r,
      priorityHeuristic: o
    };
    return this._updateHeuristicInfo(t, a), this._priorityProxies.set(s, a), s;
  }
  destroyPriority(t) {
    typeof t == "object" && this._priorityProxies.delete(t);
  }
  onViewChange(t, e, i) {
    this._calculateCutoff(i.getProjectionMatrix(e.getCamera())), this._priorityProxies.forEach((s) => {
      this._updateHeuristicInfo(t, s);
    });
  }
  reset() {
    this._priorityProxies.clear();
  }
  _calculateCutoff(t) {
    let i = 0.98;
    t.m[11] !== 0 && (i = (1 - t.m[15]) / t.m[11] * t.m[10] + t.m[14]);
    const s = Q.inverse(t);
    if (!s)
      throw new Error();
    const r = ac(s.transform4(new jn(0, 0, i, 1))), o = ac(
      s.transform4(new jn(0.0125, 0, i, 1))
    ), a = ac(
      s.transform4(new jn(0, 0.0125, i, 1))
    );
    lc(1 / r[3], r), lc(1 / o[3], o), lc(1 / a[3], a), this._calculatedCutoff = Math.min(
      du(Cc(o, r)),
      du(Cc(a, r))
    );
  }
  getCalculatedCutoff() {
    return this._calculatedCutoff;
  }
  // this will be true if streamcutoff is enabled.
}
class gl {
  constructor(t) {
    this._planes = [], this._absPlanes = [], this._signs = [], this._distanceScale = [];
    const e = t.length;
    for (const i of t)
      this._planes.push(i.slice());
    for (let i = 0; i < e; ++i) {
      this._planes[i][3] = -this._planes[i][3], this._absPlanes[i] = o_(this._planes[i]), this._signs[i] = [0, 0, 0];
      for (let s = 0; s < 3; ++s)
        this._signs[i][s] = this._planes[i][s] >= 0 ? 1 : -1;
    }
    for (let i = 0; i < e; ++i) {
      const s = Sh(this._planes[i]);
      this._distanceScale[i] = s === 0 ? 0 : 1 / s;
    }
  }
  static fromPlaneCoefficients(t) {
    const e = [];
    for (const i of t) {
      const s = [i.x, i.y, i.z, i.w];
      e.push(s);
    }
    return new gl(e);
  }
  static createFrustumFromMatrix(t) {
    const e = [];
    for (let i = 0; i < 3; ++i)
      e[i] = Cc(uo(t, 3), uo(t, i));
    for (let i = 0; i < 3; ++i)
      e[i + 3] = h_(uo(t, 3), uo(t, i));
    return new gl(e);
  }
  testAxisAlignedBox(t, e) {
    const i = this._planes.length;
    let s = Ra.FullyInside;
    for (let r = 0; r < i; ++r) {
      const o = rs(this._planes[r], t), a = rs(this._absPlanes[r], e);
      if (o + a <= this._planes[r][3])
        return Ra.Outside;
      o - a < this._planes[r][3] && (s = Ra.PartiallyInside);
    }
    return s;
  }
  axisAlignedBoxNotOutside(t, e) {
    const i = this._planes.length;
    for (let s = 0; s < i; ++s)
      if (rs(this._planes[s], l_(t, a_(e, this._signs[s]))) <= this._planes[s][3])
        return !1;
    return !0;
  }
  sphereNotOutside(t, e) {
    const i = this._planes.length;
    for (let s = 0; s < i; ++s) {
      const r = rs(this._planes[s], t) - this._planes[s][3];
      if (r < 0 && r * r * this._distanceScale[s] >= e)
        return !1;
    }
    return !0;
  }
  sphereFullyInside(t, e) {
    const i = this._planes.length;
    for (let s = 0; s < i; ++s) {
      const r = rs(this._planes[s], t) - this._planes[s][3];
      if (r < 0 || r * r * this._distanceScale[s] < e)
        return !1;
    }
    return !0;
  }
  pointInside(t) {
    const e = this._planes.length;
    for (let i = 0; i < e; ++i)
      if (rs(this._planes[i], t) - this._planes[i][3] < 0)
        return !1;
    return !0;
  }
  // 1 / (a^2 + b^2 + c^2) for each plane
}
function Zy(n) {
  return 1 / (1 + Math.exp(n));
}
class Iu {
  constructor(t) {
    const e = t.getCamera(), i = e.getPosition(), s = e.getTarget(), r = d.subtract(s, i);
    let o = r.length();
    o < 1e-7 && (o = 1e-7), this._eyeDistanceInverse = 1 / o, r.scale(this._eyeDistanceInverse);
    const a = t.getFullCameraMatrix();
    this._frustum = gl.createFrustumFromMatrix(a), this._viewProjectionW = uo(a, 3), this._cameraIsOrtho = e.getProjection() === No.Orthographic, this._position = Fr(i), this._eye = Fr(r);
  }
  calculateAttachHeuristic(t, e) {
    let i = 0;
    if (this._frustum.axisAlignedBoxNotOutside(e, t)) {
      const s = Sh(t), r = d_(e, s, this._viewProjectionW);
      if (r > 0) {
        let o = c_(e, this._position);
        const l = 1 / (rs(this._eye, o) * this._eyeDistanceInverse + 1e-5);
        o = u_(1 / uu(o), o);
        const c = rs(this._eye, o);
        let h = Math.pow(l, 6);
        this._cameraIsOrtho || (h *= Math.pow(c, 10) * 5), h < 1e-5 && (h = 1e-5), i = r * h;
      }
      return console.assert(0 <= i), -i - 1;
    }
    return i = Zy(uu(t)), console.assert(0 <= i && i < 1), i;
  }
}
const fp = class {
  static isSupported() {
    return fp._enabled && typeof fetch == "function" && typeof ReadableStream == "function";
  }
  static async request(n) {
    const t = await fetch(n);
    if (t.status === 200)
      return t;
    throw new ts(`Failed to fetch "${n}" with status ${t.status}.`);
  }
};
let Jr = fp;
Jr._enabled = !0;
const Cy = 13;
class fl {
  constructor(t, e, i, s) {
    this._cameraTimeoutId = null, this._isFirstAttachment = !0, this._attachScope = 0, s === null && (s = Cy), console.assert(s > 0), this._engine = t, this._view = e, this._callbackManager = i, this._parentToXmlAttachInfos = /* @__PURE__ */ new Map(), this._viewInfo = new Iu(this._view), this._attachPriorityManager = new Sy(), this._comparePriority = (r, o) => this._attachPriorityManager.comparePriority(r, o), this._attachQueue = this._createAttachQueue(s), this._prefetchScsQueue = this._createPrefetchScsQueue(s), this._registerCameraListener();
  }
  static async createWithEmptyModel(t, e, i, s) {
    return await t.loadEmpty(), new fl(t, e, i, s);
  }
  setPrefetchScsCutoffScale(t) {
    this._prefetchScsQueue.setCutoffScale(t), this._attachPriorityManager.setRequireBoundingInfo(this._prefetchScsQueue.cutoffEnabled());
  }
  /**
   * Used in the constructor only.
   */
  _createAttachQueue(t) {
    return new Rd(
      t,
      this._comparePriority,
      !1
    );
  }
  /**
   * Used in the constructor only.
   */
  _createPrefetchScsQueue(t) {
    const e = t + 15;
    return new If(
      0,
      this._attachPriorityManager,
      e,
      (i, s) => this._comparePriority(i, s),
      !1
    );
  }
  _reprioritizeAttachments() {
    this._viewInfo = new Iu(this._view), this._attachPriorityManager.onViewChange(this._viewInfo, this._view, this._engine), this._attachQueue.markDirty(), this._prefetchScsQueue.update();
  }
  /**
   * Used in the constructor only.
   */
  _registerCameraListener() {
    const t = () => {
      this._onCameraChange();
    };
    this._callbackManager.bind({
      camera: t,
      _shutdownBegin: () => {
        this._cameraTimeoutId !== null && (clearTimeout(this._cameraTimeoutId), this._cameraTimeoutId = null), this._callbackManager.unbind({ camera: t });
      }
    });
  }
  reprioritizeAttachmentsNow() {
    this._cameraTimeoutId !== null && (clearTimeout(this._cameraTimeoutId), this._cameraTimeoutId = null), this._reprioritizeAttachments();
  }
  _onCameraChange() {
    this._cameraTimeoutId !== null && clearTimeout(this._cameraTimeoutId), this._cameraTimeoutId = this._engine.setTimeout(() => {
      this._cameraTimeoutId = null, this._reprioritizeAttachments();
    }, 500);
  }
  /**
   * This listens on SC messages relevant for a given attachment.
   * This abstracts away the low-level details about an attachment
   * and bundles relevant information in a promise return value.
   */
  _awaitAttachInfo(t, e, i, s, r) {
    const o = s === null, a = new bu(e, i);
    let l = !1;
    const c = [], h = ye(), u = ye();
    let p = !1;
    const m = () => {
      console.assert(!p), p = !0, this._cleanupAttachLowLevel(), this._callbackManager.unbind(_);
    };
    let g = null;
    const _ = {
      _priorityMetaDataSent: (y, b) => {
        y === e && (a.registerPrototypeInstanceCount(b), h.resolve());
      },
      _announceModel: (y, b) => {
        y === e && (l = !0, a.registerMasterModelKey(b));
      },
      _inclusion: (y, b, w) => {
        y === e && (a.registerInclusion(b, w), c.push(w));
      },
      _remapModel: (y, b, w) => {
        y === e && t.remapModel(b, w);
      },
      _remapInclusion: (y, b, w, v) => {
        y === e && t.remapInclusion(b, w, v);
      },
      _missingModel: (y, b) => {
        y === e && (g = b);
      },
      _attached: (y) => {
        if (y !== e)
          return;
        if (!l) {
          if (g !== null && (o || r)) {
            console.assert(c.length === 0), u.reject(new Ll(g));
            return;
          }
          if (c.length !== 1) {
            u.reject(new ts("Bad model: Could not find master model key."));
            return;
          }
          const v = c[0];
          a.registerMasterModelKey(v);
        }
        const b = [h], w = this._isFirstAttachment;
        if (w) {
          this._isFirstAttachment = !1;
          const v = o ? Di.Direct : Di.Indirect, C = this._callbackManager.promiseTrigger("_firstAttachment", null, v);
          b.push(C);
        }
        zt(b).catch((v) => {
          throw console.assert(!1), v;
        }).then(async () => {
          w && this._engine.getSessionType() === Ke.Network && await this._callbackManager.promiseTrigger("_firstBoundingReady", null), m(), u.resolve(a);
        });
      }
    };
    return this._callbackManager.bind(_), u.catch((y) => {
      throw m(), y;
    });
  }
  _createPriority(t, e) {
    return this._attachPriorityManager.createPriority(
      this._viewInfo,
      t,
      e
    );
  }
  _cleanupAttachLowLevel() {
  }
  async _cleanupAttachHighLevel(t, e, i) {
    try {
      return await t;
    } finally {
      i !== null && this._forgetXmlAttachment(i), this._attachPriorityManager.destroyPriority(e);
    }
  }
  newAttachScope() {
    return ++this._attachScope;
  }
  _attachByStream(t, e, i, s, r, o, a, l) {
    const c = Q.toMatrix12(s.m), h = this._createPriority(s, a), u = this._attachQueue.push(async () => {
      const p = this.newAttachScope(), m = this._awaitAttachInfo(
        e,
        p,
        o.get(),
        a,
        l
      );
      try {
        return await t.enqueue(() => this._engine.attachModel(
          p,
          i,
          c,
          r,
          o.get()
        )), await m;
      } catch (g) {
        throw this._cleanupAttachLowLevel(), g;
      }
    }, h);
    return this._cleanupAttachHighLevel(u, h, a);
  }
  static _getAllModelKeys(t) {
    const e = t.getMasterModelKey(), i = t.getAllInclusions();
    if (i[1] !== e) {
      for (let r = 2; r < i.length; r += 2)
        if (i[r + 1] === e) {
          const a = i[r];
          i[r] = i[0], i[r + 1] = i[1], i[0] = a, i[1] = e;
          break;
        }
    }
    const s = [];
    for (let r = 0, o = 1; o < i.length; ++r, o += 2)
      s[r] = i[o];
    return s;
  }
  /**
   * This function is used to attach SCS buffers that are keyed to an `ExternalModelName`.
   * This happens when attaching an SCS from a model found in a shattered XML file.
   *
   * This function should be used over `simpleAttach` for this case. This is because `simpleAttach`
   * only takes a buffer as an argument. Without storing the entire buffer as a key to the attached
   * model keys of the SCS model, subsequent attachments of equivalent buffers cannot leverage
   * making new inclusions of the existing attached models. On the other hand, this keys the
   * attached models from the SCS buffer, allowing model sharing for subsequent attachments.
   *
   * Returns `Promise<null>` when the attachment is skipped (due to `toAttachData` returning `null`).
   */
  async attachByNamedScsBuffer(t, e, i, s, r, o, a, l) {
    t.getAutomaticMeasurementUnitScaling() || (o = nn);
    const c = gn(l.parent), h = Q.toMatrix12(r.m), u = this._createPriority(r, l), p = async (g) => {
      const _ = await (async () => {
        const v = c.getScsModelKeysOf(e);
        return v === null ? (c.initializeScsModelKeysOf(e), g) : v;
      })(), y = c.getScsModelKeysOf(e);
      if (y === null)
        throw new re();
      const b = this.newAttachScope();
      let w;
      if (_ instanceof Uint8Array || Jr.isSupported() && _ instanceof Response) {
        const C = this._awaitAttachInfo(
          i,
          b,
          a.get(),
          l,
          !1
        );
        try {
          await t.enqueue(() => {
            const k = this._engine.attachScsBuffer(
              b,
              _ instanceof Uint8Array ? _ : null,
              // if attachData is not an array, then data will be fed into SC as it arrives
              h,
              o,
              a.get(),
              !0
            );
            return _ instanceof Uint8Array || this.streamScsData(b, _), k;
          }), w = await C;
        } catch (k) {
          throw this._cleanupAttachLowLevel(), k;
        }
        if (y.state === ds.Pending) {
          const k = fl._getAllModelKeys(w);
          y.resolve(k);
        }
      } else if (_ === null)
        w = null, y.state === ds.Pending && y.resolve(null);
      else if (_ instanceof Array) {
        console.assert(y.state !== ds.Pending);
        const v = new bu(b, a.get());
        v.registerPrototypeInstanceCount(0);
        for (let C = 0; C < _.length; ++C) {
          const k = _[C], Y = this._engine.attachScsModelByKey(
            b,
            k,
            h,
            o,
            a.get()
          );
          v.registerInclusion(Y, k), C === 0 && v.registerMasterModelKey(k);
        }
        w = v;
      } else
        throw new re();
      return w;
    }, m = (async () => {
      const g = await this._prefetchScsQueue.push(async () => c.toScsBuffer(e, s), u);
      return l.directlyRequested = !0, this._attachQueue.push(() => p(g), u);
    })();
    return this._cleanupAttachHighLevel(m, u, l);
  }
  // Streams the data from a fetch response into the the buffer associated with the attach scope
  streamScsData(t, e) {
    this._callbackManager.trigger("_fetchBegin", e.url, t);
    const i = e.body.getReader(), s = async () => {
      for (; ; ) {
        const { done: r, value: o } = await i.read();
        if (r) {
          this._engine.feedScsBuffer(t, null), this._callbackManager.trigger("_fetchEnd", e.url, t);
          return;
        }
        this._engine.feedScsBuffer(t, o);
      }
    };
    this._engine.setTimeout(s, 0);
  }
  _attachByScsBuffer(t, e, i, s, r, o) {
    const l = Q.toMatrix12(s.m), c = this._createPriority(s, null), h = this._attachQueue.push(async () => {
      const u = this.newAttachScope(), p = this._awaitAttachInfo(
        e,
        u,
        o.get(),
        null,
        !1
      );
      try {
        return await t.enqueue(() => {
          const g = this._engine.attachScsBuffer(
            u,
            i instanceof Uint8Array ? i : null,
            // if scsBuffer is not an array, then data will be fed into SC as it arrives
            l,
            r,
            o.get(),
            !1
          );
          return i instanceof Uint8Array || this.streamScsData(u, i), g;
        }), await p;
      } catch (m) {
        throw this._cleanupAttachLowLevel(), m;
      }
    }, c);
    return this._cleanupAttachHighLevel(h, c, null);
  }
  simpleAttach(t, e, i, s, r, o, a, l) {
    if (t.getAutomaticMeasurementUnitScaling() || (r = nn), typeof i == "string")
      return this._attachByStream(
        t,
        e,
        i,
        s,
        r,
        o,
        a,
        l
      );
    if (a === null)
      return this._attachByScsBuffer(
        t,
        e,
        i,
        s,
        r,
        o
      );
    throw new re();
  }
  reset() {
    return this._isFirstAttachment = !0, this._attachScope = 0, this._parentToXmlAttachInfos.clear(), this._attachPriorityManager.reset(), this.clearAttachQueues();
  }
  /**
   * This method will effectively cancel an active LoadSubtreeByXML operation.
   * All deferred promises in the prefetch queue will be canceled.
   * Note that any open promises i.e. SCS files that are being fetched when this method is called will resolve before this method returns.
   */
  async clearAttachQueues() {
    return this._prefetchScsQueue.killDeferred(), this._attachQueue.killDeferred(), await this._prefetchScsQueue.waitForIdle(), this._attachQueue.waitForIdle();
  }
  isIdle() {
    return this._attachQueue.isIdle();
  }
  /**
   * Call this when a node has been directly requested by `Model.prototype.requestNodes`.
   */
  notifyDirectRequest(t) {
    const e = this._parentToXmlAttachInfos.get(t);
    if (e !== void 0) {
      let i = !1;
      for (const s of e)
        s.directlyRequested || (s.directlyRequested = !0, i = !0);
      i && this._reprioritizeAttachments();
    }
  }
  registerXmlAttachInfo(t) {
    const e = t.parent;
    let i = this._parentToXmlAttachInfos.get(e);
    i === void 0 && (i = [], this._parentToXmlAttachInfos.set(e, i)), i.push(t);
  }
  _forgetXmlAttachment(t) {
    const e = t.parent, i = this._parentToXmlAttachInfos.get(e);
    if (i.length === 1)
      console.assert(i[0] === t), this._parentToXmlAttachInfos.delete(e);
    else {
      console.assert(i.length > 1);
      const s = i.indexOf(t);
      console.assert(s >= 0), i.splice(s, 1);
    }
  }
  maxConcurrentAttachments() {
    return this._attachQueue.maxActivePromises();
  }
}
function Xh(n, t) {
  return new Promise((e, i) => {
    const s = new XMLHttpRequest();
    s.open("GET", n, !0), t && (s.responseType = t), s.onload = function(r) {
      if (s.readyState === Md.Done)
        if (s.status === Wd.Ok)
          e(s);
        else {
          const o = new ts(
            `XMLHttpRequest failed to GET "${n}" with status ${s.status}.`
          );
          i(o);
        }
    }, s.onerror = function(r) {
      i(r);
    }, s.send();
  });
}
async function _p(n) {
  const t = await Xh(n, "arraybuffer");
  return new Uint8Array(t.response);
}
class ky {
  constructor() {
    this._cache = /* @__PURE__ */ new Map();
  }
  clear() {
    this._cache.clear();
  }
  async load(t, e) {
    const i = this._cache.get(t);
    return i !== void 0 ? i : (this._cache.set(t, e), e);
  }
}
const yp = "Missing";
function bp(n) {
  return new DOMParser().parseFromString(n, "application/xml");
}
async function My(n) {
  const t = await Xh(n);
  let e = t.responseXML;
  return e === null && (e = bp(t.responseText)), e;
}
function Wy(n) {
  if (!n.hasChildNodes)
    return null;
  const t = n.firstChild;
  if (!(t instanceof Comment))
    return null;
  const e = t.data.split(" ");
  if (e.length !== 2 || e[0] !== "HC")
    return null;
  const i = e[1].split(".");
  if (i.length < 2)
    return null;
  const s = [];
  for (const r of i) {
    if (!Pd(r))
      return null;
    s.push(parseInt(r, 10));
  }
  return s;
}
function Py(n) {
  return mh(xh, n);
}
function Vy(n) {
  const t = n.getElementsByTagName("parsererror");
  if (t.length > 0)
    throw new ce(t[0].textContent || "unknown error");
}
function Yy(n) {
  const t = n.getParent();
  return t instanceof hi && t.getParent() instanceof on;
}
function Gy(n, t, e, i, s, r) {
  const o = new hi(
    t,
    s,
    r,
    Hn.Local,
    e
  );
  switch (i) {
    case 0:
      return o;
    case 1: {
      const a = new Si(
        n,
        o,
        ve.Local,
        Bi.Local
      );
      o.addInclusionContext(a);
      const l = Yt.createDynamic(
        n,
        a,
        yp,
        null,
        // authored node id
        null,
        // local transform
        !r
      );
      return a.addProductOccurrence(l), o;
    }
    default:
      return $n();
  }
}
function Ty(n, t, e, i) {
  return {
    getAttachScope() {
      return n;
    },
    getMasterModelKey() {
      return i;
    },
    getModelKeys() {
      return [i];
    },
    hasInclusions() {
      return !0;
    },
    getAllInclusions() {
      return [e, i];
    },
    getInclusionsOf(s) {
      return s === i ? [e, i] : [];
    },
    hasModelIncluded(s) {
      return s === i;
    },
    attachedInvisibly() {
      return t;
    },
    prototypeInstanceCount() {
      return 0;
    }
  };
}
class Fh {
  constructor(t, e, i, s, r) {
    this._loadQueue = new Ns(1024, !1), this._activeLoadCount = 0, this._activeLoadGeneration = 0, this._isFirstLoad = !0, this._firstAssemblyDataHeader = null, console.assert(t.isInitialized()), this._assemblyTree = t, this._scAttacher = e, this._engine = i, this._view = s, this._callbackManager = r, this._isScsSession = this._engine.getSessionType() === Ke.Scs, this._nodesUntilNextSleep = 2e3;
  }
  _resolveMeasurementUnits(t) {
    if (!this._assemblyTree.getAutomaticMeasurementUnitScaling())
      return;
    const e = Pn(t.getParent());
    if (e === null)
      throw new re();
    const i = e.getMeasurementUnit(), s = t.getMeasurementUnit();
    if (i === s)
      return;
    let r = t.getLocalTransform();
    r === null && (r = Xi.getIdentity());
    const o = s / i;
    r[0] *= o, r[5] *= o, r[10] *= o, t.setLocalTransformAsInitial(r);
  }
  /**
   * Used to create assembly tree data for instances that don't have authored assembly tree data.
   */
  async _patchImplicitNodesByModelInc(t, e, i, s, r) {
    let o = 0;
    if (s.length === 0)
      return;
    let a;
    const l = ji.create(() => {
      const c = t.get(), h = Ce(c), u = h.getAttachScope();
      a = h.attachedInvisibly();
      const p = h.split(u, a, c);
      c.addAttachContext(p);
      const m = new Si(
        this._assemblyTree,
        p,
        e,
        i
      );
      p.addInclusionContext(m);
      const g = Yt.createDynamic(
        this._assemblyTree,
        m,
        `Of Inclusion (${e})`,
        null,
        null,
        !a,
        r
      );
      return m.addProductOccurrence(g), g;
    });
    for (const c of s) {
      let h = this._assemblyTree.lookupAnyBodyByInstanceInc(e, c);
      if (h === null) {
        const u = l.get(), p = `Implicit Body ${++o}`, m = await this._engine.getPartsBounding(
          [e, c],
          !0,
          !1
        ), g = m.max !== m.min && !m.isDegenerate();
        h = this._assemblyTree.createMeshInstance(
          !0,
          // mark loaded
          e,
          c,
          null,
          // authored node id
          p,
          u,
          // parent
          !1,
          // prevent from resetting
          !1,
          // out of hierarchy
          g,
          !0
          // is implicit
        ), a && h.setVisibility(!1);
      }
    }
  }
  _getPrototypeInstanceCountByAttachment(t) {
    const e = /* @__PURE__ */ new Set();
    let i = 0;
    const s = t.getAllInclusions();
    for (let r = 0; r < s.length; r += 2) {
      const o = s[r], a = s[r + 1];
      e.has(a) || (e.add(a), i += this._assemblyTree.getInstanceCountByInclusion(o));
    }
    return i;
  }
  /**
   * Used to create assembly tree data for instances that don't have authored assembly tree data.
   */
  async _patchImplicitNodesByAttachment(t, e, i) {
    console.assert(t.isLoaded());
    let s = null;
    const r = ji.create(() => {
      const h = new Cr(), u = e.getMasterModelKey();
      s = new hi(
        h,
        e.getAttachScope(),
        e.attachedInvisibly(),
        u,
        t
      );
      const p = new Si(
        this._assemblyTree,
        s,
        ve.Local,
        Bi.Local
      );
      s.addInclusionContext(p);
      const m = Yt.createDynamic(
        this._assemblyTree,
        p,
        "Implicit Bodies",
        null,
        // authored node id
        null,
        // local transform
        !e.attachedInvisibly(),
        i
      );
      return p.addProductOccurrence(m), m;
    });
    let o = e.prototypeInstanceCount();
    o === 0 && ([o] = await this._engine.instanceKeyInfo(
      e.getAttachScope(),
      rl.Attachment,
      ol.KeyCountOnly
    ));
    let a = this._getPrototypeInstanceCountByAttachment(e);
    if (a === o)
      return;
    const l = await this._engine.instanceKeyInfo(
      e.getAttachScope(),
      rl.Attachment,
      ol.AllKeys
    ), c = e.getAllInclusions();
    for (let h = 0; h < c.length; h += 2) {
      const u = c[h], p = c[h + 1], m = l.get(p);
      m !== void 0 && await this._patchImplicitNodesByModelInc(
        r,
        u,
        p,
        m,
        i
      );
    }
    if (a = this._getPrototypeInstanceCountByAttachment(e), a < o)
      throw new re();
    s !== null && (await er([s]), t instanceof on, t.addAttachContext(s));
  }
  /**
   * Newly loaded children should have their instances demanded if any of their
   * ancestors are currently being demanded. This function performs this logic.
   */
  async _updateOnDemandRequests(t) {
    if (!this._assemblyTree.onDemandRequestsActive())
      return;
    const e = t.getChildren(), i = [];
    for (const s of e)
      this._assemblyTree.isBeingRequested(s) && i.push(s);
    return this._assemblyTree.requestNodes(this, i, !0);
  }
  async _populateAttachment(t, e, i, s, r, o) {
    console.assert(r === Di.Indirect == (o !== null));
    const a = await this._parseRootNodes(
      t,
      e,
      i,
      s,
      o
    );
    return await this._postProcessAttachContext(e, s, r, a), a;
  }
  async _postProcessAttachContext(t, e, i, s) {
    await yi.forceLazyPromises(s), await this._assemblyTree.enqueue(() => _f(this._engine, s));
    let r = this._assemblyTree.markImplicitNodesOutOfHierarchy();
    r && (r = s.getChildren().length > 0 || i === Di.Indirect), await this._patchImplicitNodesByAttachment(t, e, r), await this._updateOnDemandRequests(s);
    const a = s.getChildren().map((l) => l.getRuntimeId());
    this._callbackManager.trigger("_attachmentPopulated", a);
  }
  async _parseRootNodes(t, e, i, s, r) {
    const o = s.getMasterModelKey(), a = s.getInclusionsOf(o);
    o === Hn.Invalid && (console.assert(a.length === 0), a.push(ve.Invalid, Bi.Invalid));
    const l = new hi(
      i,
      s.getAttachScope(),
      s.attachedInvisibly(),
      o,
      e
    );
    r !== null && l.setReservedNodeIdOffset(r);
    const c = new Ns(1, !0), h = await this._assemblyTree.enqueue(() => l.getRootNodeMetaData(this._assemblyTree));
    for (let u = 0; u < a.length; u += 2)
      c.push(() => {
        const p = a[u], m = a[u + 1];
        return this._parseRootNode(t, l, h, p, m);
      });
    return await c.waitForIdle(), l;
  }
  async _parseRootNode(t, e, i, s, r) {
    console.assert(s !== ve.Local);
    const o = await this._populateInclusion(
      t,
      e,
      i,
      s,
      r
    );
    if (o.hasAuthoredId()) {
      console.assert(!o.isLoaded());
      const a = Ne(o);
      Yy(a) && this._setupRootNode(o, !1);
    } else
      o.getName() === null && (e.removeProductOccurrence(o) || console.assert(!1));
  }
  _setupRootNode(t, e) {
    console.assert(!t.isAbsoluteRoot()), e && t.markIsExternalModelRoot(this._assemblyTree), this._resolveMeasurementUnits(t);
  }
  async _populateInclusion(t, e, i, s, r) {
    console.assert(s !== ve.Local);
    const o = new Si(
      this._assemblyTree,
      e,
      s,
      r
    );
    e.addInclusionContext(o);
    const a = await (async () => {
      if (i === null || i.bytes.length === 0) {
        let h = null;
        return i === null && (h = yp), Yt.createDynamic(
          this._assemblyTree,
          o,
          h,
          null,
          // authored node id
          null,
          // local transform
          !e.attachedInvisibly()
        );
      }
      const l = new zo(i), c = Yt.parseBinary(
        t,
        this._assemblyTree,
        o,
        l
      );
      return Yt.reify(
        t,
        this,
        this._assemblyTree,
        o,
        c,
        o
      );
    })();
    return o.addProductOccurrence(a), a;
  }
  /**
   * COM-1701
   */
  async _rectifyLateVisibilityChange(t, e) {
    const i = Ce(e.getParent()), s = Pn(e.getParent());
    if (console.assert(s === Pn(i)), t.attachInvisibly || s === null || !s.isLoaded())
      return;
    const r = s.isVisible();
    if (i.attachedInvisibly() === !r)
      return;
    const o = r ? hs.Initial : hs.Hide;
    return gf({
      assemblyTree: this._assemblyTree,
      engine: this._engine,
      attachContext: i,
      setVisibility: o
    });
  }
  _loadCleanup(t, e, i) {
    console.assert(this._activeLoadCount > 0), t.onLoadComplete(), e !== null && this._callbackManager.unbind(e), --this._activeLoadCount, this._assemblyTree.onLoadEnd(i), this._callbackManager.trigger("visibilityChanged", [], []);
  }
  _wrap(t, e, i, s) {
    const r = this._activeLoadGeneration;
    return this._loadQueue.push(async () => {
      const o = this._assemblyTree.onLoadBegin();
      let a = null;
      if (r !== this._activeLoadGeneration)
        throw this._loadCleanup(e, a, o), new Rl();
      this._firstAssemblyDataHeader === null && (a = {
        _modelStructureHeaderParsed: async (p) => {
          a !== null && (this._firstAssemblyDataHeader === null && (this._firstAssemblyDataHeader = p), this._callbackManager.unbind(a), a = null);
        }
      }, this._callbackManager.bind(a, !0));
      try {
        await i;
      } catch (p) {
        throw await e.purgeContents(), this._loadCleanup(e, a, o), p;
      }
      const l = e.getParent();
      if (l === null)
        throw this._loadCleanup(e, a, o), new re();
      s === Di.Direct && (e.hasChildren() ? l.addLoadContext(e) : await e.purgeContents()), this._loadCleanup(e, a, o);
      const h = e.getChildren(), u = [];
      for (const p of h) {
        const m = this._rectifyLateVisibilityChange(t, p);
        u.push(m);
      }
      if (await zt(u), this._isFirstLoad) {
        this._isFirstLoad = !1, e.markAsFirstLoad();
        const p = h.map((g) => g.getRuntimeId()), m = !1;
        try {
          await this._callbackManager.promiseTrigger(
            "_firstModelLoaded",
            "firstModelLoaded",
            p,
            m,
            s
          );
        } catch (g) {
          throw console.assert(!1), g;
        }
      }
      return e;
    });
  }
  _initLoad(t, e, i) {
    ++this._activeLoadCount;
    const s = this._isScsSession && i ? new ky() : null;
    return new on(t, e, s);
  }
  static _getNetMatrix(t, e) {
    let i = Q.createFromArray(Bo(t));
    return e !== null && (i = Q.multiply(e, i)), i;
  }
  _lazyAttachInvisibly(t, e) {
    return ji.create(() => e.attachInvisibly || !t.isVisible());
  }
  _loadBySingleAttach(t, e, i, s) {
    const r = this._initLoad(e, s, !1), o = xi.create(async () => {
      const a = await i, l = new Cr(), c = Fh._getNetMatrix(e, t.additionalMatrix), h = e.getMeasurementUnit(), u = this._lazyAttachInvisibly(e, t), p = await this._scAttacher.simpleAttach(
        this._assemblyTree,
        l,
        a,
        c,
        h,
        u,
        null,
        // xml attach info
        !1
      ), m = await this._populateAttachment(
        t,
        r,
        l,
        p,
        Di.Direct,
        null
      );
      return await er([r, m]), m.hasChildren() && r.addAttachContext(m), {};
    });
    return this._wrap(t, r, o, Di.Direct);
  }
  async _populateFromXml(t, e, i, s) {
    let o = i.documentElement.firstElementChild, a = null, l = null;
    for (; o !== null; ) {
      if (o.localName === "ModelFile" && (console.assert(a === null), a = rc.parseXml(
        t,
        this._assemblyTree,
        e,
        o,
        s
      )), o.localName === "DefaultCamera" && (l = we.parseCamera(o), !l))
        throw new ce(`"DefaultCamera" element exists but couldn't be parsed`);
      o = o.nextElementSibling;
    }
    if (a === null)
      throw new ce('Expected "ModelFile" element.');
    let c = !1;
    if (this._isFirstLoad) {
      let u = nn;
      if (this._assemblyTree.getAutomaticMeasurementUnitScaling() && (u = Pn(e).getMeasurementUnit()), l != null)
        c = !0, await this._view._setCameraPromise(l, 0);
      else {
        const p = rc.parseBounding(a, u);
        !p.isDegenerate() && l === null && (c = !0, await this._view.setViewOrientation(et.Iso, 0, p));
      }
    }
    const h = await rc.reify(
      t,
      this._callbackManager,
      this,
      this._assemblyTree,
      e,
      a
    );
    for (const u of h)
      this._setupRootNode(u, !1);
    this._isFirstLoad && !c && await this._view.setViewOrientation(et.Iso, 0);
  }
  _loadByXml(t, e, i, s, r) {
    const o = this._initLoad(e, r, !0), a = xi.create(async () => {
      const l = await i;
      Vy(l);
      const c = Wy(l);
      if (c === null || !Py(c))
        throw new ce("Bad version.");
      const h = (b) => s(b, c);
      this._scAttacher.reprioritizeAttachmentsNow(), e.addLoadContext(o);
      const u = Ne(e), p = Ce(u), m = this._scAttacher.newAttachScope(), g = this._lazyAttachInvisibly(e, t), _ = p.split(
        m,
        g.get(),
        o
      );
      o.addAttachContext(_);
      const y = u.split(
        this._assemblyTree,
        _
      );
      return _.addInclusionContext(y), await this._populateFromXml(t, y, l, h), await er([o, _]), {};
    });
    return this._wrap(t, o, a, Di.Indirect);
  }
  // For external models built-directly inside SC metadata (i.e. not from a shattered XML file).
  async _attachExternalModelByInc(t, e) {
    console.assert(t.inclusionKey !== ve.Local);
    const i = Ce(e).getAttachScope(), s = t.modelKey, r = this._lazyAttachInvisibly(e, t.config), o = new Cr(), a = new hi(
      o,
      i,
      r.get(),
      s,
      e
    ), l = await a.getRootNodeMetaData(this._assemblyTree);
    return await this._populateInclusion(
      t.config,
      a,
      l,
      t.inclusionKey,
      t.modelKey
    ), a;
  }
  // For external models given by shattered XML files.
  async _attachExternalModelInfoByName(t, e, i) {
    const s = new Cr(), r = this._lazyAttachInvisibly(e, t.config), o = e.getMeasurementUnit(), a = (() => {
      const h = Q.createFromArray(Bo(e));
      if (o <= 0 || !this._assemblyTree.getAutomaticMeasurementUnitScaling())
        return h;
      const u = (() => {
        const g = i.getAttachContext().getParent();
        if (g === null)
          return nn;
        const _ = g.getParent();
        return _ === null ? nn : _.getMeasurementUnit();
      })(), p = u === nn ? 1 : o / u;
      return p === 1 ? h : Q.multiply(
        h,
        new Q().setScaleComponent(p, p, p)
      );
    })(), l = {
      bounding: t.bounding,
      parent: e,
      directlyRequested: !1
    };
    let c;
    if (this._isScsSession)
      this._scAttacher.registerXmlAttachInfo(l), c = await this._scAttacher.attachByNamedScsBuffer(
        this._assemblyTree,
        t.modelName,
        s,
        t.toAttachData,
        a,
        o,
        r,
        l
      ) || 0;
    else
      try {
        const h = await t.toAttachData(t.modelName);
        if (h === null || h === rr)
          c = 0;
        else {
          if (typeof h != "string")
            throw new re();
          this._scAttacher.registerXmlAttachInfo(l), c = await this._scAttacher.simpleAttach(
            this._assemblyTree,
            s,
            h,
            a,
            o,
            r,
            l,
            t.config.allowMissingExternalModels
          );
        }
      } catch (h) {
        if (t.config.allowMissingExternalModels && h instanceof Ll)
          c = 1;
        else
          throw h;
      }
    if (typeof c == "number") {
      const h = this._scAttacher.newAttachScope(), u = !r.get();
      return Gy(
        this._assemblyTree,
        s,
        e,
        c,
        h,
        u
      );
    } else
      return this._populateAttachment(
        t.config,
        e,
        s,
        c,
        Di.Indirect,
        t.reservedNodeIdOffset
      );
  }
  setPrefetchScsCutoffScale(t) {
    this._scAttacher.setPrefetchScsCutoffScale(t);
  }
  isIdle() {
    return this._activeLoadCount === 0 ? (console.assert(this._scAttacher.isIdle()), !0) : !1;
  }
  waitOnCurrentLoads() {
    return this._loadQueue.waitForIdle();
  }
  cancelPendingLoads() {
    return ++this._activeLoadGeneration, this.waitOnCurrentLoads();
  }
  async cancelActiveAttachmentProcess() {
    return this._scAttacher.clearAttachQueues();
  }
  loadByStream(t, e, i) {
    if (i === rr) {
      const s = new on(e, rr, null);
      return Promise.resolve(s);
    }
    return this._loadBySingleAttach(t, e, Promise.resolve(i), i);
  }
  loadByScsBuffer(t, e, i) {
    return this._loadBySingleAttach(t, e, Promise.resolve(i), "*SCS Buffer*");
  }
  async loadByScsFile(t, e, i) {
    if (Jr.isSupported())
      return this._loadBySingleAttach(t, e, Jr.request(i), i);
    {
      const s = _p(i);
      return this._loadBySingleAttach(t, e, s, i);
    }
  }
  loadByXmlDoc(t, e, i, s) {
    let r;
    return typeof i == "string" ? r = bp(i) : r = i, this._loadByXml(t, e, Promise.resolve(r), s, "*XML Document*");
  }
  loadByXmlFile(t, e, i, s) {
    const r = My(i);
    return this._loadByXml(t, e, r, s, i);
  }
  async attachByExternalModelInfo(t, e, i) {
    let s;
    Do(t) ? s = await this._attachExternalModelInfoByName(t, e, i) : s = await this._attachExternalModelByInc(t, e);
    const r = [], o = s.getChildren();
    for (const a of o) {
      this._setupRootNode(a, !0);
      const l = this._rectifyLateVisibilityChange(t.config, a);
      r.push(l);
    }
    return await zt(r), s;
  }
  /**
   * I don't think this is used at all. If so, this should be removed.
   */
  async loadByAssemblyData(t, e, i, s) {
    const r = Di.Direct, [o, a] = i, l = this._scAttacher.newAttachScope(), c = !e.isVisible(), h = Ty(l, c, o, a), u = this._initLoad(e, "*Assembly Data*", !1), p = xi.create(async () => {
      const m = new Cr(), g = h.getMasterModelKey(), _ = new hi(
        m,
        l,
        h.attachedInvisibly(),
        g,
        u
      );
      return await this._parseRootNode(t, _, s, o, a), await this._postProcessAttachContext(u, h, r, _), await er([u, _]), _.hasChildren() && u.addAttachContext(_), {};
    });
    return this._wrap(t, u, p, r);
  }
  reset() {
    return this._isFirstLoad = !0, this._firstAssemblyDataHeader = null, this._scAttacher.reset();
  }
  notifyDirectRequest(t) {
    this._scAttacher.notifyDirectRequest(t);
  }
  onLoadChildProductOccurrence() {
    if (this._nodesUntilNextSleep === 0)
      return this._nodesUntilNextSleep = 2e3, this._engine.sleep(
        10
        /* sleepLengthMilliseconds */
      );
    --this._nodesUntilNextSleep;
  }
  firstAssemblyDataHeader() {
    return this._firstAssemblyDataHeader;
  }
}
function Ey(n, t, e, i, s) {
  const r = [], o = (u) => {
    u.getInclusionContexts().forEach((m) => {
      r.push(m.getInclusionKey());
    });
  }, a = (u) => {
    u.getAttachContexts().forEach(o);
  }, c = {
    enterProductOccurrence: (u) => {
      if (i.has(u) || (i.add(u), u.isOutOfHierarchy() && !e))
        return;
      u.getChildContexts().forEach((m) => {
        m instanceof on ? a(m) : o(m);
      });
    }
  }, h = n.walk(c, t, s);
  return h ? h.then(() => r) : r;
}
function Ny(n, t, e, i) {
  return Ey(
    ua,
    n,
    t,
    e,
    i
  );
}
function Ry(n, t, e) {
  const i = [], s = /* @__PURE__ */ new Set();
  for (const r of t) {
    const o = n.lookupAnyTreeNode(r);
    if (o === null)
      throw new sn(r);
    const a = ks(o), l = Ny(o, a, s, e);
    for (const c of l)
      i.push(c);
  }
  return i;
}
async function Ly(n) {
  let t = !1;
  const e = (s) => {
    s.hasLocalTransformOverride() && (s.removeLocalTransformOverride(), t = !0);
  }, i = {
    enterProductOccurrence: e,
    enterPmi: e,
    enterCadView: e,
    enterAnyBody: (s) => {
      s.preventFromResetting() || e(s);
    }
  };
  return await yi.walk(i, n, ft.None), t;
}
function Xy(n, t, e) {
  const i = [], s = /* @__PURE__ */ new Set(), r = (a) => s.has(a) ? !1 : (s.add(a), !0), o = {
    followProductOccurrence: r,
    followPmi: r,
    followCadView: r,
    followAnyBody: r,
    enterAnyBody: (a) => {
      if (!a.isOutOfHierarchy()) {
        const l = a.getInstanceInc();
        i.push(l[0], l[1]);
      }
    }
  };
  for (const a of t)
    ua.walk(o, a, ft.None);
  n.setMeshLevel(i, e);
}
function Fy(n) {
  return n instanceof Me || n instanceof Be || n instanceof Nr || n instanceof Rr || n instanceof Lr || n instanceof Sl || n instanceof Zl || n instanceof Cl || n instanceof kl || n instanceof Ml || n instanceof Wl || n instanceof Pl || n instanceof Vl || n instanceof Yl || n instanceof Gl || n instanceof Tl || n instanceof El || n instanceof xl;
}
function Ky(n) {
  return n instanceof vl || n instanceof ha || n instanceof lr;
}
function wu(n) {
  return async (t, e) => {
    const i = mh(e, [7, 3]) ? `${t}.scs` : t, s = await n(i);
    return typeof s == "string" ? Jr.isSupported() ? Jr.request(s) : _p(s) : s;
  };
}
class Kh {
  constructor(t, e, i, s, r, o) {
    this._clearQueue = new Ns(1, !1), this._clearInProgress = !1, this._cadConfigurationsEnabled = !0, this._engine = e, this._callbackManager = i, this._cuttingManager = s, this._view = r, this._model = o, this._assemblyTree = new xy(
      t,
      this._engine,
      this._callbackManager,
      this._cuttingManager,
      this._view,
      this._model
    ), this._readyPromise = fh();
  }
  /**
   * Until `modelStructure.isReady()` is true, only the following functions are legal to call:
   *      - `modelStructure.waitForReady()`
   *      - `modelStructure.isReady()`
   */
  static unsafeCreate(t, e, i, s, r, o, a) {
    return this._create(
      t,
      e,
      i,
      s,
      r,
      o,
      a
    ).unsafeValue;
  }
  static async create(t, e, i, s, r, o, a) {
    return this._create(
      t,
      e,
      i,
      s,
      r,
      o,
      a
    );
  }
  static _create(t, e, i, s, r, o, a) {
    const l = new Kh(
      t,
      e,
      i,
      s,
      r,
      o
    ), c = l._init(a);
    return os(l, c);
  }
  async _init(t) {
    const e = await fl.createWithEmptyModel(
      this._engine,
      this._view,
      this._callbackManager,
      t
    );
    this._assemblyTree.initialize(e);
    const i = new Fh(
      this._assemblyTree,
      e,
      this._engine,
      this._view,
      this._callbackManager
    );
    console.assert(this._treeLoader === void 0), this._treeLoader = i, this._readyPromise.resolve();
  }
  async _loadSubtreePrologue(t, e, i) {
    if (this._engine.getSessionType() !== t)
      throw new ts("Incompatible load types.");
    if (i && await this._clearQueue.waitOnLatest(), this._clearInProgress)
      throw new Rl();
    const s = this._assemblyTree.lookupProductOccurrence(e);
    if (s === null)
      throw new Gi(e, li.ProductOccurrence);
    return s;
  }
  async _loadSubtreeEpilogue(t, e) {
    t.isFirstLoad() && this._engine.getSessionType() === Ke.Scs && await this._callbackManager.promiseTrigger("_firstBoundingReady", null);
    const s = t.getChildren().map((r) => r.getRuntimeId());
    return e && await this._callbackManager.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      s,
      ps.LoadModel
    ), s;
  }
  async loadSubtreeFromXmlFile(t, e, i, s) {
    await this._disableCadConfigurations();
    const r = Ke.Network, o = await this._loadSubtreePrologue(r, t, !0), a = await this._treeLoader.loadByXmlFile(
      s,
      o,
      e,
      i
    );
    return this._loadSubtreeEpilogue(a, !1);
  }
  async loadSubtreeFromXmlDoc(t, e, i, s) {
    await this._disableCadConfigurations();
    const r = Ke.Network, o = await this._loadSubtreePrologue(r, t, !0), a = await this._treeLoader.loadByXmlDoc(s, o, e, i);
    return this._loadSubtreeEpilogue(a, !1);
  }
  async loadSubtreeFromScsXmlFile(t, e, i, s) {
    await this._disableCadConfigurations();
    const r = Ke.Scs, o = await this._loadSubtreePrologue(r, t, !0), a = wu(i), l = await this._treeLoader.loadByXmlFile(s, o, e, a);
    return this._loadSubtreeEpilogue(l, !1);
  }
  async loadSubtreeFromScsXmlDoc(t, e, i, s) {
    await this._disableCadConfigurations();
    const r = Ke.Scs, o = await this._loadSubtreePrologue(r, t, !0), a = wu(i), l = await this._treeLoader.loadByXmlDoc(s, o, e, a);
    return this._loadSubtreeEpilogue(l, !1);
  }
  async _loadSubtreeFromStream(t, e, i, s) {
    const r = Ke.Network, o = await this._loadSubtreePrologue(r, t, i), a = await this._treeLoader.loadByStream(s, o, e);
    return this._loadSubtreeEpilogue(a, s._allowSubtreeLoadedCallback);
  }
  async loadSubtreeFromStream(t, e, i) {
    return this._loadSubtreeFromStream(t, e, !0, i);
  }
  async loadSubtreeFromScsFile(t, e, i) {
    const s = Ke.Scs, r = await this._loadSubtreePrologue(s, t, !0), o = await this._treeLoader.loadByScsFile(i, r, e);
    return this._loadSubtreeEpilogue(o, i._allowSubtreeLoadedCallback);
  }
  async loadSubtreeFromScsBuffer(t, e, i) {
    const s = Ke.Scs, r = await this._loadSubtreePrologue(s, t, !0), o = await this._treeLoader.loadByScsBuffer(i, r, e);
    return this._loadSubtreeEpilogue(o, i._allowSubtreeLoadedCallback);
  }
  /**
   * I don't think this is used at all. If so, this should be removed.
   */
  async loadSubtreeFromAssemblyData(t, e, i, s) {
    const r = Ke.Network, o = await this._loadSubtreePrologue(r, t, !0), a = await this._treeLoader.loadByAssemblyData(
      s,
      o,
      e,
      i
    );
    return this._loadSubtreeEpilogue(a, s._allowSubtreeLoadedCallback);
  }
  async loadMeasurementFromJson(t) {
    const e = Object.keys(t);
    for (const i of e) {
      const s = parseInt(i, 10);
      if (isNaN(s))
        continue;
      const r = t[s], o = parseInt(r.instance_id, 10);
      if (isNaN(o))
        continue;
      const a = await this._getNodeOrRepItemFromId(o);
      if (!(a instanceof Fe))
        continue;
      const l = r.edge_properties;
      for (let h = 0; h < l.length; h++) {
        const u = l[h], p = u.id, m = u.data;
        let g = null;
        switch (u.type) {
          case "circle":
            g = ha.fromJson(m);
            break;
          case "line":
            g = vl.fromJson(m);
            break;
          case "unknown_edge":
            g = lr.fromJson(m);
            break;
        }
        g !== null && a.setEdgeMeasurementProperty(p, g);
      }
      const c = r.face_properties;
      for (let h = 0; h < c.length; h++) {
        const u = c[h], p = u.id, m = u.data;
        let g = null;
        switch (u.type) {
          case "cylinder":
            g = Me.fromJson(m);
            break;
          case "plane":
            g = Be.fromJson(m);
            break;
          case "cone":
            g = Nr.fromJson(m);
            break;
          case "sphere":
            g = Rr.fromJson(m);
            break;
          case "torus":
            g = Lr.fromJson(m);
            break;
        }
        g !== null && a.setFaceMeasurementProperty(p, g);
      }
    }
  }
  async loadMeasurementFromString(t) {
    const e = JSON.parse(t);
    return this.loadMeasurementFromJson(e);
  }
  async loadMeasurementFromFile(t) {
    const e = await Xh(t, "blob");
    if (e.status !== 200)
      throw new Error(`Cannot pull measurement file '${t}': ${e.response}`);
    const s = (await Xl.loadAsync(e.response)).file("measurement.json");
    if (!s)
      throw new Error(`Cannot pull measurement data from '${t}'`);
    const r = await s.async("string");
    return this.loadMeasurementFromString(r);
  }
  async _clearImpl() {
    console.assert(!this._clearInProgress), this._clearInProgress = !0;
    try {
      await this._treeLoader.cancelActiveAttachmentProcess(), await this._treeLoader.cancelPendingLoads(), console.assert(this._treeLoader.isIdle()), console.assert(this._clearInProgress), await this._treeLoader.reset(), console.assert(this._treeLoader.isIdle()), console.assert(this._clearInProgress), await this._assemblyTree.reset(), console.assert(this._treeLoader.isIdle()), console.assert(this._clearInProgress), this._clearInProgress = !1;
    } catch (t) {
      throw console.assert(this._clearInProgress), this._clearInProgress = !1, t;
    }
  }
  clear() {
    return this._clearQueue.push(async () => (this._callbackManager.trigger("modelSwitchStart", !0), await this._clearImpl(), this._callbackManager.promiseTrigger(
      "_modelSwitched",
      "modelSwitched",
      !0,
      [],
      Di.Direct
    )));
  }
  switchToModel(t) {
    const e = t === rr;
    return this._clearQueue.push(async () => {
      this._callbackManager.trigger("modelSwitchStart", !1), await this._clearImpl();
      let i;
      return e ? i = [] : i = await this._loadSubtreeFromStream(
        this.getAbsoluteRootNodeId(),
        t,
        !1,
        new hr()
      ), await this._callbackManager.promiseTrigger(
        "_modelSwitched",
        "modelSwitched",
        e,
        i,
        Di.Direct
      ), i;
    });
  }
  getAbsoluteRootNodeId() {
    return this._assemblyTree.getRootNode().getRuntimeId();
  }
  isIdValid(t) {
    return this._assemblyTree.lookupAnyNode(t) !== null;
  }
  _getNodeChildren(t, e) {
    let i = t.getChildrenSync();
    e || (i = i.filter((o) => !o.isOutOfHierarchy()));
    const s = t.getBodyInstances();
    for (const o of s)
      (!o.isOutOfHierarchy() || e) && i.push(o);
    const r = t.getPmis();
    for (const o of r)
      i.push(o);
    return i;
  }
  getChildIds(t, e) {
    const i = this._assemblyTree.lookupProductOccurrence(t);
    if (i === null)
      return [];
    const s = this._getNodeChildren(i, e), r = [];
    for (const o of s)
      r.push(o.getRuntimeId());
    return r;
  }
  isOutOfHierarchy(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null && ks(e);
  }
  getParentId(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e === null)
      return null;
    const i = Bd(e.getParent());
    return i === null ? null : i.getRuntimeId();
  }
  async getPartReferrers(t) {
    const e = this._assemblyTree.lookupProductOccurrence(t);
    if (e === null)
      return null;
    const i = this._assemblyTree.getRootNode();
    await Sc(i), await Sf(i);
    const s = e.getPartDefinitionSync();
    if (s === null)
      return null;
    const r = s.getReferrers(), o = /* @__PURE__ */ new Set();
    for (const a of r) {
      const c = a.getParent().getReferrers();
      for (const h of c)
        o.add(h.getRuntimeId());
    }
    return Array.from(o);
  }
  async getAttributes(t) {
    const e = await this._getNodeOrRepItemFromId(t);
    return e === null ? [] : e.getAttributes();
  }
  async getProperties(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i === null)
      return null;
    const s = {}, r = {}, o = [];
    let a = i.getAttributes().then((h) => {
      for (const u of h) {
        const p = u.getValueName();
        let m = u.getTitle();
        p !== null && (m !== "" ? m = m + "/" + p : m = p);
        const _ = `${u.getValue()}${u.getUnit()}`;
        s[m] = _;
      }
    });
    o.push(a);
    const l = (h) => {
      const u = this.getNetMatrix(t), p = new d(u[0], u[1], u[2]), m = this.getUnit(t), g = p.length() / m, _ = h.surfaceArea * g * g, y = h.volume * g * g * g, b = Go(_, m);
      s["Surface Area"] = `${b}${bg}`;
      const w = Go(y, m);
      s.Volume = `${w}${Ig}`;
      const v = Q.createFromArray(u).transform(
        h.centerOfGravity
      ), C = d.scale(v, 1 / m), k = C.x.toLocaleString(), Y = C.y.toLocaleString(), P = C.z.toLocaleString();
      s.COG = `x:${k} y:${Y} z:${P}`;
    }, c = async (h) => {
      const u = await h.value;
      if (u !== null) {
        const p = await u.getAttributes();
        for (const m of p) {
          const g = m.getValueName();
          let _ = m.getTitle();
          g !== null && (_ !== "" ? _ = _ + "/" + g : _ = g);
          const b = `${m.getValue()}${m.getUnit()}`;
          r[_] = b;
        }
      }
    };
    if (i instanceof Fe) {
      const h = i.getPhysicalProperties();
      h !== null && l(h);
    } else
      i instanceof Yt && (a = Promise.resolve(Ao(i)).then(async () => {
        const h = await i.getPhysicalProperties(e);
        h !== null && l(h);
        const u = await i.getPartDefinition();
        if (u !== null)
          return c(u);
      }), o.push(a));
    return await zt(o), { ...r, ...s };
  }
  addProperty(t, e, i, s) {
    const r = this._assemblyTree.lookupAnyNode(t);
    if (r === null)
      return !1;
    const o = new Wn(
      Bn.String,
      e,
      null,
      i,
      s
    );
    return r.addAttribute(o), !0;
  }
  setPhysicalProperties(t, e, i, s) {
    const r = this._assemblyTree.lookupRepresentationItem(t);
    if (r === null)
      return !1;
    const o = new nr(i, s, e);
    return r.setPhysicalProperties(o), !0;
  }
  getUserDataIndices(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e === null)
      throw new sn(t);
    return e.getUserDataIndices();
  }
  getUserData(t, e) {
    const i = this._assemblyTree.lookupAnyTreeNode(t);
    if (i === null)
      throw new sn(t);
    return i.getUserData(e);
  }
  getInstanceIncs(t, e) {
    const i = this._assemblyTree.lookupAnyTreeNode(t);
    if (i === null)
      return console.assert(!1), [];
    const s = ks(i);
    return Oo(
      i,
      e,
      s,
      /* @__PURE__ */ new Set(),
      ft.None
    );
  }
  getNodeFromInstanceInc(t, e, i, s) {
    let r = this._assemblyTree.lookupAnyBodyByInstanceInc(
      e,
      i
    );
    if (r === null) {
      const o = t ? this._rectifyParent(e, null) : this._assemblyTree.getRootNode();
      r = this._assemblyTree.createMeshInstance(
        t,
        e,
        i,
        null,
        // authored ID
        null,
        // name
        o,
        !1,
        // prevent from resetting
        s,
        !0,
        // initially visible
        !1
        // implicit body
      );
    } else
      r instanceof In && (r = r.getParent());
    return r.getRuntimeId();
  }
  _getAssociatedModelKey(t) {
    return t instanceof Ei ? t.getModelKey() : this._getAssociatedModelKey(t.getParent());
  }
  getAssociatedModelKey(t) {
    let e = this._assemblyTree.lookupAnyTreeNode(t);
    return e === null ? (e = this._assemblyTree.lookupAnyNonTreeNode(t), e === null ? null : this._getAssociatedModelKey(e)) : Ce(e).getMasterModelKey();
  }
  getMatrix(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    if (e === null)
      return new Q();
    const i = e.getLocalTransform();
    return i === null ? new Q() : Q.createFromArray(i);
  }
  async setMatrix(t, e, i) {
    const s = this._assemblyTree.lookupAnyTreeNode(t);
    if (s === null)
      return;
    i ? s.setLocalTransformAsInitial(e.m) : s.overrideLocalTransform(e.m);
    const r = ks(s);
    return ho(this._engine, this._callbackManager, [s], r);
  }
  setMatrices(t, e, i) {
    const s = [];
    let r = !1;
    for (let o = 0; o < t.length; o++) {
      const a = this._assemblyTree.lookupAnyTreeNode(t[o]), l = e[o];
      a !== null && (i ? a.setLocalTransformAsInitial(l.m) : a.overrideLocalTransform(l.m), r = r || ks(a), s.push(a));
    }
    return ho(this._engine, this._callbackManager, s, r);
  }
  async resetToInitialMatrix(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e !== null && e.hasLocalTransformOverride()) {
      e.removeLocalTransformOverride();
      const i = ks(e);
      return ho(this._engine, this._callbackManager, [e], i);
    }
  }
  getNetMatrix(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e === null ? Xi.getIdentity() : Bo(e);
  }
  _getBodyInstanceIndexFrom(t, e, i) {
    i === void 0 && (i = {});
    const s = t.getBodyInstances();
    for (const a of s)
      if (i.value !== void 0 ? i.value++ : i.value = 0, a === e)
        return i.value;
    let r;
    const o = t.getChildrenSync();
    for (const a of o)
      if (r = this._getBodyInstanceIndexFrom(a, e, i), r !== void 0)
        return r;
  }
  async getNodeOrRepItem(t) {
    if (t instanceof Ve) {
      const e = t.getParent();
      let i, s = e;
      for (; ; ) {
        if (!(s instanceof Yt))
          return null;
        await Ao(s);
        const a = await s.getPartDefinition();
        if (a !== null) {
          i = await a.value;
          break;
        }
        s = s.getParent();
      }
      const r = this._getBodyInstanceIndexFrom(s, t), o = i.getRepresentationItems();
      return r !== void 0 && r < o.length ? o[r] : null;
    } else if (t instanceof Yt || t instanceof gi || t instanceof Ni || t instanceof Ei || t instanceof Fe)
      return t;
    return null;
  }
  async _getNodeOrRepItemFromId(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e === null ? null : this.getNodeOrRepItem(e);
  }
  async getPointAttributes(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof Fe) {
      const s = i.getPointAttributes(e);
      if (s !== null)
        return s.copy();
    }
    return null;
  }
  async getEdgeCount(t) {
    const e = await this._getNodeOrRepItemFromId(t);
    return e instanceof Fe ? e.getEdgeCount() : 0;
  }
  async getEdgeAttributes(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof Fe) {
      const s = i.getEdgeAttributes(e);
      if (s !== null)
        return s.copy();
    }
    return null;
  }
  async getEdgeProperty(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof Fe) {
      const s = i.getEdgeMeasurementProperty(e);
      if (s !== null)
        return s.copy();
    }
    return null;
  }
  async getFaceCount(t) {
    const e = await this._getNodeOrRepItemFromId(t);
    return e instanceof Fe ? e.getFaceCount() : 0;
  }
  async getFaceAttributes(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof Fe) {
      const s = i.getFaceAttributes(e);
      if (s != null)
        return s.copy();
    }
    return null;
  }
  async getFaceProperty(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof Fe) {
      const s = i.getFaceMeasurementProperty(e);
      if (s !== null)
        return s.copy();
    }
    return null;
  }
  setEdgeProperty(t, e, i) {
    const s = this._assemblyTree.lookupRepresentationItem(t);
    s !== null && Ky(i) && s.setEdgeMeasurementProperty(e, i);
  }
  setFaceProperty(t, e, i) {
    const s = this._assemblyTree.lookupRepresentationItem(t);
    s !== null && Fy(i) && s.setFaceMeasurementProperty(e, i);
  }
  getName(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e !== null ? e.getName() : null;
  }
  getNodeExchangeId(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e !== null ? e.getExchangeId() : null;
  }
  getFilters() {
    return this._assemblyTree.getFilters();
  }
  getFilterName(t) {
    return this._assemblyTree.getFilterName(t);
  }
  getFiltersWithNode(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e === null ? [] : this._assemblyTree.getFiltersWithNode(e);
  }
  getNodesFromFilterIds(t) {
    return this._assemblyTree.getNodesFromFilterIds(t);
  }
  getLayers() {
    return this._assemblyTree.getLayers();
  }
  getUniqueLayerNames() {
    return this._assemblyTree.getUniqueLayerNames();
  }
  getLayerName(t) {
    return this._assemblyTree.getLayerName(t);
  }
  getLayerIdsFromName(t) {
    return this._assemblyTree.getLayersIdFromName(t);
  }
  getNodeLayerId(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e === null)
      return null;
    const i = e.getAuthoredLayerId();
    return i === null ? null : gn(e).getRuntimeLayerId(i);
  }
  getAuthoredNodesFromLayer(t, e) {
    const i = this._assemblyTree.getNodesFromLayer(t, e);
    return i === null ? null : i.map((s) => s.getAuthoredId());
  }
  getAuthoredNodesFromLayers(t, e) {
    const i = this._assemblyTree.getNodesFromLayers(t, e);
    return i === null ? null : i.map((s) => s.getAuthoredId());
  }
  getRuntimeNodesFromLayer(t, e) {
    const i = this._assemblyTree.getNodesFromLayer(t, e);
    return i === null ? null : i.map((s) => s.getRuntimeId());
  }
  getRuntimeNodesFromLayers(t, e) {
    const i = this._assemblyTree.getNodesFromLayers(t, e);
    return i === null ? null : i.map((s) => s.getRuntimeId());
  }
  getRuntimeNodesFromLayerName(t, e) {
    const i = this._assemblyTree.getNodesFromLayerName(t, e);
    return i === null ? null : i.map((s) => s.getRuntimeId());
  }
  createCadView(t, e, i, s, r, o, a, l, c) {
    if (this._assemblyTree.lookupProductOccurrence(t) === null)
      return null;
    const u = this._assemblyTree.lookupProductOccurrence(t);
    if (u === null)
      return null;
    const p = [];
    for (const _ of s) {
      const y = this._assemblyTree.lookupPmi(_);
      y !== null && p.push(y);
    }
    const m = /* @__PURE__ */ new Map();
    for (const [_, y] of a)
      m.set(_, y.m);
    return this._assemblyTree.createCadView(
      this._engine,
      u,
      e,
      i,
      p,
      r,
      o,
      m,
      l,
      c
    ).getRuntimeId();
  }
  getCadViewMap() {
    const t = this._assemblyTree.getFirstProductOccurrenceWithView(), e = /* @__PURE__ */ new Map();
    return this._assemblyTree.forEachCadView((i) => {
      const s = i.getRuntimeId(), r = i.getParent();
      let o;
      r === t ? o = i.getName() || "(null)" : o = `${r.getName()} - ${i.getName()}`, e.set(s, o);
    }), e;
  }
  async activateCadView(t, e, i) {
    if (this._assemblyTree.hasActiveCadView())
      return await this._assemblyTree.deactivateActiveCadView(), this.activateCadView(t, e, i);
    const s = this._assemblyTree.lookupCadView(t);
    if (s !== null)
      return this._assemblyTree.activateCadView(s, e, i);
  }
  getCadViewPmis(t) {
    const e = this._assemblyTree.lookupCadView(t);
    if (e === null)
      return [];
    const i = [], s = this._assemblyTree.getCadViewPmis(e);
    for (const r of s)
      i.push(r.getRuntimeId());
    return i;
  }
  async _disableCadConfigurations() {
    this._cadConfigurationsEnabled = !1, await this._assemblyTree.deactivateActiveCadView();
  }
  async cadConfigurationsEnabled() {
    return this._cadConfigurationsEnabled && this._assemblyTree.seenExternalModel() && await this._disableCadConfigurations(), this._cadConfigurationsEnabled;
  }
  getCadConfigurations() {
    const t = {};
    return this._assemblyTree.forEachCadConfiguration((e) => {
      const i = e.getRuntimeId(), s = e.getName() || "(null)";
      t[i] = s;
    }), t;
  }
  getDefaultCadConfiguration() {
    const t = this._assemblyTree.getDefaultCadConfiguration();
    return t !== null ? t.getRuntimeId() : null;
  }
  getActiveCadConfiguration() {
    const t = this._assemblyTree.getActiveCadConfiguration();
    return t !== null ? t.getRuntimeId() : null;
  }
  getCadViewConfiguration(t) {
    const e = this._assemblyTree.lookupCadView(t);
    if (e === null)
      return null;
    const i = e.getParent();
    return i !== null && i.isAConfigurationNode() ? i.getRuntimeId() : null;
  }
  async _activateCadConfiguration(t, e) {
    this._assemblyTree.activateCadConfiguration(t);
    const i = t.getRuntimeId(), s = this._assemblyTree.getCadConfigurations().filter((l) => l !== t).map((l) => l.getRuntimeId()), r = /* @__PURE__ */ new Map();
    r.set(i, !0), s.forEach((l) => {
      r.set(l, !1);
    }), await this.setVisibilitiesByMap(r);
    const o = await Fd(t, bt.All, !0, /* @__PURE__ */ new Set());
    e && o !== null && o.length > 0 && await this._view.fitNodes([i], Ri), this._callbackManager.trigger("configurationActivated", i);
  }
  async activateCadConfiguration(t, e) {
    const i = this._assemblyTree.lookupProductOccurrence(t);
    if (i !== null)
      return this._activateCadConfiguration(i, e);
  }
  async activateDefaultCadConfiguration(t) {
    const e = this._assemblyTree.getDefaultCadConfiguration();
    e !== null && await this._activateCadConfiguration(e, t);
  }
  getDefaultCadView() {
    const t = this._assemblyTree.getDefaultCadConfiguration(), e = this._assemblyTree.getDefaultCadView(t);
    return e !== null ? e.getRuntimeId() : null;
  }
  async activateDefaultCadView(t, e) {
    const i = this.getDefaultCadView();
    i !== null && await this.activateCadView(i, t, e);
  }
  getPmis() {
    const t = {};
    return this._assemblyTree.forEachPmi((e) => {
      const i = e.getRuntimeId(), s = e.getName() || "(null)";
      t[i] = s;
    }), t;
  }
  getPmiType(t) {
    const e = this._assemblyTree.lookupPmi(t);
    return e === null ? Ud.Unknown : e.getPmiType();
  }
  getPmiSubType(t) {
    const e = this._assemblyTree.lookupPmi(t);
    return e === null ? Qd.Unknown : e.getPmiSubType();
  }
  getUnit(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e instanceof Yt ? e.getMeasurementUnit() : e instanceof Ve ? e.getParent().getMeasurementUnit() : 1;
  }
  _rectifyParent(t, e) {
    if (e !== null) {
      const s = this._assemblyTree.lookupProductOccurrence(e);
      if (s !== null)
        return s;
      console.assert(!1);
    }
    const i = this._assemblyTree.getInclusionContexts(t);
    if (i.length > 0) {
      const r = i[0].getChildren();
      return console.assert(r.length > 0), r[0];
    }
    return this._assemblyTree.getRootNode();
  }
  createMeshInstance(t, e, i, s, r, o, a) {
    const l = this._rectifyParent(t, s);
    return this._assemblyTree.createMeshInstance(
      !0,
      // mark loaded
      t,
      e,
      null,
      // authored id
      i,
      l,
      r,
      o,
      !0,
      // initially visible
      a
    ).getRuntimeId();
  }
  createPmiInstance(t, e, i, s, r, o, a) {
    const l = this._rectifyParent(t, a);
    return this._assemblyTree.createPmiInstance(
      t,
      e,
      null,
      o,
      l,
      i,
      s,
      r
    ).getRuntimeId();
  }
  setVisibilitiesByMap(t, e) {
    const i = /* @__PURE__ */ new Map();
    t.forEach((a, l) => {
      const c = this._assemblyTree.lookupAnyTreeNode(l);
      c !== null && i.set(c, a);
    });
    let s = null;
    const r = this.getActiveCadConfiguration();
    r !== null && (s = this._assemblyTree.lookupProductOccurrence(r));
    const o = this._assemblyTree.getRootNode();
    return xc({
      assemblyTree: this._assemblyTree,
      engine: this._engine,
      startNode: o,
      visibilityFormatter: (a) => i.get(a),
      resetNonAffectedToDefault: !1,
      configurationNode: s !== null ? s : void 0,
      callbackManager: this._callbackManager,
      initiallyHiddenStayHidden: e
    });
  }
  setBodyNodesVisibility(t, e) {
    const i = typeof e == "boolean" ? (s) => e : e;
    return ff({
      assemblyTree: this._assemblyTree,
      engine: this._engine,
      startNode: t,
      visibilityFormatter: i,
      resetNonAffectedToDefault: !1,
      callbackManager: this._callbackManager,
      initiallyHiddenStayHidden: !1
    });
  }
  setVisibilitiesByValue(t, e, i) {
    const s = /* @__PURE__ */ new Map();
    for (const r of t)
      s.set(r, e);
    return this.setVisibilitiesByMap(
      s,
      i !== null ? i : void 0
    );
  }
  resetAllVisibilities() {
    const t = this._assemblyTree.getRootNode(), e = this._assemblyTree.getActiveCadConfiguration();
    return xc({
      assemblyTree: this._assemblyTree,
      engine: this._engine,
      startNode: t,
      visibilityFormatter: () => {
      },
      resetNonAffectedToDefault: !0,
      configurationNode: e !== null ? e : void 0,
      callbackManager: this._callbackManager
    });
  }
  async resetAllTransforms() {
    const t = this._assemblyTree.getRootNode();
    if (await Ly(t))
      return ho(this._engine, this._callbackManager, [t], !1);
  }
  async reset() {
    if (this._cadConfigurationsEnabled = !0, this.isACadDrawing())
      return this._callbackManager.promiseTrigger("_resetDrawing", null);
    this._assemblyTree.hasActiveCadView() && await this._assemblyTree.deactivateActiveCadView();
    const t = [this.resetAllVisibilities(), this.resetAllTransforms()];
    await zt(t);
  }
  setPmiColor(t, e) {
    e === void 0 && (e = this.getAbsoluteRootNodeId());
    const i = this.getInstanceIncs(
      e,
      bt.PmiBody | bt.ViewFrame
    );
    i.length > 0 && (this._engine.setPartColor(i, vt.Faces, t), this._engine.setPartColor(i, vt.Lines, t));
  }
  resetPmiColor(t) {
    t === void 0 && (t = this.getAbsoluteRootNodeId());
    const e = this.getInstanceIncs(
      t,
      bt.PmiBody | bt.ViewFrame
    );
    e.length > 0 && (this._engine.unsetPartColor(e, vt.Faces), this._engine.unsetPartColor(e, vt.Lines));
  }
  getPmiTopologyReferences(t) {
    const e = this._assemblyTree.lookupPmi(t);
    return e === null ? null : e.getPmiTopologyReferences(this._assemblyTree);
  }
  createNode(t, e, i, s = null, r = !0, o = null) {
    let a = null;
    t !== null && (a = this._assemblyTree.lookupProductOccurrence(t)), a === null && (a = this._assemblyTree.getRootNode()), i !== null && !Hr(i) && (i = null);
    const l = (() => {
      if (o) {
        const u = o / a.getMeasurementUnit(), p = new Q().setScaleComponent(u, u, u);
        return s ? Q.multiply(s, p) : p;
      } else
        return s;
    })(), c = l === null ? null : l.m;
    return this._assemblyTree.createNode(
      a,
      e,
      i,
      c,
      r,
      o
    ).getRuntimeId();
  }
  async deleteNode(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e !== null) {
      if (e instanceof Yt || e instanceof Ve || e instanceof gi)
        return this._assemblyTree.deleteNode(e);
      throw new Gi(
        t,
        li.ProductOccurrence,
        li.BodyInstance
      );
    }
  }
  createPart(t) {
    return this._assemblyTree.createPart(t).getRuntimeId();
  }
  setPart(t, e) {
    const i = this._assemblyTree.lookupProductOccurrence(t);
    if (i === null)
      return !1;
    const s = this._assemblyTree.lookupPartDefinition(e);
    return s === null ? !1 : (this._assemblyTree.setPart(i, s), !0);
  }
  createAndAddRepItem(t, e) {
    const i = this._assemblyTree.lookupPartDefinition(t);
    return i === null ? null : i.createRepItem(this._assemblyTree, e).getRuntimeId();
  }
  getLowestAvailableNodeId() {
    return this._assemblyTree.getLowestAvailableNodeId();
  }
  getType(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e === null ? At.Unknown : Lf(e);
  }
  isVisible(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e !== null ? e.isVisible() : !1;
  }
  getBranchVisibility(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? Rf(e) : Pt.Hidden;
  }
  setMeshLevel(t, e) {
    const i = [];
    for (const s of t) {
      const r = this._assemblyTree.lookupAnyTreeNode(s);
      r !== null && i.push(r);
    }
    return Xy(this._engine, i, e);
  }
  setEnableAutomaticUnitScaling(t) {
    this._assemblyTree.setAutomaticMeasurementUnitScaling(t);
  }
  setBehaviorInitiallyHidden(t) {
    this._assemblyTree.setInitiallyHiddenStayHidden(t);
  }
  isACadDrawing() {
    return this._assemblyTree.containsDrawings();
  }
  isMeasurable() {
    return this._assemblyTree.isMeasurable();
  }
  async isLineMeasurable(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    return i instanceof Fe ? i.getEdgeMeasurementProperty(e) !== null : !1;
  }
  async isFaceMeasurable(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    return i instanceof Fe ? i.getFaceMeasurementProperty(e) !== null : !1;
  }
  getModelFileNameFromNode(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? Ce(e).getOriginalFileName() : null;
  }
  getModelFileTypeFromNode(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? Ce(e).getOriginalFileType() : null;
  }
  isAnnotationView(t) {
    const e = this._assemblyTree.lookupCadView(t);
    if (e !== null)
      return e.isAnnotationView();
    throw new Gi(t, li.CadView);
  }
  isCombineStateView(t) {
    const e = this._assemblyTree.lookupCadView(t);
    if (e)
      return e.isCombineStateView();
    throw new Gi(t, li.CadView);
  }
  /** This will undo the effect of calling preventNodeDeletion() for the given node. */
  allowNodeDeletion(t) {
    const e = this._assemblyTree.lookupBodyInstance(t);
    if (e === null)
      throw new re();
    this._assemblyTree.allowNodeDeletion(e);
  }
  preventNodeDeletion(t) {
    const e = this._assemblyTree.lookupBodyInstance(t);
    if (e === null)
      throw new re();
    this._assemblyTree.preventNodeDeletion(e);
  }
  preventMeshDeletion(t) {
    this._assemblyTree.preventMeshDeletion(t);
  }
  getBounding(t, e, i, s) {
    return Od(
      this._assemblyTree,
      this._engine,
      t,
      e,
      i,
      s
    );
  }
  getIdOffset(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    if (e !== null) {
      let i;
      return e instanceof Ei ? i = e.getInclusionContextForNodeId() : e instanceof Fe ? i = e.getParent().getInclusionContextForNodeId() : i = Ne(e), i.getIdOffset();
    }
    return 0;
  }
  /**
   * Motivation for this function:
   *
   * It is possible to begin a load where some SC geometry gets streamed in
   * but the assembly tree has not been fully parsed. Suppose an SC instance
   * (A) gets streamed, and has its node parsed by the assembly tree. If the
   * user attempts to select (A), our internals will find the NodeId associated
   * with (A). This is so far okay (but not ideal perhaps). The big issue comes
   * when the user starts to query the parents or children of the node. Since
   * the entire loaded subtree has not been fully parsed, querying such things
   * may not make sense because they might not be available. (Querying other
   * things might also be problematic.)
   *
   * It might make sense to not expose this function publically (as it is today
   * in `Model`) and do all the required filtering of selection results in the
   * selection internals. This, however might be 'problematic' when loading a
   * giant model (such as the Boeing). In this case, it might take ages for the
   * tree to completely load, which would make geometry not selectable in the
   * meantime. This might be interpreted as a bug from our users because they might
   * want to highlight such selected geometries.
   *
   * Related: COM-1169
   */
  isNodeLoaded(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    if (e === null)
      throw new sn(t);
    return e.isLoaded();
  }
  shutdown() {
    this._treeLoader && this._treeLoader.cancelPendingLoads();
  }
  isReady() {
    return console.assert(this._readyPromise.state !== ds.Rejected), this._readyPromise.state !== ds.Pending;
  }
  waitForReady() {
    return this._readyPromise;
  }
  lookupAnyTreeNode(t) {
    return this._assemblyTree.lookupAnyTreeNode(t);
  }
  lookupAnyBody(t) {
    return this._assemblyTree.lookupAnyBody(t);
  }
  lookupBodyInstance(t) {
    return this._assemblyTree.lookupBodyInstance(t);
  }
  gatherInstanceIncsFromNodeIds(t, e, i) {
    return Kd(this._assemblyTree, t, e, i);
  }
  gatherInclusionKeysFromNodeIds(t) {
    return Ry(this._assemblyTree, t, ft.None);
  }
  async requestNodes(t) {
    const e = [];
    for (const i of t) {
      const s = this._assemblyTree.lookupAnyTreeNode(i);
      s !== null && e.push(s);
    }
    return this._assemblyTree.requestNodes(this._treeLoader, e, !1);
  }
  isWithinExternalModel(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e === null)
      return !1;
    let i = Pn(e);
    for (; i !== null; ) {
      if (i.isExternalModelRoot())
        return !0;
      i = Pn(i.getParent());
    }
    return !1;
  }
  getNodeGenericType(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? jo(e) : null;
  }
  getNodeGenericId(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? e.getGenericId() : null;
  }
  getNodesByGenericId(t) {
    const e = this._assemblyTree.getNodesByGenericId(t);
    if (e !== null) {
      const i = /* @__PURE__ */ new Set();
      return e.forEach((s) => {
        i.add(s.getRuntimeId());
      }), i;
    }
    return null;
  }
  getNodesByGenericType(t) {
    const e = this._assemblyTree.getNodesByGenericType(t);
    if (e !== null) {
      const i = /* @__PURE__ */ new Set();
      return e.forEach((s) => {
        i.add(s.getRuntimeId());
      }), i;
    }
    return null;
  }
  getGenericTypes() {
    const t = [];
    return this._assemblyTree.genericTypeToNodes().forEach((i, s) => {
      t.push(s);
    }), t;
  }
  getGenericTypeIdMap() {
    const t = /* @__PURE__ */ new Map();
    return this._assemblyTree.genericTypeToNodes().forEach((i, s) => {
      const r = /* @__PURE__ */ new Set();
      i.forEach((o) => {
        r.add(o.getRuntimeId());
      }), t.set(s, r);
    }), t;
  }
  hasEffectiveGenericType(t, e) {
    const i = this.lookupAnyTreeNode(t);
    if (i === null)
      throw new sn(t);
    return qf(i, e);
  }
  registerGenericId(t, e) {
    return this._assemblyTree.registerGenericGlobalId(t, e);
  }
  registerGenericType(t, e) {
    return this._assemblyTree.registerGenericType(t, e);
  }
  hasRelationships(t) {
    const e = this.lookupAnyTreeNode(t);
    if (e === null)
      throw new sn(t);
    return Ne(e).getRelationships().length > 0;
  }
  getBimIdFromNode(t) {
    const e = this.lookupAnyTreeNode(t);
    return e === null || !e.hasAuthoredId() ? null : e.getAuthoredId().toString();
  }
  getRuntimeNodeFromBimId(t, e) {
    const i = this.lookupAnyTreeNode(t);
    return i === null ? null : Ne(i).getRuntimeNodeFromBimId(e);
  }
  getRelationsByTypeFromNode(t, e) {
    return this._assemblyTree.getRelationshipsOfItem(t, e);
  }
  firstAssemblyDataHeader() {
    return this._treeLoader.firstAssemblyDataHeader();
  }
  setPrefetchScsCutoffScale(t) {
    this._treeLoader.setPrefetchScsCutoffScale(t);
  }
  getAllRelationships(t) {
    const e = this.lookupAnyTreeNode(t);
    return e === null ? [] : Ne(e).getRelationships();
  }
  getAllBimInfos(t) {
    const e = this.lookupAnyTreeNode(t);
    return e === null ? [] : Ne(e).getBimInfos();
  }
  getInfoOfBimId(t, e) {
    const i = this.getAllBimInfos(t);
    for (const s of i)
      if (s.id === e) {
        let r = s.name, o = !1;
        if (s.category === Vs.Connected) {
          const a = this.getRuntimeNodeFromBimId(t, e);
          a !== null && this.getName(a) !== null && (r = this.getName(a), o = !0);
        }
        return { name: r, connected: o };
      }
    return { name: "", connected: !1 };
  }
  indexOfBimInfo(t, e) {
    let i = 0;
    for (const s of t) {
      if (e === s.type)
        return i;
      i++;
    }
    return -1;
  }
  getBimIdRelationshipTypes(t, e) {
    const i = [], s = this.lookupAnyTreeNode(t);
    if (s === null)
      return [];
    const o = Ne(s).getRelationships();
    for (const a of o)
      if (a.relating !== null && a.relating.relationElt.id === e) {
        const l = this.indexOfBimInfo(i, a.type);
        if (l < 0) {
          const c = [];
          if (a.related !== null)
            for (const h of a.related.relationships)
              c.push(h.id);
          i.push({
            type: a.type,
            relateds: c,
            relatings: []
          });
        } else if (a.related !== null)
          for (const c of a.related.relationships)
            i[l].relateds.indexOf(c.id) < 0 && i[l].relateds.push(c.id);
      } else if (a.related !== null) {
        for (const l of a.related.relationships)
          if (l.id === e) {
            const c = this.indexOfBimInfo(i, a.type);
            a.relating !== null && (c < 0 ? i.push({
              type: a.type,
              relateds: [],
              relatings: [a.relating.relationElt.id]
            }) : i[c].relatings.push(a.relating.relationElt.id));
          }
      }
    return i;
  }
}
class Oy {
  constructor(t) {
    this._engine = t;
  }
  getIdentityInc() {
    return this._identityInc;
  }
  // SC does not guarante an identity matrix to be created on the client
  // XXX: We should probably just reserve Matrix Inc (0, 1) for an eternal identity matrix in SC C++ code.
  async init() {
    const t = await this._engine.createIdentityMatrix();
    this._identityInc = t;
  }
}
function Ay(n, t) {
  const e = [];
  for (let i = 0; i < n.length; i += t)
    e.push(n.slice(i, i + t));
  return e;
}
function hc(n, t, e) {
  if (n.selectionMask === Xt.None)
    throw new Mt("selectionMask is None");
  return {
    ...n,
    cullSuboptimalEntities: t,
    enableOcclusionChecks: t,
    restrictLinesAndPointsToSelectedFaceInstances: e ? !1 : n.restrictLinesAndPointsToSelectedFaceInstances
  };
}
function Dy(n) {
  let t = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, i = null;
  for (const s of n)
    if (s.length > 0) {
      const r = s[0];
      r.radialMetric < t ? (t = r.radialMetric, e = r.zMetric, i = s) : r.radialMetric === t && r.zMetric < e && (e = r.zMetric, i = s);
    }
  return i;
}
function zy(n, t, e, i) {
  const s = t !== null ? t.entities : [], r = e !== null ? e.entities : [], o = i !== null ? i.entities : [], a = [s, r, o];
  for (; ; ) {
    const l = Dy(a);
    if (l === null) {
      console.assert(s.length === 0), console.assert(r.length === 0), console.assert(o.length === 0);
      return;
    }
    console.assert(l.length > 0);
    let c;
    if (l === s) {
      const h = s.pop();
      c = Oh(h);
    } else if (l === r) {
      const h = r.pop();
      c = Ah(h);
    } else {
      console.assert(l === o);
      const h = o.pop();
      c = Br(h, !0);
    }
    n.push(c);
  }
}
function Br(n, t) {
  const e = d.createFromArray(n.rayPoint), i = d.createFromArray(n.normal), s = new d(n.bounding.min[0], n.bounding.min[1], n.bounding.min[2]), r = new d(n.bounding.max[0], n.bounding.max[1], n.bounding.max[2]), o = new ni(s, r), a = new pa(
    e,
    i,
    n.elementIndex,
    n.overlayIndex,
    n.elementBits,
    o,
    t
  ), l = n.instanceInc;
  return de.create(l[1], l[0], a, null, null);
}
function Oh(n) {
  const t = new d(n.bounding.min[0], n.bounding.min[1], n.bounding.min[2]), e = new d(n.bounding.max[0], n.bounding.max[1], n.bounding.max[2]), i = new ni(t, e), s = new ga(
    n.elementIndex,
    d.createFromArray(n.point),
    n.lineSegmentVertices,
    n.bestLineSegmentVertexIndex,
    i,
    n.overlayIndex,
    n.elementBits
  ), r = n.instanceInc;
  return de.create(r[1], r[0], null, s, null);
}
function Ah(n) {
  const t = new fa(
    d.createFromArray(n.point),
    n.elementIndex,
    n.overlayIndex,
    n.elementBits
  ), e = n.instanceInc;
  return de.create(e[1], e[0], null, null, t);
}
function vu(n) {
  if (n.point !== null) {
    const t = n.point.entities[0];
    return Ah(t);
  }
  if (n.line !== null) {
    const t = n.line.entities[0];
    return Oh(t);
  }
  if (n.face !== null) {
    const t = n.face.entities[0];
    return Br(t, !1);
  }
  if (n.proximityFace !== null) {
    const t = n.proximityFace.entities[0];
    return Br(t, !0);
  }
  return null;
}
function xu(n) {
  let t = null;
  if (n.face !== null) {
    const s = n.face.entities[0];
    t = Br(s, !1);
  } else if (n.proximityFace !== null) {
    const s = n.proximityFace.entities[0];
    t = Br(s, !0);
  }
  let e = null;
  if (n.line !== null) {
    const s = n.line.entities[0];
    e = Oh(s);
  }
  let i = null;
  if (n.point !== null) {
    const s = n.point.entities[0];
    i = Ah(s);
  }
  return new dl(t, e, i);
}
function Su(n) {
  const t = [];
  if (n.face !== null)
    for (const e of n.face.entities) {
      const i = Br(e, !1);
      t.push(i);
    }
  return zy(t, n.line, n.point, n.proximityFace), t;
}
class Jy {
  constructor(t) {
    this._pickTolerance = 20, this._incrementalChunkedItems = /* @__PURE__ */ new Map(), this._sc = t;
  }
  setPickTolerance(t) {
    this._pickTolerance = t;
  }
  getPickTolerance() {
    return this._pickTolerance;
  }
  async beginScreenAreaSelection(t, e, i) {
    const s = i;
    let r;
    try {
      r = await this._sc.beginScreenAreaSelection(
        t.x,
        t.y,
        e.x,
        e.y,
        s
      );
    } catch (o) {
      throw qs(o) && o.scFunction === "beginScreenAreaSelection" ? new as() : o;
    }
    return new yo(r);
  }
  async beginRayDrillSelection(t, e, i) {
    const s = i;
    let r;
    try {
      r = await this._sc.beginRayDrillSelection(
        t.x,
        t.y,
        e,
        s
      );
    } catch (o) {
      throw qs(o) && o.scFunction === "beginRayDrillSelection" ? new as() : o;
    }
    return new yo(r);
  }
  async beginConvexPolyhedronSelection(t, e, i) {
    const s = i, r = [];
    for (const l of t)
      r.push(l.getCoefficients());
    const o = [e.x, e.y, e.z];
    let a;
    try {
      a = await this._sc.beginConvexPolyhedronSelection(r, o, s);
    } catch (l) {
      throw qs(l) && l.scFunction === "beginConvexPolyhedronSelection" ? new as() : l;
    }
    return new yo(a);
  }
  async beginSphereSelection(t, e, i) {
    const s = i;
    let r;
    try {
      r = await this._sc.beginSphereSelection(t, e, s);
    } catch (o) {
      throw qs(o) && o.scFunction === "beginSphereSelection" ? new as() : o;
    }
    return new yo(r);
  }
  endIncrementalSelection(t) {
    this._incrementalChunkedItems.delete(t._handle), this._sc.endVolumeSelection(t._handle);
  }
  async advanceIncrementalSelection(t, e) {
    const i = this._incrementalChunkedItems.get(t._handle);
    if (i && i.length !== 0)
      return i.pop();
    let s;
    try {
      s = await this._sc.advanceVolumeSelection(
        t._handle,
        5e3
        /* Batch */
      );
    } catch (a) {
      throw qs(a) && a.scFunction === "advanceVolumeSelection" ? new as() : a;
    }
    if (s.length === 2 && s[1] === lh.Invalid)
      return e ? (await this._sc.setStreamIdleMarker(), this.advanceIncrementalSelection(t, !1)) : null;
    const r = [];
    for (let a = 0; a < s.length; a += 2) {
      const l = s[a], c = s[a + 1];
      r.push(de.create(c, l));
    }
    if (r.length <= 500)
      return r;
    const o = Ay(
      r,
      500
      /* Chunk */
    ).reverse();
    return this._incrementalChunkedItems.set(t._handle, o), o.pop();
  }
  async _screenSelectByRay(t, e, i, s) {
    const r = hc(e, i, s), o = e.selectionMask, l = e.selectionMask !== Xt.Face || e.enableProximityFaces ? this._pickTolerance : -1;
    return this._sc.screenSelectByRay(o, t.x, t.y, l, r);
  }
  async _worldSelectByRay(t, e, i) {
    const s = hc(e, i, !1), r = sl(t);
    return this._sc.worldSelectByRay(r, s);
  }
  async pickFromScreen(t, e, i) {
    const s = await this._screenSelectByRay(t, e, !0, i);
    return vu(s);
  }
  async pickAllFromScreen(t, e, i) {
    const s = await this._screenSelectByRay(t, e, !1, i);
    return Su(s);
  }
  async compositePickFromScreen(t, e, i) {
    const s = await this._screenSelectByRay(t, e, !0, i);
    return xu(s);
  }
  async pickFromRay(t, e) {
    const i = await this._worldSelectByRay(t, e, !0);
    return vu(i);
  }
  async pickAllFromRay(t, e) {
    const i = await this._worldSelectByRay(t, e, !1);
    return Su(i);
  }
  async pickCompositeFromRay(t, e) {
    const i = hc(e, !0, !1), s = sl(t), r = await this._sc.worldSelectByRay(s, i);
    return xu(r);
  }
}
class By extends _s {
  constructor(t) {
    super(), this._position = new E(10, 10), this._nextItemPosition = E.zero(), this._statItemOffset = new E(5, 5), this._maxStatWidth = 0, this._viewer = t, this._backgroundPanel = new Kl(this._position, new E(300, 100)), this._backgroundPanel.setFillColor(it.white()), this._backgroundPanel.setStrokeWidth(0), this._statsText = new vm();
  }
  draw() {
    this._updateBackgroundSize();
    const t = this._viewer.markupManager.getRenderer();
    t.drawRectangle(this._backgroundPanel), t.drawTexts(this._statsText);
  }
  clearStatsText() {
    this._statsText.clear(), this._nextItemPosition.assign(this._position);
  }
  setPosition(t) {
    this._position.assign(t), this._backgroundPanel.setPosition(this._position);
  }
  addStatistic(t, e) {
    const i = E.add(this._nextItemPosition, this._statItemOffset), s = `${t}: ${e}`;
    this._statsText.addString(s, i), this._nextItemPosition.y += this._statsText.getFontSize();
  }
  _updateBackgroundSize() {
    const t = this._viewer.markupManager.getRenderer(), e = this._statsText.getStrings(), i = this._statsText.getFontSize();
    for (const o of e) {
      const a = t.measureText(o.text, this._statsText);
      this._maxStatWidth = Math.max(this._maxStatWidth, a.x);
    }
    const s = 2 * this._statItemOffset.x + this._maxStatWidth, r = e.length * (i + this._statItemOffset.y);
    this._backgroundPanel.setSize(new E(s, r));
  }
}
class Ip {
  constructor() {
    this.total_element_count = 0, this.total_triangle_count = 0;
  }
}
class jy {
  constructor(t, e) {
    this._statisticsDisplayHandle = null, this._statistics = new Ip(), this._viewer = e, this._callbackManager = t, this._callbackManager.bind({
      frameDrawn: async () => {
        await this.update();
      }
    }), this._statisticsDisplay = new By(this._viewer);
  }
  async update() {
    const t = await this._viewer.getStatistics();
    this._statistics = t, this._statisticsDisplay.clearStatsText();
    const e = Object.keys(this._statistics);
    for (const i of e) {
      const s = i, r = this._statistics[s];
      this._statisticsDisplay.addStatistic(s, r.toString());
    }
  }
  isShown() {
    return this._statisticsDisplayHandle !== null;
  }
  getStatistics() {
    return this._statistics;
  }
  async showDisplay() {
    this.isShown() || (await this.update(), this._statisticsDisplayHandle = this._viewer.markupManager.registerMarkup(
      this._statisticsDisplay
    ));
  }
  hideDisplay() {
    this.isShown() && (this._viewer.markupManager.unregisterMarkup(this._statisticsDisplayHandle), this._statisticsDisplayHandle = null);
  }
}
class Hy {
  constructor(t, e) {
    this._engineReadyPromise = ye(), this._sessionStartedPromise = ye(), this._connectionlessEmpty = !1, this._uri = "ws://localhost:9999", this._streamingMode = Ps.Default, this._rendererType = Ho.Client, this._meshLevel = 0, this._memoryLimit = 0, this._boundingPreviewMode = vs.All, this._streamCutoffScale = 1, this._loadFinished = !1, this._statistics = new Ip(), this._cachedTriangleCount = null, this._cachedElementCount = null, this._windowSize = new E(0, 0), this._cuttingSectionToKeyMap = /* @__PURE__ */ new Map(), this._cappingQuantizationGranularity = -1e4, this._cappingFaceColor = it.createFromFloat(0.5, 0.5, 0.5), this._cappingLineColor = it.createFromFloat(0.5, 0.5, 0.5), this._cappingGeometryVisibility = !0, this._cappingNeedsUpdate = !0, this._cappingDelayTimeoutId = null, this._cappingDelay = 500, this._requestBatchCountByType = [], this._pendingRequestsByType = [], this._callbackManager = t, this._applyOptions(e);
    for (let i = 0; i < co.Count; ++i)
      this._requestBatchCountByType.push(0), this._pendingRequestsByType.push([]);
  }
  getNetworkModelName() {
    if (console.assert(this._sessionType === Ke.Network), this._model !== void 0)
      return this._model;
    throw new re();
  }
  // Method inherited from AbstractScEngine.  Mainly used as an avenue for the AssemblyTree to log messages for debugging purposes.
  logMessage(t) {
    console.log(t);
  }
  // Method inherited from AbstractScEngine.  Used to abstract the setTimeout method as this method is not available in pure non browser based javascript environments, i.e. v8, JsCore.
  setTimeout(t, e) {
    return setTimeout(t, e);
  }
  // Method inherited from AbstractScEngine. The default Communicator implementation of this method makes use of setTimeout (see above).
  sleep(t) {
    return Nl(t);
  }
  getScsInfo() {
    return console.assert(this._sessionType === Ke.Scs), this._buffer !== void 0 ? this._buffer : /^wss?:\/\//i.test(this._uri) ? null : this._uri;
  }
  _applyOptions(t) {
    t.empty !== void 0 && (this._connectionlessEmpty = t.empty), t.endpointUri !== void 0 && (this._uri = t.endpointUri), t.model && (this._model = t.model), t.sessionToken !== void 0 && (this._sessionToken = t.sessionToken), t.buffer !== void 0 && (this._buffer = t.buffer), t.streamingMode !== void 0 && (this._streamingMode = t.streamingMode), t.rendererType !== void 0 && (this._rendererType = t.rendererType), t.defaultMeshLevel !== void 0 && (this._meshLevel = t.defaultMeshLevel), t.memoryLimit !== void 0 && (this._memoryLimit = t.memoryLimit), t.boundingPreviewMode !== void 0 && (this._boundingPreviewMode = t.boundingPreviewMode), t.streamCutoffScale !== void 0 && this._setStreamCutoffScale(t.streamCutoffScale);
  }
  start(t, e) {
    return this._canvasContainer = t, this._initOptions = e, Ro.createInstance({
      container: t,
      onReady: (i) => {
        this._onEngineReady(i);
      },
      onError: (i) => {
        this._callbackManager.trigger(
          "modelLoadFailure",
          this._model || "",
          `failed to load engine: ${i}`
        );
      },
      enginePath: e.enginePath
    }), !0;
  }
  setPickTolerance(t) {
    this._scSelectionManager.setPickTolerance(t);
  }
  getPickTolerance() {
    return this._scSelectionManager.getPickTolerance();
  }
  _onEngineReady(t) {
    this._sc = t, this._sessionType = Ke.Uninitialized, this._matrixCache = new Oy(this), this._scSelectionManager = new Jy(this._sc), this.resize(), this._callbackManager.bind({
      _firstBoundingReady: async () => {
        this._regenerateCapping();
      }
    }), this._sc.setEventHandler("session_started", () => {
      const e = () => (this._callbackManager.unbind(i), this._sessionStartedPromise), i = {
        _sessionStarted: () => this._onSessionStarted(),
        _assemblyTreeReady: e,
        _modelSwitched: e
      };
      this._callbackManager.bind(i), this._sessionStartedPromise.resolve(
        this._callbackManager.promiseTrigger("_sessionStarted", null)
      );
    }), this._sc.setEventHandler(
      "announce_model",
      (e, i, s) => {
        this._callbackManager.trigger("_announceModel", i, s);
      }
    ), this._sc.setEventHandler("first_instance", () => {
      this._callbackManager.trigger("_firstInstance");
    }), this._sc.setEventHandler(
      "inclusion",
      (e, i, s, r) => {
        this._callbackManager.trigger("_inclusion", i, s, r);
      }
    ), this._sc.setEventHandler(
      "remap_model",
      (e, i, s, r) => {
        this._callbackManager.trigger(
          "_remapModel",
          i,
          s,
          r
        );
      }
    ), this._sc.setEventHandler(
      "remap_inclusion",
      (e, i, s, r, o) => {
        this._callbackManager.trigger(
          "_remapInclusion",
          i,
          s,
          r,
          o
        );
      }
    ), this._sc.setEventHandler(
      "capping_idle",
      (e, i, s) => {
        this._callbackManager.trigger("cappingIdle", i, s);
      }
    ), this._sc.setEventHandler("stream_active", this._initOptions.streamingActivated), this._sc.setEventHandler("stream_idle", this._initOptions.streamingDeactivated), this._sc.setEventHandler("open_model_failed", (e, i) => {
      let s;
      switch (i.reason) {
        case "UNKNOWN_MODEL":
          s = "Unknown model";
          break;
        case "BAD_NETWORK_VERSION":
          s = "Client/Server network version mismatch";
          break;
        case "BAD_STREAM_VERSION":
        case "BAD_STORE_VERSION":
          s = "Unsupported file version";
          break;
        default:
          s = "Internal Error";
      }
      this._callbackManager.trigger("modelLoadFailure", this._model || "", s);
    }), this._sc.setEventHandler(
      "missing_model",
      (e, i, s) => {
        this._callbackManager.trigger("_missingModel", i, s), this._callbackManager.trigger("missingModel", s);
      }
    ), this._sc.setEventHandler("bad_data", (e, i) => {
      let s;
      switch (i.type) {
        case "TRUNCATED_BLOCK":
          s = "Failed to parse truncated data block.";
          break;
        case "ZFRAME_DECOMPRESS_FAILED":
          s = "Failed to decompress data.";
          break;
        case "UNMATCHED_CODE":
          s = "Unknown opcode.";
          break;
        case "STORE_VERSION_MISMATCHED":
          s = "Store version mismatched.", s += ` Expected='${i.expected}'.`, s += ` Actual='${i.actual}'.`;
          break;
        case "STREAM_VERSION_MISMATCHED":
          s = "Stream version mismatched.", s += ` Expected='${i.expected}'.`, s += ` Actual='${i.actual}'.`;
          break;
        case "PARSE_BOUNDING_TREE_FAILED":
          s = "Failed to parse bounding ";
          break;
        default:
          s = "Unknown error.";
      }
      this._callbackManager.trigger("modelLoadFailure", this._model || "", s);
    }), this._sc.setEventHandler("socket_open_failed", () => {
      this._callbackManager.trigger(
        "modelLoadFailure",
        this._model || "",
        "WebSocket connection failed."
      );
    }), this._sc.setEventHandler(
      "post_draw",
      (e, i, s, r) => {
        this._syncedCamera = s, this._statistics = i, this._initOptions.renderComplete(), this._fillStatTotalCounts();
        const o = this._fromScCamera(s);
        this._callbackManager.trigger("frameDrawn", o, r);
      }
    ), this._sc.setEventHandler(
      "priority_meta_data_sent",
      (e, i, s) => {
        this._initOptions.priorityMetaDataSent(i, s);
      }
    ), this.setAllowHighDpi(!0), this._sc.setEventHandler(
      "meta_data",
      (e, i, s, r) => {
        i < 0 && (i += 4294967296), this._callbackManager.trigger("_metaData", i, s, r);
      }
    ), this._sc.setEventHandler("draw_complete", () => {
      this._callbackManager.trigger("_drawComplete");
    }), this._sc.setEventHandler("webgl_context_lost", () => {
      this._callbackManager.trigger("webGlContextLost");
    }), this._sc.setEventHandler("websocket_connection_closed", () => {
      this._callbackManager.trigger("websocketConnectionClosed");
    }), this._initOptions.engineReady(this._sessionStartedPromise), this._engineReadyPromise.resolve();
  }
  loadFinished() {
    return this._loadFinished;
  }
  resetCachedStatistics() {
    this._cachedElementCount = null, this._cachedTriangleCount = null;
  }
  setAmbientOcclusionEnabled(t) {
    this._sc.setAmbientOcclusionEnabled(t);
  }
  setAmbientOcclusionRadius(t) {
    this._sc.setAmbientOcclusionRadius(t);
  }
  setLightingEnabled(t) {
    this._sc.setLightingEnabled(t);
  }
  _fillStatTotalCounts() {
    this._cachedElementCount !== null && this._cachedTriangleCount !== null && (this._statistics.total_element_count = this._cachedElementCount, this._statistics.total_triangle_count = this._cachedTriangleCount);
  }
  async _updateCachedStats() {
    const t = this._sc.getElementCount(), e = this._sc.getTriangleCount(), i = await Promise.all([t, e]);
    this._cachedElementCount = i[0], this._cachedTriangleCount = i[1], this._fillStatTotalCounts();
  }
  _toVector3(t) {
    return t.toArray();
  }
  startExplode(t, e) {
    this.delayCapping(), this._sc.startExplode(t, this._toVector3(e));
  }
  setExplodeMagnitude(t) {
    this._callbackManager.trigger("explode", t), this.delayCapping(), this._sc.explode(t);
  }
  stopExplode() {
    this.delayCapping(), this._sc.resetExplode();
  }
  async getStatistics(t = !1) {
    return t && !this.loadFinished() ? (await this._updateCachedStats(), this._fillStatTotalCounts(), this._statistics) : this.loadFinished() && this._cachedTriangleCount === null ? (await this._updateCachedStats(), this._fillStatTotalCounts(), this._statistics) : (this._fillStatTotalCounts(), this._statistics);
  }
  setStreamIdleMarker() {
    return this._sc.setStreamIdleMarker();
  }
  hasDepthRange(t) {
    return this._sc.MeshInstance.hasDepthRange(t);
  }
  setDepthRange(t, e, i) {
    this._sc.MeshInstance.setDepthRange(t, e, i);
  }
  unsetDepthRange(t) {
    this._sc.MeshInstance.unsetDepthRange(t);
  }
  setDefaultDepthRange(t, e) {
    this._sc.setDefaultDepthRange(t, e);
  }
  _getScPlaneArray(t) {
    const e = [];
    for (let i = 0; i < t.getCount(); i++) {
      const s = t.getPlane(i);
      if (s === null)
        continue;
      const r = [];
      s.normal.toArray(r), r[3] = s.d, e.push(r);
    }
    return e;
  }
  getCuttingSectionLimits() {
    return this._sc.cuttingSectionLimits();
  }
  async _addCuttingSection(t, e) {
    let i = kr.Invalid;
    const s = this._getScPlaneArray(t);
    if (s.length > 0 && (i = await this._sc.addCuttingSection(s), i === kr.Invalid)) {
      const r = e === lo.Add ? "add" : "update";
      throw new Mt(`Failed to ${r} cutting section.`);
    }
    this._cuttingSectionToKeyMap.set(t, i), e === lo.Add && this._callbackManager.trigger("addCuttingSection", t);
  }
  addCuttingSection(t) {
    return this._addCuttingSection(t, lo.Add);
  }
  async removeCuttingSection(t) {
    const e = this._cuttingSectionToKeyMap.get(t);
    if (e === void 0) {
      console.assert(!1);
      return;
    }
    if (this._cuttingSectionToKeyMap.delete(t), this._callbackManager.trigger("removeCuttingSection"), e !== kr.Invalid)
      return this._sc.removeCuttingSections([e]);
  }
  removeAllCuttingSections() {
    return this._cuttingSectionToKeyMap.clear(), this._callbackManager.trigger("removeCuttingSection"), this._sc.removeAllCuttingSections();
  }
  async updateCuttingSection(t) {
    const e = this._cuttingSectionToKeyMap.get(t);
    if (e === void 0) {
      console.assert(!1);
      return;
    }
    if (e === kr.Invalid)
      return this._addCuttingSection(t, lo.Update);
    const i = this._getScPlaneArray(t);
    return this._sc.replaceCuttingSection(i, e);
  }
  setCappingDelay(t) {
    this._cappingDelay = t;
  }
  enableCappingIdleCallback(t) {
    return this._sc.setCappingIdleHookEnabled(t);
  }
  getCappedInstances() {
    return this._sc.getCappedInstances();
  }
  delayCapping() {
    this._cappingDelayTimeoutId === null ? this._sc.pauseCapping() : clearTimeout(this._cappingDelayTimeoutId), this._cappingDelayTimeoutId = setTimeout(() => {
      this._cappingDelayTimeoutId = null, this._sc.resumeCapping();
    }, this._cappingDelay);
  }
  setCappingGeometryVisibility(t) {
    if (!(this._cappingGeometryVisibility === t && !this._cappingNeedsUpdate))
      if (this._cappingDelayTimeoutId !== null && (clearTimeout(this._cappingDelayTimeoutId), this._cappingDelayTimeoutId = null), this._cappingNeedsUpdate = !1, this._cappingGeometryVisibility = t, t) {
        const e = this._cappingLineColor !== null ? this._toRgba(this._cappingLineColor, 1) : [-1, -1, -1, -1], i = this._cappingFaceColor !== null ? this._toRgba(this._cappingFaceColor, 1) : [-1, -1, -1, -1];
        this._sc.enableCapping(e, i, this._cappingQuantizationGranularity);
      } else
        this._sc.disableCapping();
  }
  _regenerateCapping() {
    this._cappingNeedsUpdate = !0, this.setCappingGeometryVisibility(this._cappingGeometryVisibility);
  }
  getCappingGeometryVisibility() {
    return this._cappingGeometryVisibility;
  }
  _toRgb(t) {
    return t.toFloatArray();
  }
  _toRgba(t, e) {
    return t.toFloatArray([0, 0, 0, e]);
  }
  setCappingFaceColor(t) {
    t === null && this._cappingFaceColor === null || t !== null && this._cappingFaceColor !== null && t.equals(this._cappingFaceColor) || (t !== null ? this._cappingFaceColor = t.copy() : this._cappingFaceColor = null, this._regenerateCapping());
  }
  setCappingLineColor(t) {
    t === null && this._cappingLineColor === null || t !== null && this._cappingLineColor !== null && t.equals(this._cappingLineColor) || (t !== null ? this._cappingLineColor = t.copy() : this._cappingLineColor = null, this._regenerateCapping());
  }
  async _onSessionStarted() {
    this._sc.suspendDrawing(), this._sc.setDrawMode(Dn.Highlight), this._sc.setHighlightedInstanceFilter(Ss.Colorize), this._sc.setUnhighlightedFilter(Ss.None), this._sc.setHighlightMode(hh.VisibleWithFullOutline), this._sc.setAntiAliasingMode(ch.SMAA);
    const t = [];
    t.push(this._matrixCache.init()), this._regenerateCapping(), await Promise.all(t), this._initOptions.sceneReady(), this._sc.resumeDrawing();
  }
  isInit() {
    return this._sc !== void 0;
  }
  setRemoteEndpoint(t, e) {
    this._uri = t, this._model = e;
  }
  getSessionType() {
    return this._sessionType;
  }
  _awaitEmptyLoad() {
    const t = ye(), e = {
      _attached: (i) => {
        this._callbackManager.unbind(e), i === ar.OfInitialEmptyModel ? t.resolve() : t.reject(new re());
      }
    };
    return this._callbackManager.bind(e), t;
  }
  async loadEmpty() {
    await this._engineReadyPromise;
    try {
      if (this._sessionType !== Ke.Uninitialized)
        throw new ts("Incompatible load types.");
      const t = this._awaitEmptyLoad();
      return this._connectionlessEmpty || this._buffer !== void 0 || this._model === void 0 ? this._sessionType = this._loadEmptyScs() : this._sessionType = this._loadEmptyNetwork(), t;
    } catch (t) {
      throw this._callbackManager.trigger("modelLoadFailure", this._model || "", t.message), t;
    }
  }
  _loadEmpty(t) {
    return console.assert(t.XHRonprogress === void 0), console.assert(t.XHRonerror === void 0), console.assert(t.XHRonloadend === void 0), t.XHRonprogress = (e) => {
      this._callbackManager.trigger("XHRonprogress", e);
    }, t.XHRonerror = (e) => {
      this._callbackManager.trigger("XHRonerror", e);
    }, t.XHRonloadend = (e, i, s) => {
      this._callbackManager.trigger("XHRonloadend", e, i, s);
    }, this._sc.load(t);
  }
  _loadEmptyScs() {
    console.assert(this._model === void 0);
    const t = {
      empty: !0
    };
    return this._streamingMode === Ps.OnDemand && (t.streamInstancesOnDemand = !0), this._loadEmpty(t);
  }
  _loadEmptyNetwork() {
    console.assert(this._model !== void 0);
    const t = {
      model: rr,
      uri: this._uri,
      serverSideRendering: this._rendererType === Ho.Server,
      meshLevel: this._meshLevel,
      streamCutoffScale: this._streamCutoffScale
    };
    switch (this._sessionToken !== void 0 && (t.sessionToken = this._sessionToken), this._memoryLimit > 0 && (t.limitMiB = this._memoryLimit), (this._boundingPreviewMode & vs.Model) === vs.Model && (t.streamModelBoundingPreviews = !0), (this._boundingPreviewMode & vs.Instance) === vs.Instance && (t.streamInstanceBoundingPreviews = !0), (this._boundingPreviewMode & vs.Ejected) === vs.Ejected && (t.streamEjectedBoundingPreviews = !0), this._streamingMode) {
      case Ps.OnDemand:
        t.streamInstancesOnDemand = !0;
        break;
      case Ps.All:
        t.streamCulled = !0, t.streamMetaDataOnIdle = !0;
        break;
    }
    return this._loadEmpty(t);
  }
  setProjection(t) {
    const e = this.getCamera();
    e.getProjection() !== t && (e.setProjection(t), this.setCamera(e));
  }
  getViewMatrix(t) {
    const e = t !== void 0 ? this._toCamera(t) : this._sc.getCamera();
    return Q.createFromArray(e.viewMatrix());
  }
  getProjectionMatrix(t) {
    const e = t !== void 0 ? this._toCamera(t) : this._sc.getCamera();
    return Q.createFromArray(e.projectionMatrix());
  }
  getFullCameraMatrix(t) {
    const e = t !== void 0 ? this._toCamera(t) : this._sc.getCamera();
    return Q.createFromArray(e.fullMatrix());
  }
  getSynchedViewMatrix() {
    return this._syncedCamera ? Q.createFromArray(this._syncedCamera.viewMatrix()) : new Q();
  }
  getSynchedProjectionMatrix() {
    return this._syncedCamera ? Q.createFromArray(this._syncedCamera.projectionMatrix()) : new Q();
  }
  getPrimaryModelKey() {
    return this._sc.primaryModelKey();
  }
  getPartsBounding(t, e, i) {
    return this.getBounding(t, e, !1, i);
  }
  async getDrawnPartsBounding(t) {
    const e = await this._sc.MeshInstance.getDrawnWorldSpaceBounding(t), i = new ni();
    return i.min.fromArray(e.min), i.max.fromArray(e.max), i;
  }
  async getBounding(t, e, i, s) {
    const r = await this._sc.MeshInstance.getWorldSpaceBounding(
      t,
      e,
      i,
      s
    ), o = new ni();
    return o.min.fromArray(r.min), o.max.fromArray(r.max), o;
  }
  async getLooseBounding() {
    const t = await this._sc.getLooseBounding(), e = new ni();
    return e.min.fromArray(t.min), e.max.fromArray(t.max), e;
  }
  getClientDimensions() {
    const t = this._sc.container;
    return [t.clientWidth, t.clientHeight];
  }
  async getModelBounding(t, e, i) {
    return this.getBounding([], t, e, i);
  }
  async pickFromScreen(t, e, i) {
    return this._scSelectionManager.pickFromScreen(t, e, i);
  }
  async pickAllFromScreen(t, e, i) {
    return this._scSelectionManager.pickAllFromScreen(t, e, i);
  }
  async compositePickFromScreen(t, e, i) {
    return this._scSelectionManager.compositePickFromScreen(t, e, i);
  }
  async beginScreenAreaSelection(t, e, i) {
    return this._scSelectionManager.beginScreenAreaSelection(t, e, i);
  }
  async beginRayDrillSelection(t, e, i) {
    return this._scSelectionManager.beginRayDrillSelection(t, e, i);
  }
  async beginConvexPolyhedronSelection(t, e, i) {
    return this._scSelectionManager.beginConvexPolyhedronSelection(
      t,
      e,
      i
    );
  }
  async beginSphereSelection(t, e, i) {
    return this._scSelectionManager.beginSphereSelection(t, e, i);
  }
  endIncrementalSelection(t) {
    this._scSelectionManager.endIncrementalSelection(t);
  }
  async advanceIncrementalSelection(t) {
    return this._scSelectionManager.advanceIncrementalSelection(t, !1);
  }
  flushMetaDataCache() {
    this._sc.flushMetaDataCache();
  }
  async safeGetMetaDatas(t, e) {
    const i = [];
    for (const s of e)
      i.push(t, s);
    try {
      return await this.getDataFromIds(i);
    } catch {
      return null;
    }
  }
  async safeGetMetaData(t, e) {
    const i = await this.safeGetMetaDatas(t, [e]);
    return i !== null ? i[0] : null;
  }
  async safeLoadMetaDatas(t) {
    await this.getDataFromIds(t);
  }
  getDataFromIds(t) {
    if (this._requestBatchCountByType[co.MetaData] === 0)
      return this._getDataFromIds(t);
    const e = new Sg(t);
    return this._pendingRequestsByType[co.MetaData].push(e), e.promise;
  }
  _getDataFromIds(t) {
    return this._sc.getMetaData(t);
  }
  pickFromRay(t, e) {
    return this._scSelectionManager.pickFromRay(t, e);
  }
  pickAllFromRay(t, e) {
    return this._scSelectionManager.pickAllFromRay(t, e);
  }
  updateCamera(t) {
    const e = t._getFlags(), i = this._sc.getCamera();
    return (e & ki.Position) === ki.Position && i.setPosition(this._toVector3(t.getPosition())), (e & ki.Target) === ki.Target && i.setTarget(this._toVector3(t.getTarget())), (e & ki.Up) === ki.Up && i.setUpVector(this._toVector3(t.getUp())), this._setCamera(i), this.getCamera();
  }
  _toProjection(t) {
    switch (t) {
      default:
      case te.Orthographic:
        return No.Orthographic;
      case te.Perspective:
        return No.Perspective;
    }
  }
  _toCamera(t) {
    const e = this._sc.getCamera();
    return e.reset(
      this._toProjection(t.getProjection()),
      this._toVector3(t.getPosition()),
      this._toVector3(t.getTarget()),
      this._toVector3(t.getUp()),
      t.getWidth(),
      t.getHeight()
    ), e.setNearLimit(t.getNearLimit()), e;
  }
  setCamera(t) {
    const e = this._toCamera(t);
    this._setCamera(e);
  }
  _setCamera(t) {
    this.delayCapping(), this._sc.setCamera(t);
  }
  markCameraAsEmpty() {
    this._sc.markCameraAsEmpty();
  }
  setInstancesMatrix(t, e) {
    this._sc.MeshInstance.setAnonymousMatrix(t, e.m);
  }
  // This implementation attempts to reduce saturation when setting large quantities of matrices in SSR (i.e. Animation System)
  // A single message containing all new matrix values is sent via setAnonymousMatrices as opposed to individual messages via setAnonymousMatrix
  setMatrices(t, e) {
    const i = [];
    for (let s = 0; s < e.length; s++)
      i.push(...e[s].m);
    this._sc.MeshInstance.setAnonymousMatrices(t, i);
  }
  highlightParts(t, e) {
    this._sc.MeshInstance.setHighlighted(t, e), this._sc.MeshInstance.setXRay(t, e);
  }
  highlightElements(t, e, i, s, r) {
    const o = this._toElementType(e);
    this._sc.MeshInstance.setElementHighlighted(
      t,
      o,
      i,
      s,
      r
    ), this._sc.MeshInstance.setElementXRay(t, o, i, s, r);
  }
  getPartHighlighted(t) {
    return this._sc.MeshInstance.getHighlighted(t);
  }
  getElementHighlighted(t, e, i) {
    return this._sc.MeshInstance.getElementHighlighted(
      t,
      this._toElementType(e),
      i
    );
  }
  setNodeHighlightColor(t, e) {
    let i;
    t ? (this._sc.setHighlightedInstanceFilter(Ss.Colorize), i = this._toRgba(t, 1), this._sc.setHiddenLineHighlightedInstanceFillColor(i), this._sc.setHighlightedInstanceColor(i)) : this._sc.setHighlightedInstanceFilter(Ss.None), e ? i = this._toRgba(e, 1) : i = [0, 0, 0, 0], this._sc.setHiddenLineHighlightedInstanceOutlineColor(i), this._sc.setHighlightedInstanceOutlineColor(i);
  }
  setElementHighlightColor(t, e) {
    let i;
    t ? (this._sc.setHighlightedElementFilter(Ss.Colorize), i = this._toRgba(t, 1), this._sc.setHighlightedElementColor(i), this._sc.setHiddenLineHighlightedElementFillColor(i)) : this._sc.setHighlightedElementFilter(Ss.None), e ? i = this._toRgba(e, 1) : i = [0, 0, 0, 0], this._sc.setHighlightedElementOutlineColor(i), this._sc.setHiddenLineHighlightedElementOutlineColor(i);
  }
  setHighlightColorizeCompression(t) {
    this._sc.setHighlightColorizeCompression(t);
  }
  async computeMinimumBodyBodyDistance(t, e) {
    if (t.length !== 2 || e.length !== 2)
      throw new Mt("Invalid instance inc.");
    const i = await this._sc.MeshInstance.computeMinimalBodyBodyDistance(t, e);
    return va(i);
  }
  async computeMininimumFaceFaceDistance(t, e, i, s) {
    if (t.length !== 2 || i.length !== 2)
      throw new Mt("Invalid instance inc.");
    const r = await this._sc.MeshInstance.computeMinimalFaceFaceDistance(
      t,
      e,
      i,
      s
    );
    return va(r);
  }
  async computeMinimumFaceRayDistance(t, e, i) {
    if (t.length !== 2)
      throw new Mt("Invalid instance inc.");
    const s = sl(i), r = await this._sc.MeshInstance.computeMinimalFaceRayDistance(t, e, s);
    return va(r);
  }
  async computeMinimumFaceLineDistance(t, e, i) {
    if (t.length !== 2)
      throw new Mt("Invalid instance inc.");
    const s = sl(i), r = await this._sc.MeshInstance.computeMinimalFaceLineDistance(t, e, s);
    return va(r);
  }
  pauseRendering(t) {
    if (this._sc.suspendDrawing(), typeof t == "function")
      try {
        t();
      } finally {
        this._sc.resumeDrawing();
      }
  }
  resumeRendering() {
    this._sc.resumeDrawing();
  }
  beginRequestBatch(t) {
    ++this._requestBatchCountByType[t];
  }
  endRequestBatch(t) {
    this._requestBatchCountByType[t] > 0 && --this._requestBatchCountByType[t], this._flushBatchedRequests(t);
  }
  _flushBatchedRequests(t) {
    const e = this._pendingRequestsByType[t];
    this._pendingRequestsByType[t] = [];
    const i = [];
    for (const s of e)
      for (const r of s.ids)
        i.push(r);
    switch (t) {
      case co.MetaData:
        return this._flushBatchedMetaDataRequests(e, i);
      default:
        return console.assert(!1), Promise.resolve();
    }
  }
  async _flushBatchedMetaDataRequests(t, e) {
    const i = await this._getDataFromIds(e);
    let s = 0;
    for (const r of t) {
      const o = [], a = r.ids.length / 2;
      for (let l = 0; l < a; ++l) {
        const c = i[s++];
        o.push(c);
      }
      r.promise.resolve(o);
    }
    console.assert(s === i.length);
  }
  clearHighlight() {
    this._sc.unsetAllHighlighted(), this._sc.unsetAllXRay();
  }
  resetColors() {
    this._sc.unsetAllColors();
  }
  resetOpacity() {
    this._sc.unsetAllOpacity();
  }
  setPartOpacity(t, e) {
    this.pauseRendering(() => {
      this._sc.MeshInstance.setOpacity(t, Je.Faces, e), this._sc.MeshInstance.setOpacity(t, Je.Lines, e), this._sc.MeshInstance.setOpacity(t, Je.Points, e);
    });
  }
  unsetPartOpacity(t) {
    this.pauseRendering(() => {
      this._sc.MeshInstance.unsetOpacity(t, Je.Faces), this._sc.MeshInstance.unsetOpacity(t, Je.Lines), this._sc.MeshInstance.unsetOpacity(t, Je.Points);
    });
  }
  getPartOpacity(t) {
    return this._sc.MeshInstance.getOpacity(t, Je.Faces);
  }
  getEffectivePartOpacity(t, e) {
    return this._sc.MeshInstance.getEffectiveOpacity(t, this._toElementType(e));
  }
  async getPartHasTransparency(t) {
    const e = [];
    e.push(this._sc.MeshInstance.hasTransparency(t, Je.Faces)), e.push(this._sc.MeshInstance.hasTransparency(t, Je.Lines)), e.push(this._sc.MeshInstance.hasTransparency(t, Je.Points));
    const [i, s, r] = await Promise.all(e);
    for (let o = 0; o < i.length; ++o)
      i[o] || (i[o] = s[o] || r[o]);
    return i;
  }
  setPartColor(t, e, i) {
    this._sc.MeshInstance.setColor(t, this._toElementType(e), i.getFloatArray());
  }
  unsetPartColor(t, e) {
    this._sc.MeshInstance.unsetColor(t, this._toElementType(e));
  }
  getPartColor(t, e) {
    return this._sc.MeshInstance.getColor(t, this._toElementType(e)).then(
      (i) => i.map((s) => s ? it.createFromFloatArray(s) : null)
    );
  }
  async getEffectivePartColor(t, e) {
    const i = this._toElementType(e);
    return (await this._sc.MeshInstance.getEffectiveColor(t, i)).map(it.createFromFloatArray);
  }
  setPartAmbientColor(t, e, i) {
    this._sc.MeshInstance.setAmbientColor(
      t,
      this._toElementType(e),
      i.getFloatArray()
    );
  }
  setPartAmbientMix(t, e, i) {
    this._sc.MeshInstance.setAmbientMix(t, this._toElementType(e), i);
  }
  setPartEmissiveColor(t, e, i) {
    this._sc.MeshInstance.setEmissiveColor(
      t,
      this._toElementType(e),
      i.getFloatArray()
    );
  }
  unsetPartEmissiveColor(t, e) {
    this._sc.MeshInstance.unsetEmissiveColor(t, this._toElementType(e));
  }
  setPartSpecularColor(t, e, i) {
    this._sc.MeshInstance.setSpecularColor(
      t,
      this._toElementType(e),
      i.getFloatArray()
    );
  }
  unsetPartSpecularColor(t, e) {
    this._sc.MeshInstance.unsetSpecularColor(t, this._toElementType(e));
  }
  setPartSpecularIntensity(t, e, i) {
    this._sc.MeshInstance.setSpecularIntensity(t, this._toElementType(e), i);
  }
  unsetPartSpecularIntensity(t, e) {
    this._sc.MeshInstance.unsetSpecularIntensity(t, this._toElementType(e));
  }
  setElementColor(t, e, i, s, r) {
    this._sc.MeshInstance.setElementColor(
      t,
      this._toElementType(e),
      i,
      s,
      r.getFloatArray()
    );
  }
  unsetElementColor(t, e, i, s) {
    this._sc.MeshInstance.unsetElementColor(
      t,
      this._toElementType(e),
      i,
      s
    );
  }
  getElementColor(t, e, i) {
    return this._sc.MeshInstance.getElementColor(
      t,
      this._toElementType(e),
      i
    ).then((s) => s.map((r) => r ? it.createFromFloatArray(r) : null));
  }
  async getEffectiveElementColor(t, e, i) {
    const s = this._toElementType(e);
    return (await this._sc.MeshInstance.getEffectiveElementColor(t, s, i)).map(it.createFromFloatArray);
  }
  synchronizeVisibilities(t, e) {
    t.length > 0 && this._sc.MeshInstance.synchronizeVisibilities(t, e);
  }
  setPartVisibility(t, e, i) {
    t.length > 0 && this._sc.MeshInstance.setVisible(t, e, i);
  }
  setElementVisibility(t, e, i, s, r) {
    t.length > 0 && this._sc.MeshInstance.setElementVisible(
      t,
      this._toElementType(e),
      i,
      s,
      r
    );
  }
  clearElementVisibility(t, e) {
    t.length > 0 && this._sc.MeshInstance.clearElementVisible(t, this._toElementType(e));
  }
  setVisibilityByAttachment(t, e) {
    this._sc.setVisibilityByAttachment(t, e);
  }
  requestMeshInstances(t) {
    this._sc.demandMeshInstances(t);
  }
  getRendererType() {
    return this._rendererType;
  }
  _toMeshDataBuilder(t) {
    const e = t._getFaceData(), i = t._getPointData(), s = t._getPolylineData(), r = new this._sc.MeshDataBuilder();
    for (const h of e)
      r.addFace(h.vertexData, {
        normals: h.normalData,
        rgba32s: h.rgba32data,
        uvs: h.uvData,
        bits: h.bits
      });
    for (const h of i)
      r.addPoints(h.vertexData, {
        rgba32s: h.rgba32data,
        bits: h.bits
      });
    for (const h of s)
      r.addPolyline(h.vertexData, {
        rgba32s: h.rgba32data,
        bits: h.bits
      });
    let o;
    ((h) => {
      h[h.None = 0] = "None", h[h.ClockwiseWinding = 1] = "ClockwiseWinding", h[h.CounterClockwiseWinding = 2] = "CounterClockwiseWinding", h[h.TwoSided = 4] = "TwoSided", h[h.Manifold = 65536] = "Manifold";
    })(o || (o = {}));
    let a = 0;
    switch (t.getFaceWinding()) {
      case yn.Clockwise:
        a = 1;
        break;
      case yn.CounterClockwise:
        a = 2;
        break;
      case yn.Unknown:
      default:
        a = 0;
        break;
    }
    const l = t.getBackfacesEnabled() ? 4 : 0, c = t.isManifold() ? 65536 : 0;
    return r.formatBits |= a | l | c, r;
  }
  createMesh(t) {
    const e = this._toMeshDataBuilder(t);
    return this._sc.MeshData.create(e);
  }
  replaceMesh(t, e) {
    const i = this._toMeshDataBuilder(e);
    return this._sc.MeshData.replace(t, i);
  }
  destroyMeshes(t) {
    return this._sc.MeshData.destroy(t);
  }
  _toImageFormat(t) {
    switch (t) {
      case Oi.Gray8:
        return xs.Gray8;
      case Oi.GrayAlpha16:
        return xs.GrayAlpha16;
      case Oi.Rgb24:
        return xs.Rgb24;
      case Oi.Rgba32:
        return xs.Rgba32;
      case Oi.Jpeg:
        return xs.Jpeg;
      case Oi.Png:
        return xs.Png;
    }
  }
  _validateImage(t) {
    if (t.format === void 0)
      throw new fn("missing 'format' property");
    if (t.data === void 0)
      throw new fn("missing 'data' property");
    if ((t.format === Oi.Gray8 || t.format === Oi.GrayAlpha16 || t.format === Oi.Rgb24 || t.format === Oi.Rgba32) && (t.width === void 0 || t.width <= 0 || t.height === void 0 || t.height <= 0))
      throw new fn("uncompressed format requested but missing width or height");
  }
  async _pngImageHasAlpha(t) {
    let e;
    try {
      e = await new Promise((a, l) => {
        const c = new Image();
        c.onload = () => {
          a(c);
        }, c.onerror = () => {
          l();
        }, c.src = `data:image/png;base64, ${fg(t)}`;
      });
    } catch {
      return console.warn(
        "Unable to read PNG image to check alpha component. Will be considered with alpha."
      ), !0;
    }
    const i = document.createElement("canvas"), s = i.getContext("2d");
    if (s === null)
      return console.warn(
        "Unable to create 2d context to check alpha component. Will be considered with alpha."
      ), !0;
    i.width = e.width, i.height = e.height, s.drawImage(e, 0, 0);
    const o = s.getImageData(0, 0, e.width, e.height).data;
    for (let a = 0; a < o.length; a += 4)
      if (o[a + 3] < 255)
        return !0;
    return !1;
  }
  async createImage(t, e) {
    this._validateImage(t);
    let i = !1;
    if (t.format === Oi.Png && (i = await this._pngImageHasAlpha(t.data)), e !== void 0) {
      this._validateImage(e);
      let s = !1;
      return e.format === Oi.Png && (s = await this._pngImageHasAlpha(e.data)), this._sc.Image.create(
        this._toImageFormat(t.format),
        t.data,
        i,
        t.width,
        t.height,
        this._toImageFormat(e.format),
        e.data,
        s,
        e.width,
        e.height
      );
    } else
      return this._sc.Image.create(
        this._toImageFormat(t.format),
        t.data,
        i,
        t.width,
        t.height
      );
  }
  destroyImages(t) {
    return this._sc.Image.destroy(t);
  }
  _toTextureTiling(t) {
    switch (t) {
      default:
      case Vc.Repeat:
        return il.Repeat;
      case Vc.Clamp:
        return il.Clamp;
    }
  }
  _toTextureInterpolation(t) {
    return t === !1 ? $a.Off : $a.On;
  }
  _toTextureMipMapping(t) {
    return t === !1 ? tl.Off : tl.On;
  }
  _toTextureParameterization(t) {
    switch (t) {
      default:
      case el.UV:
        return el.UV;
    }
  }
  _toTextureModifier(t) {
    switch (t) {
      default:
      case 0:
        return Zo.None;
      case Zo.Decal:
        return Zo.Decal;
    }
  }
  async setTexture(t, e) {
    if (e.imageId === void 0)
      throw new fn("missing 'imageId' property");
    return this._sc.MeshInstance.setTexture(
      t,
      Je.Faces,
      e.imageId,
      e.matrix !== void 0 ? e.matrix.m : new Q().m,
      this._toTextureTiling(e.tiling),
      this._toTextureInterpolation(e.interpolation),
      this._toTextureMipMapping(e.mipMapping),
      this._toTextureParameterization(e.parameterization),
      this._toTextureModifier(e.modifiers)
    );
  }
  unsetTexture(t) {
    this._sc.MeshInstance.unsetTexture(t, Je.Faces);
  }
  createMatrix(t) {
    return this._sc.Matrix.create(t);
  }
  createIdentityMatrix() {
    return this._sc.Matrix.create();
  }
  async createMeshInstance(t) {
    const e = t.getMeshId();
    if (e === null)
      throw new Mt("MeshId is not set");
    let i = this._matrixCache.getIdentityInc();
    const s = [], r = t.getMatrix();
    if (r) {
      const u = this.createMatrix(r.m).then((p) => {
        i = p;
      });
      s.push(u);
    }
    const o = new it(255, 0, 0), a = this._toRgba(
      t.getFaceColor() || o,
      t.getOpacity()
    ), l = this._toRgba(
      t.getLineColor() || o,
      t.getLineOpacity()
    ), c = this._toRgba(
      t.getPointColor() || o,
      t.getPointOpacity()
    );
    await Promise.all(s);
    const h = await this._sc.MeshInstance.create(
      e,
      i,
      a,
      l,
      c,
      t.getCreationFlags(),
      t.getOverlayIndex()
    );
    return this._callbackManager.trigger("_geometryCreated", h), h;
  }
  destroyLocalInstances(t) {
    return this._sc.MeshInstance.destroy(t);
  }
  _fromScCamera(t) {
    let e = te.Orthographic;
    return t.projection() === te.Perspective && (e = te.Perspective), ci.create(
      d.createFromArray(t.position()),
      d.createFromArray(t.target()),
      d.createFromArray(t.upVector()),
      e,
      t.fieldWidth(),
      t.fieldHeight(),
      t.nearLimit()
    );
  }
  async getCameraPromise() {
    const t = await this._sc.getCameraPromise();
    return this._fromScCamera(t);
  }
  getCamera() {
    const t = this._sc.getCamera();
    return this._fromScCamera(t);
  }
  resize() {
    this._sc.onResize(), this._windowSize.set(this._canvasContainer.offsetWidth, this._canvasContainer.offsetHeight);
  }
  setFaceVisibility(t) {
    this._sc.setFacesVisible(t);
  }
  setLineVisibility(t) {
    this._sc.setLinesVisible(t);
  }
  getCanvasSize() {
    return this._windowSize.copy();
  }
  setBackgroundGradient(t, e) {
    this._sc.setBackgroundGradient(
      t ? this._toRgba(t, 1) : [0, 0, 0, 0],
      e ? this._toRgba(e, 1) : [0, 0, 0, 0]
    );
  }
  setBoundingPreviewUnderDrawColor(t) {
    this._sc.setBoundingPreviewUnderdrawColor(this._toRgba(t, 0.7));
  }
  setBoundingPreviewTestedColor(t) {
    this._sc.setBoundingPreviewTestedColor(this._toRgba(t, 0.7));
  }
  setBoundingPreviewEjectedColor(t) {
    this._sc.setBoundingPreviewEjectedColor(this._toRgba(t, 0.7));
  }
  setBoundingPreviewUnderDraw(t) {
    this._sc.setBoundingPreviewUnderdraw(
      t.reduce((e, i) => (e.push(this._toVector3(i.min), this._toVector3(i.max)), e), [])
    );
  }
  setBoundingDebugLevel(t) {
    this._sc.setBoundingDebugLevel(t);
  }
  setBoundingPreviewTested(t) {
    this._sc.setBoundingPreviewTested(
      t.reduce((e, i) => (e.push(this._toVector3(i.min), this._toVector3(i.max)), e), [])
    );
  }
  setBoundingPreviewEjected(t) {
    this._sc.setBoundingPreviewEjected(
      t.reduce((e, i) => (e.push(this._toVector3(i.min), this._toVector3(i.max)), e), [])
    );
  }
  setServerRenderQuality(t, e, i, s) {
    this._sc.setSsrQuality({
      jpegQualityLow: t,
      jpegQualityHigh: e,
      scaleLow: i,
      scaleHigh: s
    });
  }
  setMinimumFramerate(t) {
    this._sc.setMinFrameRate(t);
  }
  getMinimumFramerate() {
    return this._sc.getMinFrameRate();
  }
  setBackFacesVisible(t) {
    this._sc.setBackFacesVisible(t);
  }
  setDrawMode(t) {
    this._sc.setDrawMode(t);
  }
  enableHiddenLineRendering(t) {
    this.setDrawMode(Dn.HiddenLine), this._sc.setHiddenLineVisibleLineColor(
      this._toRgba(t.getVisibleLineColor(), t.getVisibleLineOpacity())
    ), this._sc.setHiddenLineHiddenLineColor(
      this._toRgba(t.getObscuredLineColor(), t.getObscuredLineOpacity())
    );
  }
  setAntiAliasingMode(t) {
    this._sc.setAntiAliasingMode(t);
  }
  setInstanceModifier(t, e, i) {
    switch (t) {
      case Xe.DoNotCut:
        this._sc.MeshInstance.setDoNotCut(e, i);
        break;
      case Xe.DoNotExplode:
        this._sc.MeshInstance.setDoNotExplode(e, i);
        break;
      case Xe.DoNotSelect:
        this._sc.MeshInstance.setDoNotSelect(e, i);
        break;
      case Xe.SuppressCameraScale:
        this._sc.MeshInstance.setSuppressCameraScale(e, i);
        break;
      case Xe.OverrideSceneVisibility:
        this._sc.MeshInstance.setOverrideSceneVisibility(e, i);
        break;
      case Xe.DoNotLight:
        this._sc.MeshInstance.setDoNotLight(e, i);
        break;
      case Xe.DoNotOutlineHighlight:
        this._sc.MeshInstance.setDoNotOutlineHighlight(e, i);
        break;
      case Xe.ExcludeBounding:
        this._sc.MeshInstance.setExcludeBounding(e, i);
        break;
      case Xe.DoNotUseVertexColors:
        this._sc.MeshInstance.setDoNotUseVertexColors(e, i);
        break;
      case Xe.AlwaysDraw:
        this._sc.MeshInstance.setAlwaysDraw(e, i);
        break;
      case Xe.DoNotXRay:
        this._sc.MeshInstance.setDoNotXRay(e, i);
        break;
      case Xe.ScreenOriented:
        this._sc.MeshInstance.setScreenOriented(e, i);
        break;
      case Xe.ScreenSpace:
        this._sc.MeshInstance.setScreenSpace(e, i);
        break;
      case Xe.ScreenSpaceStretched:
        this._sc.MeshInstance.setScreenSpaceStretched(e, i);
        break;
    }
  }
  attachModel(t, e, i, s, r) {
    const o = [e, i];
    return this._attachModels(t, [o], s, r);
  }
  attachScsModelByKey(t, e, i, s, r) {
    return console.assert(this._sessionType === Ke.Scs), this._sc.attachScsModelByKey(
      t,
      i,
      e,
      s,
      r
    );
  }
  async _attachModels(t, e, i, s) {
    await this._sc.attachModels(
      t,
      e,
      i,
      s
    ), this._callbackManager.trigger("_attached", t);
  }
  async attachScsBuffer(t, e, i, s, r, o) {
    await this._sc.attachScsBuffer(
      t,
      e,
      i,
      s,
      r,
      o
    ), this._callbackManager.trigger("_attached", t);
  }
  feedScsBuffer(t, e) {
    this._sc.feedScsBuffer(t, e);
  }
  _parseKeyInfo(t, e, i) {
    if (t || e)
      return i;
    const s = /* @__PURE__ */ new Map();
    for (let r = 0; r < i.length; ++r) {
      const o = i[r++], a = [];
      for (; r < i.length && i[r] !== Bi.Invalid; ++r)
        a.push(i[r]);
      s.set(o, a);
    }
    return s;
  }
  async instanceKeyInfo(t, e, i) {
    const s = e === rl.Model, r = i === ol.KeyCountOnly, o = await this._sc.meshInstanceKeyInfo(t, s, r);
    return this._parseKeyInfo(s, r, o);
  }
  async metaDataKeyInfo(t, e, i) {
    const s = await this._sc.metaDataKeyInfo(t, e, i);
    return this._parseKeyInfo(e, i, s);
  }
  modelKeysFromInclusionKeys(t) {
    return this._sc.modelKeysFromInclusionKeys(t);
  }
  detachInclusions(t) {
    return this._sc.detachInclusions(t);
  }
  async resetToEmpty(t, e) {
    for (let i = 0; i < this._requestBatchCountByType.length; ++i) {
      this._requestBatchCountByType[i] = 0;
      for (const s of this._pendingRequestsByType[i])
        s.promise.reject(s.ids);
      this._pendingRequestsByType[i].length = 0;
    }
    await this._sc.resetToEmpty(t, e), this.flushMetaDataCache();
  }
  setDrawStrategy(t) {
    console.warn(
      "This API has been deactivated for lack of stability it is recommended not to use it"
    ), this._sc.setDrawStrategy(t);
  }
  redraw() {
    this._sc.queueRedraw();
  }
  disconnectNetwork() {
    this._sc.disconnectNetwork();
  }
  shutdown() {
    this._cappingDelayTimeoutId !== null && (clearTimeout(this._cappingDelayTimeoutId), this._cappingDelayTimeoutId = null), this._sessionType = Ke.Uninitialized, this._sc.shutDown();
  }
  getVersionString() {
    return this._sc.getStreamVersion().toString();
  }
  setAllowHighDpi(t) {
    this._sc.allowHighDpi = t, this.resize();
  }
  getAllowHighDpi() {
    return this._sc.allowHighDpi;
  }
  setMeshLevel(t, e) {
    this._sc.MeshInstance.setMeshLevel(t, e);
  }
  setMetallicRoughness(t, e, i) {
    this._sc.MeshInstance.setMetallicRoughness(t, e, i);
  }
  setMetallicRoughnessMaterialOverride(t, e) {
    this._sc.setMetallicRoughnessMaterialOverride(t, e);
  }
  async getMetallicRoughness(t) {
    const e = await this._sc.MeshInstance.getMetallicRoughness(t), i = [];
    for (let s = 0; s < e.length; s += 2) {
      if (e[s] < 0 || e[s + 1] < 0) {
        i.push(null);
        continue;
      }
      i.push({
        metallic: e[s],
        roughness: e[s + 1]
      });
    }
    return i;
  }
  unsetMetallicRoughness(t) {
    this._sc.MeshInstance.unsetMetallicRoughness(t);
  }
  setOverlayVisibility(t, e) {
    this._sc.Overlay.setVisible(t, e);
  }
  setOverlayCamera(t, e) {
    const i = this._toCamera(e);
    this._sc.Overlay.setCamera(t, i);
  }
  destroyOverlay(t) {
    this._sc.Overlay.destroy(t);
  }
  _overlayUnit(t) {
    switch (t) {
      case Bt.ProportionOfCanvas:
        return Co.ProportionOfScreen;
      case Bt.ProportionOfOtherDimension:
        return Co.ProportionOfOtherDimension;
      default:
        return Co.Pixels;
    }
  }
  getMaxOverlayIndex() {
    return this._sc.Overlay.maxIndex();
  }
  _overlayAnchor(t) {
    switch (t) {
      case Jt.BottomCenter:
        return kn.BottomCenter;
      case Jt.Center:
        return kn.Center;
      case Jt.LeftCenter:
        return kn.LeftCenter;
      case Jt.LowerLeftCorner:
        return kn.LowerLeftCorner;
      case Jt.LowerRightCorner:
        return kn.LowerRightCorner;
      case Jt.RightCenter:
        return kn.RightCenter;
      case Jt.TopCenter:
        return kn.TopCenter;
      case Jt.UpperRightCorner:
        return kn.UpperRightCorner;
      default:
        return kn.UpperLeftCorner;
    }
  }
  setOverlayViewport(t, e, i, s, r, o, a, l, c, h) {
    this._sc.Overlay.setViewport(
      t,
      this._overlayAnchor(e),
      i,
      this._overlayUnit(s),
      r,
      this._overlayUnit(o),
      a,
      this._overlayUnit(l),
      c,
      this._overlayUnit(h)
    );
  }
  addNodesToOverlay(t, e) {
    this._sc.MeshInstance.setOverlayIndex(t, e);
  }
  getInstancesMeshData(t) {
    return this._sc.MeshInstance.getMeshData(t);
  }
  getInstancesCappingMeshData(t) {
    return this._sc.MeshInstance.getCappingMeshData(t);
  }
  getMeshData(t) {
    return this._sc.MeshData.getData(t);
  }
  _toElementType(t) {
    switch (t) {
      case vt.Faces:
        return Je.Faces;
      case vt.Lines:
        return Je.Lines;
      case vt.Points:
        return Je.Points;
    }
  }
  _toXRayGroup(t) {
    switch (t) {
      case Qo.Selected:
        return nl.Selected;
      case Qo.Unselected:
        return nl.Unselected;
    }
  }
  setXRayColor(t, e, i) {
    this._sc.setXRayMaterial(
      this._toXRayGroup(t),
      this._toElementType(e),
      this._toRgba(i, 1)
    );
  }
  unsetXRayColor(t, e) {
    return this._sc.unsetXRayMaterial(this._toXRayGroup(t), this._toElementType(e));
  }
  setXRayOpacity(t, e) {
    e !== void 0 ? this._sc.setXRayOpacity(this._toElementType(e), t) : (this._sc.setXRayOpacity(Je.Faces, t), this._sc.setXRayOpacity(Je.Lines, t), this._sc.setXRayOpacity(Je.Points, t));
  }
  setXRayTransparencyMode(t) {
    this._sc.setXRayTransparencyMode(t);
  }
  setGoochBlue(t) {
    this._sc.setGoochBlue(t);
  }
  setGoochBaseColorProminence(t) {
    this._sc.setGoochBaseColorProminence(t);
  }
  setGoochYellow(t) {
    this._sc.setGoochYellow(t);
  }
  setGoochLuminanceShiftStrength(t) {
    this._sc.setGoochLuminanceShiftStrength(t);
  }
  setToonShadingBandCount(t) {
    this._sc.setToonBandCount(t);
  }
  setToonShadingSpecularFactor(t) {
    this._sc.setToonSpecularFactor(t);
  }
  setTransparencyMode(t) {
    this._sc.setTransparencyMode(t);
  }
  setPointSize(t, e) {
    this._sc.setPointSize(t, e);
  }
  async getPointSize() {
    const t = await Promise.all([this._sc.getPointSize(), this._sc.getPointSizeUnit()]);
    return [t[0], t[1]];
  }
  setPointShape(t) {
    this._sc.setPointShape(t);
  }
  async getPointShape() {
    return await this._sc.getPointShape();
  }
  setEyeDomeLightingEnabled(t) {
    this._sc.setEyeDomeLightingEnabled(t);
  }
  getEyeDomeLightingEnabled() {
    return this._sc.getEyeDomeLightingEnabled();
  }
  setEyeDomeLightingBlurSamples(t) {
    this._sc.setEyeDomeLightingBlurSamples(t);
  }
  getEyeDomeLightingBlurSamples() {
    return this._sc.getEyeDomeLightingBlurSamples();
  }
  setEyeDomeLightingBlurInterval(t) {
    this._sc.setEyeDomeLightingBlurInterval(t);
  }
  getEyeDomeLightingBlurInterval() {
    return this._sc.getEyeDomeLightingBlurInterval();
  }
  setEyeDomeLightingBlurEdgeDistance(t) {
    this._sc.setEyeDomeLightingBlurEdgeDistance(t);
  }
  getEyeDomeLightingBlurEdgeDistance() {
    return this._sc.getEyeDomeLightingBlurEdgeDistance();
  }
  setEyeDomeLightingShadingEdgeDistance(t) {
    this._sc.setEyeDomeLightingShadingEdgeDistance(t);
  }
  getEyeDomeLightingShadingEdgeDistance() {
    return this._sc.getEyeDomeLightingShadingEdgeDistance();
  }
  setEyeDomeLightingOpacity(t) {
    this._sc.setEyeDomeLightingOpacity(t);
  }
  getEyeDomeLightingOpacity() {
    return this._sc.getEyeDomeLightingOpacity();
  }
  setDisplayIncompleteFrames(t) {
    this._sc.setDisplayIncompleteFrames(t);
  }
  setInteractiveDrawDelay(t) {
    this._sc.setPostInputDelay(t);
  }
  setInteractiveDrawLimitIncreaseEnabled(t) {
    this._sc.setInteractiveDrawLimitIncreaseEnabled(t);
  }
  getInteractiveDrawLimitIncreaseEnabled() {
    return this._sc.getInteractiveDrawLimitIncreaseEnabled();
  }
  setCullingVector(t, e, i, s) {
    this._sc.MeshInstance.setCullingVector(
      t,
      e,
      [i.x, i.y, i.z],
      s
    );
  }
  unsetCullingVector(t) {
    this._sc.MeshInstance.unsetCullingVector(t);
  }
  async getCullingVector(t) {
    const e = await this._sc.MeshInstance.getCullingVector(t), i = [];
    for (const s of e)
      s.vector[0] === 0 && s.vector[1] === 0 && s.vector[2] === 0 ? i.push(null) : i.push({
        space: s.space,
        vector: d.createFromArray(s.vector),
        toleranceDegrees: s.toleranceDegrees
      });
    return i;
  }
  _setStreamCutoffScale(t) {
    this._streamCutoffScale = Math.max(0, Math.min(t, 2));
  }
  setStreamCutoffScale(t) {
    this._setStreamCutoffScale(t), this._sc.setStreamCutoffScale(this._streamCutoffScale);
  }
  getStreamCutoffScale() {
    return this._streamCutoffScale;
  }
  loseWebGlContext() {
    return this._sc._loseWebGlContext();
  }
  triangulatePolygon(t, e) {
    const i = this._sc.triangulatePolygon(t, e);
    return new Float32Array(i);
  }
  debug_log(t) {
    return this._sc.debug_log(t);
  }
  debug_stateFailure(t) {
    return this._sc.debug_stateFailure(t);
  }
  debug_sync() {
    return this._sc.debug_sync();
  }
  setLinePattern(t, e, i, s) {
    this._sc.MeshInstance.setLinePattern(t, e, i, s);
  }
  unsetLinePattern(t) {
    this._sc.MeshInstance.unsetLinePattern(t);
  }
  async createFloorplanMesh(t) {
    return this._sc.createFloorplanMesh(t);
  }
  async exportToSvg(t) {
    return (await this._sc.exportToSvg(t)).map((s) => String.fromCharCode(s)).join("");
  }
  async beginExportToSvg(t) {
    return this._sc.beginExportToSvg(t);
  }
  async advanceExportToSvg() {
    const t = await this._sc.advanceExportToSvg();
    if (t.length !== 0)
      return t.reduce((e, i) => {
        const s = String.fromCharCode(i);
        switch (s) {
          case `
`:
            return e;
          case "'":
            return `${e}"`;
          default:
            return `${e}${s}`;
        }
      }, "");
  }
  waitForImageDecoding() {
    return this._sc.waitForImageDecoding();
  }
  registerBimInstances(t, e) {
    return this._sc.registerBimInstances(t, e);
  }
  setAmbientLightColor(t) {
    this._sc.setAmbientLightColor(this._toRgb(t));
  }
  getLightKeys() {
    return this._sc.getLightKeys();
  }
  async getLight(t) {
    try {
      const e = await this._sc.getLight(t);
      return new oy(
        e.type,
        e.space,
        new d(...e.position),
        it.createFromFloatArray(e.color)
      );
    } catch {
      return;
    }
  }
  clearLights() {
    this._sc.clearLights();
  }
  addLight(t) {
    return this._sc.addLight(
      t.type,
      t.space,
      this._toVector3(t.position),
      this._toRgb(t.color)
    );
  }
  removeLight(t) {
    this._sc.removeLight(t);
  }
  updateLight(t, e) {
    this._sc.updateLight(
      t,
      e.type,
      e.space,
      this._toVector3(e.position),
      this._toRgb(e.color)
    );
  }
  setBloomEnabled(t) {
    this._sc.setBloomEnabled(t);
  }
  setBloomThreshold(t) {
    this._sc.setBloomThreshold(t);
  }
  setBloomThresholdRampWidth(t) {
    this._sc.setBloomThresholdRampWidth(t);
  }
  setBloomIntensityScale(t) {
    this._sc.setBloomIntensityScale(t);
  }
  _toBlurIntervalUnit(t) {
    switch (t) {
      default:
      case mn.Pixels:
        return So.Pixels;
      case mn.ProportionOfWidth:
        return So.ProportionOfWidth;
      case mn.ProportionOfHeight:
        return So.ProportionOfHeight;
    }
  }
  setBloomLayers(t) {
    for (const e of t)
      if (e.blurInterval !== void 0 && e.blurInterval.length !== 2)
        throw new Mt(
          "'blurInterval' must be an array containing a number followed by a BlurIntervalUnit"
        );
    this._sc.suspendDrawing(), this._sc.setBloomLayerCount(t.length);
    for (let e = 0; e < t.length; ++e) {
      const i = t[e];
      i.intensity !== void 0 && this._sc.setBloomIntensity(e, i.intensity), i.blurSamples !== void 0 && this._sc.setBloomBlurSamples(e, i.blurSamples), i.blurInterval !== void 0 && this._sc.setBloomBlurInterval(
        e,
        i.blurInterval[0],
        this._toBlurIntervalUnit(i.blurInterval[1])
      );
    }
    this._sc.resumeDrawing();
  }
  startComparison(t, e, i) {
    const s = i != null && i.sameColor ? this._toRgb(i.sameColor) : [0, 0, 0], r = i != null && i.only1Color ? this._toRgb(i.only1Color) : [1, 0, 0], o = i != null && i.only2Color ? this._toRgb(i.only2Color) : [0, 1, 0];
    this._sc.setComparisonColors(s, r, o), this._sc.startComparison(t, e);
  }
  endComparison() {
    this._sc.endComparison();
  }
  setSimpleShadowColor(t) {
    this._sc.setSimpleShadowColor(this._toRgb(t));
  }
  setSimpleShadowEnabled(t) {
    this._sc.setSimpleShadowEnabled(t);
  }
  setSimpleShadowOpacity(t) {
    this._sc.setSimpleShadowOpacity(t);
  }
  setGroundPlane(t, e) {
    e !== void 0 ? this._sc.setGroundPlaneWithPosition(this._toVector3(t), this._toVector3(e)) : this._sc.setGroundPlane(this._toVector3(t));
  }
  setSimpleShadowResolution(t) {
    this._sc.setSimpleShadowResolution(t);
  }
  setSimpleShadowBlurSamples(t) {
    this._sc.setSimpleShadowBlurSamples(t);
  }
  setSimpleShadowBlurInterval(t) {
    this._sc.setSimpleShadowBlurInterval(t);
  }
  setSimpleShadowInteractiveUpdateEnabled(t = !0) {
    this._sc.setSimpleShadowInteractiveUpdateEnabled(t);
  }
  setSilhouetteColor(t) {
    this._sc.setSilhouetteColor(this._toRgb(t));
  }
  setSilhouetteEnabled(t = !0) {
    this._sc.setSilhouetteEnabled(t);
  }
  setSilhouetteOpacity(t) {
    this._sc.setSilhouetteOpacity(t);
  }
  setSilhouetteThreshold(t) {
    this._sc.setSilhouetteThreshold(t);
  }
  setSilhouetteThresholdRampWidth(t) {
    this._sc.setSilhouetteThresholdRampWidth(t);
  }
  setHardEdgeColor(t) {
    this._sc.setHardEdgeColor(this._toRgb(t));
  }
  setHardEdgesEnabled(t = !0) {
    this._sc.setHardEdgesEnabled(t);
  }
  setHardEdgeOpacity(t) {
    this._sc.setHardEdgeOpacity(t);
  }
  setHardEdgeThreshold(t) {
    this._sc.setHardEdgeThreshold(t);
  }
  setHardEdgeThresholdRampWidth(t) {
    this._sc.setHardEdgeThresholdRampWidth(t);
  }
  setSimpleReflectionEnabled(t = !0) {
    this._sc.setSimpleReflectionEnabled(t);
  }
  setSimpleReflectionBlurInterval(t, e) {
    this._sc.setSimpleReflectionBlurInterval(t, this._toBlurIntervalUnit(e));
  }
  setSimpleReflectionBlurSamples(t) {
    this._sc.setSimpleReflectionBlurSamples(t);
  }
  setSimpleReflectionFadeAngle(t) {
    this._sc.setSimpleReflectionFadeAngle(t);
  }
  setSimpleReflectionOpacity(t) {
    this._sc.setSimpleReflectionOpacity(t);
  }
  setSimpleReflectionAttenuation(t, e, i = uh.World) {
    this._sc.setSimpleReflectionAttenuation(t, e, i);
  }
  throttleLoad(t, e) {
    this._sc.throttleLoad(t, e);
  }
  _toVector3Array(t) {
    const e = [];
    for (const i of t)
      e.push([i.x, i.y, i.z]);
    return e;
  }
  testPointVisibility(t) {
    return this._sc.testPointVisibility(this._toVector3Array(t));
  }
  setPointVisibilityTest(t) {
    this._sc.setPointVisibilityTest(this._toVector3Array(t));
  }
  setImageBasedLightingEnabled(t) {
    this._sc.setImageBasedLightingEnabled(t);
  }
  setImageBasedLightingIntensity(t) {
    this._sc.setImageBasedLightingIntensity(t);
  }
  _toMatrix9(t) {
    return [
      t.m[0],
      t.m[1],
      t.m[2],
      t.m[4],
      t.m[5],
      t.m[6],
      t.m[8],
      t.m[9],
      t.m[10]
    ];
  }
  setImageBasedLightingMatrix(t) {
    this._sc.setImageBasedLightingMatrix(this._toMatrix9(t));
  }
  setImageBasedLightingEnvironment(t) {
    this._sc.setImageBasedLightingEnvironment(t);
  }
  setImageBasedLightingEnvironmentToDefault() {
    this._sc.setImageBasedLightingEnvironmentToDefault();
  }
  setLineJitterEnabled(t) {
    this._sc.setLineJitterEnabled(t);
  }
  setLineJitterInstanceCount(t) {
    this._sc.setLineJitterInstanceCount(t);
  }
  setLineJitterRadius(t) {
    this._sc.setLineJitterRadius(t);
  }
  setLineJitterFrequency(t) {
    this._sc.setLineJitterFrequency(t);
  }
}
const Uy = () => new window.XMLHttpRequest();
function Qy(n, t) {
  let e, i, s, r;
  t || (t = {}), typeof t == "function" ? (r = t, t = {}) : typeof t.callback == "function" && (r = t.callback), !r && typeof Promise < "u" ? e = new Promise(function(o, a) {
    i = o, s = a;
  }) : (i = function(o) {
    r(null, o);
  }, s = function(o) {
    r(o, null);
  });
  try {
    const o = Uy();
    if (o.open("GET", n, !0), "responseType" in o && (o.responseType = "arraybuffer"), o.overrideMimeType && o.overrideMimeType("text/plain; charset=x-user-defined"), o.onreadystatechange = function() {
      if (o.readyState === 4)
        if (o.status === 200 || o.status === 0)
          try {
            i(o.response ?? o.responseText);
          } catch (a) {
            s(a);
          }
        else
          s(new Error("Ajax error for " + n + " : " + this.status + " " + this.statusText));
    }, t.progress) {
      const a = t.progress;
      o.onprogress = function(l) {
        a({
          path: n,
          originalEvent: l,
          percent: l.loaded / l.total * 100,
          loaded: l.loaded,
          total: l.total
        });
      };
    }
    o.send();
  } catch (o) {
    s(o, null);
  }
  return e;
}
class qy {
  constructor(t) {
    this._id = 0, this._bcfMap = /* @__PURE__ */ new Map(), this._viewer = t;
  }
  _getId() {
    return ++this._id;
  }
  /**
   * Gets a map containing BCF data correlated with the BCF filename.
   */
  getBCFMap() {
    return this._bcfMap;
  }
  /**
   * Gets the parsed BCF data for a BCF file.
   * @param id corresponding to the BCF file.
   */
  getBCFData(t) {
    return this._bcfMap.get(t) || null;
  }
  /**
   * Removes the parsed BCF data for a BCF file.
   * @param id corresponding to the BCF file.
   */
  removeBCFData(t) {
    this._bcfMap.delete(t), this._viewer.trigger("bcfRemoved", t);
  }
  /**
   * Creates a BCF file.
   * @param filename
   */
  createBCFData(t) {
    const e = this._getId(), i = new Oa(t, e);
    return this._bcfMap.set(e, i), this._viewer.trigger("bcfLoaded", i.getId(), i.getFilename()), i;
  }
  /**
   * Imports BCF data from a BCF file.
   * @param filename
   */
  async addBCFFromFile(t) {
    const e = this._getId(), i = new Oa(t, e);
    this._bcfMap.set(e, i);
    const s = await new V_.external.Promise((r, o) => {
      Qy(t, (a, l) => {
        a ? o(a) : r(l);
      });
    });
    await this._loadBCFData(s, i);
  }
  /**
   * Imports BCF data from a buffer.
   * @param buffer
   * @param filename
   */
  async addBCFFromBuffer(t, e) {
    const i = this._getId(), s = new Oa(e, i);
    this._bcfMap.set(i, s), await this._loadBCFData(t, s);
  }
  async _getVersion(t) {
    const e = t.file("bcf.version");
    if (e === null)
      return pn.v1_0;
    {
      const r = (await this._getDocument(e)).documentElement.firstElementChild;
      if (r != null && r.textContent)
        switch (r.textContent) {
          case "2.0 RC":
            return pn.v2_0;
          case "2.1":
            return pn.v2_1;
        }
      return pn.Unknown;
    }
  }
  async _loadBCFData(t, e) {
    const i = this._viewer.model, s = await i.getModelBounding(!0, !1), r = i.getNodeUnitMultiplier(i.getAbsoluteRootNode()), o = e.getId(), a = e.getFilename(), l = await Xl.loadAsync(t);
    e.setVersion(await this._getVersion(l));
    const c = [];
    l.forEach(async (h) => {
      const u = ye();
      c.push(u);
      const p = this._getFileType(h);
      if (p === Ci.Markup || p === Ci.Snapshot || p === Ci.Viewpoint) {
        const m = h.split("/"), g = m[0], _ = m[1];
        let y = e.getTopic(g);
        if (y === null && (y = new Ol(o, a, g, this._viewer), e.addTopic(g, y)), _.length) {
          const b = l.file(h);
          if (b !== null)
            switch (p) {
              case Ci.Markup:
                y.addMarkup(_, await this._getDocument(b));
                break;
              case Ci.Viewpoint:
                y.addViewpoint(
                  _,
                  await this._getDocument(b),
                  e.getVersion(),
                  s,
                  r
                );
                break;
              case Ci.Snapshot:
                y.addSnapshot(_, await b.async("uint8array"));
                break;
            }
        }
      }
      u.resolve();
    }), await zt(c), this._viewer.trigger("bcfLoaded", o, a);
  }
  async _getDocument(t) {
    return new DOMParser().parseFromString(await t.async("text"), "application/xml");
  }
  _getFileType(t) {
    if (t.slice(-1) === "/")
      return Ci.TopicFolder;
    const e = t.split(".");
    switch (console.assert(e.length === 2), e[1]) {
      case "bcf":
        return Ci.Markup;
      case "bcfv":
        return Ci.Viewpoint;
      case "png":
        return Ci.Snapshot;
      case "version":
        return Ci.Version;
      case "xsd":
        return Ci.Schema;
      case "bcfp":
        return Ci.Project;
    }
    return Ci.Unknown;
  }
}
class $y {
  constructor(t, e) {
    this._callbackManager = t, this._operatorManager = e, this._contextEventChecker = new tb(this._callbackManager);
  }
  injectMouseDownEvent(t, e, i, s, r) {
    const o = new Qn(t, e, i, s, r, Vn.Down), a = kt.MouseDown;
    this._callbackManager.trigger("_inputInteraction", o, a), this._operatorManager.injectEvent(o, a), this._contextEventChecker.onMouseDownEvent(o);
  }
  injectMouseMoveEvent(t, e, i, s, r) {
    const o = new Qn(t, e, i, s, r, Vn.Move), a = kt.MouseMove;
    this._callbackManager.trigger("_inputInteraction", o, a), this._operatorManager.injectEvent(o, a);
  }
  injectMouseUpEvent(t, e, i, s, r) {
    const o = new Qn(t, e, i, s, r, Vn.Up), a = kt.MouseUp;
    this._callbackManager.trigger("_inputInteraction", o, a), this._operatorManager.injectEvent(o, a), this._contextEventChecker.onMouseUpEvent(o);
  }
  injectMousewheelEvent(t, e, i, s, r) {
    const o = new gm(t, e, i, s, r, Vn.Wheel), a = kt.Mousewheel;
    this._callbackManager.trigger("_inputInteraction", o, a), this._operatorManager.injectEvent(o, a);
  }
  injectKeyDownEvent(t, e) {
    const i = new Lc(t, e, kc.Down), s = kt.KeyDown;
    this._callbackManager.trigger("_inputInteraction", i, s), this._operatorManager.injectEvent(i, s);
  }
  injectKeyUpEvent(t, e) {
    const i = new Lc(t, e, kc.Up), s = kt.KeyUp;
    this._callbackManager.trigger("_inputInteraction", i, s), this._operatorManager.injectEvent(i, s);
  }
  injectTouchStartEvent(t, e, i, s) {
    const r = new Ja(t, e, i, s, La.Start), o = kt.TouchStart;
    this._callbackManager.trigger("_inputInteraction", r, o), this._operatorManager.injectEvent(r, o), this._contextEventChecker.onTouchStartEvent(r);
  }
  injectTouchMoveEvent(t, e, i, s) {
    const r = new Ja(t, e, i, s, La.Start), o = kt.TouchMove;
    this._callbackManager.trigger("_inputInteraction", r, o), this._operatorManager.injectEvent(r, o), this._contextEventChecker.onTouchMoveEvent(r);
  }
  injectTouchEndEvent(t, e, i, s) {
    const r = new Ja(t, e, i, s, La.End), o = kt.TouchEnd;
    this._callbackManager.trigger("_inputInteraction", r, o), this._operatorManager.injectEvent(r, o), this._contextEventChecker.onTouchEndEvent(r);
  }
  injectViewOrientationChangeEvent() {
    this._operatorManager._injectViewOrientationChangeEvent();
  }
}
class tb {
  constructor(t) {
    this._contextMenuMouseButton = Kt.Right, this._contextMenuPositionStart = E.zero(), this._touchTimer = new Os(), this._activeTouchCount = 0, this._initialPosition = E.zero(), this._callbackManager = t;
  }
  onMouseDownEvent(t) {
    t.getHandled() || this._contextMenuPositionStart.assign(t.getPosition());
  }
  onMouseUpEvent(t) {
    if (!t.getHandled()) {
      const e = t.getPosition();
      t.getButton() === this._contextMenuMouseButton && this._contextMenuPositionStart.equals(e) && this._callbackManager.trigger("contextMenu", e, t.getModifiers());
    }
  }
  onTouchStartEvent(t) {
    const e = t.getPosition().copy();
    this._activeTouchCount === 0 && (this._initialPosition = e), ++this._activeTouchCount, t.getHandled() || this._touchTimer.set(600, () => {
      this._callbackManager.trigger("contextMenu", e, _e.None);
    });
  }
  onTouchMoveEvent(t) {
    if (!this._touchTimer.isIdle(mi.BeforeAction)) {
      const e = E.subtract(this._initialPosition, t.getPosition()), i = Math.abs(e.squaredLength()), s = window.outerHeight * 0.02, r = s * s;
      i > r && this._touchTimer.clear();
    }
  }
  onTouchEndEvent(t) {
    this._activeTouchCount > 0 && --this._activeTouchCount, this._touchTimer.clear();
  }
}
class eb {
  constructor() {
    this._activeInterpolation = null, this._updateTimer = new Os(), this._updateInterval = 16;
  }
  stop() {
    this._activeInterpolation && this._activeInterpolation.stop(), this._activeInterpolation = null, this._updateTimer.clear();
  }
  start(t, e = !0) {
    return this._activeInterpolation && !e ? !1 : (this.stop(), this._activeInterpolation = t, this._activeInterpolation.start(), this.update(), !0);
  }
  update() {
    if (this._activeInterpolation)
      if (this._activeInterpolation.update(), this._activeInterpolation.isComplete()) {
        const t = this._activeInterpolation.getCallback();
        t !== null && t();
      } else
        this._updateTimer.isIdle(mi.BeforeAction) && this._updateTimer.set(this._updateInterval, () => {
          this.update();
        });
  }
}
class Gr {
  constructor(t, e, i, s, r) {
    this._container = t, this._canvasContainerElement = e, this._markupSvgElement = i, this._redlineSvgElement = s, this._redlineElement = r;
  }
  getCanvasContainerElement() {
    return this._canvasContainerElement;
  }
  getMarkupSvgElement() {
    return this._markupSvgElement;
  }
  getRedlineSvgElement() {
    return this._redlineSvgElement;
  }
  getRedlineElement() {
    return this._redlineElement;
  }
  shutdown() {
    this._container.removeChild(this._markupSvgElement), this._container.removeChild(this._redlineSvgElement), this._container.removeChild(this._redlineElement), this._container.removeChild(this._canvasContainerElement);
  }
  static createFromElement(t) {
    let e = t.id;
    e.length === 0 && (e = Qi());
    const i = `${e}-canvas-container`, s = `${e}-svg`, r = `${e}-redline-svg`, o = `${e}-redline`, a = document.createElement("div");
    a.id = i, a.style.width = "100%", a.style.height = "100%", a.style.position = "absolute", a.tabIndex = -1, a.classList.add("webviewer-canvas"), a.oncontextmenu = () => !1, t.appendChild(a);
    const l = Gr._createSvgElement(s);
    t.appendChild(l);
    const c = Gr._createSvgElement(r);
    t.appendChild(c);
    const h = document.createElement("div");
    return h.id = o, h.style.position = "absolute", h.style.width = "100%", h.style.height = "100%", h.style.pointerEvents = "none", t.appendChild(h), new Gr(
      t,
      a,
      l,
      c,
      h
    );
  }
  static createFromId(t) {
    const e = document.getElementById(t);
    return e === null ? null : this.createFromElement(e);
  }
  static _createSvgElement(t) {
    const e = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    return e.id = t, e.style.width = "100%", e.style.height = "100%", e.style.position = "absolute", e.style.pointerEvents = "none", e.style.overflow = "hidden", e.setAttributeNS(
      "http://www.w3.org/2000/xmlns/",
      "xmlns:xlink",
      "http://www.w3.org/1999/xlink"
    ), e;
  }
}
class ib {
  constructor() {
    this.left = 0, this.top = 0;
  }
}
const $e = class {
  constructor(n, t) {
    this._isIE = !1, this._isFirefox = !1, this._canvas = null, this._canvasEventFunctions = /* @__PURE__ */ new Map(), this._documentEventFunctions = /* @__PURE__ */ new Map(), this._pointerEventsEnabled = !0, this._processInput = !1, this._eventsBound = !1, this._dragStarted = !1, this._captureInput = !1, this._elementOffset = new ib(), this._pointerUp = !1, this._buttons = Ai.None, this._eventDispatcher = n, this._timeoutMonitor = t, this._document = document;
    const e = navigator.userAgent.toLowerCase();
    this._isIE = e.indexOf("trident") >= 0 || e.indexOf("edge") >= 0, this._isFirefox = e.indexOf("firefox") > -1;
  }
  _tryLockEventDispatcher() {
    return !$e._activeEventDispatcherLocked || $e._activeEventDispatcher === this._eventDispatcher ? (this._calculateElementOffset(), $e._activeEventDispatcher = this._eventDispatcher, $e._activeOffset = this._elementOffset, $e._activeEventDispatcherLocked = !0, !0) : !1;
  }
  _unlockEventDispatcher() {
    $e._activeEventDispatcherLocked = !1;
  }
  shutdown() {
    this.unbindEvents();
  }
  setDocument(n) {
    this._unbindDocumentEvents(), this._document = n, this._initDocumentEvents();
  }
  setOptions(n) {
    n.hasOwnProperty("usePointerEvents") && this.setPointerEventsEnabled(!!n.usePointerEvents);
  }
  elementResize() {
    this._calculateElementOffset();
  }
  setPointerEventsEnabled(n) {
    this._pointerEventsEnabled = n;
  }
  getPointerEventsEnabled() {
    return this._pointerEventsEnabled;
  }
  _browserSupportsPointerEvents() {
    return window.hasOwnProperty("PointerEvent");
  }
  _usePointerEvents() {
    return this._browserSupportsPointerEvents() && this._pointerEventsEnabled && this._isIE;
  }
  _calculateElementOffset() {
    if (this._canvas !== null) {
      const n = this._canvas.getBoundingClientRect();
      this._elementOffset.left = n.left, this._elementOffset.top = n.top;
    }
  }
  _initDocumentEvents() {
    this._usePointerEvents() ? (this._bindDocumentEvent("pointermove", (n) => {
      this._processDocumentPointerMove(n);
    }), this._bindDocumentEvent("pointerup", (n) => {
      this._processDocumentPointerUp(n);
    })) : (this._bindDocumentEvent("mousemove", (n) => {
      this._processDocumentMouseMove(n);
    }), this._bindDocumentEvent("mouseup", (n) => {
      this._processDocumentMouseUp(n);
    }));
  }
  _initCanvasEvents() {
    this._usePointerEvents() ? (this._bindCanvasEvent("pointerdown", (n) => {
      this._processPointerDown(n);
    }), this._bindCanvasEvent("pointermove", (n) => {
      this._processPointerMove(n);
    }), this._bindCanvasEvent("pointerup", (n) => {
      this._processPointerUp(n);
    }), this._bindCanvasEvent("pointerenter", (n) => {
      this._processPointerEnter(n);
    }), this._bindCanvasEvent("pointerleave", (n) => {
      this._processPointerLeave(n);
    })) : (this._bindCanvasEvent("mousedown", (n) => {
      this._processMouseDown(n);
    }), this._bindCanvasEvent("mousemove", (n) => {
      this._processMouseMove(n);
    }), this._bindCanvasEvent("mouseup", (n) => {
      this._processMouseUp(n);
    }), this._bindCanvasEvent("mouseenter", (n) => {
      this._processMouseEnter(n);
    }), this._bindCanvasEvent("mouseleave", (n) => {
      this._processMouseLeave(n);
    }), this._bindCanvasEvent("touchstart", (n) => {
      this._processTouchStart(n);
    }), this._bindCanvasEvent("touchmove", (n) => {
      this._processTouchMove(n);
    }), this._bindCanvasEvent("touchend", (n) => {
      this._processTouchEnd(n);
    }), this._bindCanvasEvent("touchcancel", (n) => {
      this._processTouchEnd(n);
    })), this._isFirefox ? this._bindCanvasEvent("DOMMouseScroll", (n) => {
      this._processMousewheel(n);
    }) : this._bindCanvasEvent("mousewheel", (n) => {
      this._processMousewheel(n);
    }), this._bindCanvasEvent("keydown", (n) => {
      this._processKeyDownEvent(n);
    }), this._bindCanvasEvent("keyup", (n) => {
      this._processKeyUpEvent(n);
    });
  }
  bindEvents(n) {
    this._eventsBound || (this._canvas = n, this.elementResize(), this._processInput = !0, this._initCanvasEvents(), this._initDocumentEvents(), this._eventsBound = !0);
  }
  _bindDocumentEvent(n, t) {
    if (this._document === null)
      return;
    const e = this._documentEventFunctions.get(n);
    e !== void 0 && this._document.removeEventListener(n, e), this._documentEventFunctions.set(n, t), this._document.addEventListener(n, t);
  }
  _bindCanvasEvent(n, t) {
    if (this._canvas === null)
      return;
    const e = this._canvasEventFunctions.get(n);
    e !== void 0 && this._canvas.removeEventListener(n, e), this._canvasEventFunctions.set(n, t), this._canvas.addEventListener(n, t);
  }
  _unbindDocumentEvents() {
    this._documentEventFunctions.forEach((n, t) => {
      this._document.removeEventListener(t, n);
    }), this._documentEventFunctions.clear();
  }
  _unbindCanvasEvents() {
    this._canvas !== null && (this._canvasEventFunctions.forEach((n, t) => {
      this._canvas.removeEventListener(t, n);
    }), this._canvasEventFunctions.clear()), console.assert(this._canvasEventFunctions.size === 0);
  }
  unbindEvents() {
    this._unbindCanvasEvents(), this._unbindDocumentEvents(), this._processInput = !1, this._eventsBound = !1, $e._activeEventDispatcher === this._eventDispatcher && this._unlockEventDispatcher();
  }
  _convertEventCoordsToTargetCoords(n, t, e = !0) {
    let i;
    return e && $e._activeOffset !== null ? i = $e._activeOffset : i = this._elementOffset, new E(n - i.left, t - i.top);
  }
  focusInput(n) {
    this._canvas !== null && (n ? this._canvas.focus() : this._canvas.blur());
  }
  _setButtons(n) {
    n.buttons && (this._buttons = n.buttons);
  }
  ////Mouse Events
  _processMouseDown(n) {
    if (this._tryLockEventDispatcher()) {
      switch (n.button) {
        case 0:
          this._buttons |= Ai.Left;
          break;
        case 1:
          this._buttons |= Ai.Middle;
          break;
        case 2:
          this._buttons |= Ai.Right;
          break;
      }
      if (n.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput) {
        const t = this._convertEventCoordsToTargetCoords(n.clientX, n.clientY), e = this._getEventModifiers(n);
        $e._activeEventDispatcher.injectMouseDownEvent(
          t.x,
          t.y,
          n.button,
          this._buttons,
          e
        ), this._dragStarted = !0;
      }
    }
  }
  _processMouseMove(n, t = !1) {
    if (n.preventDefault(), this._timeoutMonitor.resetTimeout(), !(!t && !this._tryLockEventDispatcher()) && this._processInput) {
      const e = this._convertEventCoordsToTargetCoords(n.clientX, n.clientY), i = this._getEventModifiers(n);
      $e._activeEventDispatcher !== null && $e._activeEventDispatcher.injectMouseMoveEvent(
        e.x,
        e.y,
        Kt.None,
        this._buttons,
        i
      );
    }
  }
  _processMouseUp(n, t = !1) {
    switch (n.button) {
      case 0:
        this._buttons &= ~Ai.Left;
        break;
      case 1:
        this._buttons &= ~Ai.Middle;
        break;
      case 2:
        this._buttons &= ~Ai.Right;
        break;
    }
    if (n.preventDefault(), this._timeoutMonitor.resetTimeout(), !!this._tryLockEventDispatcher() && (n.stopPropagation(), this._processInput)) {
      const e = this._convertEventCoordsToTargetCoords(n.clientX, n.clientY), i = this._getEventModifiers(n);
      $e._activeEventDispatcher.injectMouseUpEvent(
        e.x,
        e.y,
        n.button,
        this._buttons,
        i
      ), this._buttons === Ai.None && (this._dragStarted = !1, this._captureInput = !1, t && this._unlockEventDispatcher());
    }
  }
  _processMousewheel(n) {
    if (n.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput) {
      let t;
      const e = this._convertEventCoordsToTargetCoords(n.clientX, n.clientY), i = this._getEventModifiers(n);
      this._isFirefox ? t = n.detail > 0 ? -1 : 1 : t = n.wheelDelta > 0 ? 1 : -1, this._eventDispatcher.injectMousewheelEvent(
        e.x,
        e.y,
        t,
        this._buttons,
        i
      );
    }
  }
  _processDocumentMouseMove(n) {
    this._dragStarted && this._captureInput && this._processMouseMove(n, !0);
  }
  _processDocumentMouseUp(n) {
    this._dragStarted && this._captureInput && this._processMouseUp(n, !0);
  }
  _processMouseLeave(n) {
    if (this._dragStarted) {
      this._captureInput = !0;
      return;
    }
    this._unlockEventDispatcher();
  }
  _processMouseEnter(n) {
    this._tryLockEventDispatcher() && this._dragStarted && (this._captureInput = !1);
  }
  //KeyEvents
  _isFunctionKey(n) {
    return 112 <= n.which && n.which <= 123;
  }
  _processKeyDownEvent(n) {
    if (this._isFunctionKey(n) || n.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput) {
      const t = this._getEventModifiers(n);
      this._eventDispatcher.injectKeyDownEvent(
        // tslint:disable-next-line:deprecation
        n.which,
        t
      );
    }
  }
  _processKeyUpEvent(n) {
    if (n.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput) {
      const t = this._getEventModifiers(n);
      this._eventDispatcher.injectKeyUpEvent(
        // tslint:disable-next-line:deprecation
        n.which,
        t
      );
    }
  }
  //Touch Events
  _processTouchStart(n) {
    if (n.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput)
      for (let t = 0; t < n.changedTouches.length; t++) {
        const e = n.changedTouches.item(t), i = this._convertEventCoordsToTargetCoords(e.clientX, e.clientY, !1);
        this._eventDispatcher.injectTouchStartEvent(
          e.identifier,
          i.x,
          i.y,
          this._buttons
        );
      }
  }
  _processTouchMove(n) {
    if (n.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput)
      for (let t = 0; t < n.changedTouches.length; t++) {
        const e = n.changedTouches.item(t), i = this._convertEventCoordsToTargetCoords(e.clientX, e.clientY, !1);
        this._eventDispatcher.injectTouchMoveEvent(
          e.identifier,
          i.x,
          i.y,
          this._buttons
        );
      }
  }
  _processTouchEnd(n) {
    if (n.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput)
      for (let t = 0; t < n.changedTouches.length; t++) {
        const e = n.changedTouches.item(t), i = this._convertEventCoordsToTargetCoords(e.clientX, e.clientY, !1);
        this._eventDispatcher.injectTouchEndEvent(
          e.identifier,
          i.x,
          i.y,
          this._buttons
        );
      }
  }
  //PointerEvents
  _processPointerDown(n) {
    if (this._tryLockEventDispatcher() && (this._setButtons(n), n.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput)) {
      const t = this._convertEventCoordsToTargetCoords(n.clientX, n.clientY), e = this._getEventModifiers(n);
      n.pointerType === "mouse" ? $e._activeEventDispatcher.injectMouseDownEvent(
        t.x,
        t.y,
        n.button,
        this._buttons,
        e
      ) : n.pointerType === "touch" && $e._activeEventDispatcher.injectTouchStartEvent(
        n.pointerId,
        t.x,
        t.y,
        this._buttons
      ), this._pointerUp = !1;
    }
  }
  _processPointerMove(n, t = !1) {
    if (n.preventDefault(), this._timeoutMonitor.resetTimeout(), !(!t && !this._tryLockEventDispatcher()) && (this._setButtons(n), this._processInput)) {
      const e = this._convertEventCoordsToTargetCoords(n.clientX, n.clientY), i = this._getEventModifiers(n);
      $e._activeEventDispatcher !== null && (n.pointerType === "mouse" ? $e._activeEventDispatcher.injectMouseMoveEvent(
        e.x,
        e.y,
        n.button,
        this._buttons,
        i
      ) : n.pointerType === "touch" && $e._activeEventDispatcher.injectTouchMoveEvent(
        n.pointerId,
        e.x,
        e.y,
        this._buttons
      ));
    }
  }
  _processPointerUp(n, t = !1) {
    if (this._setButtons(n), n.preventDefault(), this._timeoutMonitor.resetTimeout(), !!this._tryLockEventDispatcher() && this._processInput) {
      const e = this._convertEventCoordsToTargetCoords(n.clientX, n.clientY), i = this._getEventModifiers(n);
      n.pointerType === "mouse" && !this._pointerUp ? $e._activeEventDispatcher.injectMouseUpEvent(
        e.x,
        e.y,
        n.button,
        this._buttons,
        i
      ) : n.pointerType === "touch" && this._eventDispatcher.injectTouchEndEvent(
        n.pointerId,
        e.x,
        e.y,
        this._buttons
      ), this._buttons === Ai.None && (this._dragStarted = !1, this._captureInput = !1, this._pointerUp = !0, t && this._unlockEventDispatcher());
    }
  }
  _processPointerEnter(n) {
    this._tryLockEventDispatcher() && (this._pointerUp || (this._captureInput = !1));
  }
  _processPointerLeave(n) {
    if (!this._pointerUp) {
      this._captureInput = !0;
      return;
    }
    this._unlockEventDispatcher();
  }
  _processDocumentPointerMove(n) {
    !this._pointerUp && this._captureInput && this._processPointerMove(n, !0);
  }
  _processDocumentPointerUp(n) {
    !this._pointerUp && this._captureInput && this._processPointerUp(n, !0);
  }
  _getEventModifiers(n) {
    let t = _e.None;
    return n.altKey && (t |= _e.Alt), n.ctrlKey && (t |= _e.Control), n.shiftKey && (t |= _e.Shift), n.metaKey && (t |= _e.Command), t;
  }
};
let Ul = $e;
Ul._activeEventDispatcher = null;
Ul._activeEventDispatcherLocked = !1;
Ul._activeOffset = null;
var Ql = { exports: {} }, wo = { exports: {} };
(function() {
  var n, t, e, i, s, r;
  typeof performance < "u" && performance !== null && performance.now ? wo.exports = function() {
    return performance.now();
  } : typeof process < "u" && process !== null && process.hrtime ? (wo.exports = function() {
    return (n() - s) / 1e6;
  }, t = process.hrtime, n = function() {
    var o;
    return o = t(), o[0] * 1e9 + o[1];
  }, i = n(), r = process.uptime() * 1e9, s = i - r) : Date.now ? (wo.exports = function() {
    return Date.now() - e;
  }, e = Date.now()) : (wo.exports = function() {
    return (/* @__PURE__ */ new Date()).getTime() - e;
  }, e = (/* @__PURE__ */ new Date()).getTime());
}).call($s);
var nb = wo.exports, sb = nb, gs = typeof window > "u" ? $s : window, Wa = ["moz", "webkit"], Tr = "AnimationFrame", jr = gs["request" + Tr], aa = gs["cancel" + Tr] || gs["cancelRequest" + Tr];
for (var no = 0; !jr && no < Wa.length; no++)
  jr = gs[Wa[no] + "Request" + Tr], aa = gs[Wa[no] + "Cancel" + Tr] || gs[Wa[no] + "CancelRequest" + Tr];
if (!jr || !aa) {
  var uc = 0, Zu = 0, Bs = [], rb = 1e3 / 60;
  jr = function(n) {
    if (Bs.length === 0) {
      var t = sb(), e = Math.max(0, rb - (t - uc));
      uc = e + t, setTimeout(function() {
        var i = Bs.slice(0);
        Bs.length = 0;
        for (var s = 0; s < i.length; s++)
          if (!i[s].cancelled)
            try {
              i[s].callback(uc);
            } catch (r) {
              setTimeout(function() {
                throw r;
              }, 0);
            }
      }, Math.round(e));
    }
    return Bs.push({
      handle: ++Zu,
      callback: n,
      cancelled: !1
    }), Zu;
  }, aa = function(n) {
    for (var t = 0; t < Bs.length; t++)
      Bs[t].handle === n && (Bs[t].cancelled = !0);
  };
}
Ql.exports = function(n) {
  return jr.call(gs, n);
};
Ql.exports.cancel = function() {
  aa.apply(gs, arguments);
};
Ql.exports.polyfill = function(n) {
  n || (n = gs), n.requestAnimationFrame = jr, n.cancelAnimationFrame = aa;
};
var ob = Ql.exports;
const dc = /* @__PURE__ */ Il(ob);
var ab = function(n) {
  this.ok = !1, this.alpha = 1, n.charAt(0) == "#" && (n = n.substr(1, 6)), n = n.replace(/ /g, ""), n = n.toLowerCase();
  var t = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "00ffff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000000",
    blanchedalmond: "ffebcd",
    blue: "0000ff",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "00ffff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dodgerblue: "1e90ff",
    feldspar: "d19275",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "ff00ff",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgrey: "d3d3d3",
    lightgreen: "90ee90",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslateblue: "8470ff",
    lightslategray: "778899",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "00ff00",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "ff00ff",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370d8",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "d87093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "ff0000",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    violetred: "d02090",
    wheat: "f5deb3",
    white: "ffffff",
    whitesmoke: "f5f5f5",
    yellow: "ffff00",
    yellowgreen: "9acd32"
  };
  n = t[n] || n;
  for (var e = [
    {
      re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
      example: ["rgba(123, 234, 45, 0.8)", "rgba(255,234,245,1.0)"],
      process: function(l) {
        return [
          parseInt(l[1]),
          parseInt(l[2]),
          parseInt(l[3]),
          parseFloat(l[4])
        ];
      }
    },
    {
      re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
      example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
      process: function(l) {
        return [
          parseInt(l[1]),
          parseInt(l[2]),
          parseInt(l[3])
        ];
      }
    },
    {
      re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      example: ["#00ff00", "336699"],
      process: function(l) {
        return [
          parseInt(l[1], 16),
          parseInt(l[2], 16),
          parseInt(l[3], 16)
        ];
      }
    },
    {
      re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      example: ["#fb0", "f0f"],
      process: function(l) {
        return [
          parseInt(l[1] + l[1], 16),
          parseInt(l[2] + l[2], 16),
          parseInt(l[3] + l[3], 16)
        ];
      }
    }
  ], i = 0; i < e.length; i++) {
    var s = e[i].re, r = e[i].process, o = s.exec(n);
    if (o) {
      var a = r(o);
      this.r = a[0], this.g = a[1], this.b = a[2], a.length > 3 && (this.alpha = a[3]), this.ok = !0;
    }
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toRGBA = function() {
    return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.alpha + ")";
  }, this.toHex = function() {
    var l = this.r.toString(16), c = this.g.toString(16), h = this.b.toString(16);
    return l.length == 1 && (l = "0" + l), c.length == 1 && (c = "0" + c), h.length == 1 && (h = "0" + h), "#" + l + c + h;
  }, this.getHelpXML = function() {
    for (var l = new Array(), c = 0; c < e.length; c++)
      for (var h = e[c].example, u = 0; u < h.length; u++)
        l[l.length] = h[u];
    for (var p in t)
      l[l.length] = p;
    var m = document.createElement("ul");
    m.setAttribute("id", "rgbcolor-examples");
    for (var c = 0; c < l.length; c++)
      try {
        var g = document.createElement("li"), _ = new RGBColor(l[c]), y = document.createElement("div");
        y.style.cssText = "margin: 3px; border: 1px solid black; background:" + _.toHex() + "; color:" + _.toHex(), y.appendChild(document.createTextNode("test"));
        var b = document.createTextNode(
          " " + l[c] + " -> " + _.toRGB() + " -> " + _.toHex()
        );
        g.appendChild(y), g.appendChild(b), m.appendChild(g);
      } catch {
      }
    return m;
  };
};
const nh = /* @__PURE__ */ Il(ab);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var wp = function(n, t) {
  return (wp = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var s in i)
      Object.prototype.hasOwnProperty.call(i, s) && (e[s] = i[s]);
  })(n, t);
};
function vp(n, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  function e() {
    this.constructor = n;
  }
  wp(n, t), n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
function lb(n) {
  var t = "";
  Array.isArray(n) || (n = [n]);
  for (var e = 0; e < n.length; e++) {
    var i = n[e];
    if (i.type === at.CLOSE_PATH)
      t += "z";
    else if (i.type === at.HORIZ_LINE_TO)
      t += (i.relative ? "h" : "H") + i.x;
    else if (i.type === at.VERT_LINE_TO)
      t += (i.relative ? "v" : "V") + i.y;
    else if (i.type === at.MOVE_TO)
      t += (i.relative ? "m" : "M") + i.x + " " + i.y;
    else if (i.type === at.LINE_TO)
      t += (i.relative ? "l" : "L") + i.x + " " + i.y;
    else if (i.type === at.CURVE_TO)
      t += (i.relative ? "c" : "C") + i.x1 + " " + i.y1 + " " + i.x2 + " " + i.y2 + " " + i.x + " " + i.y;
    else if (i.type === at.SMOOTH_CURVE_TO)
      t += (i.relative ? "s" : "S") + i.x2 + " " + i.y2 + " " + i.x + " " + i.y;
    else if (i.type === at.QUAD_TO)
      t += (i.relative ? "q" : "Q") + i.x1 + " " + i.y1 + " " + i.x + " " + i.y;
    else if (i.type === at.SMOOTH_QUAD_TO)
      t += (i.relative ? "t" : "T") + i.x + " " + i.y;
    else {
      if (i.type !== at.ARC)
        throw new Error('Unexpected command type "' + i.type + '" at index ' + e + ".");
      t += (i.relative ? "a" : "A") + i.rX + " " + i.rY + " " + i.xRot + " " + +i.lArcFlag + " " + +i.sweepFlag + " " + i.x + " " + i.y;
    }
  }
  return t;
}
function sh(n, t) {
  var e = n[0], i = n[1];
  return [e * Math.cos(t) - i * Math.sin(t), e * Math.sin(t) + i * Math.cos(t)];
}
function Cn() {
  for (var n = [], t = 0; t < arguments.length; t++)
    n[t] = arguments[t];
  for (var e = 0; e < n.length; e++)
    if (typeof n[e] != "number")
      throw new Error("assertNumbers arguments[" + e + "] is not a number. " + typeof n[e] + " == typeof " + n[e]);
  return !0;
}
var Cs = Math.PI;
function mc(n, t, e) {
  n.lArcFlag = n.lArcFlag === 0 ? 0 : 1, n.sweepFlag = n.sweepFlag === 0 ? 0 : 1;
  var i = n.rX, s = n.rY, r = n.x, o = n.y;
  i = Math.abs(n.rX), s = Math.abs(n.rY);
  var a = sh([(t - r) / 2, (e - o) / 2], -n.xRot / 180 * Cs), l = a[0], c = a[1], h = Math.pow(l, 2) / Math.pow(i, 2) + Math.pow(c, 2) / Math.pow(s, 2);
  1 < h && (i *= Math.sqrt(h), s *= Math.sqrt(h)), n.rX = i, n.rY = s;
  var u = Math.pow(i, 2) * Math.pow(c, 2) + Math.pow(s, 2) * Math.pow(l, 2), p = (n.lArcFlag !== n.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(i, 2) * Math.pow(s, 2) - u) / u)), m = i * c / s * p, g = -s * l / i * p, _ = sh([m, g], n.xRot / 180 * Cs);
  n.cX = _[0] + (t + r) / 2, n.cY = _[1] + (e + o) / 2, n.phi1 = Math.atan2((c - g) / s, (l - m) / i), n.phi2 = Math.atan2((-c - g) / s, (-l - m) / i), n.sweepFlag === 0 && n.phi2 > n.phi1 && (n.phi2 -= 2 * Cs), n.sweepFlag === 1 && n.phi2 < n.phi1 && (n.phi2 += 2 * Cs), n.phi1 *= 180 / Cs, n.phi2 *= 180 / Cs;
}
function Cu(n, t, e) {
  Cn(n, t, e);
  var i = n * n + t * t - e * e;
  if (0 > i)
    return [];
  if (i === 0)
    return [[n * e / (n * n + t * t), t * e / (n * n + t * t)]];
  var s = Math.sqrt(i);
  return [[(n * e + t * s) / (n * n + t * t), (t * e - n * s) / (n * n + t * t)], [(n * e - t * s) / (n * n + t * t), (t * e + n * s) / (n * n + t * t)]];
}
var ti, is = Math.PI / 180;
function ku(n, t, e) {
  return (1 - e) * n + e * t;
}
function Mu(n, t, e, i) {
  return n + Math.cos(i / 180 * Cs) * t + Math.sin(i / 180 * Cs) * e;
}
function Wu(n, t, e, i) {
  var s = 1e-6, r = t - n, o = e - t, a = 3 * r + 3 * (i - e) - 6 * o, l = 6 * (o - r), c = 3 * r;
  return Math.abs(a) < s ? [-c / l] : function(h, u, p) {
    p === void 0 && (p = 1e-6);
    var m = h * h / 4 - u;
    if (m < -p)
      return [];
    if (m <= p)
      return [-h / 2];
    var g = Math.sqrt(m);
    return [-h / 2 - g, -h / 2 + g];
  }(l / a, c / a, s);
}
function Pu(n, t, e, i, s) {
  var r = 1 - s;
  return n * (r * r * r) + t * (3 * r * r * s) + e * (3 * r * s * s) + i * (s * s * s);
}
(function(n) {
  function t() {
    return s(function(a, l, c) {
      return a.relative && (a.x1 !== void 0 && (a.x1 += l), a.y1 !== void 0 && (a.y1 += c), a.x2 !== void 0 && (a.x2 += l), a.y2 !== void 0 && (a.y2 += c), a.x !== void 0 && (a.x += l), a.y !== void 0 && (a.y += c), a.relative = !1), a;
    });
  }
  function e() {
    var a = NaN, l = NaN, c = NaN, h = NaN;
    return s(function(u, p, m) {
      return u.type & at.SMOOTH_CURVE_TO && (u.type = at.CURVE_TO, a = isNaN(a) ? p : a, l = isNaN(l) ? m : l, u.x1 = u.relative ? p - a : 2 * p - a, u.y1 = u.relative ? m - l : 2 * m - l), u.type & at.CURVE_TO ? (a = u.relative ? p + u.x2 : u.x2, l = u.relative ? m + u.y2 : u.y2) : (a = NaN, l = NaN), u.type & at.SMOOTH_QUAD_TO && (u.type = at.QUAD_TO, c = isNaN(c) ? p : c, h = isNaN(h) ? m : h, u.x1 = u.relative ? p - c : 2 * p - c, u.y1 = u.relative ? m - h : 2 * m - h), u.type & at.QUAD_TO ? (c = u.relative ? p + u.x1 : u.x1, h = u.relative ? m + u.y1 : u.y1) : (c = NaN, h = NaN), u;
    });
  }
  function i() {
    var a = NaN, l = NaN;
    return s(function(c, h, u) {
      if (c.type & at.SMOOTH_QUAD_TO && (c.type = at.QUAD_TO, a = isNaN(a) ? h : a, l = isNaN(l) ? u : l, c.x1 = c.relative ? h - a : 2 * h - a, c.y1 = c.relative ? u - l : 2 * u - l), c.type & at.QUAD_TO) {
        a = c.relative ? h + c.x1 : c.x1, l = c.relative ? u + c.y1 : c.y1;
        var p = c.x1, m = c.y1;
        c.type = at.CURVE_TO, c.x1 = ((c.relative ? 0 : h) + 2 * p) / 3, c.y1 = ((c.relative ? 0 : u) + 2 * m) / 3, c.x2 = (c.x + 2 * p) / 3, c.y2 = (c.y + 2 * m) / 3;
      } else
        a = NaN, l = NaN;
      return c;
    });
  }
  function s(a) {
    var l = 0, c = 0, h = NaN, u = NaN;
    return function(p) {
      if (isNaN(h) && !(p.type & at.MOVE_TO))
        throw new Error("path must start with moveto");
      var m = a(p, l, c, h, u);
      return p.type & at.CLOSE_PATH && (l = h, c = u), p.x !== void 0 && (l = p.relative ? l + p.x : p.x), p.y !== void 0 && (c = p.relative ? c + p.y : p.y), p.type & at.MOVE_TO && (h = l, u = c), m;
    };
  }
  function r(a, l, c, h, u, p) {
    return Cn(a, l, c, h, u, p), s(function(m, g, _, y) {
      var b = m.x1, w = m.x2, v = m.relative && !isNaN(y), C = m.x !== void 0 ? m.x : v ? 0 : g, k = m.y !== void 0 ? m.y : v ? 0 : _;
      function Y(O) {
        return O * O;
      }
      m.type & at.HORIZ_LINE_TO && l !== 0 && (m.type = at.LINE_TO, m.y = m.relative ? 0 : _), m.type & at.VERT_LINE_TO && c !== 0 && (m.type = at.LINE_TO, m.x = m.relative ? 0 : g), m.x !== void 0 && (m.x = m.x * a + k * c + (v ? 0 : u)), m.y !== void 0 && (m.y = C * l + m.y * h + (v ? 0 : p)), m.x1 !== void 0 && (m.x1 = m.x1 * a + m.y1 * c + (v ? 0 : u)), m.y1 !== void 0 && (m.y1 = b * l + m.y1 * h + (v ? 0 : p)), m.x2 !== void 0 && (m.x2 = m.x2 * a + m.y2 * c + (v ? 0 : u)), m.y2 !== void 0 && (m.y2 = w * l + m.y2 * h + (v ? 0 : p));
      var P = a * h - l * c;
      if (m.xRot !== void 0 && (a !== 1 || l !== 0 || c !== 0 || h !== 1))
        if (P === 0)
          delete m.rX, delete m.rY, delete m.xRot, delete m.lArcFlag, delete m.sweepFlag, m.type = at.LINE_TO;
        else {
          var L = m.xRot * Math.PI / 180, N = Math.sin(L), D = Math.cos(L), B = 1 / Y(m.rX), V = 1 / Y(m.rY), X = Y(D) * B + Y(N) * V, Z = 2 * N * D * (B - V), W = Y(N) * B + Y(D) * V, st = X * h * h - Z * l * h + W * l * l, j = Z * (a * h + l * c) - 2 * (X * c * h + W * a * l), gt = X * c * c - Z * a * c + W * a * a, U = (Math.atan2(j, st - gt) + Math.PI) % Math.PI / 2, ht = Math.sin(U), z = Math.cos(U);
          m.rX = Math.abs(P) / Math.sqrt(st * Y(z) + j * ht * z + gt * Y(ht)), m.rY = Math.abs(P) / Math.sqrt(st * Y(ht) - j * ht * z + gt * Y(z)), m.xRot = 180 * U / Math.PI;
        }
      return m.sweepFlag !== void 0 && 0 > P && (m.sweepFlag = +!m.sweepFlag), m;
    });
  }
  function o() {
    return function(a) {
      var l = {};
      for (var c in a)
        l[c] = a[c];
      return l;
    };
  }
  n.ROUND = function(a) {
    function l(c) {
      return Math.round(c * a) / a;
    }
    return a === void 0 && (a = 1e13), Cn(a), function(c) {
      return c.x1 !== void 0 && (c.x1 = l(c.x1)), c.y1 !== void 0 && (c.y1 = l(c.y1)), c.x2 !== void 0 && (c.x2 = l(c.x2)), c.y2 !== void 0 && (c.y2 = l(c.y2)), c.x !== void 0 && (c.x = l(c.x)), c.y !== void 0 && (c.y = l(c.y)), c.rX !== void 0 && (c.rX = l(c.rX)), c.rY !== void 0 && (c.rY = l(c.rY)), c;
    };
  }, n.TO_ABS = t, n.TO_REL = function() {
    return s(function(a, l, c) {
      return a.relative || (a.x1 !== void 0 && (a.x1 -= l), a.y1 !== void 0 && (a.y1 -= c), a.x2 !== void 0 && (a.x2 -= l), a.y2 !== void 0 && (a.y2 -= c), a.x !== void 0 && (a.x -= l), a.y !== void 0 && (a.y -= c), a.relative = !0), a;
    });
  }, n.NORMALIZE_HVZ = function(a, l, c) {
    return a === void 0 && (a = !0), l === void 0 && (l = !0), c === void 0 && (c = !0), s(function(h, u, p, m, g) {
      if (isNaN(m) && !(h.type & at.MOVE_TO))
        throw new Error("path must start with moveto");
      return l && h.type & at.HORIZ_LINE_TO && (h.type = at.LINE_TO, h.y = h.relative ? 0 : p), c && h.type & at.VERT_LINE_TO && (h.type = at.LINE_TO, h.x = h.relative ? 0 : u), a && h.type & at.CLOSE_PATH && (h.type = at.LINE_TO, h.x = h.relative ? m - u : m, h.y = h.relative ? g - p : g), h.type & at.ARC && (h.rX === 0 || h.rY === 0) && (h.type = at.LINE_TO, delete h.rX, delete h.rY, delete h.xRot, delete h.lArcFlag, delete h.sweepFlag), h;
    });
  }, n.NORMALIZE_ST = e, n.QT_TO_C = i, n.INFO = s, n.SANITIZE = function(a) {
    a === void 0 && (a = 0), Cn(a);
    var l = NaN, c = NaN, h = NaN, u = NaN;
    return s(function(p, m, g, _, y) {
      var b = Math.abs, w = !1, v = 0, C = 0;
      if (p.type & at.SMOOTH_CURVE_TO && (v = isNaN(l) ? 0 : m - l, C = isNaN(c) ? 0 : g - c), p.type & (at.CURVE_TO | at.SMOOTH_CURVE_TO) ? (l = p.relative ? m + p.x2 : p.x2, c = p.relative ? g + p.y2 : p.y2) : (l = NaN, c = NaN), p.type & at.SMOOTH_QUAD_TO ? (h = isNaN(h) ? m : 2 * m - h, u = isNaN(u) ? g : 2 * g - u) : p.type & at.QUAD_TO ? (h = p.relative ? m + p.x1 : p.x1, u = p.relative ? g + p.y1 : p.y2) : (h = NaN, u = NaN), p.type & at.LINE_COMMANDS || p.type & at.ARC && (p.rX === 0 || p.rY === 0 || !p.lArcFlag) || p.type & at.CURVE_TO || p.type & at.SMOOTH_CURVE_TO || p.type & at.QUAD_TO || p.type & at.SMOOTH_QUAD_TO) {
        var k = p.x === void 0 ? 0 : p.relative ? p.x : p.x - m, Y = p.y === void 0 ? 0 : p.relative ? p.y : p.y - g;
        v = isNaN(h) ? p.x1 === void 0 ? v : p.relative ? p.x : p.x1 - m : h - m, C = isNaN(u) ? p.y1 === void 0 ? C : p.relative ? p.y : p.y1 - g : u - g;
        var P = p.x2 === void 0 ? 0 : p.relative ? p.x : p.x2 - m, L = p.y2 === void 0 ? 0 : p.relative ? p.y : p.y2 - g;
        b(k) <= a && b(Y) <= a && b(v) <= a && b(C) <= a && b(P) <= a && b(L) <= a && (w = !0);
      }
      return p.type & at.CLOSE_PATH && b(m - _) <= a && b(g - y) <= a && (w = !0), w ? [] : p;
    });
  }, n.MATRIX = r, n.ROTATE = function(a, l, c) {
    l === void 0 && (l = 0), c === void 0 && (c = 0), Cn(a, l, c);
    var h = Math.sin(a), u = Math.cos(a);
    return r(u, h, -h, u, l - l * u + c * h, c - l * h - c * u);
  }, n.TRANSLATE = function(a, l) {
    return l === void 0 && (l = 0), Cn(a, l), r(1, 0, 0, 1, a, l);
  }, n.SCALE = function(a, l) {
    return l === void 0 && (l = a), Cn(a, l), r(a, 0, 0, l, 0, 0);
  }, n.SKEW_X = function(a) {
    return Cn(a), r(1, 0, Math.atan(a), 1, 0, 0);
  }, n.SKEW_Y = function(a) {
    return Cn(a), r(1, Math.atan(a), 0, 1, 0, 0);
  }, n.X_AXIS_SYMMETRY = function(a) {
    return a === void 0 && (a = 0), Cn(a), r(-1, 0, 0, 1, a, 0);
  }, n.Y_AXIS_SYMMETRY = function(a) {
    return a === void 0 && (a = 0), Cn(a), r(1, 0, 0, -1, 0, a);
  }, n.A_TO_C = function() {
    return s(function(a, l, c) {
      return at.ARC === a.type ? function(h, u, p) {
        var m, g, _, y;
        h.cX || mc(h, u, p);
        for (var b = Math.min(h.phi1, h.phi2), w = Math.max(h.phi1, h.phi2) - b, v = Math.ceil(w / 90), C = new Array(v), k = u, Y = p, P = 0; P < v; P++) {
          var L = ku(h.phi1, h.phi2, P / v), N = ku(h.phi1, h.phi2, (P + 1) / v), D = N - L, B = 4 / 3 * Math.tan(D * is / 4), V = [Math.cos(L * is) - B * Math.sin(L * is), Math.sin(L * is) + B * Math.cos(L * is)], X = V[0], Z = V[1], W = [Math.cos(N * is), Math.sin(N * is)], st = W[0], j = W[1], gt = [st + B * Math.sin(N * is), j - B * Math.cos(N * is)], U = gt[0], ht = gt[1];
          C[P] = { relative: h.relative, type: at.CURVE_TO };
          var z = function(O, _t) {
            var rt = sh([O * h.rX, _t * h.rY], h.xRot), ut = rt[0], oe = rt[1];
            return [h.cX + ut, h.cY + oe];
          };
          m = z(X, Z), C[P].x1 = m[0], C[P].y1 = m[1], g = z(U, ht), C[P].x2 = g[0], C[P].y2 = g[1], _ = z(st, j), C[P].x = _[0], C[P].y = _[1], h.relative && (C[P].x1 -= k, C[P].y1 -= Y, C[P].x2 -= k, C[P].y2 -= Y, C[P].x -= k, C[P].y -= Y), k = (y = [C[P].x, C[P].y])[0], Y = y[1];
        }
        return C;
      }(a, a.relative ? 0 : l, a.relative ? 0 : c) : a;
    });
  }, n.ANNOTATE_ARCS = function() {
    return s(function(a, l, c) {
      return a.relative && (l = 0, c = 0), at.ARC === a.type && mc(a, l, c), a;
    });
  }, n.CLONE = o, n.CALCULATE_BOUNDS = function() {
    var a = function(p) {
      var m = {};
      for (var g in p)
        m[g] = p[g];
      return m;
    }, l = t(), c = i(), h = e(), u = s(function(p, m, g) {
      var _ = h(c(l(a(p))));
      function y(ht) {
        ht > u.maxX && (u.maxX = ht), ht < u.minX && (u.minX = ht);
      }
      function b(ht) {
        ht > u.maxY && (u.maxY = ht), ht < u.minY && (u.minY = ht);
      }
      if (_.type & at.DRAWING_COMMANDS && (y(m), b(g)), _.type & at.HORIZ_LINE_TO && y(_.x), _.type & at.VERT_LINE_TO && b(_.y), _.type & at.LINE_TO && (y(_.x), b(_.y)), _.type & at.CURVE_TO) {
        y(_.x), b(_.y);
        for (var w = 0, v = Wu(m, _.x1, _.x2, _.x); w < v.length; w++)
          0 < (U = v[w]) && 1 > U && y(Pu(m, _.x1, _.x2, _.x, U));
        for (var C = 0, k = Wu(g, _.y1, _.y2, _.y); C < k.length; C++)
          0 < (U = k[C]) && 1 > U && b(Pu(g, _.y1, _.y2, _.y, U));
      }
      if (_.type & at.ARC) {
        y(_.x), b(_.y), mc(_, m, g);
        for (var Y = _.xRot / 180 * Math.PI, P = Math.cos(Y) * _.rX, L = Math.sin(Y) * _.rX, N = -Math.sin(Y) * _.rY, D = Math.cos(Y) * _.rY, B = _.phi1 < _.phi2 ? [_.phi1, _.phi2] : -180 > _.phi2 ? [_.phi2 + 360, _.phi1 + 360] : [_.phi2, _.phi1], V = B[0], X = B[1], Z = function(ht) {
          var z = ht[0], O = ht[1], _t = 180 * Math.atan2(O, z) / Math.PI;
          return _t < V ? _t + 360 : _t;
        }, W = 0, st = Cu(N, -P, 0).map(Z); W < st.length; W++)
          (U = st[W]) > V && U < X && y(Mu(_.cX, P, N, U));
        for (var j = 0, gt = Cu(D, -L, 0).map(Z); j < gt.length; j++) {
          var U;
          (U = gt[j]) > V && U < X && b(Mu(_.cY, L, D, U));
        }
      }
      return p;
    });
    return u.minX = 1 / 0, u.maxX = -1 / 0, u.minY = 1 / 0, u.maxY = -1 / 0, u;
  };
})(ti || (ti = {}));
var vn, xp = function() {
  function n() {
  }
  return n.prototype.round = function(t) {
    return this.transform(ti.ROUND(t));
  }, n.prototype.toAbs = function() {
    return this.transform(ti.TO_ABS());
  }, n.prototype.toRel = function() {
    return this.transform(ti.TO_REL());
  }, n.prototype.normalizeHVZ = function(t, e, i) {
    return this.transform(ti.NORMALIZE_HVZ(t, e, i));
  }, n.prototype.normalizeST = function() {
    return this.transform(ti.NORMALIZE_ST());
  }, n.prototype.qtToC = function() {
    return this.transform(ti.QT_TO_C());
  }, n.prototype.aToC = function() {
    return this.transform(ti.A_TO_C());
  }, n.prototype.sanitize = function(t) {
    return this.transform(ti.SANITIZE(t));
  }, n.prototype.translate = function(t, e) {
    return this.transform(ti.TRANSLATE(t, e));
  }, n.prototype.scale = function(t, e) {
    return this.transform(ti.SCALE(t, e));
  }, n.prototype.rotate = function(t, e, i) {
    return this.transform(ti.ROTATE(t, e, i));
  }, n.prototype.matrix = function(t, e, i, s, r, o) {
    return this.transform(ti.MATRIX(t, e, i, s, r, o));
  }, n.prototype.skewX = function(t) {
    return this.transform(ti.SKEW_X(t));
  }, n.prototype.skewY = function(t) {
    return this.transform(ti.SKEW_Y(t));
  }, n.prototype.xSymmetry = function(t) {
    return this.transform(ti.X_AXIS_SYMMETRY(t));
  }, n.prototype.ySymmetry = function(t) {
    return this.transform(ti.Y_AXIS_SYMMETRY(t));
  }, n.prototype.annotateArcs = function() {
    return this.transform(ti.ANNOTATE_ARCS());
  }, n;
}(), cb = function(n) {
  return n === " " || n === "	" || n === "\r" || n === `
`;
}, Vu = function(n) {
  return "0".charCodeAt(0) <= n.charCodeAt(0) && n.charCodeAt(0) <= "9".charCodeAt(0);
}, hb = function(n) {
  function t() {
    var e = n.call(this) || this;
    return e.curNumber = "", e.curCommandType = -1, e.curCommandRelative = !1, e.canParseCommandOrComma = !0, e.curNumberHasExp = !1, e.curNumberHasExpDigits = !1, e.curNumberHasDecimal = !1, e.curArgs = [], e;
  }
  return vp(t, n), t.prototype.finish = function(e) {
    if (e === void 0 && (e = []), this.parse(" ", e), this.curArgs.length !== 0 || !this.canParseCommandOrComma)
      throw new SyntaxError("Unterminated command at the path end.");
    return e;
  }, t.prototype.parse = function(e, i) {
    var s = this;
    i === void 0 && (i = []);
    for (var r = function(u) {
      i.push(u), s.curArgs.length = 0, s.canParseCommandOrComma = !0;
    }, o = 0; o < e.length; o++) {
      var a = e[o], l = !(this.curCommandType !== at.ARC || this.curArgs.length !== 3 && this.curArgs.length !== 4 || this.curNumber.length !== 1 || this.curNumber !== "0" && this.curNumber !== "1"), c = Vu(a) && (this.curNumber === "0" && a === "0" || l);
      if (!Vu(a) || c)
        if (a !== "e" && a !== "E")
          if (a !== "-" && a !== "+" || !this.curNumberHasExp || this.curNumberHasExpDigits)
            if (a !== "." || this.curNumberHasExp || this.curNumberHasDecimal || l) {
              if (this.curNumber && this.curCommandType !== -1) {
                var h = Number(this.curNumber);
                if (isNaN(h))
                  throw new SyntaxError("Invalid number ending at " + o);
                if (this.curCommandType === at.ARC) {
                  if (this.curArgs.length === 0 || this.curArgs.length === 1) {
                    if (0 > h)
                      throw new SyntaxError('Expected positive number, got "' + h + '" at index "' + o + '"');
                  } else if ((this.curArgs.length === 3 || this.curArgs.length === 4) && this.curNumber !== "0" && this.curNumber !== "1")
                    throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + o + '"');
                }
                this.curArgs.push(h), this.curArgs.length === ub[this.curCommandType] && (at.HORIZ_LINE_TO === this.curCommandType ? r({ type: at.HORIZ_LINE_TO, relative: this.curCommandRelative, x: h }) : at.VERT_LINE_TO === this.curCommandType ? r({ type: at.VERT_LINE_TO, relative: this.curCommandRelative, y: h }) : this.curCommandType === at.MOVE_TO || this.curCommandType === at.LINE_TO || this.curCommandType === at.SMOOTH_QUAD_TO ? (r({ type: this.curCommandType, relative: this.curCommandRelative, x: this.curArgs[0], y: this.curArgs[1] }), at.MOVE_TO === this.curCommandType && (this.curCommandType = at.LINE_TO)) : this.curCommandType === at.CURVE_TO ? r({ type: at.CURVE_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x2: this.curArgs[2], y2: this.curArgs[3], x: this.curArgs[4], y: this.curArgs[5] }) : this.curCommandType === at.SMOOTH_CURVE_TO ? r({ type: at.SMOOTH_CURVE_TO, relative: this.curCommandRelative, x2: this.curArgs[0], y2: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === at.QUAD_TO ? r({ type: at.QUAD_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === at.ARC && r({ type: at.ARC, relative: this.curCommandRelative, rX: this.curArgs[0], rY: this.curArgs[1], xRot: this.curArgs[2], lArcFlag: this.curArgs[3], sweepFlag: this.curArgs[4], x: this.curArgs[5], y: this.curArgs[6] })), this.curNumber = "", this.curNumberHasExpDigits = !1, this.curNumberHasExp = !1, this.curNumberHasDecimal = !1, this.canParseCommandOrComma = !0;
              }
              if (!cb(a))
                if (a === "," && this.canParseCommandOrComma)
                  this.canParseCommandOrComma = !1;
                else if (a !== "+" && a !== "-" && a !== ".")
                  if (c)
                    this.curNumber = a, this.curNumberHasDecimal = !1;
                  else {
                    if (this.curArgs.length !== 0)
                      throw new SyntaxError("Unterminated command at index " + o + ".");
                    if (!this.canParseCommandOrComma)
                      throw new SyntaxError('Unexpected character "' + a + '" at index ' + o + ". Command cannot follow comma");
                    if (this.canParseCommandOrComma = !1, a !== "z" && a !== "Z")
                      if (a === "h" || a === "H")
                        this.curCommandType = at.HORIZ_LINE_TO, this.curCommandRelative = a === "h";
                      else if (a === "v" || a === "V")
                        this.curCommandType = at.VERT_LINE_TO, this.curCommandRelative = a === "v";
                      else if (a === "m" || a === "M")
                        this.curCommandType = at.MOVE_TO, this.curCommandRelative = a === "m";
                      else if (a === "l" || a === "L")
                        this.curCommandType = at.LINE_TO, this.curCommandRelative = a === "l";
                      else if (a === "c" || a === "C")
                        this.curCommandType = at.CURVE_TO, this.curCommandRelative = a === "c";
                      else if (a === "s" || a === "S")
                        this.curCommandType = at.SMOOTH_CURVE_TO, this.curCommandRelative = a === "s";
                      else if (a === "q" || a === "Q")
                        this.curCommandType = at.QUAD_TO, this.curCommandRelative = a === "q";
                      else if (a === "t" || a === "T")
                        this.curCommandType = at.SMOOTH_QUAD_TO, this.curCommandRelative = a === "t";
                      else {
                        if (a !== "a" && a !== "A")
                          throw new SyntaxError('Unexpected character "' + a + '" at index ' + o + ".");
                        this.curCommandType = at.ARC, this.curCommandRelative = a === "a";
                      }
                    else
                      i.push({ type: at.CLOSE_PATH }), this.canParseCommandOrComma = !0, this.curCommandType = -1;
                  }
                else
                  this.curNumber = a, this.curNumberHasDecimal = a === ".";
            } else
              this.curNumber += a, this.curNumberHasDecimal = !0;
          else
            this.curNumber += a;
        else
          this.curNumber += a, this.curNumberHasExp = !0;
      else
        this.curNumber += a, this.curNumberHasExpDigits = this.curNumberHasExp;
    }
    return i;
  }, t.prototype.transform = function(e) {
    return Object.create(this, { parse: { value: function(i, s) {
      s === void 0 && (s = []);
      for (var r = 0, o = Object.getPrototypeOf(this).parse.call(this, i); r < o.length; r++) {
        var a = o[r], l = e(a);
        Array.isArray(l) ? s.push.apply(s, l) : s.push(l);
      }
      return s;
    } } });
  }, t;
}(xp), at = function(n) {
  function t(e) {
    var i = n.call(this) || this;
    return i.commands = typeof e == "string" ? t.parse(e) : e, i;
  }
  return vp(t, n), t.prototype.encode = function() {
    return t.encode(this.commands);
  }, t.prototype.getBounds = function() {
    var e = ti.CALCULATE_BOUNDS();
    return this.transform(e), e;
  }, t.prototype.transform = function(e) {
    for (var i = [], s = 0, r = this.commands; s < r.length; s++) {
      var o = e(r[s]);
      Array.isArray(o) ? i.push.apply(i, o) : i.push(o);
    }
    return this.commands = i, this;
  }, t.encode = function(e) {
    return lb(e);
  }, t.parse = function(e) {
    var i = new hb(), s = [];
    return i.parse(e, s), i.finish(s), s;
  }, t.CLOSE_PATH = 1, t.MOVE_TO = 2, t.HORIZ_LINE_TO = 4, t.VERT_LINE_TO = 8, t.LINE_TO = 16, t.CURVE_TO = 32, t.SMOOTH_CURVE_TO = 64, t.QUAD_TO = 128, t.SMOOTH_QUAD_TO = 256, t.ARC = 512, t.LINE_COMMANDS = t.LINE_TO | t.HORIZ_LINE_TO | t.VERT_LINE_TO, t.DRAWING_COMMANDS = t.HORIZ_LINE_TO | t.VERT_LINE_TO | t.LINE_TO | t.CURVE_TO | t.SMOOTH_CURVE_TO | t.QUAD_TO | t.SMOOTH_QUAD_TO | t.ARC, t;
}(xp), ub = ((vn = {})[at.MOVE_TO] = 2, vn[at.LINE_TO] = 2, vn[at.HORIZ_LINE_TO] = 1, vn[at.VERT_LINE_TO] = 1, vn[at.CLOSE_PATH] = 0, vn[at.QUAD_TO] = 4, vn[at.SMOOTH_QUAD_TO] = 2, vn[at.CURVE_TO] = 6, vn[at.SMOOTH_CURVE_TO] = 4, vn[at.ARC] = 7, vn);
function Ha(n) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Ha = function(t) {
    return typeof t;
  } : Ha = function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ha(n);
}
function db(n, t) {
  if (!(n instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
var mb = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259], pb = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
function gb(n, t, e, i, s) {
  if (typeof n == "string" && (n = document.getElementById(n)), !n || Ha(n) !== "object" || !("getContext" in n))
    throw new TypeError("Expecting canvas with `getContext` method in processCanvasRGB(A) calls!");
  var r = n.getContext("2d");
  try {
    return r.getImageData(t, e, i, s);
  } catch (o) {
    throw new Error("unable to access image data: " + o);
  }
}
function fb(n, t, e, i, s, r) {
  if (!(isNaN(r) || r < 1)) {
    r |= 0;
    var o = gb(n, t, e, i, s);
    o = _b(o, t, e, i, s, r), n.getContext("2d").putImageData(o, t, e);
  }
}
function _b(n, t, e, i, s, r) {
  for (var o = n.data, a = 2 * r + 1, l = i - 1, c = s - 1, h = r + 1, u = h * (h + 1) / 2, p = new Yu(), m = p, g, _ = 1; _ < a; _++)
    m = m.next = new Yu(), _ === h && (g = m);
  m.next = p;
  for (var y = null, b = null, w = 0, v = 0, C = mb[r], k = pb[r], Y = 0; Y < s; Y++) {
    m = p;
    for (var P = o[v], L = o[v + 1], N = o[v + 2], D = o[v + 3], B = 0; B < h; B++)
      m.r = P, m.g = L, m.b = N, m.a = D, m = m.next;
    for (var V = 0, X = 0, Z = 0, W = 0, st = h * P, j = h * L, gt = h * N, U = h * D, ht = u * P, z = u * L, O = u * N, _t = u * D, rt = 1; rt < h; rt++) {
      var ut = v + ((l < rt ? l : rt) << 2), oe = o[ut], Re = o[ut + 1], Wt = o[ut + 2], Dt = o[ut + 3], ee = h - rt;
      ht += (m.r = oe) * ee, z += (m.g = Re) * ee, O += (m.b = Wt) * ee, _t += (m.a = Dt) * ee, V += oe, X += Re, Z += Wt, W += Dt, m = m.next;
    }
    y = p, b = g;
    for (var ie = 0; ie < i; ie++) {
      var Ye = _t * C >> k;
      if (o[v + 3] = Ye, Ye !== 0) {
        var bi = 255 / Ye;
        o[v] = (ht * C >> k) * bi, o[v + 1] = (z * C >> k) * bi, o[v + 2] = (O * C >> k) * bi;
      } else
        o[v] = o[v + 1] = o[v + 2] = 0;
      ht -= st, z -= j, O -= gt, _t -= U, st -= y.r, j -= y.g, gt -= y.b, U -= y.a;
      var S = ie + r + 1;
      S = w + (S < l ? S : l) << 2, V += y.r = o[S], X += y.g = o[S + 1], Z += y.b = o[S + 2], W += y.a = o[S + 3], ht += V, z += X, O += Z, _t += W, y = y.next;
      var $ = b, H = $.r, T = $.g, G = $.b, K = $.a;
      st += H, j += T, gt += G, U += K, V -= H, X -= T, Z -= G, W -= K, b = b.next, v += 4;
    }
    w += i;
  }
  for (var tt = 0; tt < i; tt++) {
    v = tt << 2;
    var nt = o[v], A = o[v + 1], lt = o[v + 2], dt = o[v + 3], ct = h * nt, It = h * A, jt = h * lt, Ft = h * dt, si = u * nt, cn = u * A, Ii = u * lt, hn = u * dt;
    m = p;
    for (var pe = 0; pe < h; pe++)
      m.r = nt, m.g = A, m.b = lt, m.a = dt, m = m.next;
    for (var En = i, Nn = 0, Vi = 0, He = 0, Yi = 0, qi = 1; qi <= r; qi++) {
      v = En + tt << 2;
      var wn = h - qi;
      si += (m.r = nt = o[v]) * wn, cn += (m.g = A = o[v + 1]) * wn, Ii += (m.b = lt = o[v + 2]) * wn, hn += (m.a = dt = o[v + 3]) * wn, Yi += nt, Nn += A, Vi += lt, He += dt, m = m.next, qi < c && (En += i);
    }
    v = tt, y = p, b = g;
    for (var Zi = 0; Zi < s; Zi++) {
      var Ge = v << 2;
      o[Ge + 3] = dt = hn * C >> k, dt > 0 ? (dt = 255 / dt, o[Ge] = (si * C >> k) * dt, o[Ge + 1] = (cn * C >> k) * dt, o[Ge + 2] = (Ii * C >> k) * dt) : o[Ge] = o[Ge + 1] = o[Ge + 2] = 0, si -= ct, cn -= It, Ii -= jt, hn -= Ft, ct -= y.r, It -= y.g, jt -= y.b, Ft -= y.a, Ge = tt + ((Ge = Zi + h) < c ? Ge : c) * i << 2, si += Yi += y.r = o[Ge], cn += Nn += y.g = o[Ge + 1], Ii += Vi += y.b = o[Ge + 2], hn += He += y.a = o[Ge + 3], y = y.next, ct += nt = b.r, It += A = b.g, jt += lt = b.b, Ft += dt = b.a, Yi -= nt, Nn -= A, Vi -= lt, He -= dt, b = b.next, v += i;
    }
  }
  return n;
}
var Yu = (
  /**
   * Set properties.
   */
  function n() {
    db(this, n), this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null;
  }
);
function $r(n) {
  return n.replace(/(?!\u3000)\s+/gm, " ");
}
function yb(n) {
  return n.replace(/^[\n \t]+/, "");
}
function bb(n) {
  return n.replace(/[\n \t]+$/, "");
}
function an(n) {
  const t = n.match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm);
  return t ? t.map(parseFloat) : [];
}
function Ib(n) {
  const t = an(n);
  return [
    t[0] || 0,
    t[1] || 0,
    t[2] || 0,
    t[3] || 0,
    t[4] || 0,
    t[5] || 0
  ];
}
const wb = /^[A-Z-]+$/;
function vb(n) {
  return wb.test(n) ? n.toLowerCase() : n;
}
function Sp(n) {
  const t = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(n);
  return t && (t[2] || t[3] || t[4]) || "";
}
function xb(n) {
  if (!n.startsWith("rgb"))
    return n;
  let t = 3;
  return n.replace(
    /\d+(\.\d+)?/g,
    (i, s) => t-- && s ? String(Math.round(parseFloat(i))) : i
  );
}
const Sb = /(\[[^\]]+\])/g, Zb = /(#[^\s+>~.[:]+)/g, Cb = /(\.[^\s+>~.[:]+)/g, kb = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi, Mb = /(:[\w-]+\([^)]*\))/gi, Wb = /(:[^\s+>~.[:]+)/g, Pb = /([^\s+>~.[:]+)/g;
function js(n, t) {
  const e = t.exec(n);
  return e ? [
    n.replace(t, " "),
    e.length
  ] : [
    n,
    0
  ];
}
function Vb(n) {
  const t = [
    0,
    0,
    0
  ];
  let e = n.replace(/:not\(([^)]*)\)/g, "     $1 ").replace(/{[\s\S]*/gm, " "), i = 0;
  return [e, i] = js(e, Sb), t[1] += i, [e, i] = js(e, Zb), t[0] += i, [e, i] = js(e, Cb), t[1] += i, [e, i] = js(e, kb), t[2] += i, [e, i] = js(e, Mb), t[1] += i, [e, i] = js(e, Wb), t[1] += i, e = e.replace(/[*\s+>~]/g, " ").replace(/[#.]/g, " "), [e, i] = js(e, Pb), t[2] += i, t.join("");
}
const Er = 1e-8;
function Gu(n) {
  return Math.sqrt(Math.pow(n[0], 2) + Math.pow(n[1], 2));
}
function rh(n, t) {
  return (n[0] * t[0] + n[1] * t[1]) / (Gu(n) * Gu(t));
}
function Tu(n, t) {
  return (n[0] * t[1] < n[1] * t[0] ? -1 : 1) * Math.acos(rh(n, t));
}
function Eu(n) {
  return n * n * n;
}
function Nu(n) {
  return 3 * n * n * (1 - n);
}
function Ru(n) {
  return 3 * n * (1 - n) * (1 - n);
}
function Lu(n) {
  return (1 - n) * (1 - n) * (1 - n);
}
function Xu(n) {
  return n * n;
}
function Fu(n) {
  return 2 * n * (1 - n);
}
function Ku(n) {
  return (1 - n) * (1 - n);
}
class Zt {
  static empty(t) {
    return new Zt(t, "EMPTY", "");
  }
  split() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : " ";
    const { document: e, name: i } = this;
    return $r(this.getString()).trim().split(t).map(
      (s) => new Zt(e, i, s)
    );
  }
  hasValue(t) {
    const e = this.value;
    return e !== null && e !== "" && (t || e !== 0) && typeof e < "u";
  }
  isString(t) {
    const { value: e } = this, i = typeof e == "string";
    return !i || !t ? i : t.test(e);
  }
  isUrlDefinition() {
    return this.isString(/^url\(/);
  }
  isPixels() {
    if (!this.hasValue())
      return !1;
    const t = this.getString();
    switch (!0) {
      case t.endsWith("px"):
      case /^[0-9]+$/.test(t):
        return !0;
      default:
        return !1;
    }
  }
  setValue(t) {
    return this.value = t, this;
  }
  getValue(t) {
    return typeof t > "u" || this.hasValue() ? this.value : t;
  }
  getNumber(t) {
    if (!this.hasValue())
      return typeof t > "u" ? 0 : parseFloat(t);
    const { value: e } = this;
    let i = parseFloat(e);
    return this.isString(/%$/) && (i /= 100), i;
  }
  getString(t) {
    return typeof t > "u" || this.hasValue() ? typeof this.value > "u" ? "" : String(this.value) : String(t);
  }
  getColor(t) {
    let e = this.getString(t);
    return this.isNormalizedColor || (this.isNormalizedColor = !0, e = xb(e), this.value = e), e;
  }
  getDpi() {
    return 96;
  }
  getRem() {
    return this.document.rootEmSize;
  }
  getEm() {
    return this.document.emSize;
  }
  getUnits() {
    return this.getString().replace(/[0-9.-]/g, "");
  }
  getPixels(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (!this.hasValue())
      return 0;
    const [i, s] = typeof t == "boolean" ? [
      void 0,
      t
    ] : [
      t
    ], { viewPort: r } = this.document.screen;
    switch (!0) {
      case this.isString(/vmin$/):
        return this.getNumber() / 100 * Math.min(r.computeSize("x"), r.computeSize("y"));
      case this.isString(/vmax$/):
        return this.getNumber() / 100 * Math.max(r.computeSize("x"), r.computeSize("y"));
      case this.isString(/vw$/):
        return this.getNumber() / 100 * r.computeSize("x");
      case this.isString(/vh$/):
        return this.getNumber() / 100 * r.computeSize("y");
      case this.isString(/rem$/):
        return this.getNumber() * this.getRem();
      case this.isString(/em$/):
        return this.getNumber() * this.getEm();
      case this.isString(/ex$/):
        return this.getNumber() * this.getEm() / 2;
      case this.isString(/px$/):
        return this.getNumber();
      case this.isString(/pt$/):
        return this.getNumber() * this.getDpi() * (1 / 72);
      case this.isString(/pc$/):
        return this.getNumber() * 15;
      case this.isString(/cm$/):
        return this.getNumber() * this.getDpi() / 2.54;
      case this.isString(/mm$/):
        return this.getNumber() * this.getDpi() / 25.4;
      case this.isString(/in$/):
        return this.getNumber() * this.getDpi();
      case (this.isString(/%$/) && s):
        return this.getNumber() * this.getEm();
      case this.isString(/%$/):
        return this.getNumber() * r.computeSize(i);
      default: {
        const o = this.getNumber();
        return e && o < 1 ? o * r.computeSize(i) : o;
      }
    }
  }
  getMilliseconds() {
    return this.hasValue() ? this.isString(/ms$/) ? this.getNumber() : this.getNumber() * 1e3 : 0;
  }
  getRadians() {
    if (!this.hasValue())
      return 0;
    switch (!0) {
      case this.isString(/deg$/):
        return this.getNumber() * (Math.PI / 180);
      case this.isString(/grad$/):
        return this.getNumber() * (Math.PI / 200);
      case this.isString(/rad$/):
        return this.getNumber();
      default:
        return this.getNumber() * (Math.PI / 180);
    }
  }
  getDefinition() {
    const t = this.getString(), e = /#([^)'"]+)/.exec(t), i = (e == null ? void 0 : e[1]) || t;
    return this.document.definitions[i];
  }
  getFillStyleDefinition(t, e) {
    let i = this.getDefinition();
    if (!i)
      return null;
    if (typeof i.createGradient == "function" && "getBoundingBox" in t)
      return i.createGradient(this.document.ctx, t, e);
    if (typeof i.createPattern == "function") {
      if (i.getHrefAttribute().hasValue()) {
        const s = i.getAttribute("patternTransform");
        i = i.getHrefAttribute().getDefinition(), i && s.hasValue() && i.getAttribute("patternTransform", !0).setValue(s.value);
      }
      if (i)
        return i.createPattern(this.document.ctx, t, e);
    }
    return null;
  }
  getTextBaseline() {
    if (!this.hasValue())
      return null;
    const t = this.getString();
    return Zt.textBaselineMapping[t] || null;
  }
  addOpacity(t) {
    let e = this.getColor();
    const i = e.length;
    let s = 0;
    for (let r = 0; r < i && (e[r] === "," && s++, s !== 3); r++)
      ;
    if (t.hasValue() && this.isString() && s !== 3) {
      const r = new nh(e);
      r.ok && (r.alpha = t.getNumber(), e = r.toRGBA());
    }
    return new Zt(this.document, this.name, e);
  }
  constructor(t, e, i) {
    this.document = t, this.name = e, this.value = i, this.isNormalizedColor = !1;
  }
}
Zt.textBaselineMapping = {
  baseline: "alphabetic",
  "before-edge": "top",
  "text-before-edge": "top",
  middle: "middle",
  central: "middle",
  "after-edge": "bottom",
  "text-after-edge": "bottom",
  ideographic: "ideographic",
  alphabetic: "alphabetic",
  hanging: "hanging",
  mathematical: "alphabetic"
};
class la {
  clear() {
    this.viewPorts = [];
  }
  setCurrent(t, e) {
    this.viewPorts.push({
      width: t,
      height: e
    });
  }
  removeCurrent() {
    this.viewPorts.pop();
  }
  getRoot() {
    const [t] = this.viewPorts;
    return t || Ou();
  }
  getCurrent() {
    const { viewPorts: t } = this, e = t[t.length - 1];
    return e || Ou();
  }
  get width() {
    return this.getCurrent().width;
  }
  get height() {
    return this.getCurrent().height;
  }
  computeSize(t) {
    return typeof t == "number" ? t : t === "x" ? this.width : t === "y" ? this.height : Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
  }
  constructor() {
    this.viewPorts = [];
  }
}
la.DEFAULT_VIEWPORT_WIDTH = 800;
la.DEFAULT_VIEWPORT_HEIGHT = 600;
function Ou() {
  return {
    width: la.DEFAULT_VIEWPORT_WIDTH,
    height: la.DEFAULT_VIEWPORT_HEIGHT
  };
}
class Pe {
  static parse(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const [i = e, s = e] = an(t);
    return new Pe(i, s);
  }
  static parseScale(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    const [i = e, s = i] = an(t);
    return new Pe(i, s);
  }
  static parsePath(t) {
    const e = an(t), i = e.length, s = [];
    for (let r = 0; r < i; r += 2)
      s.push(new Pe(e[r], e[r + 1]));
    return s;
  }
  angleTo(t) {
    return Math.atan2(t.y - this.y, t.x - this.x);
  }
  applyTransform(t) {
    const { x: e, y: i } = this, s = e * t[0] + i * t[2] + t[4], r = e * t[1] + i * t[3] + t[5];
    this.x = s, this.y = r;
  }
  constructor(t, e) {
    this.x = t, this.y = e;
  }
}
class Yb {
  isWorking() {
    return this.working;
  }
  start() {
    if (this.working)
      return;
    const { screen: t, onClick: e, onMouseMove: i } = this, s = t.ctx.canvas;
    s.onclick = e, s.onmousemove = i, this.working = !0;
  }
  stop() {
    if (!this.working)
      return;
    const t = this.screen.ctx.canvas;
    this.working = !1, t.onclick = null, t.onmousemove = null;
  }
  hasEvents() {
    return this.working && this.events.length > 0;
  }
  runEvents() {
    if (!this.working)
      return;
    const { screen: t, events: e, eventElements: i } = this, { style: s } = t.ctx.canvas;
    let r;
    s && (s.cursor = ""), e.forEach((o, a) => {
      let { run: l } = o;
      for (r = i[a]; r; )
        l(r), r = r.parent;
    }), this.events = [], this.eventElements = [];
  }
  checkPath(t, e) {
    if (!this.working || !e)
      return;
    const { events: i, eventElements: s } = this;
    i.forEach((r, o) => {
      let { x: a, y: l } = r;
      !s[o] && e.isPointInPath && e.isPointInPath(a, l) && (s[o] = t);
    });
  }
  checkBoundingBox(t, e) {
    if (!this.working || !e)
      return;
    const { events: i, eventElements: s } = this;
    i.forEach((r, o) => {
      let { x: a, y: l } = r;
      !s[o] && e.isPointInBox(a, l) && (s[o] = t);
    });
  }
  mapXY(t, e) {
    const { window: i, ctx: s } = this.screen, r = new Pe(t, e);
    let o = s.canvas;
    for (; o; )
      r.x -= o.offsetLeft, r.y -= o.offsetTop, o = o.offsetParent;
    return i != null && i.scrollX && (r.x += i.scrollX), i != null && i.scrollY && (r.y += i.scrollY), r;
  }
  onClick(t) {
    const { x: e, y: i } = this.mapXY(t.clientX, t.clientY);
    this.events.push({
      type: "onclick",
      x: e,
      y: i,
      run(s) {
        s.onClick && s.onClick();
      }
    });
  }
  onMouseMove(t) {
    const { x: e, y: i } = this.mapXY(t.clientX, t.clientY);
    this.events.push({
      type: "onmousemove",
      x: e,
      y: i,
      run(s) {
        s.onMouseMove && s.onMouseMove();
      }
    });
  }
  constructor(t) {
    this.screen = t, this.working = !1, this.events = [], this.eventElements = [], this.onClick = this.onClick.bind(this), this.onMouseMove = this.onMouseMove.bind(this);
  }
}
const Zp = typeof window < "u" ? window : null, Cp = typeof fetch < "u" ? fetch.bind(void 0) : void 0;
class bs {
  wait(t) {
    this.waits.push(t);
  }
  ready() {
    return this.readyPromise ? this.readyPromise : Promise.resolve();
  }
  isReady() {
    if (this.isReadyLock)
      return !0;
    const t = this.waits.every(
      (e) => e()
    );
    return t && (this.waits = [], this.resolveReady && this.resolveReady()), this.isReadyLock = t, t;
  }
  setDefaults(t) {
    t.strokeStyle = "rgba(0,0,0,0)", t.lineCap = "butt", t.lineJoin = "miter", t.miterLimit = 4;
  }
  setViewBox(t) {
    let { document: e, ctx: i, aspectRatio: s, width: r, desiredWidth: o, height: a, desiredHeight: l, minX: c = 0, minY: h = 0, refX: u, refY: p, clip: m = !1, clipX: g = 0, clipY: _ = 0 } = t;
    const y = $r(s).replace(/^defer\s/, ""), [b, w] = y.split(" "), v = b || "xMidYMid", C = w || "meet", k = r / o, Y = a / l, P = Math.min(k, Y), L = Math.max(k, Y);
    let N = o, D = l;
    C === "meet" && (N *= P, D *= P), C === "slice" && (N *= L, D *= L);
    const B = new Zt(e, "refX", u), V = new Zt(e, "refY", p), X = B.hasValue() && V.hasValue();
    if (X && i.translate(-P * B.getPixels("x"), -P * V.getPixels("y")), m) {
      const Z = P * g, W = P * _;
      i.beginPath(), i.moveTo(Z, W), i.lineTo(r, W), i.lineTo(r, a), i.lineTo(Z, a), i.closePath(), i.clip();
    }
    if (!X) {
      const Z = C === "meet" && P === Y, W = C === "slice" && L === Y, st = C === "meet" && P === k, j = C === "slice" && L === k;
      v.startsWith("xMid") && (Z || W) && i.translate(r / 2 - N / 2, 0), v.endsWith("YMid") && (st || j) && i.translate(0, a / 2 - D / 2), v.startsWith("xMax") && (Z || W) && i.translate(r - N, 0), v.endsWith("YMax") && (st || j) && i.translate(0, a - D);
    }
    switch (!0) {
      case v === "none":
        i.scale(k, Y);
        break;
      case C === "meet":
        i.scale(P, P);
        break;
      case C === "slice":
        i.scale(L, L);
        break;
    }
    i.translate(-c, -h);
  }
  start(t) {
    let { enableRedraw: e = !1, ignoreMouse: i = !1, ignoreAnimation: s = !1, ignoreDimensions: r = !1, ignoreClear: o = !1, forceRedraw: a, scaleWidth: l, scaleHeight: c, offsetX: h, offsetY: u } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { mouse: p } = this, m = 1e3 / bs.FRAMERATE;
    if (this.isReadyLock = !1, this.frameDuration = m, this.readyPromise = new Promise((w) => {
      this.resolveReady = w;
    }), this.isReady() && this.render(t, r, o, l, c, h, u), !e)
      return;
    let g = Date.now(), _ = g, y = 0;
    const b = () => {
      g = Date.now(), y = g - _, y >= m && (_ = g - y % m, this.shouldUpdate(s, a) && (this.render(t, r, o, l, c, h, u), p.runEvents())), this.intervalId = dc(b);
    };
    i || p.start(), this.intervalId = dc(b);
  }
  stop() {
    this.intervalId && (dc.cancel(this.intervalId), this.intervalId = null), this.mouse.stop();
  }
  shouldUpdate(t, e) {
    if (!t) {
      const { frameDuration: i } = this;
      if (this.animations.reduce(
        (r, o) => o.update(i) || r,
        !1
      ))
        return !0;
    }
    return !!(typeof e == "function" && e() || !this.isReadyLock && this.isReady() || this.mouse.hasEvents());
  }
  render(t, e, i, s, r, o, a) {
    const { viewPort: l, ctx: c, isFirstRender: h } = this, u = c.canvas;
    l.clear(), u.width && u.height && l.setCurrent(u.width, u.height);
    const p = t.getStyle("width"), m = t.getStyle("height");
    !e && (h || typeof s != "number" && typeof r != "number") && (p.hasValue() && (u.width = p.getPixels("x"), u.style && (u.style.width = "".concat(u.width, "px"))), m.hasValue() && (u.height = m.getPixels("y"), u.style && (u.style.height = "".concat(u.height, "px"))));
    let g = u.clientWidth || u.width, _ = u.clientHeight || u.height;
    if (e && p.hasValue() && m.hasValue() && (g = p.getPixels("x"), _ = m.getPixels("y")), l.setCurrent(g, _), typeof o == "number" && t.getAttribute("x", !0).setValue(o), typeof a == "number" && t.getAttribute("y", !0).setValue(a), typeof s == "number" || typeof r == "number") {
      const y = an(t.getAttribute("viewBox").getString());
      let b = 0, w = 0;
      if (typeof s == "number") {
        const C = t.getStyle("width");
        C.hasValue() ? b = C.getPixels("x") / s : y[2] && !isNaN(y[2]) && (b = y[2] / s);
      }
      if (typeof r == "number") {
        const C = t.getStyle("height");
        C.hasValue() ? w = C.getPixels("y") / r : y[3] && !isNaN(y[3]) && (w = y[3] / r);
      }
      b || (b = w), w || (w = b), t.getAttribute("width", !0).setValue(s), t.getAttribute("height", !0).setValue(r);
      const v = t.getStyle("transform", !0, !0);
      v.setValue("".concat(v.getString(), " scale(").concat(1 / b, ", ").concat(1 / w, ")"));
    }
    i || c.clearRect(0, 0, g, _), t.render(c), h && (this.isFirstRender = !1);
  }
  constructor(t, { fetch: e = Cp, window: i = Zp } = {}) {
    if (this.ctx = t, this.viewPort = new la(), this.mouse = new Yb(this), this.animations = [], this.waits = [], this.frameDuration = 0, this.isReadyLock = !1, this.isFirstRender = !0, this.intervalId = null, this.window = i, !e)
      throw new Error("Can't find 'fetch' in 'globalThis', please provide it via options");
    this.fetch = e;
  }
}
bs.defaultWindow = Zp;
bs.defaultFetch = Cp;
bs.FRAMERATE = 30;
bs.MAX_VIRTUAL_PIXELS = 3e4;
const { defaultFetch: Gb } = bs, Tb = typeof DOMParser < "u" ? DOMParser : void 0;
class pc {
  async parse(t) {
    return t.startsWith("<") ? this.parseFromString(t) : this.load(t);
  }
  parseFromString(t) {
    const e = new this.DOMParser();
    try {
      return this.checkDocument(e.parseFromString(t, "image/svg+xml"));
    } catch {
      return this.checkDocument(e.parseFromString(t, "text/xml"));
    }
  }
  checkDocument(t) {
    const e = t.getElementsByTagName("parsererror")[0];
    if (e)
      throw new Error(e.textContent || "Unknown parse error");
    return t;
  }
  async load(t) {
    const i = await (await this.fetch(t)).text();
    return this.parseFromString(i);
  }
  constructor({ fetch: t = Gb, DOMParser: e = Tb } = {}) {
    if (!t)
      throw new Error("Can't find 'fetch' in 'globalThis', please provide it via options");
    if (!e)
      throw new Error("Can't find 'DOMParser' in 'globalThis', please provide it via options");
    this.fetch = t, this.DOMParser = e;
  }
}
class Eb {
  apply(t) {
    const { x: e, y: i } = this.point;
    t.translate(e || 0, i || 0);
  }
  unapply(t) {
    const { x: e, y: i } = this.point;
    t.translate(-1 * e || 0, -1 * i || 0);
  }
  applyToPoint(t) {
    const { x: e, y: i } = this.point;
    t.applyTransform([
      1,
      0,
      0,
      1,
      e || 0,
      i || 0
    ]);
  }
  constructor(t, e) {
    this.type = "translate", this.point = Pe.parse(e);
  }
}
class Nb {
  apply(t) {
    const { cx: e, cy: i, originX: s, originY: r, angle: o } = this, a = e + s.getPixels("x"), l = i + r.getPixels("y");
    t.translate(a, l), t.rotate(o.getRadians()), t.translate(-a, -l);
  }
  unapply(t) {
    const { cx: e, cy: i, originX: s, originY: r, angle: o } = this, a = e + s.getPixels("x"), l = i + r.getPixels("y");
    t.translate(a, l), t.rotate(-1 * o.getRadians()), t.translate(-a, -l);
  }
  applyToPoint(t) {
    const { cx: e, cy: i, angle: s } = this, r = s.getRadians();
    t.applyTransform([
      1,
      0,
      0,
      1,
      e || 0,
      i || 0
      // this.p.y
    ]), t.applyTransform([
      Math.cos(r),
      Math.sin(r),
      -Math.sin(r),
      Math.cos(r),
      0,
      0
    ]), t.applyTransform([
      1,
      0,
      0,
      1,
      -e || 0,
      -i || 0
      // -this.p.y
    ]);
  }
  constructor(t, e, i) {
    this.type = "rotate";
    const s = an(e);
    this.angle = new Zt(t, "angle", s[0]), this.originX = i[0], this.originY = i[1], this.cx = s[1] || 0, this.cy = s[2] || 0;
  }
}
class Rb {
  apply(t) {
    const { scale: { x: e, y: i }, originX: s, originY: r } = this, o = s.getPixels("x"), a = r.getPixels("y");
    t.translate(o, a), t.scale(e, i || e), t.translate(-o, -a);
  }
  unapply(t) {
    const { scale: { x: e, y: i }, originX: s, originY: r } = this, o = s.getPixels("x"), a = r.getPixels("y");
    t.translate(o, a), t.scale(1 / e, 1 / i || e), t.translate(-o, -a);
  }
  applyToPoint(t) {
    const { x: e, y: i } = this.scale;
    t.applyTransform([
      e || 0,
      0,
      0,
      i || 0,
      0,
      0
    ]);
  }
  constructor(t, e, i) {
    this.type = "scale";
    const s = Pe.parseScale(e);
    (s.x === 0 || s.y === 0) && (s.x = Er, s.y = Er), this.scale = s, this.originX = i[0], this.originY = i[1];
  }
}
class kp {
  apply(t) {
    const { originX: e, originY: i, matrix: s } = this, r = e.getPixels("x"), o = i.getPixels("y");
    t.translate(r, o), t.transform(s[0], s[1], s[2], s[3], s[4], s[5]), t.translate(-r, -o);
  }
  unapply(t) {
    const { originX: e, originY: i, matrix: s } = this, r = s[0], o = s[2], a = s[4], l = s[1], c = s[3], h = s[5], u = 0, p = 0, m = 1, g = 1 / (r * (c * m - h * p) - o * (l * m - h * u) + a * (l * p - c * u)), _ = e.getPixels("x"), y = i.getPixels("y");
    t.translate(_, y), t.transform(g * (c * m - h * p), g * (h * u - l * m), g * (a * p - o * m), g * (r * m - a * u), g * (o * h - a * c), g * (a * l - r * h)), t.translate(-_, -y);
  }
  applyToPoint(t) {
    t.applyTransform(this.matrix);
  }
  constructor(t, e, i) {
    this.type = "matrix", this.matrix = Ib(e), this.originX = i[0], this.originY = i[1];
  }
}
class Mp extends kp {
  constructor(t, e, i) {
    super(t, e, i), this.type = "skew", this.angle = new Zt(t, "angle", e);
  }
}
class Lb extends Mp {
  constructor(t, e, i) {
    super(t, e, i), this.type = "skewX", this.matrix = [
      1,
      0,
      Math.tan(this.angle.getRadians()),
      1,
      0,
      0
    ];
  }
}
class Xb extends Mp {
  constructor(t, e, i) {
    super(t, e, i), this.type = "skewY", this.matrix = [
      1,
      Math.tan(this.angle.getRadians()),
      0,
      1,
      0,
      0
    ];
  }
}
function Fb(n) {
  return $r(n).trim().replace(/\)([a-zA-Z])/g, ") $1").replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/);
}
function Kb(n) {
  const [t = "", e = ""] = n.split("(");
  return [
    t.trim(),
    e.trim().replace(")", "")
  ];
}
class pr {
  static fromElement(t, e) {
    const i = e.getStyle("transform", !1, !0);
    if (i.hasValue()) {
      const [s, r = s] = e.getStyle("transform-origin", !1, !0).split();
      if (s && r) {
        const o = [
          s,
          r
        ];
        return new pr(t, i.getString(), o);
      }
    }
    return null;
  }
  apply(t) {
    this.transforms.forEach(
      (e) => e.apply(t)
    );
  }
  unapply(t) {
    this.transforms.forEach(
      (e) => e.unapply(t)
    );
  }
  // TODO: applyToPoint unused ... remove?
  applyToPoint(t) {
    this.transforms.forEach(
      (e) => e.applyToPoint(t)
    );
  }
  constructor(t, e, i) {
    this.document = t, this.transforms = [], Fb(e).forEach((r) => {
      if (r === "none")
        return;
      const [o, a] = Kb(r), l = pr.transformTypes[o];
      l && this.transforms.push(new l(this.document, a, i));
    });
  }
}
pr.transformTypes = {
  translate: Eb,
  rotate: Nb,
  scale: Rb,
  matrix: kp,
  skewX: Lb,
  skewY: Xb
};
class ke {
  getAttribute(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const i = this.attributes[t];
    if (!i && e) {
      const s = new Zt(this.document, t, "");
      return this.attributes[t] = s, s;
    }
    return i || Zt.empty(this.document);
  }
  getHrefAttribute() {
    let t;
    for (const e in this.attributes)
      if (e === "href" || e.endsWith(":href")) {
        t = this.attributes[e];
        break;
      }
    return t || Zt.empty(this.document);
  }
  getStyle(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    const s = this.styles[t];
    if (s)
      return s;
    const r = this.getAttribute(t);
    if (r.hasValue())
      return this.styles[t] = r, r;
    if (!i) {
      const { parent: o } = this;
      if (o) {
        const a = o.getStyle(t);
        if (a.hasValue())
          return a;
      }
    }
    if (e) {
      const o = new Zt(this.document, t, "");
      return this.styles[t] = o, o;
    }
    return Zt.empty(this.document);
  }
  render(t) {
    if (!(this.getStyle("display").getString() === "none" || this.getStyle("visibility").getString() === "hidden")) {
      if (t.save(), this.getStyle("mask").hasValue()) {
        const e = this.getStyle("mask").getDefinition();
        e && (this.applyEffects(t), e.apply(t, this));
      } else if (this.getStyle("filter").getValue("none") !== "none") {
        const e = this.getStyle("filter").getDefinition();
        e && (this.applyEffects(t), e.apply(t, this));
      } else
        this.setContext(t), this.renderChildren(t), this.clearContext(t);
      t.restore();
    }
  }
  setContext(t) {
  }
  applyEffects(t) {
    const e = pr.fromElement(this.document, this);
    e && e.apply(t);
    const i = this.getStyle("clip-path", !1, !0);
    if (i.hasValue()) {
      const s = i.getDefinition();
      s && s.apply(t);
    }
  }
  clearContext(t) {
  }
  renderChildren(t) {
    this.children.forEach((e) => {
      e.render(t);
    });
  }
  addChild(t) {
    const e = t instanceof ke ? t : this.document.createElement(t);
    e.parent = this, ke.ignoreChildTypes.includes(e.type) || this.children.push(e);
  }
  matchesSelector(t) {
    var e;
    const { node: i } = this;
    if (typeof i.matches == "function")
      return i.matches(t);
    const s = (e = i.getAttribute) === null || e === void 0 ? void 0 : e.call(i, "class");
    return !s || s === "" ? !1 : s.split(" ").some(
      (r) => ".".concat(r) === t
    );
  }
  addStylesFromStyleDefinition() {
    const { styles: t, stylesSpecificity: e } = this.document;
    let i;
    for (const s in t)
      if (!s.startsWith("@") && this.matchesSelector(s)) {
        const r = t[s], o = e[s];
        if (r)
          for (const a in r) {
            let l = this.stylesSpecificity[a];
            typeof l > "u" && (l = "000"), o && o >= l && (i = r[a], i && (this.styles[a] = i), this.stylesSpecificity[a] = o);
          }
      }
  }
  removeStyles(t, e) {
    return e.reduce((s, r) => {
      const o = t.getStyle(r);
      if (!o.hasValue())
        return s;
      const a = o.getString();
      return o.setValue(""), [
        ...s,
        [
          r,
          a
        ]
      ];
    }, []);
  }
  restoreStyles(t, e) {
    e.forEach((i) => {
      let [s, r] = i;
      t.getStyle(s, !0).setValue(r);
    });
  }
  isFirstChild() {
    var t;
    return ((t = this.parent) === null || t === void 0 ? void 0 : t.children.indexOf(this)) === 0;
  }
  constructor(t, e, i = !1) {
    if (this.document = t, this.node = e, this.captureTextNodes = i, this.type = "", this.attributes = {}, this.styles = {}, this.stylesSpecificity = {}, this.animationFrozen = !1, this.animationFrozenValue = "", this.parent = null, this.children = [], !e || e.nodeType !== 1)
      return;
    Array.from(e.attributes).forEach((o) => {
      const a = vb(o.nodeName);
      this.attributes[a] = new Zt(t, a, o.value);
    }), this.addStylesFromStyleDefinition(), this.getAttribute("style").hasValue() && this.getAttribute("style").getString().split(";").map(
      (a) => a.trim()
    ).forEach((a) => {
      if (!a)
        return;
      const [l, c] = a.split(":").map(
        (h) => h.trim()
      );
      l && (this.styles[l] = new Zt(t, l, c));
    });
    const { definitions: s } = t, r = this.getAttribute("id");
    r.hasValue() && (s[r.getString()] || (s[r.getString()] = this)), Array.from(e.childNodes).forEach((o) => {
      if (o.nodeType === 1)
        this.addChild(o);
      else if (i && (o.nodeType === 3 || o.nodeType === 4)) {
        const a = t.createTextNode(o);
        a.getText().length > 0 && this.addChild(a);
      }
    });
  }
}
ke.ignoreChildTypes = [
  "title"
];
class Ob extends ke {
  constructor(t, e, i) {
    super(t, e, i);
  }
}
function Ab(n) {
  const t = n.trim();
  return /^('|")/.test(t) ? t : '"'.concat(t, '"');
}
function Db(n) {
  return typeof process > "u" ? n : n.trim().split(",").map(Ab).join(",");
}
function zb(n) {
  if (!n)
    return "";
  const t = n.trim().toLowerCase();
  switch (t) {
    case "normal":
    case "italic":
    case "oblique":
    case "inherit":
    case "initial":
    case "unset":
      return t;
    default:
      return /^oblique\s+(-|)\d+deg$/.test(t) ? t : "";
  }
}
function Jb(n) {
  if (!n)
    return "";
  const t = n.trim().toLowerCase();
  switch (t) {
    case "normal":
    case "bold":
    case "lighter":
    case "bolder":
    case "inherit":
    case "initial":
    case "unset":
      return t;
    default:
      return /^[\d.]+$/.test(t) ? t : "";
  }
}
class Li {
  static parse() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", e = arguments.length > 1 ? arguments[1] : void 0, i = "", s = "", r = "", o = "", a = "";
    const l = $r(t).trim().split(" "), c = {
      fontSize: !1,
      fontStyle: !1,
      fontWeight: !1,
      fontVariant: !1
    };
    return l.forEach((h) => {
      switch (!0) {
        case (!c.fontStyle && Li.styles.includes(h)):
          h !== "inherit" && (i = h), c.fontStyle = !0;
          break;
        case (!c.fontVariant && Li.variants.includes(h)):
          h !== "inherit" && (s = h), c.fontStyle = !0, c.fontVariant = !0;
          break;
        case (!c.fontWeight && Li.weights.includes(h)):
          h !== "inherit" && (r = h), c.fontStyle = !0, c.fontVariant = !0, c.fontWeight = !0;
          break;
        case !c.fontSize:
          h !== "inherit" && (o = h.split("/")[0] || ""), c.fontStyle = !0, c.fontVariant = !0, c.fontWeight = !0, c.fontSize = !0;
          break;
        default:
          h !== "inherit" && (a += h);
      }
    }), new Li(i, s, r, o, a, e);
  }
  toString() {
    return [
      zb(this.fontStyle),
      this.fontVariant,
      Jb(this.fontWeight),
      this.fontSize,
      // Wrap fontFamily only on nodejs and only for canvas.ctx
      Db(this.fontFamily)
    ].join(" ").trim();
  }
  constructor(t, e, i, s, r, o) {
    const a = o ? typeof o == "string" ? Li.parse(o) : o : {};
    this.fontFamily = r || a.fontFamily, this.fontSize = s || a.fontSize, this.fontStyle = t || a.fontStyle, this.fontWeight = i || a.fontWeight, this.fontVariant = e || a.fontVariant;
  }
}
Li.styles = "normal|italic|oblique|inherit";
Li.variants = "normal|small-caps|inherit";
Li.weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit";
class Tn {
  get x() {
    return this.x1;
  }
  get y() {
    return this.y1;
  }
  get width() {
    return this.x2 - this.x1;
  }
  get height() {
    return this.y2 - this.y1;
  }
  addPoint(t, e) {
    typeof t < "u" && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = t, this.x2 = t), t < this.x1 && (this.x1 = t), t > this.x2 && (this.x2 = t)), typeof e < "u" && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = e, this.y2 = e), e < this.y1 && (this.y1 = e), e > this.y2 && (this.y2 = e));
  }
  addX(t) {
    this.addPoint(t, 0);
  }
  addY(t) {
    this.addPoint(0, t);
  }
  addBoundingBox(t) {
    if (!t)
      return;
    const { x1: e, y1: i, x2: s, y2: r } = t;
    this.addPoint(e, i), this.addPoint(s, r);
  }
  sumCubic(t, e, i, s, r) {
    return Math.pow(1 - t, 3) * e + 3 * Math.pow(1 - t, 2) * t * i + 3 * (1 - t) * Math.pow(t, 2) * s + Math.pow(t, 3) * r;
  }
  bezierCurveAdd(t, e, i, s, r) {
    const o = 6 * e - 12 * i + 6 * s, a = -3 * e + 9 * i - 9 * s + 3 * r, l = 3 * i - 3 * e;
    if (a === 0) {
      if (o === 0)
        return;
      const p = -l / o;
      0 < p && p < 1 && (t ? this.addX(this.sumCubic(p, e, i, s, r)) : this.addY(this.sumCubic(p, e, i, s, r)));
      return;
    }
    const c = Math.pow(o, 2) - 4 * l * a;
    if (c < 0)
      return;
    const h = (-o + Math.sqrt(c)) / (2 * a);
    0 < h && h < 1 && (t ? this.addX(this.sumCubic(h, e, i, s, r)) : this.addY(this.sumCubic(h, e, i, s, r)));
    const u = (-o - Math.sqrt(c)) / (2 * a);
    0 < u && u < 1 && (t ? this.addX(this.sumCubic(u, e, i, s, r)) : this.addY(this.sumCubic(u, e, i, s, r)));
  }
  // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
  addBezierCurve(t, e, i, s, r, o, a, l) {
    this.addPoint(t, e), this.addPoint(a, l), this.bezierCurveAdd(!0, t, i, r, a), this.bezierCurveAdd(!1, e, s, o, l);
  }
  addQuadraticCurve(t, e, i, s, r, o) {
    const a = t + 0.6666666666666666 * (i - t), l = e + 2 / 3 * (s - e), c = a + 1 / 3 * (r - t), h = l + 1 / 3 * (o - e);
    this.addBezierCurve(t, e, a, c, l, h, r, o);
  }
  isPointInBox(t, e) {
    const { x1: i, y1: s, x2: r, y2: o } = this;
    return i <= t && t <= r && s <= e && e <= o;
  }
  constructor(t = Number.NaN, e = Number.NaN, i = Number.NaN, s = Number.NaN) {
    this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = s, this.addPoint(t, e), this.addPoint(i, s);
  }
}
class _r extends ke {
  calculateOpacity() {
    let t = 1, e = this;
    for (; e; ) {
      const i = e.getStyle("opacity", !1, !0);
      i.hasValue(!0) && (t *= i.getNumber()), e = e.parent;
    }
    return t;
  }
  setContext(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (!e) {
      const i = this.getStyle("fill"), s = this.getStyle("fill-opacity"), r = this.getStyle("stroke"), o = this.getStyle("stroke-opacity");
      if (i.isUrlDefinition()) {
        const m = i.getFillStyleDefinition(this, s);
        m && (t.fillStyle = m);
      } else if (i.hasValue()) {
        i.getString() === "currentColor" && i.setValue(this.getStyle("color").getColor());
        const m = i.getColor();
        m !== "inherit" && (t.fillStyle = m === "none" ? "rgba(0,0,0,0)" : m);
      }
      if (s.hasValue()) {
        const m = new Zt(this.document, "fill", t.fillStyle).addOpacity(s).getColor();
        t.fillStyle = m;
      }
      if (r.isUrlDefinition()) {
        const m = r.getFillStyleDefinition(this, o);
        m && (t.strokeStyle = m);
      } else if (r.hasValue()) {
        r.getString() === "currentColor" && r.setValue(this.getStyle("color").getColor());
        const m = r.getString();
        m !== "inherit" && (t.strokeStyle = m === "none" ? "rgba(0,0,0,0)" : m);
      }
      if (o.hasValue()) {
        const m = new Zt(this.document, "stroke", t.strokeStyle).addOpacity(o).getString();
        t.strokeStyle = m;
      }
      const a = this.getStyle("stroke-width");
      if (a.hasValue()) {
        const m = a.getPixels();
        t.lineWidth = m || Er;
      }
      const l = this.getStyle("stroke-linecap"), c = this.getStyle("stroke-linejoin"), h = this.getStyle("stroke-miterlimit"), u = this.getStyle("stroke-dasharray"), p = this.getStyle("stroke-dashoffset");
      if (l.hasValue() && (t.lineCap = l.getString()), c.hasValue() && (t.lineJoin = c.getString()), h.hasValue() && (t.miterLimit = h.getNumber()), u.hasValue() && u.getString() !== "none") {
        const m = an(u.getString());
        typeof t.setLineDash < "u" ? t.setLineDash(m) : typeof t.webkitLineDash < "u" ? t.webkitLineDash = m : typeof t.mozDash < "u" && !(m.length === 1 && m[0] === 0) && (t.mozDash = m);
        const g = p.getPixels();
        typeof t.lineDashOffset < "u" ? t.lineDashOffset = g : typeof t.webkitLineDashOffset < "u" ? t.webkitLineDashOffset = g : typeof t.mozDashOffset < "u" && (t.mozDashOffset = g);
      }
    }
    if (this.modifiedEmSizeStack = !1, typeof t.font < "u") {
      const i = this.getStyle("font"), s = this.getStyle("font-style"), r = this.getStyle("font-variant"), o = this.getStyle("font-weight"), a = this.getStyle("font-size"), l = this.getStyle("font-family"), c = new Li(s.getString(), r.getString(), o.getString(), a.hasValue() ? "".concat(a.getPixels(!0), "px") : "", l.getString(), Li.parse(i.getString(), t.font));
      s.setValue(c.fontStyle), r.setValue(c.fontVariant), o.setValue(c.fontWeight), a.setValue(c.fontSize), l.setValue(c.fontFamily), t.font = c.toString(), a.isPixels() && (this.document.emSize = a.getPixels(), this.modifiedEmSizeStack = !0);
    }
    e || (this.applyEffects(t), t.globalAlpha = this.calculateOpacity());
  }
  clearContext(t) {
    super.clearContext(t), this.modifiedEmSizeStack && this.document.popEmSize();
  }
  constructor(...t) {
    super(...t), this.modifiedEmSizeStack = !1;
  }
}
class Fs extends _r {
  setContext(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    super.setContext(t, e);
    const i = this.getStyle("dominant-baseline").getTextBaseline() || this.getStyle("alignment-baseline").getTextBaseline();
    i && (t.textBaseline = i);
  }
  initializeCoordinates() {
    this.x = 0, this.y = 0, this.leafTexts = [], this.textChunkStart = 0, this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY;
  }
  getBoundingBox(t) {
    if (this.type !== "text")
      return this.getTElementBoundingBox(t);
    this.initializeCoordinates(), this.adjustChildCoordinatesRecursive(t);
    let e = null;
    return this.children.forEach((i, s) => {
      const r = this.getChildBoundingBox(t, this, this, s);
      e ? e.addBoundingBox(r) : e = r;
    }), e;
  }
  getFontSize() {
    const { document: t, parent: e } = this, i = Li.parse(t.ctx.font).fontSize;
    return e.getStyle("font-size").getNumber(i);
  }
  getTElementBoundingBox(t) {
    const e = this.getFontSize();
    return new Tn(this.x, this.y - e, this.x + this.measureText(t), this.y);
  }
  getGlyph(t, e, i) {
    const s = e[i];
    let r;
    if (t.isArabic) {
      var o;
      const a = e.length, l = e[i - 1], c = e[i + 1];
      let h = "isolated";
      (i === 0 || l === " ") && i < a - 1 && c !== " " && (h = "terminal"), i > 0 && l !== " " && i < a - 1 && c !== " " && (h = "medial"), i > 0 && l !== " " && (i === a - 1 || c === " ") && (h = "initial"), r = ((o = t.arabicGlyphs[s]) === null || o === void 0 ? void 0 : o[h]) || t.glyphs[s];
    } else
      r = t.glyphs[s];
    return r || (r = t.missingGlyph), r;
  }
  getText() {
    return "";
  }
  getTextFromNode(t) {
    const e = t || this.node, i = Array.from(e.parentNode.childNodes), s = i.indexOf(e), r = i.length - 1;
    let o = $r(
      // textNode.value
      // || textNode.text
      e.textContent || ""
    );
    return s === 0 && (o = yb(o)), s === r && (o = bb(o)), o;
  }
  renderChildren(t) {
    if (this.type !== "text") {
      this.renderTElementChildren(t);
      return;
    }
    this.initializeCoordinates(), this.adjustChildCoordinatesRecursive(t), this.children.forEach((i, s) => {
      this.renderChild(t, this, this, s);
    });
    const { mouse: e } = this.document.screen;
    e.isWorking() && e.checkBoundingBox(this, this.getBoundingBox(t));
  }
  renderTElementChildren(t) {
    const { document: e, parent: i } = this, s = this.getText(), r = i.getStyle("font-family").getDefinition();
    if (r) {
      const { unitsPerEm: l } = r.fontFace, c = Li.parse(e.ctx.font), h = i.getStyle("font-size").getNumber(c.fontSize), u = i.getStyle("font-style").getString(c.fontStyle), p = h / l, m = r.isRTL ? s.split("").reverse().join("") : s, g = an(i.getAttribute("dx").getString()), _ = m.length;
      for (let y = 0; y < _; y++) {
        const b = this.getGlyph(r, m, y);
        t.translate(this.x, this.y), t.scale(p, -p);
        const w = t.lineWidth;
        t.lineWidth = t.lineWidth * l / h, u === "italic" && t.transform(1, 0, 0.4, 1, 0, 0), b.render(t), u === "italic" && t.transform(1, 0, -0.4, 1, 0, 0), t.lineWidth = w, t.scale(1 / p, -1 / p), t.translate(-this.x, -this.y), this.x += h * (b.horizAdvX || r.horizAdvX) / l, typeof g[y] < "u" && !isNaN(g[y]) && (this.x += g[y]);
      }
      return;
    }
    const { x: o, y: a } = this;
    t.fillStyle && t.fillText(s, o, a), t.strokeStyle && t.strokeText(s, o, a);
  }
  applyAnchoring() {
    if (this.textChunkStart >= this.leafTexts.length)
      return;
    const t = this.leafTexts[this.textChunkStart], e = t.getStyle("text-anchor").getString("start"), i = !1;
    let s = 0;
    e === "start" && !i || e === "end" && i ? s = t.x - this.minX : e === "end" && !i || e === "start" && i ? s = t.x - this.maxX : s = t.x - (this.minX + this.maxX) / 2;
    for (let r = this.textChunkStart; r < this.leafTexts.length; r++)
      this.leafTexts[r].x += s;
    this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.textChunkStart = this.leafTexts.length;
  }
  adjustChildCoordinatesRecursive(t) {
    this.children.forEach((e, i) => {
      this.adjustChildCoordinatesRecursiveCore(t, this, this, i);
    }), this.applyAnchoring();
  }
  adjustChildCoordinatesRecursiveCore(t, e, i, s) {
    const r = i.children[s];
    r.children.length > 0 ? r.children.forEach((o, a) => {
      e.adjustChildCoordinatesRecursiveCore(t, e, r, a);
    }) : this.adjustChildCoordinates(t, e, i, s);
  }
  adjustChildCoordinates(t, e, i, s) {
    const r = i.children[s];
    if (typeof r.measureText != "function")
      return r;
    t.save(), r.setContext(t, !0);
    const o = r.getAttribute("x"), a = r.getAttribute("y"), l = r.getAttribute("dx"), c = r.getAttribute("dy"), h = r.getStyle("font-family").getDefinition(), u = !!(h != null && h.isRTL);
    s === 0 && (o.hasValue() || o.setValue(r.getInheritedAttribute("x")), a.hasValue() || a.setValue(r.getInheritedAttribute("y")), l.hasValue() || l.setValue(r.getInheritedAttribute("dx")), c.hasValue() || c.setValue(r.getInheritedAttribute("dy")));
    const p = r.measureText(t);
    return u && (e.x -= p), o.hasValue() ? (e.applyAnchoring(), r.x = o.getPixels("x"), l.hasValue() && (r.x += l.getPixels("x"))) : (l.hasValue() && (e.x += l.getPixels("x")), r.x = e.x), e.x = r.x, u || (e.x += p), a.hasValue() ? (r.y = a.getPixels("y"), c.hasValue() && (r.y += c.getPixels("y"))) : (c.hasValue() && (e.y += c.getPixels("y")), r.y = e.y), e.y = r.y, e.leafTexts.push(r), e.minX = Math.min(e.minX, r.x, r.x + p), e.maxX = Math.max(e.maxX, r.x, r.x + p), r.clearContext(t), t.restore(), r;
  }
  getChildBoundingBox(t, e, i, s) {
    const r = i.children[s];
    if (typeof r.getBoundingBox != "function")
      return null;
    const o = r.getBoundingBox(t);
    return o && r.children.forEach((a, l) => {
      const c = e.getChildBoundingBox(t, e, r, l);
      o.addBoundingBox(c);
    }), o;
  }
  renderChild(t, e, i, s) {
    const r = i.children[s];
    r.render(t), r.children.forEach((o, a) => {
      e.renderChild(t, e, r, a);
    });
  }
  measureText(t) {
    const { measureCache: e } = this;
    if (~e)
      return e;
    const i = this.getText(), s = this.measureTargetText(t, i);
    return this.measureCache = s, s;
  }
  measureTargetText(t, e) {
    if (!e.length)
      return 0;
    const { parent: i } = this, s = i.getStyle("font-family").getDefinition();
    if (s) {
      const o = this.getFontSize(), a = s.isRTL ? e.split("").reverse().join("") : e, l = an(i.getAttribute("dx").getString()), c = a.length;
      let h = 0;
      for (let u = 0; u < c; u++) {
        const p = this.getGlyph(s, a, u);
        h += (p.horizAdvX || s.horizAdvX) * o / s.fontFace.unitsPerEm, typeof l[u] < "u" && !isNaN(l[u]) && (h += l[u]);
      }
      return h;
    }
    if (!t.measureText)
      return e.length * 10;
    t.save(), this.setContext(t, !0);
    const { width: r } = t.measureText(e);
    return this.clearContext(t), t.restore(), r;
  }
  /**
  * Inherits positional attributes from {@link TextElement} parent(s). Attributes
  * are only inherited from a parent to its first child.
  * @param name - The attribute name.
  * @returns The attribute value or null.
  */
  getInheritedAttribute(t) {
    let e = this;
    for (; e instanceof Fs && e.isFirstChild() && e.parent; ) {
      const i = e.parent.getAttribute(t);
      if (i.hasValue(!0))
        return i.getString("0");
      e = e.parent;
    }
    return null;
  }
  constructor(t, e, i) {
    super(t, e, new.target === Fs ? !0 : i), this.type = "text", this.x = 0, this.y = 0, this.leafTexts = [], this.textChunkStart = 0, this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.measureCache = -1;
  }
}
class ql extends Fs {
  getText() {
    return this.text;
  }
  constructor(t, e, i) {
    super(t, e, new.target === ql ? !0 : i), this.type = "tspan", this.text = this.children.length > 0 ? "" : this.getTextFromNode();
  }
}
class Bb extends ql {
  constructor(...t) {
    super(...t), this.type = "textNode";
  }
}
class Nt extends at {
  reset() {
    this.i = -1, this.command = null, this.previousCommand = null, this.start = new Pe(0, 0), this.control = new Pe(0, 0), this.current = new Pe(0, 0), this.points = [], this.angles = [];
  }
  isEnd() {
    const { i: t, commands: e } = this;
    return t >= e.length - 1;
  }
  next() {
    const t = this.commands[++this.i];
    return this.previousCommand = this.command, this.command = t, t;
  }
  getPoint() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "x", e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "y";
    const i = new Pe(this.command[t], this.command[e]);
    return this.makeAbsolute(i);
  }
  getAsControlPoint(t, e) {
    const i = this.getPoint(t, e);
    return this.control = i, i;
  }
  getAsCurrentPoint(t, e) {
    const i = this.getPoint(t, e);
    return this.current = i, i;
  }
  getReflectedControlPoint() {
    const t = this.previousCommand.type;
    if (t !== at.CURVE_TO && t !== at.SMOOTH_CURVE_TO && t !== at.QUAD_TO && t !== at.SMOOTH_QUAD_TO)
      return this.current;
    const { current: { x: e, y: i }, control: { x: s, y: r } } = this;
    return new Pe(2 * e - s, 2 * i - r);
  }
  makeAbsolute(t) {
    if (this.command.relative) {
      const { x: e, y: i } = this.current;
      t.x += e, t.y += i;
    }
    return t;
  }
  addMarker(t, e, i) {
    const { points: s, angles: r } = this;
    i && r.length > 0 && !r[r.length - 1] && (r[r.length - 1] = s[s.length - 1].angleTo(i)), this.addMarkerAngle(t, e ? e.angleTo(t) : null);
  }
  addMarkerAngle(t, e) {
    this.points.push(t), this.angles.push(e);
  }
  getMarkerPoints() {
    return this.points;
  }
  getMarkerAngles() {
    const { angles: t } = this, e = t.length;
    for (let i = 0; i < e; i++)
      if (!t[i]) {
        for (let s = i + 1; s < e; s++)
          if (t[s]) {
            t[i] = t[s];
            break;
          }
      }
    return t;
  }
  constructor(t) {
    super(t.replace(/([+\-.])\s+/gm, "$1").replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, "")), this.control = new Pe(0, 0), this.start = new Pe(0, 0), this.current = new Pe(0, 0), this.command = null, this.commands = this.commands, this.i = -1, this.previousCommand = null, this.points = [], this.angles = [];
  }
}
class me extends _r {
  path(t) {
    const { pathParser: e } = this, i = new Tn();
    for (e.reset(), t && t.beginPath(); !e.isEnd(); )
      switch (e.next().type) {
        case Nt.MOVE_TO:
          this.pathM(t, i);
          break;
        case Nt.LINE_TO:
          this.pathL(t, i);
          break;
        case Nt.HORIZ_LINE_TO:
          this.pathH(t, i);
          break;
        case Nt.VERT_LINE_TO:
          this.pathV(t, i);
          break;
        case Nt.CURVE_TO:
          this.pathC(t, i);
          break;
        case Nt.SMOOTH_CURVE_TO:
          this.pathS(t, i);
          break;
        case Nt.QUAD_TO:
          this.pathQ(t, i);
          break;
        case Nt.SMOOTH_QUAD_TO:
          this.pathT(t, i);
          break;
        case Nt.ARC:
          this.pathA(t, i);
          break;
        case Nt.CLOSE_PATH:
          this.pathZ(t, i);
          break;
      }
    return i;
  }
  getBoundingBox(t) {
    return this.path();
  }
  getMarkers() {
    const { pathParser: t } = this, e = t.getMarkerPoints(), i = t.getMarkerAngles();
    return e.map(
      (r, o) => [
        r,
        i[o]
      ]
    );
  }
  renderChildren(t) {
    this.path(t), this.document.screen.mouse.checkPath(this, t);
    const e = this.getStyle("fill-rule");
    t.fillStyle !== "" && (e.getString("inherit") !== "inherit" ? t.fill(e.getString()) : t.fill()), t.strokeStyle !== "" && (this.getAttribute("vector-effect").getString() === "non-scaling-stroke" ? (t.save(), t.setTransform(1, 0, 0, 1, 0, 0), t.stroke(), t.restore()) : t.stroke());
    const i = this.getMarkers();
    if (i) {
      const s = i.length - 1, r = this.getStyle("marker-start"), o = this.getStyle("marker-mid"), a = this.getStyle("marker-end");
      if (r.isUrlDefinition()) {
        const l = r.getDefinition(), [c, h] = i[0];
        l.render(t, c, h);
      }
      if (o.isUrlDefinition()) {
        const l = o.getDefinition();
        for (let c = 1; c < s; c++) {
          const [h, u] = i[c];
          l.render(t, h, u);
        }
      }
      if (a.isUrlDefinition()) {
        const l = a.getDefinition(), [c, h] = i[s];
        l.render(t, c, h);
      }
    }
  }
  static pathM(t) {
    const e = t.getAsCurrentPoint();
    return t.start = t.current, {
      point: e
    };
  }
  pathM(t, e) {
    const { pathParser: i } = this, { point: s } = me.pathM(i), { x: r, y: o } = s;
    i.addMarker(s), e.addPoint(r, o), t && t.moveTo(r, o);
  }
  static pathL(t) {
    const { current: e } = t, i = t.getAsCurrentPoint();
    return {
      current: e,
      point: i
    };
  }
  pathL(t, e) {
    const { pathParser: i } = this, { current: s, point: r } = me.pathL(i), { x: o, y: a } = r;
    i.addMarker(r, s), e.addPoint(o, a), t && t.lineTo(o, a);
  }
  static pathH(t) {
    const { current: e, command: i } = t, s = new Pe((i.relative ? e.x : 0) + i.x, e.y);
    return t.current = s, {
      current: e,
      point: s
    };
  }
  pathH(t, e) {
    const { pathParser: i } = this, { current: s, point: r } = me.pathH(i), { x: o, y: a } = r;
    i.addMarker(r, s), e.addPoint(o, a), t && t.lineTo(o, a);
  }
  static pathV(t) {
    const { current: e, command: i } = t, s = new Pe(e.x, (i.relative ? e.y : 0) + i.y);
    return t.current = s, {
      current: e,
      point: s
    };
  }
  pathV(t, e) {
    const { pathParser: i } = this, { current: s, point: r } = me.pathV(i), { x: o, y: a } = r;
    i.addMarker(r, s), e.addPoint(o, a), t && t.lineTo(o, a);
  }
  static pathC(t) {
    const { current: e } = t, i = t.getPoint("x1", "y1"), s = t.getAsControlPoint("x2", "y2"), r = t.getAsCurrentPoint();
    return {
      current: e,
      point: i,
      controlPoint: s,
      currentPoint: r
    };
  }
  pathC(t, e) {
    const { pathParser: i } = this, { current: s, point: r, controlPoint: o, currentPoint: a } = me.pathC(i);
    i.addMarker(a, o, r), e.addBezierCurve(s.x, s.y, r.x, r.y, o.x, o.y, a.x, a.y), t && t.bezierCurveTo(r.x, r.y, o.x, o.y, a.x, a.y);
  }
  static pathS(t) {
    const { current: e } = t, i = t.getReflectedControlPoint(), s = t.getAsControlPoint("x2", "y2"), r = t.getAsCurrentPoint();
    return {
      current: e,
      point: i,
      controlPoint: s,
      currentPoint: r
    };
  }
  pathS(t, e) {
    const { pathParser: i } = this, { current: s, point: r, controlPoint: o, currentPoint: a } = me.pathS(i);
    i.addMarker(a, o, r), e.addBezierCurve(s.x, s.y, r.x, r.y, o.x, o.y, a.x, a.y), t && t.bezierCurveTo(r.x, r.y, o.x, o.y, a.x, a.y);
  }
  static pathQ(t) {
    const { current: e } = t, i = t.getAsControlPoint("x1", "y1"), s = t.getAsCurrentPoint();
    return {
      current: e,
      controlPoint: i,
      currentPoint: s
    };
  }
  pathQ(t, e) {
    const { pathParser: i } = this, { current: s, controlPoint: r, currentPoint: o } = me.pathQ(i);
    i.addMarker(o, r, r), e.addQuadraticCurve(s.x, s.y, r.x, r.y, o.x, o.y), t && t.quadraticCurveTo(r.x, r.y, o.x, o.y);
  }
  static pathT(t) {
    const { current: e } = t, i = t.getReflectedControlPoint();
    t.control = i;
    const s = t.getAsCurrentPoint();
    return {
      current: e,
      controlPoint: i,
      currentPoint: s
    };
  }
  pathT(t, e) {
    const { pathParser: i } = this, { current: s, controlPoint: r, currentPoint: o } = me.pathT(i);
    i.addMarker(o, r, r), e.addQuadraticCurve(s.x, s.y, r.x, r.y, o.x, o.y), t && t.quadraticCurveTo(r.x, r.y, o.x, o.y);
  }
  static pathA(t) {
    const { current: e, command: i } = t;
    let { rX: s, rY: r, xRot: o, lArcFlag: a, sweepFlag: l } = i;
    const c = o * (Math.PI / 180), h = t.getAsCurrentPoint(), u = new Pe(Math.cos(c) * (e.x - h.x) / 2 + Math.sin(c) * (e.y - h.y) / 2, -Math.sin(c) * (e.x - h.x) / 2 + Math.cos(c) * (e.y - h.y) / 2), p = Math.pow(u.x, 2) / Math.pow(s, 2) + Math.pow(u.y, 2) / Math.pow(r, 2);
    p > 1 && (s *= Math.sqrt(p), r *= Math.sqrt(p));
    let m = (a === l ? -1 : 1) * Math.sqrt((Math.pow(s, 2) * Math.pow(r, 2) - Math.pow(s, 2) * Math.pow(u.y, 2) - Math.pow(r, 2) * Math.pow(u.x, 2)) / (Math.pow(s, 2) * Math.pow(u.y, 2) + Math.pow(r, 2) * Math.pow(u.x, 2)));
    isNaN(m) && (m = 0);
    const g = new Pe(m * s * u.y / r, m * -r * u.x / s), _ = new Pe((e.x + h.x) / 2 + Math.cos(c) * g.x - Math.sin(c) * g.y, (e.y + h.y) / 2 + Math.sin(c) * g.x + Math.cos(c) * g.y), y = Tu([
      1,
      0
    ], [
      (u.x - g.x) / s,
      (u.y - g.y) / r
    ]), b = [
      (u.x - g.x) / s,
      (u.y - g.y) / r
    ], w = [
      (-u.x - g.x) / s,
      (-u.y - g.y) / r
    ];
    let v = Tu(b, w);
    return rh(b, w) <= -1 && (v = Math.PI), rh(b, w) >= 1 && (v = 0), {
      currentPoint: h,
      rX: s,
      rY: r,
      sweepFlag: l,
      xAxisRotation: c,
      centp: _,
      a1: y,
      ad: v
    };
  }
  pathA(t, e) {
    const { pathParser: i } = this, { currentPoint: s, rX: r, rY: o, sweepFlag: a, xAxisRotation: l, centp: c, a1: h, ad: u } = me.pathA(i), p = 1 - a ? 1 : -1, m = h + p * (u / 2), g = new Pe(c.x + r * Math.cos(m), c.y + o * Math.sin(m));
    if (i.addMarkerAngle(g, m - p * Math.PI / 2), i.addMarkerAngle(s, m - p * Math.PI), e.addPoint(s.x, s.y), t && !isNaN(h) && !isNaN(u)) {
      const _ = r > o ? r : o, y = r > o ? 1 : r / o, b = r > o ? o / r : 1;
      t.translate(c.x, c.y), t.rotate(l), t.scale(y, b), t.arc(0, 0, _, h, h + u, !!(1 - a)), t.scale(1 / y, 1 / b), t.rotate(-l), t.translate(-c.x, -c.y);
    }
  }
  static pathZ(t) {
    t.current = t.start;
  }
  pathZ(t, e) {
    me.pathZ(this.pathParser), t && e.x1 !== e.x2 && e.y1 !== e.y2 && t.closePath();
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "path", this.pathParser = new Nt(this.getAttribute("d").getString());
  }
}
class Ia extends _r {
  setContext(t) {
    var e;
    const { document: i } = this, { screen: s, window: r } = i, o = t.canvas;
    if (s.setDefaults(t), "style" in o && typeof t.font < "u" && r && typeof r.getComputedStyle < "u") {
      t.font = r.getComputedStyle(o).getPropertyValue("font");
      const w = new Zt(i, "fontSize", Li.parse(t.font).fontSize);
      w.hasValue() && (i.rootEmSize = w.getPixels("y"), i.emSize = i.rootEmSize);
    }
    this.getAttribute("x").hasValue() || this.getAttribute("x", !0).setValue(0), this.getAttribute("y").hasValue() || this.getAttribute("y", !0).setValue(0);
    let { width: a, height: l } = s.viewPort;
    this.getStyle("width").hasValue() || this.getStyle("width", !0).setValue("100%"), this.getStyle("height").hasValue() || this.getStyle("height", !0).setValue("100%"), this.getStyle("color").hasValue() || this.getStyle("color", !0).setValue("black");
    const c = this.getAttribute("refX"), h = this.getAttribute("refY"), u = this.getAttribute("viewBox"), p = u.hasValue() ? an(u.getString()) : null, m = !this.root && this.getStyle("overflow").getValue("hidden") !== "visible";
    let g = 0, _ = 0, y = 0, b = 0;
    p && (g = p[0], _ = p[1]), this.root || (a = this.getStyle("width").getPixels("x"), l = this.getStyle("height").getPixels("y"), this.type === "marker" && (y = g, b = _, g = 0, _ = 0)), s.viewPort.setCurrent(a, l), this.node && (!this.parent || ((e = this.node.parentNode) === null || e === void 0 ? void 0 : e.nodeName) === "foreignObject") && this.getStyle("transform", !1, !0).hasValue() && !this.getStyle("transform-origin", !1, !0).hasValue() && this.getStyle("transform-origin", !0, !0).setValue("50% 50%"), super.setContext(t), t.translate(this.getAttribute("x").getPixels("x"), this.getAttribute("y").getPixels("y")), p && (a = p[2], l = p[3]), i.setViewBox({
      ctx: t,
      aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
      width: s.viewPort.width,
      desiredWidth: a,
      height: s.viewPort.height,
      desiredHeight: l,
      minX: g,
      minY: _,
      refX: c.getValue(),
      refY: h.getValue(),
      clip: m,
      clipX: y,
      clipY: b
    }), p && (s.viewPort.removeCurrent(), s.viewPort.setCurrent(a, l));
  }
  clearContext(t) {
    super.clearContext(t), this.document.screen.viewPort.removeCurrent();
  }
  /**
  * Resize SVG to fit in given size.
  * @param width
  * @param height
  * @param preserveAspectRatio
  */
  resize(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    const s = this.getAttribute("width", !0), r = this.getAttribute("height", !0), o = this.getAttribute("viewBox"), a = this.getAttribute("style"), l = s.getNumber(0), c = r.getNumber(0);
    if (i)
      if (typeof i == "string")
        this.getAttribute("preserveAspectRatio", !0).setValue(i);
      else {
        const h = this.getAttribute("preserveAspectRatio");
        h.hasValue() && h.setValue(h.getString().replace(/^\s*(\S.*\S)\s*$/, "$1"));
      }
    if (s.setValue(t), r.setValue(e), o.hasValue() || o.setValue("0 0 ".concat(l || t, " ").concat(c || e)), a.hasValue()) {
      const h = this.getStyle("width"), u = this.getStyle("height");
      h.hasValue() && h.setValue("".concat(t, "px")), u.hasValue() && u.setValue("".concat(e, "px"));
    }
  }
  constructor(...t) {
    super(...t), this.type = "svg", this.root = !1;
  }
}
class Wp extends me {
  path(t) {
    const e = this.getAttribute("x").getPixels("x"), i = this.getAttribute("y").getPixels("y"), s = this.getStyle("width", !1, !0).getPixels("x"), r = this.getStyle("height", !1, !0).getPixels("y"), o = this.getAttribute("rx"), a = this.getAttribute("ry");
    let l = o.getPixels("x"), c = a.getPixels("y");
    if (o.hasValue() && !a.hasValue() && (c = l), a.hasValue() && !o.hasValue() && (l = c), l = Math.min(l, s / 2), c = Math.min(c, r / 2), t) {
      const h = 4 * ((Math.sqrt(2) - 1) / 3);
      t.beginPath(), r > 0 && s > 0 && (t.moveTo(e + l, i), t.lineTo(e + s - l, i), t.bezierCurveTo(e + s - l + h * l, i, e + s, i + c - h * c, e + s, i + c), t.lineTo(e + s, i + r - c), t.bezierCurveTo(e + s, i + r - c + h * c, e + s - l + h * l, i + r, e + s - l, i + r), t.lineTo(e + l, i + r), t.bezierCurveTo(e + l - h * l, i + r, e, i + r - c + h * c, e, i + r - c), t.lineTo(e, i + c), t.bezierCurveTo(e, i + c - h * c, e + l - h * l, i, e + l, i), t.closePath());
    }
    return new Tn(e, i, e + s, i + r);
  }
  getMarkers() {
    return null;
  }
  constructor(...t) {
    super(...t), this.type = "rect";
  }
}
class jb extends me {
  path(t) {
    const e = this.getAttribute("cx").getPixels("x"), i = this.getAttribute("cy").getPixels("y"), s = this.getAttribute("r").getPixels();
    return t && s > 0 && (t.beginPath(), t.arc(e, i, s, 0, Math.PI * 2, !1), t.closePath()), new Tn(e - s, i - s, e + s, i + s);
  }
  getMarkers() {
    return null;
  }
  constructor(...t) {
    super(...t), this.type = "circle";
  }
}
class Hb extends me {
  path(t) {
    const e = 4 * ((Math.sqrt(2) - 1) / 3), i = this.getAttribute("rx").getPixels("x"), s = this.getAttribute("ry").getPixels("y"), r = this.getAttribute("cx").getPixels("x"), o = this.getAttribute("cy").getPixels("y");
    return t && i > 0 && s > 0 && (t.beginPath(), t.moveTo(r + i, o), t.bezierCurveTo(r + i, o + e * s, r + e * i, o + s, r, o + s), t.bezierCurveTo(r - e * i, o + s, r - i, o + e * s, r - i, o), t.bezierCurveTo(r - i, o - e * s, r - e * i, o - s, r, o - s), t.bezierCurveTo(r + e * i, o - s, r + i, o - e * s, r + i, o), t.closePath()), new Tn(r - i, o - s, r + i, o + s);
  }
  getMarkers() {
    return null;
  }
  constructor(...t) {
    super(...t), this.type = "ellipse";
  }
}
class Ub extends me {
  getPoints() {
    return [
      new Pe(this.getAttribute("x1").getPixels("x"), this.getAttribute("y1").getPixels("y")),
      new Pe(this.getAttribute("x2").getPixels("x"), this.getAttribute("y2").getPixels("y"))
    ];
  }
  path(t) {
    const [{ x: e, y: i }, { x: s, y: r }] = this.getPoints();
    return t && (t.beginPath(), t.moveTo(e, i), t.lineTo(s, r)), new Tn(e, i, s, r);
  }
  getMarkers() {
    const [t, e] = this.getPoints(), i = t.angleTo(e);
    return [
      [
        t,
        i
      ],
      [
        e,
        i
      ]
    ];
  }
  constructor(...t) {
    super(...t), this.type = "line";
  }
}
class Pp extends me {
  path(t) {
    const { points: e } = this, [{ x: i, y: s }] = e, r = new Tn(i, s);
    return t && (t.beginPath(), t.moveTo(i, s)), e.forEach((o) => {
      let { x: a, y: l } = o;
      r.addPoint(a, l), t && t.lineTo(a, l);
    }), r;
  }
  getMarkers() {
    const { points: t } = this, e = t.length - 1, i = [];
    return t.forEach((s, r) => {
      r !== e && i.push([
        s,
        s.angleTo(t[r + 1])
      ]);
    }), i.length > 0 && i.push([
      t[t.length - 1],
      i[i.length - 1][1]
    ]), i;
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "polyline", this.points = [], this.points = Pe.parsePath(this.getAttribute("points").getString());
  }
}
class Qb extends Pp {
  path(t) {
    const e = super.path(t), [{ x: i, y: s }] = this.points;
    return t && (t.lineTo(i, s), t.closePath()), e;
  }
  constructor(...t) {
    super(...t), this.type = "polygon";
  }
}
class qb extends ke {
  createPattern(t, e, i) {
    const s = this.getStyle("width").getPixels("x", !0), r = this.getStyle("height").getPixels("y", !0), o = new Ia(this.document, null);
    o.attributes.viewBox = new Zt(this.document, "viewBox", this.getAttribute("viewBox").getValue()), o.attributes.width = new Zt(this.document, "width", "".concat(s, "px")), o.attributes.height = new Zt(this.document, "height", "".concat(r, "px")), o.attributes.transform = new Zt(this.document, "transform", this.getAttribute("patternTransform").getValue()), o.children = this.children;
    const a = this.document.createCanvas(s, r), l = a.getContext("2d"), c = this.getAttribute("x"), h = this.getAttribute("y");
    c.hasValue() && h.hasValue() && l.translate(c.getPixels("x", !0), h.getPixels("y", !0)), i.hasValue() ? this.styles["fill-opacity"] = i : Reflect.deleteProperty(this.styles, "fill-opacity");
    for (let p = -1; p <= 1; p++)
      for (let m = -1; m <= 1; m++)
        l.save(), o.attributes.x = new Zt(this.document, "x", p * a.width), o.attributes.y = new Zt(this.document, "y", m * a.height), o.render(l), l.restore();
    return t.createPattern(a, "repeat");
  }
  constructor(...t) {
    super(...t), this.type = "pattern";
  }
}
class $b extends ke {
  render(t, e, i) {
    if (!e)
      return;
    const { x: s, y: r } = e, o = this.getAttribute("orient").getString("auto"), a = this.getAttribute("markerUnits").getString("strokeWidth");
    t.translate(s, r), o === "auto" && t.rotate(i), a === "strokeWidth" && t.scale(t.lineWidth, t.lineWidth), t.save();
    const l = new Ia(this.document);
    l.type = this.type, l.attributes.viewBox = new Zt(this.document, "viewBox", this.getAttribute("viewBox").getValue()), l.attributes.refX = new Zt(this.document, "refX", this.getAttribute("refX").getValue()), l.attributes.refY = new Zt(this.document, "refY", this.getAttribute("refY").getValue()), l.attributes.width = new Zt(this.document, "width", this.getAttribute("markerWidth").getValue()), l.attributes.height = new Zt(this.document, "height", this.getAttribute("markerHeight").getValue()), l.attributes.overflow = new Zt(this.document, "overflow", this.getAttribute("overflow").getValue()), l.attributes.fill = new Zt(this.document, "fill", this.getAttribute("fill").getColor("black")), l.attributes.stroke = new Zt(this.document, "stroke", this.getAttribute("stroke").getValue("none")), l.children = this.children, l.render(t), t.restore(), a === "strokeWidth" && t.scale(1 / t.lineWidth, 1 / t.lineWidth), o === "auto" && t.rotate(-i), t.translate(-s, -r);
  }
  constructor(...t) {
    super(...t), this.type = "marker";
  }
}
class t0 extends ke {
  render() {
  }
  constructor(...t) {
    super(...t), this.type = "defs";
  }
}
class Dh extends _r {
  getBoundingBox(t) {
    const e = new Tn();
    return this.children.forEach((i) => {
      e.addBoundingBox(i.getBoundingBox(t));
    }), e;
  }
  constructor(...t) {
    super(...t), this.type = "g";
  }
}
class Vp extends ke {
  getGradientUnits() {
    return this.getAttribute("gradientUnits").getString("objectBoundingBox");
  }
  createGradient(t, e, i) {
    let s = this;
    this.getHrefAttribute().hasValue() && (s = this.getHrefAttribute().getDefinition(), this.inheritStopContainer(s));
    const { stops: r } = s, o = this.getGradient(t, e);
    if (!o)
      return this.addParentOpacity(i, r[r.length - 1].color);
    if (r.forEach((a) => {
      o.addColorStop(a.offset, this.addParentOpacity(i, a.color));
    }), this.getAttribute("gradientTransform").hasValue()) {
      const { document: a } = this, { MAX_VIRTUAL_PIXELS: l } = bs, { viewPort: c } = a.screen, h = c.getRoot(), u = new Wp(a);
      u.attributes.x = new Zt(a, "x", -l / 3), u.attributes.y = new Zt(a, "y", -l / 3), u.attributes.width = new Zt(a, "width", l), u.attributes.height = new Zt(a, "height", l);
      const p = new Dh(a);
      p.attributes.transform = new Zt(a, "transform", this.getAttribute("gradientTransform").getValue()), p.children = [
        u
      ];
      const m = new Ia(a);
      m.attributes.x = new Zt(a, "x", 0), m.attributes.y = new Zt(a, "y", 0), m.attributes.width = new Zt(a, "width", h.width), m.attributes.height = new Zt(a, "height", h.height), m.children = [
        p
      ];
      const g = a.createCanvas(h.width, h.height), _ = g.getContext("2d");
      return _.fillStyle = o, m.render(_), _.createPattern(g, "no-repeat");
    }
    return o;
  }
  inheritStopContainer(t) {
    this.attributesToInherit.forEach((e) => {
      !this.getAttribute(e).hasValue() && t.getAttribute(e).hasValue() && this.getAttribute(e, !0).setValue(t.getAttribute(e).getValue());
    });
  }
  addParentOpacity(t, e) {
    return t.hasValue() ? new Zt(this.document, "color", e).addOpacity(t).getColor() : e;
  }
  constructor(t, e, i) {
    super(t, e, i), this.attributesToInherit = [
      "gradientUnits"
    ], this.stops = [];
    const { stops: s, children: r } = this;
    r.forEach((o) => {
      o.type === "stop" && s.push(o);
    });
  }
}
class e0 extends Vp {
  getGradient(t, e) {
    const i = this.getGradientUnits() === "objectBoundingBox", s = i ? e.getBoundingBox(t) : null;
    if (i && !s)
      return null;
    !this.getAttribute("x1").hasValue() && !this.getAttribute("y1").hasValue() && !this.getAttribute("x2").hasValue() && !this.getAttribute("y2").hasValue() && (this.getAttribute("x1", !0).setValue(0), this.getAttribute("y1", !0).setValue(0), this.getAttribute("x2", !0).setValue(1), this.getAttribute("y2", !0).setValue(0));
    const r = i ? s.x + s.width * this.getAttribute("x1").getNumber() : this.getAttribute("x1").getPixels("x"), o = i ? s.y + s.height * this.getAttribute("y1").getNumber() : this.getAttribute("y1").getPixels("y"), a = i ? s.x + s.width * this.getAttribute("x2").getNumber() : this.getAttribute("x2").getPixels("x"), l = i ? s.y + s.height * this.getAttribute("y2").getNumber() : this.getAttribute("y2").getPixels("y");
    return r === a && o === l ? null : t.createLinearGradient(r, o, a, l);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "linearGradient", this.attributesToInherit.push("x1", "y1", "x2", "y2");
  }
}
class i0 extends Vp {
  getGradient(t, e) {
    const i = this.getGradientUnits() === "objectBoundingBox", s = e.getBoundingBox(t);
    if (i && !s)
      return null;
    this.getAttribute("cx").hasValue() || this.getAttribute("cx", !0).setValue("50%"), this.getAttribute("cy").hasValue() || this.getAttribute("cy", !0).setValue("50%"), this.getAttribute("r").hasValue() || this.getAttribute("r", !0).setValue("50%");
    const r = i ? s.x + s.width * this.getAttribute("cx").getNumber() : this.getAttribute("cx").getPixels("x"), o = i ? s.y + s.height * this.getAttribute("cy").getNumber() : this.getAttribute("cy").getPixels("y");
    let a = r, l = o;
    this.getAttribute("fx").hasValue() && (a = i ? s.x + s.width * this.getAttribute("fx").getNumber() : this.getAttribute("fx").getPixels("x")), this.getAttribute("fy").hasValue() && (l = i ? s.y + s.height * this.getAttribute("fy").getNumber() : this.getAttribute("fy").getPixels("y"));
    const c = i ? (s.width + s.height) / 2 * this.getAttribute("r").getNumber() : this.getAttribute("r").getPixels(), h = this.getAttribute("fr").getPixels();
    return t.createRadialGradient(a, l, h, r, o, c);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "radialGradient", this.attributesToInherit.push("cx", "cy", "r", "fx", "fy", "fr");
  }
}
class n0 extends ke {
  constructor(t, e, i) {
    super(t, e, i), this.type = "stop";
    const s = Math.max(0, Math.min(1, this.getAttribute("offset").getNumber())), r = this.getStyle("stop-opacity");
    let o = this.getStyle("stop-color", !0);
    o.getString() === "" && o.setValue("#000"), r.hasValue() && (o = o.addOpacity(r)), this.offset = s, this.color = o.getColor();
  }
}
class zh extends ke {
  getProperty() {
    const t = this.getAttribute("attributeType").getString(), e = this.getAttribute("attributeName").getString();
    return t === "CSS" ? this.parent.getStyle(e, !0) : this.parent.getAttribute(e, !0);
  }
  calcValue() {
    const { initialUnits: t } = this, { progress: e, from: i, to: s } = this.getProgress();
    let r = i.getNumber() + (s.getNumber() - i.getNumber()) * e;
    return t === "%" && (r *= 100), "".concat(r).concat(t);
  }
  update(t) {
    const { parent: e } = this, i = this.getProperty();
    if (this.initialValue || (this.initialValue = i.getString(), this.initialUnits = i.getUnits()), this.duration > this.maxDuration) {
      const r = this.getAttribute("fill").getString("remove");
      if (this.getAttribute("repeatCount").getString() === "indefinite" || this.getAttribute("repeatDur").getString() === "indefinite")
        this.duration = 0;
      else if (r === "freeze" && !this.frozen)
        this.frozen = !0, e && i && (e.animationFrozen = !0, e.animationFrozenValue = i.getString());
      else if (r === "remove" && !this.removed)
        return this.removed = !0, e && i && i.setValue(e.animationFrozen ? e.animationFrozenValue : this.initialValue), !0;
      return !1;
    }
    this.duration += t;
    let s = !1;
    if (this.begin < this.duration) {
      let r = this.calcValue();
      const o = this.getAttribute("type");
      if (o.hasValue()) {
        const a = o.getString();
        r = "".concat(a, "(").concat(r, ")");
      }
      i.setValue(r), s = !0;
    }
    return s;
  }
  getProgress() {
    const { document: t, values: e } = this;
    let i = (this.duration - this.begin) / (this.maxDuration - this.begin), s, r;
    if (e.hasValue()) {
      const o = i * (e.getValue().length - 1), a = Math.floor(o), l = Math.ceil(o);
      let c;
      c = e.getValue()[a], s = new Zt(t, "from", c ? parseFloat(c) : 0), c = e.getValue()[l], r = new Zt(t, "to", c ? parseFloat(c) : 0), i = (o - a) / (l - a);
    } else
      s = this.from, r = this.to;
    return {
      progress: i,
      from: s,
      to: r
    };
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "animate", this.duration = 0, this.initialUnits = "", this.removed = !1, this.frozen = !1, t.screen.animations.push(this), this.begin = this.getAttribute("begin").getMilliseconds(), this.maxDuration = this.begin + this.getAttribute("dur").getMilliseconds(), this.from = this.getAttribute("from"), this.to = this.getAttribute("to"), this.values = new Zt(t, "values", null);
    const s = this.getAttribute("values");
    s.hasValue() && this.values.setValue(s.getString().split(";"));
  }
}
class s0 extends zh {
  calcValue() {
    const { progress: t, from: e, to: i } = this.getProgress(), s = new nh(e.getColor()), r = new nh(i.getColor());
    if (s.ok && r.ok) {
      const o = s.r + (r.r - s.r) * t, a = s.g + (r.g - s.g) * t, l = s.b + (r.b - s.b) * t;
      return "rgb(".concat(Math.floor(o), ", ").concat(Math.floor(a), ", ").concat(Math.floor(l), ")");
    }
    return this.getAttribute("from").getColor();
  }
  constructor(...t) {
    super(...t), this.type = "animateColor";
  }
}
class r0 extends zh {
  calcValue() {
    const { progress: t, from: e, to: i } = this.getProgress(), s = an(e.getString()), r = an(i.getString());
    return s.map((a, l) => {
      const c = r[l];
      return a + (c - a) * t;
    }).join(" ");
  }
  constructor(...t) {
    super(...t), this.type = "animateTransform";
  }
}
class Yp extends ke {
  constructor(t, e, i) {
    super(t, e, i), this.type = "font-face", this.ascent = this.getAttribute("ascent").getNumber(), this.descent = this.getAttribute("descent").getNumber(), this.unitsPerEm = this.getAttribute("units-per-em").getNumber();
  }
}
class Jh extends me {
  constructor(t, e, i) {
    super(t, e, i), this.type = "glyph", this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber(), this.unicode = this.getAttribute("unicode").getString(), this.arabicForm = this.getAttribute("arabic-form").getString();
  }
}
class Gp extends Jh {
  constructor(...t) {
    super(...t), this.type = "missing-glyph", this.horizAdvX = 0;
  }
}
class o0 extends ke {
  render() {
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "font", this.isArabic = !1, this.glyphs = {}, this.arabicGlyphs = {}, this.isRTL = !1, this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
    const { definitions: s } = t, { children: r } = this;
    for (const o of r)
      if (o instanceof Yp) {
        this.fontFace = o;
        const a = o.getStyle("font-family");
        a.hasValue() && (s[a.getString()] = this);
      } else if (o instanceof Gp)
        this.missingGlyph = o;
      else if (o instanceof Jh)
        if (o.arabicForm) {
          this.isRTL = !0, this.isArabic = !0;
          const a = this.arabicGlyphs[o.unicode];
          typeof a > "u" ? this.arabicGlyphs[o.unicode] = {
            [o.arabicForm]: o
          } : a[o.arabicForm] = o;
        } else
          this.glyphs[o.unicode] = o;
  }
}
class a0 extends Fs {
  getText() {
    const t = this.getHrefAttribute().getDefinition();
    if (t) {
      const e = t.children[0];
      if (e)
        return e.getText();
    }
    return "";
  }
  constructor(...t) {
    super(...t), this.type = "tref";
  }
}
class l0 extends Fs {
  getText() {
    return this.text;
  }
  renderChildren(t) {
    if (this.hasText) {
      super.renderChildren(t);
      const { document: e, x: i, y: s } = this, { mouse: r } = e.screen, o = new Zt(e, "fontSize", Li.parse(e.ctx.font).fontSize);
      r.isWorking() && r.checkBoundingBox(this, new Tn(i, s - o.getPixels("y"), i + this.measureText(t), s));
    } else if (this.children.length > 0) {
      const e = new Dh(this.document);
      e.children = this.children, e.parent = this, e.render(t);
    }
  }
  onClick() {
    const { window: t } = this.document;
    t && t.open(this.getHrefAttribute().getString());
  }
  onMouseMove() {
    const t = this.document.ctx;
    t.canvas.style.cursor = "pointer";
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "a";
    const { childNodes: s } = e, r = s[0], o = s.length > 0 && Array.from(s).every(
      (a) => a.nodeType === 3
    );
    this.hasText = o, this.text = o ? this.getTextFromNode(r) : "";
  }
}
class c0 extends Fs {
  getText() {
    return this.text;
  }
  path(t) {
    const { dataArray: e } = this;
    t && t.beginPath(), e.forEach((i) => {
      let { type: s, points: r } = i;
      switch (s) {
        case Nt.LINE_TO:
          t && t.lineTo(r[0], r[1]);
          break;
        case Nt.MOVE_TO:
          t && t.moveTo(r[0], r[1]);
          break;
        case Nt.CURVE_TO:
          t && t.bezierCurveTo(r[0], r[1], r[2], r[3], r[4], r[5]);
          break;
        case Nt.QUAD_TO:
          t && t.quadraticCurveTo(r[0], r[1], r[2], r[3]);
          break;
        case Nt.ARC: {
          const [o, a, l, c, h, u, p, m] = r, g = l > c ? l : c, _ = l > c ? 1 : l / c, y = l > c ? c / l : 1;
          t && (t.translate(o, a), t.rotate(p), t.scale(_, y), t.arc(0, 0, g, h, h + u, !!(1 - m)), t.scale(1 / _, 1 / y), t.rotate(-p), t.translate(-o, -a));
          break;
        }
        case Nt.CLOSE_PATH:
          t && t.closePath();
          break;
      }
    });
  }
  renderChildren(t) {
    this.setTextData(t), t.save();
    const e = this.parent.getStyle("text-decoration").getString(), i = this.getFontSize(), { glyphInfo: s } = this, r = t.fillStyle;
    e === "underline" && t.beginPath(), s.forEach((o, a) => {
      const { p0: l, p1: c, rotation: h, text: u } = o;
      t.save(), t.translate(l.x, l.y), t.rotate(h), t.fillStyle && t.fillText(u, 0, 0), t.strokeStyle && t.strokeText(u, 0, 0), t.restore(), e === "underline" && (a === 0 && t.moveTo(l.x, l.y + i / 8), t.lineTo(c.x, c.y + i / 5));
    }), e === "underline" && (t.lineWidth = i / 20, t.strokeStyle = r, t.stroke(), t.closePath()), t.restore();
  }
  getLetterSpacingAt() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return this.letterSpacingCache[t] || 0;
  }
  findSegmentToFitChar(t, e, i, s, r, o, a, l, c) {
    let h = o, u = this.measureText(t, l);
    l === " " && e === "justify" && i < s && (u += (s - i) / r), c > -1 && (h += this.getLetterSpacingAt(c));
    const p = this.textHeight / 20, m = this.getEquidistantPointOnPath(h, p, 0), g = this.getEquidistantPointOnPath(h + u, p, 0), _ = {
      p0: m,
      p1: g
    }, y = m && g ? Math.atan2(g.y - m.y, g.x - m.x) : 0;
    if (a) {
      const b = Math.cos(Math.PI / 2 + y) * a, w = Math.cos(-y) * a;
      _.p0 = {
        ...m,
        x: m.x + b,
        y: m.y + w
      }, _.p1 = {
        ...g,
        x: g.x + b,
        y: g.y + w
      };
    }
    return h += u, {
      offset: h,
      segment: _,
      rotation: y
    };
  }
  measureText(t, e) {
    const { measuresCache: i } = this, s = e || this.getText();
    if (i.has(s))
      return i.get(s);
    const r = this.measureTargetText(t, s);
    return i.set(s, r), r;
  }
  // This method supposes what all custom fonts already loaded.
  // If some font will be loaded after this method call, <textPath> will not be rendered correctly.
  // You need to call this method manually to update glyphs cache.
  setTextData(t) {
    if (this.glyphInfo)
      return;
    const e = this.getText(), i = e.split(""), s = e.split(" ").length - 1, r = this.parent.getAttribute("dx").split().map(
      (v) => v.getPixels("x")
    ), o = this.parent.getAttribute("dy").getPixels("y"), a = this.parent.getStyle("text-anchor").getString("start"), l = this.getStyle("letter-spacing"), c = this.parent.getStyle("letter-spacing");
    let h = 0;
    !l.hasValue() || l.getValue() === "inherit" ? h = c.getPixels() : l.hasValue() && l.getValue() !== "initial" && l.getValue() !== "unset" && (h = l.getPixels());
    const u = [], p = e.length;
    this.letterSpacingCache = u;
    for (let v = 0; v < p; v++)
      u.push(typeof r[v] < "u" ? r[v] : h);
    const m = u.reduce(
      (v, C, k) => k === 0 ? 0 : v + C || 0,
      0
    ), g = this.measureText(t), _ = Math.max(g + m, 0);
    this.textWidth = g, this.textHeight = this.getFontSize(), this.glyphInfo = [];
    const y = this.getPathLength(), b = this.getStyle("startOffset").getNumber(0) * y;
    let w = 0;
    (a === "middle" || a === "center") && (w = -_ / 2), (a === "end" || a === "right") && (w = -_), w += b, i.forEach((v, C) => {
      const { offset: k, segment: Y, rotation: P } = this.findSegmentToFitChar(t, a, _, y, s, w, o, v, C);
      w = k, !(!Y.p0 || !Y.p1) && this.glyphInfo.push({
        // transposeX: midpoint.x,
        // transposeY: midpoint.y,
        text: i[C],
        p0: Y.p0,
        p1: Y.p1,
        rotation: P
      });
    });
  }
  parsePathData(t) {
    if (this.pathLength = -1, !t)
      return [];
    const e = [], { pathParser: i } = t;
    for (i.reset(); !i.isEnd(); ) {
      const { current: s } = i, r = s ? s.x : 0, o = s ? s.y : 0, a = i.next();
      let l = a.type, c = [];
      switch (a.type) {
        case Nt.MOVE_TO:
          this.pathM(i, c);
          break;
        case Nt.LINE_TO:
          l = this.pathL(i, c);
          break;
        case Nt.HORIZ_LINE_TO:
          l = this.pathH(i, c);
          break;
        case Nt.VERT_LINE_TO:
          l = this.pathV(i, c);
          break;
        case Nt.CURVE_TO:
          this.pathC(i, c);
          break;
        case Nt.SMOOTH_CURVE_TO:
          l = this.pathS(i, c);
          break;
        case Nt.QUAD_TO:
          this.pathQ(i, c);
          break;
        case Nt.SMOOTH_QUAD_TO:
          l = this.pathT(i, c);
          break;
        case Nt.ARC:
          c = this.pathA(i);
          break;
        case Nt.CLOSE_PATH:
          me.pathZ(i);
          break;
      }
      a.type !== Nt.CLOSE_PATH ? e.push({
        type: l,
        points: c,
        start: {
          x: r,
          y: o
        },
        pathLength: this.calcLength(r, o, l, c)
      }) : e.push({
        type: Nt.CLOSE_PATH,
        points: [],
        pathLength: 0
      });
    }
    return e;
  }
  pathM(t, e) {
    const { x: i, y: s } = me.pathM(t).point;
    e.push(i, s);
  }
  pathL(t, e) {
    const { x: i, y: s } = me.pathL(t).point;
    return e.push(i, s), Nt.LINE_TO;
  }
  pathH(t, e) {
    const { x: i, y: s } = me.pathH(t).point;
    return e.push(i, s), Nt.LINE_TO;
  }
  pathV(t, e) {
    const { x: i, y: s } = me.pathV(t).point;
    return e.push(i, s), Nt.LINE_TO;
  }
  pathC(t, e) {
    const { point: i, controlPoint: s, currentPoint: r } = me.pathC(t);
    e.push(i.x, i.y, s.x, s.y, r.x, r.y);
  }
  pathS(t, e) {
    const { point: i, controlPoint: s, currentPoint: r } = me.pathS(t);
    return e.push(i.x, i.y, s.x, s.y, r.x, r.y), Nt.CURVE_TO;
  }
  pathQ(t, e) {
    const { controlPoint: i, currentPoint: s } = me.pathQ(t);
    e.push(i.x, i.y, s.x, s.y);
  }
  pathT(t, e) {
    const { controlPoint: i, currentPoint: s } = me.pathT(t);
    return e.push(i.x, i.y, s.x, s.y), Nt.QUAD_TO;
  }
  pathA(t) {
    let { rX: e, rY: i, sweepFlag: s, xAxisRotation: r, centp: o, a1: a, ad: l } = me.pathA(t);
    return s === 0 && l > 0 && (l -= 2 * Math.PI), s === 1 && l < 0 && (l += 2 * Math.PI), [
      o.x,
      o.y,
      e,
      i,
      a,
      l,
      r,
      s
    ];
  }
  calcLength(t, e, i, s) {
    let r = 0, o = null, a = null, l = 0;
    switch (i) {
      case Nt.LINE_TO:
        return this.getLineLength(t, e, s[0], s[1]);
      case Nt.CURVE_TO:
        for (r = 0, o = this.getPointOnCubicBezier(0, t, e, s[0], s[1], s[2], s[3], s[4], s[5]), l = 0.01; l <= 1; l += 0.01)
          a = this.getPointOnCubicBezier(l, t, e, s[0], s[1], s[2], s[3], s[4], s[5]), r += this.getLineLength(o.x, o.y, a.x, a.y), o = a;
        return r;
      case Nt.QUAD_TO:
        for (r = 0, o = this.getPointOnQuadraticBezier(0, t, e, s[0], s[1], s[2], s[3]), l = 0.01; l <= 1; l += 0.01)
          a = this.getPointOnQuadraticBezier(l, t, e, s[0], s[1], s[2], s[3]), r += this.getLineLength(o.x, o.y, a.x, a.y), o = a;
        return r;
      case Nt.ARC: {
        r = 0;
        const c = s[4], h = s[5], u = s[4] + h;
        let p = Math.PI / 180;
        if (Math.abs(c - u) < p && (p = Math.abs(c - u)), o = this.getPointOnEllipticalArc(s[0], s[1], s[2], s[3], c, 0), h < 0)
          for (l = c - p; l > u; l -= p)
            a = this.getPointOnEllipticalArc(s[0], s[1], s[2], s[3], l, 0), r += this.getLineLength(o.x, o.y, a.x, a.y), o = a;
        else
          for (l = c + p; l < u; l += p)
            a = this.getPointOnEllipticalArc(s[0], s[1], s[2], s[3], l, 0), r += this.getLineLength(o.x, o.y, a.x, a.y), o = a;
        return a = this.getPointOnEllipticalArc(s[0], s[1], s[2], s[3], u, 0), r += this.getLineLength(o.x, o.y, a.x, a.y), r;
      }
    }
    return 0;
  }
  getPointOnLine(t, e, i, s, r) {
    let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : e, a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : i;
    const l = (r - i) / (s - e + Er);
    let c = Math.sqrt(t * t / (1 + l * l));
    s < e && (c *= -1);
    let h = l * c, u = null;
    if (s === e)
      u = {
        x: o,
        y: a + h
      };
    else if ((a - i) / (o - e + Er) === l)
      u = {
        x: o + c,
        y: a + h
      };
    else {
      let p = 0, m = 0;
      const g = this.getLineLength(e, i, s, r);
      if (g < Er)
        return null;
      let _ = (o - e) * (s - e) + (a - i) * (r - i);
      _ /= g * g, p = e + _ * (s - e), m = i + _ * (r - i);
      const y = this.getLineLength(o, a, p, m), b = Math.sqrt(t * t - y * y);
      c = Math.sqrt(b * b / (1 + l * l)), s < e && (c *= -1), h = l * c, u = {
        x: p + c,
        y: m + h
      };
    }
    return u;
  }
  getPointOnPath(t) {
    const e = this.getPathLength();
    let i = 0, s = null;
    if (t < -5e-5 || t - 5e-5 > e)
      return null;
    const { dataArray: r } = this;
    for (const o of r) {
      if (o && (o.pathLength < 5e-5 || i + o.pathLength + 5e-5 < t)) {
        i += o.pathLength;
        continue;
      }
      const a = t - i;
      let l = 0;
      switch (o.type) {
        case Nt.LINE_TO:
          s = this.getPointOnLine(a, o.start.x, o.start.y, o.points[0], o.points[1], o.start.x, o.start.y);
          break;
        case Nt.ARC: {
          const c = o.points[4], h = o.points[5], u = o.points[4] + h;
          if (l = c + a / o.pathLength * h, h < 0 && l < u || h >= 0 && l > u)
            break;
          s = this.getPointOnEllipticalArc(o.points[0], o.points[1], o.points[2], o.points[3], l, o.points[6]);
          break;
        }
        case Nt.CURVE_TO:
          l = a / o.pathLength, l > 1 && (l = 1), s = this.getPointOnCubicBezier(l, o.start.x, o.start.y, o.points[0], o.points[1], o.points[2], o.points[3], o.points[4], o.points[5]);
          break;
        case Nt.QUAD_TO:
          l = a / o.pathLength, l > 1 && (l = 1), s = this.getPointOnQuadraticBezier(l, o.start.x, o.start.y, o.points[0], o.points[1], o.points[2], o.points[3]);
          break;
      }
      if (s)
        return s;
      break;
    }
    return null;
  }
  getLineLength(t, e, i, s) {
    return Math.sqrt((i - t) * (i - t) + (s - e) * (s - e));
  }
  getPathLength() {
    return this.pathLength === -1 && (this.pathLength = this.dataArray.reduce(
      (t, e) => e.pathLength > 0 ? t + e.pathLength : t,
      0
    )), this.pathLength;
  }
  getPointOnCubicBezier(t, e, i, s, r, o, a, l, c) {
    const h = l * Eu(t) + o * Nu(t) + s * Ru(t) + e * Lu(t), u = c * Eu(t) + a * Nu(t) + r * Ru(t) + i * Lu(t);
    return {
      x: h,
      y: u
    };
  }
  getPointOnQuadraticBezier(t, e, i, s, r, o, a) {
    const l = o * Xu(t) + s * Fu(t) + e * Ku(t), c = a * Xu(t) + r * Fu(t) + i * Ku(t);
    return {
      x: l,
      y: c
    };
  }
  getPointOnEllipticalArc(t, e, i, s, r, o) {
    const a = Math.cos(o), l = Math.sin(o), c = {
      x: i * Math.cos(r),
      y: s * Math.sin(r)
    };
    return {
      x: t + (c.x * a - c.y * l),
      y: e + (c.x * l + c.y * a)
    };
  }
  // TODO need some optimisations. possibly build cache only for curved segments?
  buildEquidistantCache(t, e) {
    const i = this.getPathLength(), s = e || 0.25, r = t || i / 100;
    if (!this.equidistantCache || this.equidistantCache.step !== r || this.equidistantCache.precision !== s) {
      this.equidistantCache = {
        step: r,
        precision: s,
        points: []
      };
      let o = 0;
      for (let a = 0; a <= i; a += s) {
        const l = this.getPointOnPath(a), c = this.getPointOnPath(a + s);
        !l || !c || (o += this.getLineLength(l.x, l.y, c.x, c.y), o >= r && (this.equidistantCache.points.push({
          x: l.x,
          y: l.y,
          distance: a
        }), o -= r));
      }
    }
  }
  getEquidistantPointOnPath(t, e, i) {
    if (this.buildEquidistantCache(e, i), t < 0 || t - this.getPathLength() > 5e-5)
      return null;
    const s = Math.round(t / this.getPathLength() * (this.equidistantCache.points.length - 1));
    return this.equidistantCache.points[s] || null;
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "textPath", this.textWidth = 0, this.textHeight = 0, this.pathLength = -1, this.glyphInfo = null, this.letterSpacingCache = [], this.measuresCache = /* @__PURE__ */ new Map([
      [
        "",
        0
      ]
    ]);
    const s = this.getHrefAttribute().getDefinition();
    this.text = this.getTextFromNode(), this.dataArray = this.parsePathData(s);
  }
}
const h0 = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
class u0 extends _r {
  async loadImage(t) {
    try {
      const e = await this.document.createImage(t);
      this.image = e;
    } catch (e) {
      console.error('Error while loading image "'.concat(t, '":'), e);
    }
    this.loaded = !0;
  }
  async loadSvg(t) {
    const e = h0.exec(t);
    if (e) {
      const i = e[5];
      i && (e[4] === "base64" ? this.image = atob(i) : this.image = decodeURIComponent(i));
    } else
      try {
        const s = await (await this.document.fetch(t)).text();
        this.image = s;
      } catch (i) {
        console.error('Error while loading image "'.concat(t, '":'), i);
      }
    this.loaded = !0;
  }
  renderChildren(t) {
    const { document: e, image: i, loaded: s } = this, r = this.getAttribute("x").getPixels("x"), o = this.getAttribute("y").getPixels("y"), a = this.getStyle("width").getPixels("x"), l = this.getStyle("height").getPixels("y");
    if (!(!s || !i || !a || !l)) {
      if (t.save(), t.translate(r, o), typeof i == "string") {
        const c = e.canvg.forkString(t, i, {
          ignoreMouse: !0,
          ignoreAnimation: !0,
          ignoreDimensions: !0,
          ignoreClear: !0,
          offsetX: 0,
          offsetY: 0,
          scaleWidth: a,
          scaleHeight: l
        }), { documentElement: h } = c.document;
        h && (h.parent = this), c.render();
      } else
        e.setViewBox({
          ctx: t,
          aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
          width: a,
          desiredWidth: i.width,
          height: l,
          desiredHeight: i.height
        }), this.loaded && (!("complete" in i) || i.complete) && t.drawImage(i, 0, 0);
      t.restore();
    }
  }
  getBoundingBox() {
    const t = this.getAttribute("x").getPixels("x"), e = this.getAttribute("y").getPixels("y"), i = this.getStyle("width").getPixels("x"), s = this.getStyle("height").getPixels("y");
    return new Tn(t, e, t + i, e + s);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "image", this.loaded = !1;
    const s = this.getHrefAttribute().getString();
    if (!s)
      return;
    const r = s.endsWith(".svg") || /^\s*data:image\/svg\+xml/i.test(s);
    t.images.push(this), r ? this.loadSvg(s) : this.loadImage(s);
  }
}
class d0 extends _r {
  render(t) {
  }
  constructor(...t) {
    super(...t), this.type = "symbol";
  }
}
class m0 {
  async load(t, e) {
    try {
      const { document: i } = this, r = (await i.canvg.parser.load(e)).getElementsByTagName("font");
      Array.from(r).forEach((o) => {
        const a = i.createElement(o);
        i.definitions[t] = a;
      });
    } catch (i) {
      console.error('Error while loading font "'.concat(e, '":'), i);
    }
    this.loaded = !0;
  }
  constructor(t) {
    this.document = t, this.loaded = !1, t.fonts.push(this);
  }
}
class Tp extends ke {
  constructor(t, e, i) {
    super(t, e, i), this.type = "style", $r(
      Array.from(e.childNodes).map(
        (o) => o.textContent
      ).join("").replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, "").replace(/@import.*;/g, "")
      // remove imports
    ).split("}").forEach((o) => {
      const a = o.trim();
      if (!a)
        return;
      const l = a.split("{"), c = l[0].split(","), h = l[1].split(";");
      c.forEach((u) => {
        const p = u.trim();
        if (!p)
          return;
        const m = t.styles[p] || {};
        if (h.forEach((g) => {
          const _ = g.indexOf(":"), y = g.substr(0, _).trim(), b = g.substr(_ + 1, g.length - _).trim();
          y && b && (m[y] = new Zt(t, y, b));
        }), t.styles[p] = m, t.stylesSpecificity[p] = Vb(p), p === "@font-face") {
          const g = m["font-family"].getString().replace(/"|'/g, "");
          m.src.getString().split(",").forEach((y) => {
            if (y.indexOf('format("svg")') > 0) {
              const b = Sp(y);
              b && new m0(t).load(g, b);
            }
          });
        }
      });
    });
  }
}
Tp.parseExternalUrl = Sp;
class p0 extends _r {
  setContext(t) {
    super.setContext(t);
    const e = this.getAttribute("x"), i = this.getAttribute("y");
    e.hasValue() && t.translate(e.getPixels("x"), 0), i.hasValue() && t.translate(0, i.getPixels("y"));
  }
  path(t) {
    const { element: e } = this;
    e && e.path(t);
  }
  renderChildren(t) {
    const { document: e, element: i } = this;
    if (i) {
      let s = i;
      if (i.type === "symbol" && (s = new Ia(e), s.attributes.viewBox = new Zt(e, "viewBox", i.getAttribute("viewBox").getString()), s.attributes.preserveAspectRatio = new Zt(e, "preserveAspectRatio", i.getAttribute("preserveAspectRatio").getString()), s.attributes.overflow = new Zt(e, "overflow", i.getAttribute("overflow").getString()), s.children = i.children, i.styles.opacity = new Zt(e, "opacity", this.calculateOpacity())), s.type === "svg") {
        const o = this.getStyle("width", !1, !0), a = this.getStyle("height", !1, !0);
        o.hasValue() && (s.attributes.width = new Zt(e, "width", o.getString())), a.hasValue() && (s.attributes.height = new Zt(e, "height", a.getString()));
      }
      const r = s.parent;
      s.parent = this, s.render(t), s.parent = r;
    }
  }
  getBoundingBox(t) {
    const { element: e } = this;
    return e ? e.getBoundingBox(t) : null;
  }
  elementTransform() {
    const { document: t, element: e } = this;
    return e ? pr.fromElement(t, e) : null;
  }
  get element() {
    return this.cachedElement || (this.cachedElement = this.getHrefAttribute().getDefinition()), this.cachedElement;
  }
  constructor(...t) {
    super(...t), this.type = "use";
  }
}
function Pa(n, t, e, i, s, r) {
  return n[e * i * 4 + t * 4 + r];
}
function Va(n, t, e, i, s, r, o) {
  n[e * i * 4 + t * 4 + r] = o;
}
function qe(n, t, e) {
  return n[t] * e;
}
function ns(n, t, e, i) {
  return t + Math.cos(n) * e + Math.sin(n) * i;
}
class Ep extends ke {
  apply(t, e, i, s, r) {
    const { includeOpacity: o, matrix: a } = this, l = t.getImageData(0, 0, s, r);
    for (let c = 0; c < r; c++)
      for (let h = 0; h < s; h++) {
        const u = Pa(l.data, h, c, s, r, 0), p = Pa(l.data, h, c, s, r, 1), m = Pa(l.data, h, c, s, r, 2), g = Pa(l.data, h, c, s, r, 3);
        let _ = qe(a, 0, u) + qe(a, 1, p) + qe(a, 2, m) + qe(a, 3, g) + qe(a, 4, 1), y = qe(a, 5, u) + qe(a, 6, p) + qe(a, 7, m) + qe(a, 8, g) + qe(a, 9, 1), b = qe(a, 10, u) + qe(a, 11, p) + qe(a, 12, m) + qe(a, 13, g) + qe(a, 14, 1), w = qe(a, 15, u) + qe(a, 16, p) + qe(a, 17, m) + qe(a, 18, g) + qe(a, 19, 1);
        o && (_ = 0, y = 0, b = 0, w *= g / 255), Va(l.data, h, c, s, r, 0, _), Va(l.data, h, c, s, r, 1, y), Va(l.data, h, c, s, r, 2, b), Va(l.data, h, c, s, r, 3, w);
      }
    t.clearRect(0, 0, s, r), t.putImageData(l, 0, 0);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "feColorMatrix";
    let s = an(this.getAttribute("values").getString());
    switch (this.getAttribute("type").getString("matrix")) {
      case "saturate": {
        const r = s[0];
        s = [
          0.213 + 0.787 * r,
          0.715 - 0.715 * r,
          0.072 - 0.072 * r,
          0,
          0,
          0.213 - 0.213 * r,
          0.715 + 0.285 * r,
          0.072 - 0.072 * r,
          0,
          0,
          0.213 - 0.213 * r,
          0.715 - 0.715 * r,
          0.072 + 0.928 * r,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1
        ];
        break;
      }
      case "hueRotate": {
        const r = s[0] * Math.PI / 180;
        s = [
          ns(r, 0.213, 0.787, -0.213),
          ns(r, 0.715, -0.715, -0.715),
          ns(r, 0.072, -0.072, 0.928),
          0,
          0,
          ns(r, 0.213, -0.213, 0.143),
          ns(r, 0.715, 0.285, 0.14),
          ns(r, 0.072, -0.072, -0.283),
          0,
          0,
          ns(r, 0.213, -0.213, -0.787),
          ns(r, 0.715, -0.715, 0.715),
          ns(r, 0.072, 0.928, 0.072),
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1
        ];
        break;
      }
      case "luminanceToAlpha":
        s = [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0.2125,
          0.7154,
          0.0721,
          0,
          0,
          0,
          0,
          0,
          0,
          1
        ];
        break;
    }
    this.matrix = s, this.includeOpacity = this.getAttribute("includeOpacity").hasValue();
  }
}
class $l extends ke {
  apply(t, e) {
    const { document: i } = this;
    let s = this.getAttribute("x").getPixels("x"), r = this.getAttribute("y").getPixels("y"), o = this.getStyle("width").getPixels("x"), a = this.getStyle("height").getPixels("y");
    if (!o && !a) {
      const m = new Tn();
      this.children.forEach((g) => {
        m.addBoundingBox(g.getBoundingBox(t));
      }), s = Math.floor(m.x1), r = Math.floor(m.y1), o = Math.floor(m.width), a = Math.floor(m.height);
    }
    const l = this.removeStyles(e, $l.ignoreStyles), c = i.createCanvas(s + o, r + a), h = c.getContext("2d");
    i.screen.setDefaults(h), this.renderChildren(h), new Ep(i, {
      nodeType: 1,
      childNodes: [],
      attributes: [
        {
          nodeName: "type",
          value: "luminanceToAlpha"
        },
        {
          nodeName: "includeOpacity",
          value: "true"
        }
      ]
    }).apply(h, 0, 0, s + o, r + a);
    const u = i.createCanvas(s + o, r + a), p = u.getContext("2d");
    i.screen.setDefaults(p), e.render(p), p.globalCompositeOperation = "destination-in", p.fillStyle = h.createPattern(c, "no-repeat"), p.fillRect(0, 0, s + o, r + a), t.fillStyle = p.createPattern(u, "no-repeat"), t.fillRect(0, 0, s + o, r + a), this.restoreStyles(e, l);
  }
  render(t) {
  }
  constructor(...t) {
    super(...t), this.type = "mask";
  }
}
$l.ignoreStyles = [
  "mask",
  "transform",
  "clip-path"
];
const Au = () => {
};
class g0 extends ke {
  apply(t) {
    const { document: e } = this, i = Reflect.getPrototypeOf(t), { beginPath: s, closePath: r } = t;
    i && (i.beginPath = Au, i.closePath = Au), Reflect.apply(s, t, []), this.children.forEach((o) => {
      if (!("path" in o))
        return;
      let a = "elementTransform" in o ? o.elementTransform() : null;
      a || (a = pr.fromElement(e, o)), a && a.apply(t), o.path(t), i && (i.closePath = r), a && a.unapply(t);
    }), Reflect.apply(r, t, []), t.clip(), i && (i.beginPath = s, i.closePath = r);
  }
  render(t) {
  }
  constructor(...t) {
    super(...t), this.type = "clipPath";
  }
}
class tc extends ke {
  apply(t, e) {
    const { document: i, children: s } = this, r = "getBoundingBox" in e ? e.getBoundingBox(t) : null;
    if (!r)
      return;
    let o = 0, a = 0;
    s.forEach((b) => {
      const w = b.extraFilterDistance || 0;
      o = Math.max(o, w), a = Math.max(a, w);
    });
    const l = Math.floor(r.width), c = Math.floor(r.height), h = l + 2 * o, u = c + 2 * a;
    if (h < 1 || u < 1)
      return;
    const p = Math.floor(r.x), m = Math.floor(r.y), g = this.removeStyles(e, tc.ignoreStyles), _ = i.createCanvas(h, u), y = _.getContext("2d");
    i.screen.setDefaults(y), y.translate(-p + o, -m + a), e.render(y), s.forEach((b) => {
      typeof b.apply == "function" && b.apply(y, 0, 0, h, u);
    }), t.drawImage(_, 0, 0, h, u, p - o, m - a, h, u), this.restoreStyles(e, g);
  }
  render(t) {
  }
  constructor(...t) {
    super(...t), this.type = "filter";
  }
}
tc.ignoreStyles = [
  "filter",
  "transform",
  "clip-path"
];
class f0 extends ke {
  apply(t, e, i, s, r) {
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "feDropShadow", this.addStylesFromStyleDefinition();
  }
}
class _0 extends ke {
  apply(t, e, i, s, r) {
  }
  constructor(...t) {
    super(...t), this.type = "feMorphology";
  }
}
class y0 extends ke {
  apply(t, e, i, s, r) {
  }
  constructor(...t) {
    super(...t), this.type = "feComposite";
  }
}
class b0 extends ke {
  apply(t, e, i, s, r) {
    const { document: o, blurRadius: a } = this, l = o.window ? o.window.document.body : null, c = t.canvas;
    c.id = o.getUniqueId(), l && (c.style.display = "none", l.appendChild(c)), fb(c, e, i, s, r, a), l && l.removeChild(c);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "feGaussianBlur", this.blurRadius = Math.floor(this.getAttribute("stdDeviation").getNumber()), this.extraFilterDistance = this.blurRadius;
  }
}
class I0 extends ke {
  constructor(...t) {
    super(...t), this.type = "title";
  }
}
class w0 extends ke {
  constructor(...t) {
    super(...t), this.type = "desc";
  }
}
const v0 = {
  svg: Ia,
  rect: Wp,
  circle: jb,
  ellipse: Hb,
  line: Ub,
  polyline: Pp,
  polygon: Qb,
  path: me,
  pattern: qb,
  marker: $b,
  defs: t0,
  linearGradient: e0,
  radialGradient: i0,
  stop: n0,
  animate: zh,
  animateColor: s0,
  animateTransform: r0,
  font: o0,
  "font-face": Yp,
  "missing-glyph": Gp,
  glyph: Jh,
  text: Fs,
  tspan: ql,
  tref: a0,
  a: l0,
  textPath: c0,
  image: u0,
  g: Dh,
  symbol: d0,
  style: Tp,
  use: p0,
  mask: $l,
  clipPath: g0,
  filter: tc,
  feDropShadow: f0,
  feMorphology: _0,
  feComposite: y0,
  feColorMatrix: Ep,
  feGaussianBlur: b0,
  title: I0,
  desc: w0
};
function x0(n, t) {
  const e = document.createElement("canvas");
  return e.width = n, e.height = t, e;
}
async function S0(n) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const e = document.createElement("img");
  return t && (e.crossOrigin = "Anonymous"), new Promise((i, s) => {
    e.onload = () => {
      i(e);
    }, e.onerror = (r, o, a, l, c) => {
      s(c);
    }, e.src = n;
  });
}
const gc = 12;
class Gs {
  bindCreateImage(t, e) {
    return typeof e == "boolean" ? (i, s) => t(i, typeof s == "boolean" ? s : e) : t;
  }
  get window() {
    return this.screen.window;
  }
  get fetch() {
    return this.screen.fetch;
  }
  get ctx() {
    return this.screen.ctx;
  }
  get emSize() {
    const { emSizeStack: t } = this;
    return t[t.length - 1] || gc;
  }
  set emSize(t) {
    const { emSizeStack: e } = this;
    e.push(t);
  }
  popEmSize() {
    const { emSizeStack: t } = this;
    t.pop();
  }
  getUniqueId() {
    return "canvg".concat(++this.uniqueId);
  }
  isImagesLoaded() {
    return this.images.every(
      (t) => t.loaded
    );
  }
  isFontsLoaded() {
    return this.fonts.every(
      (t) => t.loaded
    );
  }
  createDocumentElement(t) {
    const e = this.createElement(t.documentElement);
    return e.root = !0, e.addStylesFromStyleDefinition(), this.documentElement = e, e;
  }
  createElement(t) {
    const e = t.nodeName.replace(/^[^:]+:/, ""), i = Gs.elementTypes[e];
    return i ? new i(this, t) : new Ob(this, t);
  }
  createTextNode(t) {
    return new Bb(this, t);
  }
  setViewBox(t) {
    this.screen.setViewBox({
      document: this,
      ...t
    });
  }
  constructor(t, { rootEmSize: e = gc, emSize: i = gc, createCanvas: s = Gs.createCanvas, createImage: r = Gs.createImage, anonymousCrossOrigin: o } = {}) {
    this.canvg = t, this.definitions = {}, this.styles = {}, this.stylesSpecificity = {}, this.images = [], this.fonts = [], this.emSizeStack = [], this.uniqueId = 0, this.screen = t.screen, this.rootEmSize = e, this.emSize = i, this.createCanvas = s, this.createImage = this.bindCreateImage(r, o), this.screen.wait(
      () => this.isImagesLoaded()
    ), this.screen.wait(
      () => this.isFontsLoaded()
    );
  }
}
Gs.createCanvas = x0;
Gs.createImage = S0;
Gs.elementTypes = v0;
class ir {
  /**
  * Create Canvg instance from SVG source string or URL.
  * @param ctx - Rendering context.
  * @param svg - SVG source string or URL.
  * @param options - Rendering options.
  * @returns Canvg instance.
  */
  static async from(t, e) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const r = await new pc(i).parse(e);
    return new ir(t, r, i);
  }
  /**
  * Create Canvg instance from SVG source string.
  * @param ctx - Rendering context.
  * @param svg - SVG source string.
  * @param options - Rendering options.
  * @returns Canvg instance.
  */
  static fromString(t, e) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const r = new pc(i).parseFromString(e);
    return new ir(t, r, i);
  }
  /**
  * Create new Canvg instance with inherited options.
  * @param ctx - Rendering context.
  * @param svg - SVG source string or URL.
  * @param options - Rendering options.
  * @returns Canvg instance.
  */
  fork(t, e) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ir.from(t, e, {
      ...this.options,
      ...i
    });
  }
  /**
  * Create new Canvg instance with inherited options.
  * @param ctx - Rendering context.
  * @param svg - SVG source string.
  * @param options - Rendering options.
  * @returns Canvg instance.
  */
  forkString(t, e) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ir.fromString(t, e, {
      ...this.options,
      ...i
    });
  }
  /**
  * Document is ready promise.
  * @returns Ready promise.
  */
  ready() {
    return this.screen.ready();
  }
  /**
  * Document is ready value.
  * @returns Is ready or not.
  */
  isReady() {
    return this.screen.isReady();
  }
  /**
  * Render only first frame, ignoring animations and mouse.
  * @param options - Rendering options.
  */
  async render() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.start({
      enableRedraw: !0,
      ignoreAnimation: !0,
      ignoreMouse: !0,
      ...t
    }), await this.ready(), this.stop();
  }
  /**
  * Start rendering.
  * @param options - Render options.
  */
  start() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { documentElement: e, screen: i, options: s } = this;
    i.start(e, {
      enableRedraw: !0,
      ...s,
      ...t
    });
  }
  /**
  * Stop rendering.
  */
  stop() {
    this.screen.stop();
  }
  /**
  * Resize SVG to fit in given size.
  * @param width
  * @param height
  * @param preserveAspectRatio
  */
  resize(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    this.documentElement.resize(t, e, i);
  }
  /**
  * Main constructor.
  * @param ctx - Rendering context.
  * @param svg - SVG Document.
  * @param options - Rendering options.
  */
  constructor(t, e, i = {}) {
    this.parser = new pc(i), this.screen = new bs(t, i), this.options = i;
    const s = new Gs(this, i), r = s.createDocumentElement(e);
    this.document = s, this.documentElement = r;
  }
}
(function(n, t, e, i, s, r) {
  function o(f, I, x, M, R) {
    return m(f, f, x, M, I, f.defaultView.pageXOffset, f.defaultView.pageYOffset).then(function(F) {
      W("Document cloned");
      var ot = "data-html2canvas-node" + R, q = "[" + ot + "='" + R + "']";
      f.querySelector(q).removeAttribute(ot);
      var ot = F.contentWindow, pt = ot.document.querySelector(q);
      return (typeof I.onclone == "function" ? Promise.resolve(I.onclone(ot.document)) : Promise.resolve(!0)).then(function() {
        return a(pt, F, I, x, M);
      });
    });
  }
  function a(f, I, x, M, R) {
    var F = I.contentWindow, q = new wn(F.document), ot = new X(x, q), pt = O(f);
    M = x.type === "view" ? M : c(F.document), R = x.type === "view" ? R : h(F.document);
    var Rt = new x.renderer(M, R, ot, x, t);
    return new rt(f, Rt, q, ot, x).ready.then(function() {
      W("Finished rendering");
      var ue;
      return ue = x.type === "view" ? l(Rt.canvas, {
        width: Rt.canvas.width,
        height: Rt.canvas.height,
        top: 0,
        left: 0,
        x: 0,
        y: 0
      }) : f === F.document.body || f === F.document.documentElement || x.canvas != null ? Rt.canvas : l(Rt.canvas, {
        width: x.width != null ? x.width : pt.width,
        height: x.height != null ? x.height : pt.height,
        top: pt.top,
        left: pt.left,
        x: F.pageXOffset,
        y: F.pageYOffset
      }), x.removeContainer && (I.parentNode.removeChild(I), W("Cleaned up container")), ue;
    });
  }
  function l(f, I) {
    var x = t.createElement("canvas"), M = Math.min(f.width - 1, Math.max(0, I.left)), R = Math.min(f.width, Math.max(1, I.left + I.width)), F = Math.min(f.height - 1, Math.max(0, I.top)), q = Math.min(f.height, Math.max(1, I.top + I.height));
    return x.width = I.width, x.height = I.height, W("Cropping canvas at:", "left:", I.left, "top:", I.top, "width:", R - M, "height:", q - F), W("Resulting crop with width", I.width, "and height", I.height, " with x", M, "and y", F), x.getContext("2d").drawImage(f, M, F, R - M, q - F, I.x, I.y, R - M, q - F), x;
  }
  function c(f) {
    return Math.max(
      Math.max(f.body.scrollWidth, f.documentElement.scrollWidth),
      Math.max(f.body.offsetWidth, f.documentElement.offsetWidth),
      Math.max(f.body.clientWidth, f.documentElement.clientWidth)
    );
  }
  function h(f) {
    return Math.max(
      Math.max(f.body.scrollHeight, f.documentElement.scrollHeight),
      Math.max(f.body.offsetHeight, f.documentElement.offsetHeight),
      Math.max(f.body.clientHeight, f.documentElement.clientHeight)
    );
  }
  function u() {
    return "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
  }
  function p(f, I) {
    for (var x = f.nodeType === 3 ? t.createTextNode(f.nodeValue) : f.cloneNode(!1), M = f.firstChild; M; )
      I !== !0 && M.nodeType === 1 && M.nodeName === "SCRIPT" || x.appendChild(p(M, I)), M = M.nextSibling;
    return x;
  }
  function m(f, I, x, M, R, F, q) {
    b(f);
    var ot = t.documentMode && 9 >= t.documentMode ? p(f.documentElement, R.javascriptEnabled) : f.documentElement.cloneNode(!0), pt = I.createElement("iframe");
    return pt.className = "html2canvas-container", pt.style.visibility = "hidden", pt.style.position = "fixed", pt.style.left = "-10000px", pt.style.top = "0px", pt.style.border = "0", pt.width = x, pt.height = M, pt.scrolling = "no", I.body.appendChild(pt), new Promise(function(Rt) {
      var ue = pt.contentWindow.document;
      g(f.documentElement, ot, "textarea"), g(f.documentElement, ot, "select"), pt.contentWindow.onload = pt.onload = function() {
        var ri = setInterval(function() {
          0 < ue.body.childNodes.length && (w(f, ue), clearInterval(ri), R.type === "view" && pt.contentWindow.scrollTo(F, q), Rt(pt));
        }, 50);
      }, ue.open(), ue.write("<!DOCTYPE html><html></html>"), !f.defaultView || F === f.defaultView.pageXOffset && q === f.defaultView.pageYOffset || f.defaultView.scrollTo(F, q), ue.replaceChild(
        R.javascriptEnabled === !0 ? ue.adoptNode(ot) : v(ue.adoptNode(ot)),
        ue.documentElement
      ), ue.close();
    });
  }
  function g(f, I, x) {
    f = f.getElementsByTagName(x), I = I.getElementsByTagName(x), x = f.length;
    for (var M = 0; M < x; M++)
      I[M].value = f[M].value;
  }
  function _(f, I, x, M, R, F) {
    return new Ii(f, I, n.document).then(y(f)).then(function(q) {
      return m(q, x, M, R, F, 0, 0);
    });
  }
  function y(f) {
    return function(I) {
      var x = new DOMParser(), M;
      try {
        M = x.parseFromString(I, "text/html");
      } catch {
        W("DOMParser not supported, falling back to createHTMLDocument"), M = t.implementation.createHTMLDocument("");
        try {
          M.open(), M.write(I), M.close();
        } catch {
          W("createHTMLDocument write not supported, falling back to document.body.innerHTML"), M.body.innerHTML = I;
        }
      }
      return I = M.querySelector("base"), I && I.href.host || (I = M.createElement("base"), I.href = f, M.head.insertBefore(I, M.head.firstChild)), M;
    };
  }
  function b(f) {
    [].slice.call(f.querySelectorAll("canvas"), 0).forEach(function(I) {
      I.setAttribute("data-html2canvas-canvas-clone", "canvas-" + Fp++);
    });
  }
  function w(f, I) {
    [].slice.call(f.querySelectorAll("[data-html2canvas-canvas-clone]"), 0).forEach(function(x) {
      try {
        var M = I.querySelector(
          '[data-html2canvas-canvas-clone="' + x.getAttribute("data-html2canvas-canvas-clone") + '"]'
        );
        M && (M.width = x.width, M.height = x.height, M.getContext("2d").putImageData(x.getContext("2d").getImageData(0, 0, x.width, x.height), 0, 0));
      } catch (R) {
        W("Unable to copy canvas content from", x, R);
      }
      x.removeAttribute("data-html2canvas-canvas-clone");
    });
  }
  function v(f) {
    return [].slice.call(f.childNodes, 0).filter(C).forEach(function(I) {
      I.tagName === "SCRIPT" ? f.removeChild(I) : v(I);
    }), f;
  }
  function C(f) {
    return f.nodeType === Node.ELEMENT_NODE;
  }
  function k(f) {
    var I = t.createElement("a");
    return I.href = f, I.href = I.href, I;
  }
  function Y(f) {
    this.b = this.g = this.r = 0, this.a = null, this.fromArray(f) || this.namedColor(f) || this.rgb(f) || this.rgba(f) || this.hex6(f) || this.hex3(f);
  }
  function P(f) {
    if (this.src = f, W("DummyImageContainer for", f), !this.promise || !this.image) {
      W("Initiating DummyImageContainer"), P.prototype.image = new Image();
      var I = this.image;
      P.prototype.promise = new Promise(function(x, M) {
        I.onload = x, I.onerror = M, I.src = u(), I.complete === !0 && x(I);
      });
    }
  }
  function L(f, I) {
    var x = t.createElement("div"), M = t.createElement("img"), R = t.createElement("span"), F;
    x.style.visibility = "hidden", x.style.fontFamily = f, x.style.fontSize = I, x.style.margin = 0, x.style.padding = 0, t.body.appendChild(x), M.src = u(), M.width = 1, M.height = 1, M.style.margin = 0, M.style.padding = 0, M.style.verticalAlign = "baseline", R.style.fontFamily = f, R.style.fontSize = I, R.style.margin = 0, R.style.padding = 0, R.appendChild(t.createTextNode("Hidden Text")), x.appendChild(R), x.appendChild(M), F = M.offsetTop - R.offsetTop + 1, x.removeChild(R), x.appendChild(t.createTextNode("Hidden Text")), x.style.lineHeight = "normal", M.style.verticalAlign = "super", M = M.offsetTop - x.offsetTop + 1, t.body.removeChild(x), this.baseline = F, this.lineWidth = 1, this.middle = M;
  }
  function N() {
    this.data = {};
  }
  function D(f, I, x) {
    this.image = null, this.src = f;
    var M = this, R = O(f);
    this.promise = (I ? new Promise(function(F) {
      f.contentWindow.document.URL === "about:blank" || f.contentWindow.document.documentElement == null ? f.contentWindow.onload = f.onload = function() {
        F(f);
      } : F(f);
    }) : this.proxyLoad(x.proxy, R, x)).then(function(F) {
      return html2canvas(F.contentWindow.document.documentElement, {
        type: "view",
        width: F.width,
        height: F.height,
        proxy: x.proxy,
        javascriptEnabled: x.javascriptEnabled,
        removeContainer: x.removeContainer,
        allowTaint: x.allowTaint,
        imageTimeout: x.imageTimeout / 2
      });
    }).then(function(F) {
      return M.image = F;
    });
  }
  function B(f) {
    this.src = f.value, this.colorStops = [], this.type = null, this.y1 = this.x1 = this.y0 = this.x0 = 0.5, this.promise = Promise.resolve(!0);
  }
  function V(f, I) {
    this.src = f, this.image = new Image();
    var x = this;
    this.tainted = null, this.promise = new Promise(function(M, R) {
      x.image.onload = M, x.image.onerror = R, I && (x.image.crossOrigin = "anonymous"), x.image.src = f, x.image.complete === !0 && M(x.image);
    });
  }
  function X(f, I) {
    this.link = null, this.options = f, this.support = I, this.origin = this.getOrigin(n.location.href);
  }
  function Z(f) {
    B.apply(this, arguments), this.type = this.TYPES.LINEAR;
    var I = f.args[0].match(this.stepRegExp) === null;
    I ? f.args[0].split(" ").reverse().forEach(function(x) {
      switch (x) {
        case "left":
          this.x0 = 0, this.x1 = 1;
          break;
        case "top":
          this.y0 = 0, this.y1 = 1;
          break;
        case "right":
          this.x0 = 1, this.x1 = 0;
          break;
        case "bottom":
          this.y0 = 1, this.y1 = 0;
          break;
        case "to":
          x = this.y0;
          var M = this.x0;
          this.y0 = this.y1, this.x0 = this.x1, this.x1 = M, this.y1 = x;
      }
    }, this) : (this.y0 = 0, this.y1 = 1), this.colorStops = f.args.slice(I ? 1 : 0).map(function(x) {
      return x = x.match(this.stepRegExp), { color: new Y(x[1]), stop: x[3] === "%" ? x[2] / 100 : null };
    }, this), this.colorStops[0].stop === null && (this.colorStops[0].stop = 0), this.colorStops[this.colorStops.length - 1].stop === null && (this.colorStops[this.colorStops.length - 1].stop = 1), this.colorStops.forEach(function(x, M) {
      x.stop === null && this.colorStops.slice(M).some(function(R, F) {
        return R.stop !== null ? (x.stop = (R.stop - this.colorStops[M - 1].stop) / (F + 1) + this.colorStops[M - 1].stop, !0) : !1;
      }, this);
    }, this);
  }
  function W() {
    n.html2canvas.logging && n.console && n.console.log && Function.prototype.bind.call(n.console.log, n.console).apply(
      n.console,
      [Date.now() - n.html2canvas.start + "ms", "html2canvas:"].concat(
        [].slice.call(arguments, 0)
      )
    );
  }
  function st(f, I) {
    this.node = f, this.parent = I, this.borders = this.bounds = this.stack = null, this.clip = [], this.backgroundClip = [], this.computedStyles = this.visible = this.offsetBounds = null, this.colors = {}, this.styles = {}, this.transformMatrix = this.transformData = this.backgroundImages = null, this.isPseudoElement = !1, this.opacity = null;
  }
  function j(f) {
    if (f && f[1] === "matrix")
      return f[2].split(",").map(function(I) {
        return parseFloat(I.trim());
      });
  }
  function gt(f) {
    return f.toString().indexOf("%") !== -1;
  }
  function U(f) {
    var I, x, M, R, F, q = [], ot = 0, pt = 0, Rt, ue, ri = function() {
      I && (x.substr(0, 1) === '"' && (x = x.substr(1, x.length - 2)), x && ue.push(x), I.substr(0, 1) === "-" && 0 < (R = I.indexOf("-", 1) + 1) && (M = I.substr(0, R), I = I.substr(R)), q.push({ prefix: M, method: I.toLowerCase(), value: F, args: ue, image: null })), ue = [], I = M = x = F = "";
    };
    return ue = [], I = M = x = F = "", f.split("").forEach(function(Te) {
      if (!(ot === 0 && -1 < ` \r
	`.indexOf(Te))) {
        switch (Te) {
          case '"':
            Rt ? Rt === Te && (Rt = null) : Rt = Te;
            break;
          case "(":
            if (!Rt) {
              if (ot === 0) {
                ot = 1, F += Te;
                return;
              }
              pt++;
            }
            break;
          case ")":
            if (!Rt && ot === 1) {
              if (pt === 0) {
                ot = 0, F += Te, ri();
                return;
              }
              pt--;
            }
            break;
          case ",":
            if (!Rt) {
              if (ot === 0) {
                ri();
                return;
              }
              if (ot === 1 && pt === 0 && !I.match(/^url$/i)) {
                ue.push(x), x = "", F += Te;
                return;
              }
            }
        }
        F += Te, ot === 0 ? I += Te : x += Te;
      }
    }), ri(), q;
  }
  function ht(f) {
    return f.replace("px", "");
  }
  function z(f) {
    return parseFloat(f);
  }
  function O(f) {
    if (f.getBoundingClientRect) {
      var I = f.getBoundingClientRect(), x = f.offsetWidth == null ? I.width : f.offsetWidth;
      return {
        top: I.top,
        bottom: I.bottom || I.top + I.height,
        right: I.left + x,
        left: I.left,
        width: x,
        height: f.offsetHeight == null ? I.height : f.offsetHeight
      };
    }
    return {};
  }
  function _t(f) {
    var I = f.offsetParent ? _t(f.offsetParent) : { top: 0, left: 0 };
    return {
      top: f.offsetTop + I.top,
      bottom: f.offsetTop + f.offsetHeight + I.top,
      right: f.offsetLeft + I.left + f.offsetWidth,
      left: f.offsetLeft + I.left,
      width: f.offsetWidth,
      height: f.offsetHeight
    };
  }
  function rt(f, I, x, M, R) {
    if (W("Starting NodeParser"), this.renderer = I, this.options = R, this.range = null, this.support = x, this.renderQueue = [], this.stack = new qi(!0, 1, f.ownerDocument, null), x = new st(f, null), R.background && I.rectangle(0, 0, I.width, I.height, new Y(R.background)), f === f.ownerDocument.documentElement) {
      var F = new st(
        x.color("backgroundColor").isTransparent() ? f.ownerDocument.body : f.ownerDocument.documentElement,
        null
      );
      I.rectangle(0, 0, I.width, I.height, F.color("backgroundColor"));
    }
    x.visibile = x.isElementVisible(), this.createPseudoHideStyles(f.ownerDocument), this.disableAnimations(f.ownerDocument), this.nodes = [].concat.apply(
      [],
      [x].concat(this.getChildren(x)).filter(function(q) {
        return q.visible = q.isElementVisible();
      }).map(this.getPseudoElements, this)
    ), this.fontMetrics = new N(), W("Fetched nodes, total:", this.nodes.length), W("Calculate overflow clips"), this.calculateOverflowClips(), W("Start fetching images"), this.images = M.fetch(this.nodes.filter(lt)), this.ready = this.images.ready.then(
      It(function() {
        return W("Images loaded, starting parsing"), W("Creating stacking contexts"), this.createStackingContexts(), W("Sorting stacking contexts"), this.sortStackingContexts(this.stack), this.parse(this.stack), W("Render queue created with " + this.renderQueue.length + " items"), new Promise(
          It(function(q) {
            R.async ? typeof R.async == "function" ? R.async.call(this, this.renderQueue, q) : 0 < this.renderQueue.length ? (this.renderIndex = 0, this.asyncRenderer(this.renderQueue, q)) : q() : (this.renderQueue.forEach(this.paint, this), q());
          }, this)
        );
      }, this)
    );
  }
  function ut(f) {
    return f.replace(/(\-[a-z])/g, function(I) {
      return I.toUpperCase().replace("-", "");
    });
  }
  function oe() {
  }
  function Re(f, I, x, M) {
    return f.map(function(R, F) {
      if (0 < R.width) {
        var q = I.left, ot = I.top, pt = I.width, Rt = I.height - f[2].width;
        switch (F) {
          case 0:
            Rt = f[0].width, R.args = ie(
              {
                c1: [q, ot],
                c2: [q + pt, ot],
                c3: [q + pt - f[1].width, ot + Rt],
                c4: [q + f[3].width, ot + Rt]
              },
              M[0],
              M[1],
              x.topLeftOuter,
              x.topLeftInner,
              x.topRightOuter,
              x.topRightInner
            );
            break;
          case 1:
            q = I.left + I.width - f[1].width, pt = f[1].width, R.args = ie(
              {
                c1: [q + pt, ot],
                c2: [q + pt, ot + Rt + f[2].width],
                c3: [q, ot + Rt],
                c4: [q, ot + f[0].width]
              },
              M[1],
              M[2],
              x.topRightOuter,
              x.topRightInner,
              x.bottomRightOuter,
              x.bottomRightInner
            );
            break;
          case 2:
            ot = ot + I.height - f[2].width, Rt = f[2].width, R.args = ie(
              {
                c1: [q + pt, ot + Rt],
                c2: [q, ot + Rt],
                c3: [q + f[3].width, ot],
                c4: [q + pt - f[3].width, ot]
              },
              M[2],
              M[3],
              x.bottomRightOuter,
              x.bottomRightInner,
              x.bottomLeftOuter,
              x.bottomLeftInner
            );
            break;
          case 3:
            pt = f[3].width, R.args = ie(
              {
                c1: [q, ot + Rt + f[2].width],
                c2: [q, ot],
                c3: [q + pt, ot + f[0].width],
                c4: [q + pt, ot + Rt]
              },
              M[3],
              M[0],
              x.bottomLeftOuter,
              x.bottomLeftInner,
              x.topLeftOuter,
              x.topLeftInner
            );
        }
      }
      return R;
    });
  }
  function Wt(f, I, x, M) {
    var F = (Math.sqrt(2) - 1) / 3 * 4, R = x * F, F = M * F;
    return x = f + x, M = I + M, {
      topLeft: ee({ x: f, y: M }, { x: f, y: M - F }, { x: x - R, y: I }, { x, y: I }),
      topRight: ee({ x: f, y: I }, { x: f + R, y: I }, { x, y: M - F }, { x, y: M }),
      bottomRight: ee({ x, y: I }, { x, y: I + F }, { x: f + R, y: M }, { x: f, y: M }),
      bottomLeft: ee({ x, y: M }, { x: x - R, y: M }, { x: f, y: I + F }, { x: f, y: I })
    };
  }
  function Dt(f, I, x) {
    var M = f.left, R = f.top, F = f.width;
    f = f.height;
    var q = I[0][0], ot = I[0][1], pt = I[1][0], Rt = I[1][1], ue = I[2][0], ri = I[2][1], Te = I[3][0];
    I = I[3][1];
    var Oe = F - pt, Ae = f - ri, es = F - ue, Is = f - I;
    return {
      topLeftOuter: Wt(M, R, q, ot).topLeft.subdivide(0.5),
      topLeftInner: Wt(
        M + x[3].width,
        R + x[0].width,
        Math.max(0, q - x[3].width),
        Math.max(0, ot - x[0].width)
      ).topLeft.subdivide(0.5),
      topRightOuter: Wt(M + Oe, R, pt, Rt).topRight.subdivide(0.5),
      topRightInner: Wt(
        M + Math.min(Oe, F + x[3].width),
        R + x[0].width,
        Oe > F + x[3].width ? 0 : pt - x[3].width,
        Rt - x[0].width
      ).topRight.subdivide(0.5),
      bottomRightOuter: Wt(M + es, R + Ae, ue, ri).bottomRight.subdivide(0.5),
      bottomRightInner: Wt(
        M + Math.min(es, F - x[3].width),
        R + Math.min(Ae, f + x[0].width),
        Math.max(0, ue - x[1].width),
        ri - x[2].width
      ).bottomRight.subdivide(0.5),
      bottomLeftOuter: Wt(M, R + Is, Te, I).bottomLeft.subdivide(0.5),
      bottomLeftInner: Wt(
        M + x[3].width,
        R + Is,
        Math.max(0, Te - x[3].width),
        I - x[2].width
      ).bottomLeft.subdivide(0.5)
    };
  }
  function ee(f, I, x, M) {
    var R = function(F, q, ot) {
      return { x: F.x + (q.x - F.x) * ot, y: F.y + (q.y - F.y) * ot };
    };
    return {
      start: f,
      startControl: I,
      endControl: x,
      end: M,
      subdivide: function(F) {
        var q = R(f, I, F), Rt = R(I, x, F), ot = R(x, M, F), pt = R(q, Rt, F), Rt = R(Rt, ot, F);
        return F = R(pt, Rt, F), [ee(f, q, pt, F), ee(F, Rt, ot, M)];
      },
      curveTo: function(F) {
        F.push(["bezierCurve", I.x, I.y, x.x, x.y, M.x, M.y]);
      },
      curveToReversed: function(F) {
        F.push(["bezierCurve", x.x, x.y, I.x, I.y, f.x, f.y]);
      }
    };
  }
  function ie(f, I, x, M, R, F, q) {
    var ot = [];
    return 0 < I[0] || 0 < I[1] ? (ot.push(["line", M[1].start.x, M[1].start.y]), M[1].curveTo(ot)) : ot.push(["line", f.c1[0], f.c1[1]]), 0 < x[0] || 0 < x[1] ? (ot.push(["line", F[0].start.x, F[0].start.y]), F[0].curveTo(ot), ot.push(["line", q[0].end.x, q[0].end.y]), q[0].curveToReversed(ot)) : (ot.push(["line", f.c2[0], f.c2[1]]), ot.push(["line", f.c3[0], f.c3[1]])), 0 < I[0] || 0 < I[1] ? (ot.push(["line", R[1].end.x, R[1].end.y]), R[1].curveToReversed(ot)) : ot.push(["line", f.c4[0], f.c4[1]]), ot;
  }
  function Ye(f, I, x, M, R, F, q) {
    0 < I[0] || 0 < I[1] ? (f.push(["line", M[0].start.x, M[0].start.y]), M[0].curveTo(f), M[1].curveTo(f)) : f.push(["line", F, q]), (0 < x[0] || 0 < x[1]) && f.push(["line", R[0].start.x, R[0].start.y]);
  }
  function bi(f) {
    return 0 > f.cssInt("zIndex");
  }
  function S(f) {
    return 0 < f.cssInt("zIndex");
  }
  function $(f) {
    return f.cssInt("zIndex") === 0;
  }
  function H(f) {
    return ["inline", "inline-block", "inline-table"].indexOf(f.css("display")) !== -1;
  }
  function T(f) {
    return 0 < f.node.data.trim().length;
  }
  function G(f) {
    return ["TopLeft", "TopRight", "BottomRight", "BottomLeft"].map(function(I) {
      return I = f.css("border" + I + "Radius").split(" "), 1 >= I.length && (I[1] = I[0]), I.map(jt);
    });
  }
  function K(f) {
    return f.nodeType === Node.TEXT_NODE || f.nodeType === Node.ELEMENT_NODE;
  }
  function tt(f) {
    return f.css("position") !== "static";
  }
  function nt(f) {
    return f.css("float") !== "none";
  }
  function A(f) {
    var I = this;
    return function() {
      return !f.apply(I, arguments);
    };
  }
  function lt(f) {
    return f.node.nodeType === Node.ELEMENT_NODE;
  }
  function dt(f) {
    return f.node.nodeType === Node.TEXT_NODE;
  }
  function ct(f) {
    return function(I, x) {
      return I.cssInt("zIndex") + f.indexOf(I) / f.length - (x.cssInt("zIndex") + f.indexOf(x) / f.length);
    };
  }
  function It(f, I) {
    return function() {
      return f.apply(I, arguments);
    };
  }
  function jt(f) {
    return parseInt(f, 10);
  }
  function Ft(f) {
    return f.width;
  }
  function si(f) {
    return f.node.nodeType !== Node.ELEMENT_NODE || "SCRIPT HEAD TITLE OBJECT BR OPTION".split(" ").indexOf(f.node.nodeName) === -1;
  }
  function cn(f) {
    for (var I = [], x = 0, M = !1, R; f.length; )
      [32, 13, 10, 9, 45].indexOf(f[x]) !== -1 === M ? (R = f.splice(0, x), R.length && I.push(n.html2canvas.punycode.ucs2.encode(R)), M = !M, x = 0) : x++, x >= f.length && (R = f.splice(0, x), R.length && I.push(n.html2canvas.punycode.ucs2.encode(R)));
    return I;
  }
  function Ii(f, I, x) {
    if (!I)
      return Promise.reject("No proxy configured");
    var M = En(Qh);
    return f = Nn(I, f, M), Qh ? Hh(f) : pe(x, f, M).then(function(R) {
      return Ge(R.content);
    });
  }
  function hn(f, I, x) {
    var M = En(qh);
    return f = Nn(I, f, M), qh ? Promise.resolve(f) : pe(x, f, M).then(function(R) {
      return "data:" + R.type + ";base64," + R.content;
    });
  }
  function pe(f, I, x) {
    return new Promise(function(M, R) {
      var F = f.createElement("script"), q = function() {
        delete n.html2canvas.proxy[x], f.body.removeChild(F);
      };
      n.html2canvas.proxy[x] = function(ot) {
        q(), M(ot);
      }, F.src = I, F.onerror = function(ot) {
        q(), R(ot);
      }, f.body.appendChild(F);
    });
  }
  function En(f) {
    var I = new Uint32Array(1);
    return (window.crypto || window.msCrypto).getRandomValues(I), f ? "" : "html2canvas_" + Date.now() + "_" + ++Bp + "_" + Math.round(1e5 * (I[0] / 4294967295));
  }
  function Nn(f, I, x) {
    return f + "?url=" + encodeURIComponent(I) + (x.length ? "&callback=html2canvas.proxy." + x : "");
  }
  function Vi(f, I) {
    t.createElement("script");
    var x = t.createElement("a");
    x.href = f, this.src = f = x.href, this.image = new Image();
    var M = this;
    this.promise = new Promise(function(R, F) {
      M.image.crossOrigin = "Anonymous", M.image.onload = R, M.image.onerror = F, new hn(f, I, t).then(function(q) {
        M.image.src = q;
      }).catch(F);
    });
  }
  function He(f, I, x) {
    st.call(this, f, I), this.isPseudoElement = !0, this.before = x === ":before";
  }
  function Yi(f, I, x, M, R) {
    this.width = f, this.height = I, this.images = x, this.options = M, this.document = R;
  }
  function qi(f, I, x, M) {
    st.call(this, x, M), this.ownStacking = f, this.contexts = [], this.children = [], this.opacity = (this.parent ? this.parent.stack.opacity : 1) * I;
  }
  function wn(f) {
    this.rangeBounds = this.testRangeBounds(f), this.cors = this.testCORS(), this.svg = this.testSVG();
  }
  function Zi(f) {
    this.src = f, this.image = null;
    var I = this;
    this.promise = this.hasFabric().then(function() {
      return I.isInline(f) ? Promise.resolve(I.inlineFormatting(f)) : Hh(f);
    }).then(function(x) {
      return new Promise(function(M) {
        html2canvas.fabric.loadSVGFromString(x, I.createCanvas.call(I, M));
      });
    });
  }
  function Ge(f) {
    var I = f.length, x, M, R, F, q, ot, pt = "";
    for (x = 0; x < I; x += 4)
      M = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(f[x]), R = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(f[x + 1]), F = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(f[x + 2]), q = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(f[x + 3]), M = M << 2 | R >> 4, R = (R & 15) << 4 | F >> 2, ot = (F & 3) << 6 | q, pt = F === 64 ? pt + String.fromCharCode(M) : q === 64 || q === -1 ? pt + String.fromCharCode(M, R) : pt + String.fromCharCode(M, R, ot);
    return pt;
  }
  function Ds(f, I) {
    this.src = f, this.image = null;
    var x = this;
    this.promise = I ? new Promise(function(M, R) {
      x.image = new Image(), x.image.onload = M, x.image.onerror = R, x.image.src = "data:image/svg+xml," + new XMLSerializer().serializeToString(f), x.image.complete === !0 && M(x.image);
    }) : this.hasFabric().then(function() {
      return new Promise(function(M) {
        html2canvas.fabric.parseSVGDocument(f, x.createCanvas.call(x, M));
      });
    });
  }
  function yr(f, I) {
    st.call(this, f, I);
  }
  function Lp(f, I, x) {
    if (0 < f.length)
      return I + x.toUpperCase();
  }
  function jh(f) {
    B.apply(this, arguments), this.type = f.args[0] === "linear" ? this.TYPES.LINEAR : this.TYPES.RADIAL;
  }
  function Hh(f) {
    return new Promise(function(I, x) {
      var M = new XMLHttpRequest();
      M.open("GET", f), M.onload = function() {
        M.status === 200 ? I(M.responseText) : x(Error(M.statusText));
      }, M.onerror = function() {
        x(Error("Network Error"));
      }, M.send();
    });
  }
  function Le(f, I) {
    Yi.apply(this, arguments), this.canvas = this.options.canvas || this.document.createElement("canvas"), this.options.canvas || (this.canvas.width = f, this.canvas.height = I), this.ctx = this.canvas.getContext("2d"), this.taintCtx = this.document.createElement("canvas").getContext("2d"), this.ctx.textBaseline = "bottom", this.variables = {}, W("Initialized CanvasRenderer with size", f, "x", I);
  }
  function Xp(f) {
    return 0 < f.length;
  }
  if (function() {
    function f(J, mt) {
      Ue[Lt] = J, Ue[Lt + 1] = mt, Lt += 2, Lt === 2 && Qe();
    }
    function I(J) {
      return typeof J == "function";
    }
    function x() {
      return function() {
        process.nextTick(q);
      };
    }
    function M() {
      var J = 0, mt = new qt(q), yt = t.createTextNode("");
      return mt.observe(yt, { characterData: !0 }), function() {
        yt.data = J = ++J % 2;
      };
    }
    function R() {
      var J = new MessageChannel();
      return J.port1.onmessage = q, function() {
        J.port2.postMessage(0);
      };
    }
    function F() {
      return function() {
        setTimeout(q, 1);
      };
    }
    function q() {
      for (var J = 0; J < Lt; J += 2)
        (0, Ue[J])(Ue[J + 1]), Ue[J] = void 0, Ue[J + 1] = void 0;
      Lt = 0;
    }
    function ot() {
    }
    function pt(J, mt, yt, Tt) {
      try {
        J.call(mt, yt, Tt);
      } catch (ae) {
        return ae;
      }
    }
    function Rt(J, mt, yt) {
      f(function(Tt) {
        var ae = !1, Ze = pt(
          yt,
          mt,
          function(wi) {
            ae || (ae = !0, mt !== wi ? ri(Tt, wi) : Oe(Tt, wi));
          },
          function(wi) {
            ae || (ae = !0, Ae(Tt, wi));
          }
        );
        !ae && Ze && (ae = !0, Ae(Tt, Ze));
      }, J);
    }
    function ue(J, mt) {
      mt.a === 1 ? Oe(J, mt.b) : J.a === 2 ? Ae(J, mt.b) : es(
        mt,
        void 0,
        function(yt) {
          ri(J, yt);
        },
        function(yt) {
          Ae(J, yt);
        }
      );
    }
    function ri(J, mt) {
      if (J === mt)
        Ae(J, new TypeError("You cannot resolve a promise with itself"));
      else if (typeof mt == "function" || typeof mt == "object" && mt !== null)
        if (mt.constructor === J.constructor)
          ue(J, mt);
        else {
          var yt;
          try {
            yt = mt.then;
          } catch (Tt) {
            ge.error = Tt, yt = ge;
          }
          yt === ge ? Ae(J, ge.error) : yt === void 0 ? Oe(J, mt) : I(yt) ? Rt(J, mt, yt) : Oe(J, mt);
        }
      else
        Oe(J, mt);
    }
    function Te(J) {
      J.f && J.f(J.b), Is(J);
    }
    function Oe(J, mt) {
      J.a === void 0 && (J.b = mt, J.a = 1, J.e.length !== 0 && f(Is, J));
    }
    function Ae(J, mt) {
      J.a === void 0 && (J.a = 2, J.b = mt, f(Te, J));
    }
    function es(J, mt, yt, Tt) {
      var ae = J.e, Ze = ae.length;
      J.f = null, ae[Ze] = mt, ae[Ze + 1] = yt, ae[Ze + 2] = Tt, Ze === 0 && J.a && f(Is, J);
    }
    function Is(J) {
      var mt = J.e, yt = J.a;
      if (mt.length !== 0) {
        for (var Tt, ae, Ze = J.b, wi = 0; wi < mt.length; wi += 3)
          Tt = mt[wi], ae = mt[wi + yt], Tt ? $i(yt, Tt, ae, Ze) : ae(Ze);
        J.e.length = 0;
      }
    }
    function wa() {
      this.error = null;
    }
    function $i(J, mt, yt, Tt) {
      var ae = I(yt), Ze, wi, Js, $h;
      if (ae) {
        try {
          Ze = yt(Tt);
        } catch (jp) {
          De.error = jp, Ze = De;
        }
        if (Ze === De ? ($h = !0, wi = Ze.error, Ze = null) : Js = !0, mt === Ze) {
          Ae(mt, new TypeError("A promises callback cannot return that same promise."));
          return;
        }
      } else
        Ze = Tt, Js = !0;
      mt.a === void 0 && (ae && Js ? ri(mt, Ze) : $h ? Ae(mt, wi) : J === 1 ? Oe(mt, Ze) : J === 2 && Ae(mt, Ze));
    }
    function zs(J, mt) {
      try {
        mt(
          function(yt) {
            ri(J, yt);
          },
          function(yt) {
            Ae(J, yt);
          }
        );
      } catch (yt) {
        Ae(J, yt);
      }
    }
    function Fi(J, mt, yt, Tt) {
      this.n = J, this.c = new J(ot, Tt), this.i = yt, this.o(mt) ? (this.m = mt, this.d = this.length = mt.length, this.l(), this.length === 0 ? Oe(this.c, this.b) : (this.length = this.length || 0, this.k(), this.d === 0 && Oe(this.c, this.b))) : Ae(this.c, this.p());
    }
    function St(J) {
      if (this.b = this.a = void 0, this.e = [], ot !== J) {
        if (!I(J))
          throw new TypeError(
            "You must pass a resolver function as the first argument to the promise constructor"
          );
        if (!(this instanceof St))
          throw new TypeError(
            "Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function."
          );
        zs(this, J);
      }
    }
    var Vt = Array.isArray ? Array.isArray : function(J) {
      return Object.prototype.toString.call(J) === "[object Array]";
    }, Lt = 0, Ee = typeof n < "u" ? n : {}, qt = Ee.MutationObserver || Ee.WebKitMutationObserver, Ee = typeof Uint8ClampedArray < "u" && typeof importScripts < "u" && typeof MessageChannel < "u", Ue = Array(1e3), Qe;
    Qe = typeof process < "u" && {}.toString.call(process) === "[object process]" ? x() : qt ? M() : Ee ? R() : F();
    var ge = new wa(), De = new wa();
    Fi.prototype.o = function(J) {
      return Vt(J);
    }, Fi.prototype.p = function() {
      return Error("Array Methods must be provided an Array");
    }, Fi.prototype.l = function() {
      this.b = Array(this.length);
    }, Fi.prototype.k = function() {
      for (var J = this.length, mt = this.c, yt = this.m, Tt = 0; mt.a === void 0 && Tt < J; Tt++)
        this.j(yt[Tt], Tt);
    }, Fi.prototype.j = function(J, mt) {
      var yt = this.n;
      typeof J == "object" && J !== null ? J.constructor === yt && J.a !== void 0 ? (J.f = null, this.g(J.a, mt, J.b)) : this.q(yt.resolve(J), mt) : (this.d--, this.b[mt] = this.h(J));
    }, Fi.prototype.g = function(J, mt, yt) {
      var Tt = this.c;
      Tt.a === void 0 && (this.d--, this.i && J === 2 ? Ae(Tt, yt) : this.b[mt] = this.h(yt)), this.d === 0 && Oe(Tt, this.b);
    }, Fi.prototype.h = function(J) {
      return J;
    }, Fi.prototype.q = function(J, mt) {
      var yt = this;
      es(
        J,
        void 0,
        function(Tt) {
          yt.g(1, mt, Tt);
        },
        function(Tt) {
          yt.g(2, mt, Tt);
        }
      );
    }, St.all = function(J, mt) {
      return new Fi(this, J, !0, mt).c;
    }, St.race = function(J, mt) {
      function yt(Js) {
        ri(ae, Js);
      }
      function Tt(Js) {
        Ae(ae, Js);
      }
      var ae = new this(ot, mt);
      if (!Vt(J))
        return Ae(ae, new TypeError("You must pass an array to race.")), ae;
      for (var Ze = J.length, wi = 0; ae.a === void 0 && wi < Ze; wi++)
        es(this.resolve(J[wi]), void 0, yt, Tt);
      return ae;
    }, St.resolve = function(J, mt) {
      if (J && typeof J == "object" && J.constructor === this)
        return J;
      var yt = new this(ot, mt);
      return ri(yt, J), yt;
    }, St.reject = function(J, mt) {
      var yt = new this(ot, mt);
      return Ae(yt, J), yt;
    }, St.prototype = {
      constructor: St,
      then: function(J, mt) {
        var yt = this.a;
        if (yt === 1 && !J || yt === 2 && !mt)
          return this;
        var Tt = new this.constructor(ot), ae = this.b;
        if (yt) {
          var Ze = arguments[yt - 1];
          f(function() {
            $i(yt, Tt, Ze, ae);
          });
        } else
          es(this, Tt, J, mt);
        return Tt;
      },
      catch: function(J) {
        return this.then(null, J);
      }
    };
    var Se = {
      Promise: St,
      polyfill: function() {
        var J;
        J = typeof i < "u" ? i : typeof n < "u" && n.document ? n : self, "Promise" in J && "resolve" in J.Promise && "reject" in J.Promise && "all" in J.Promise && "race" in J.Promise && function() {
          var mt;
          return new J.Promise(function(yt) {
            mt = yt;
          }), I(mt);
        }() || (J.Promise = St);
      }
    };
    typeof s == "function" && s.amd ? s(function() {
      return Se;
    }) : typeof module < "u" && module.exports ? module.exports = Se : typeof this < "u" && (this.ES6Promise = Se);
  }.call(n), n && n.ES6Promise && n.ES6Promise.polyfill(), typeof t > "u" || typeof Object.create != "function" || typeof t.createElement("canvas").getContext != "function")
    (n || module.exports).html2canvas = function() {
      return Promise.reject("No canvas support");
    };
  else {
    (function(f) {
      function I(St) {
        throw RangeError(wa[St]);
      }
      function x(St, Vt) {
        for (var Lt = St.length, qt = []; Lt--; )
          qt[Lt] = Vt(St[Lt]);
        return qt;
      }
      function M(St, Vt) {
        var Lt = St.split("@"), qt = "";
        return 1 < Lt.length && (qt = Lt[0] + "@", St = Lt[1]), Lt = St.split(Is), Lt = x(Lt, Vt).join("."), qt + Lt;
      }
      function R(St) {
        for (var Vt = [], Lt = 0, qt = St.length, Ee, Ue; Lt < qt; )
          Ee = St.charCodeAt(Lt++), 55296 <= Ee && 56319 >= Ee && Lt < qt ? (Ue = St.charCodeAt(Lt++), (Ue & 64512) == 56320 ? Vt.push(((Ee & 1023) << 10) + (Ue & 1023) + 65536) : (Vt.push(Ee), Lt--)) : Vt.push(Ee);
        return Vt;
      }
      function F(St) {
        return x(St, function(Vt) {
          var Lt = "";
          return 65535 < Vt && (Vt -= 65536, Lt += zs(Vt >>> 10 & 1023 | 55296), Vt = 56320 | Vt & 1023), Lt += zs(Vt);
        }).join("");
      }
      function q(St, Vt) {
        return St + 22 + 75 * (26 > St) - ((Vt != 0) << 5);
      }
      function ot(St, Vt, Lt) {
        var qt = 0;
        for (St = Lt ? $i(St / 700) : St >> 1, St += $i(St / Vt); 455 < St; qt += 36)
          St = $i(St / 35);
        return $i(qt + 36 * St / (St + 38));
      }
      function pt(St) {
        var Vt = [], Lt = St.length, qt, Ee = 0, Ue = 128, Qe = 72, ge, De, Se, J, mt;
        for (ge = St.lastIndexOf("-"), 0 > ge && (ge = 0), De = 0; De < ge; ++De)
          128 <= St.charCodeAt(De) && I("not-basic"), Vt.push(St.charCodeAt(De));
        for (ge = 0 < ge ? ge + 1 : 0; ge < Lt; ) {
          for (De = Ee, qt = 1, Se = 36; ge >= Lt && I("invalid-input"), J = St.charCodeAt(ge++), J = 10 > J - 48 ? J - 22 : 26 > J - 65 ? J - 65 : 26 > J - 97 ? J - 97 : 36, (36 <= J || J > $i((2147483647 - Ee) / qt)) && I("overflow"), Ee += J * qt, mt = Se <= Qe ? 1 : Se >= Qe + 26 ? 26 : Se - Qe, !(J < mt); Se += 36)
            J = 36 - mt, qt > $i(2147483647 / J) && I("overflow"), qt *= J;
          qt = Vt.length + 1, Qe = ot(Ee - De, qt, De == 0), $i(Ee / qt) > 2147483647 - Ue && I("overflow"), Ue += $i(Ee / qt), Ee %= qt, Vt.splice(Ee++, 0, Ue);
        }
        return F(Vt);
      }
      function Rt(St) {
        var Vt, Lt, qt, Ee, Ue, Qe, ge, De, Se, J = [], mt, yt, Tt;
        for (St = R(St), mt = St.length, Vt = 128, Lt = 0, Ue = 72, Qe = 0; Qe < mt; ++Qe)
          Se = St[Qe], 128 > Se && J.push(zs(Se));
        for ((qt = Ee = J.length) && J.push("-"); qt < mt; ) {
          for (ge = 2147483647, Qe = 0; Qe < mt; ++Qe)
            Se = St[Qe], Se >= Vt && Se < ge && (ge = Se);
          for (yt = qt + 1, ge - Vt > $i((2147483647 - Lt) / yt) && I("overflow"), Lt += (ge - Vt) * yt, Vt = ge, Qe = 0; Qe < mt; ++Qe)
            if (Se = St[Qe], Se < Vt && 2147483647 < ++Lt && I("overflow"), Se == Vt) {
              for (De = Lt, ge = 36; Se = ge <= Ue ? 1 : ge >= Ue + 26 ? 26 : ge - Ue, !(De < Se); ge += 36)
                Tt = De - Se, De = 36 - Se, J.push(zs(q(Se + Tt % De, 0))), De = $i(Tt / De);
              J.push(zs(q(De, 0))), Ue = ot(Lt, yt, qt == Ee), Lt = 0, ++qt;
            }
          ++Lt, ++Vt;
        }
        return J.join("");
      }
      var ue = typeof e == "object" && e && !e.nodeType && e, ri = typeof module == "object" && module && !module.nodeType && module, Te = typeof i == "object" && i;
      (Te.global === Te || Te.window === Te || Te.self === Te) && (f = Te);
      var Oe, Ae = /^xn--/, es = /[^\x20-\x7E]/, Is = /[\x2E\u3002\uFF0E\uFF61]/g, wa = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, $i = Math.floor, zs = String.fromCharCode, Fi;
      if (Oe = {
        version: "1.3.1",
        ucs2: { decode: R, encode: F },
        decode: pt,
        encode: Rt,
        toASCII: function(St) {
          return M(St, function(Vt) {
            return es.test(Vt) ? "xn--" + Rt(Vt) : Vt;
          });
        },
        toUnicode: function(St) {
          return M(St, function(Vt) {
            return Ae.test(Vt) ? pt(Vt.slice(4).toLowerCase()) : Vt;
          });
        }
      }, typeof s == "function" && typeof s.amd == "object" && s.amd)
        s("punycode", function() {
          return Oe;
        });
      else if (ue && ri)
        if (module.exports == ue)
          ri.exports = Oe;
        else
          for (Fi in Oe)
            Oe.hasOwnProperty(Fi) && (ue[Fi] = Oe[Fi]);
      else
        f.punycode = Oe;
    })(this);
    var Fp = 0, Kp = 0;
    n.html2canvas = function(f, I) {
      var x = Kp++;
      if (I = I || {}, I.logging && (n.html2canvas.logging = !0, n.html2canvas.start = Date.now()), I.async = typeof I.async > "u" ? !0 : I.async, I.allowTaint = typeof I.allowTaint > "u" ? !1 : I.allowTaint, I.removeContainer = typeof I.removeContainer > "u" ? !0 : I.removeContainer, I.javascriptEnabled = typeof I.javascriptEnabled > "u" ? !1 : I.javascriptEnabled, I.imageTimeout = typeof I.imageTimeout > "u" ? 1e4 : I.imageTimeout, I.renderer = typeof I.renderer == "function" ? I.renderer : Le, I.strict = !!I.strict, typeof f == "string") {
        if (typeof I.proxy != "string")
          return Promise.reject("Proxy must be used when rendering url");
        var M = I.width != null ? I.width : n.innerWidth, R = I.height != null ? I.height : n.innerHeight;
        return _(k(f), I.proxy, t, M, R, I).then(function(q) {
          return a(q.contentWindow.document.documentElement, q, I, M, R);
        });
      }
      var F = (f === r ? [t.documentElement] : f.length ? f : [f])[0];
      return F.setAttribute("data-html2canvas-node" + x, x), o(
        F.ownerDocument,
        I,
        F.ownerDocument.defaultView.innerWidth,
        F.ownerDocument.defaultView.innerHeight,
        x
      ).then(function(q) {
        return typeof I.onrendered == "function" && (W(
          "options.onrendered is deprecated, html2canvas returns a Promise containing the canvas"
        ), I.onrendered(q)), q;
      });
    }, n.html2canvas.punycode = this.punycode, n.html2canvas.proxy = {}, Y.prototype.darken = function(f) {
      return f = 1 - f, new Y([
        Math.round(this.r * f),
        Math.round(this.g * f),
        Math.round(this.b * f),
        this.a
      ]);
    }, Y.prototype.isTransparent = function() {
      return this.a === 0;
    }, Y.prototype.isBlack = function() {
      return this.r === 0 && this.g === 0 && this.b === 0;
    }, Y.prototype.fromArray = function(f) {
      return Array.isArray(f) && (this.r = Math.min(f[0], 255), this.g = Math.min(f[1], 255), this.b = Math.min(f[2], 255), 3 < f.length && (this.a = f[3])), Array.isArray(f);
    };
    var Op = /^#([a-f0-9]{3})$/i;
    Y.prototype.hex3 = function(f) {
      return (f = f.match(Op)) !== null && (this.r = parseInt(f[1][0] + f[1][0], 16), this.g = parseInt(f[1][1] + f[1][1], 16), this.b = parseInt(f[1][2] + f[1][2], 16)), f !== null;
    };
    var Ap = /^#([a-f0-9]{6})$/i;
    Y.prototype.hex6 = function(f) {
      return (f = f.match(Ap)) !== null && (this.r = parseInt(f[1].substring(0, 2), 16), this.g = parseInt(f[1].substring(2, 4), 16), this.b = parseInt(f[1].substring(4, 6), 16)), f !== null;
    };
    var Dp = /^rgb\((\d{1,3}) *, *(\d{1,3}) *, *(\d{1,3})\)$/;
    Y.prototype.rgb = function(f) {
      return (f = f.match(Dp)) !== null && (this.r = Number(f[1]), this.g = Number(f[2]), this.b = Number(f[3])), f !== null;
    };
    var zp = /^rgba\((\d{1,3}) *, *(\d{1,3}) *, *(\d{1,3}) *, *(\d+\.?\d*)\)$/;
    Y.prototype.rgba = function(f) {
      return (f = f.match(zp)) !== null && (this.r = Number(f[1]), this.g = Number(f[2]), this.b = Number(f[3]), this.a = Number(f[4])), f !== null;
    }, Y.prototype.toString = function() {
      return this.a !== null && this.a !== 1 ? "rgba(" + [this.r, this.g, this.b, this.a].join() + ")" : "rgb(" + [this.r, this.g, this.b].join() + ")";
    }, Y.prototype.namedColor = function(f) {
      var I = Jp[f.toLowerCase()];
      if (I)
        this.r = I[0], this.g = I[1], this.b = I[2];
      else if (f.toLowerCase() === "transparent")
        return this.r = this.g = this.b = this.a = 0, !0;
      return !!I;
    }, Y.prototype.isColor = !0;
    var Jp = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
    N.prototype.getMetrics = function(f, I) {
      return this.data[f + "-" + I] === r && (this.data[f + "-" + I] = new L(f, I)), this.data[f + "-" + I];
    }, D.prototype.proxyLoad = function(f, I, x) {
      var M = this.src;
      return _(M.src, f, M.ownerDocument, I.width, I.height, x);
    }, B.prototype.TYPES = { LINEAR: 1, RADIAL: 2 }, X.prototype.findImages = function(f) {
      var I = [];
      return f.reduce(function(x, M) {
        switch (M.node.nodeName) {
          case "IMG":
            return x.concat([{ args: [M.node.src], method: "url" }]);
          case "svg":
          case "IFRAME":
            return x.concat([{ args: [M.node], method: M.node.nodeName }]);
        }
        return x;
      }, []).forEach(this.addImage(I, this.loadImage), this), I;
    }, X.prototype.findBackgroundImage = function(f, I) {
      return I.parseBackgroundImages().filter(this.hasImageBackground).forEach(this.addImage(f, this.loadImage), this), f;
    }, X.prototype.addImage = function(f, I) {
      return function(x) {
        x.args.forEach(function(M) {
          this.imageExists(f, M) || (f.splice(0, 0, I.call(this, x)), W("Added image #" + f.length, typeof M == "string" ? M.substring(0, 100) : M));
        }, this);
      };
    }, X.prototype.hasImageBackground = function(f) {
      return f.method !== "none";
    }, X.prototype.loadImage = function(f) {
      return f.method === "url" ? (f = f.args[0], !this.isSVG(f) || this.support.svg || this.options.allowTaint ? f.match(/data:image\/.*;base64,/i) ? new V(f.replace(/url\(['"]{0,}|['"]{0,}\)$/gi, ""), !1) : this.isSameOrigin(f) || this.options.allowTaint === !0 || this.isSVG(f) ? new V(f, !1) : this.support.cors && !this.options.allowTaint && this.options.useCORS ? new V(f, !0) : this.options.proxy ? new Vi(f, this.options.proxy) : new P(f) : new Zi(f)) : f.method === "linear-gradient" ? new Z(f) : f.method === "gradient" ? new jh(f) : f.method === "svg" ? new Ds(f.args[0], this.support.svg) : f.method === "IFRAME" ? new D(f.args[0], this.isSameOrigin(f.args[0].src), this.options) : new P(f);
    }, X.prototype.isSVG = function(f) {
      return f.substring(f.length - 3).toLowerCase() === "svg" || Zi.prototype.isInline(f);
    }, X.prototype.imageExists = function(f, I) {
      return f.some(function(x) {
        return x.src === I;
      });
    }, X.prototype.isSameOrigin = function(f) {
      return this.getOrigin(f) === this.origin;
    }, X.prototype.getOrigin = function(f) {
      var I = this.link || (this.link = t.createElement("a"));
      return I.href = f, I.href = I.href, I.protocol + I.hostname + I.port;
    }, X.prototype.getPromise = function(f) {
      return this.timeout(f, this.options.imageTimeout).catch(function() {
        return new P(f.src).promise.then(function(I) {
          f.image = I;
        });
      });
    }, X.prototype.get = function(f) {
      var I = null;
      return this.images.some(function(x) {
        return (I = x).src === f;
      }) ? I : null;
    }, X.prototype.fetch = function(f) {
      return this.images = f.reduce(It(this.findBackgroundImage, this), this.findImages(f)), this.images.forEach(function(I, x) {
        I.promise.then(
          function() {
            W("Succesfully loaded image #" + (x + 1), I);
          },
          function(M) {
            W("Failed loading image #" + (x + 1), I, M);
          }
        );
      }), this.ready = Promise.all(this.images.map(this.getPromise, this)), W("Finished searching images"), this;
    }, X.prototype.timeout = function(f, I) {
      var x, M = Promise.race([
        f.promise,
        new Promise(function(R, F) {
          x = setTimeout(function() {
            W("Timed out loading image", f), F(f);
          }, I);
        })
      ]).then(function(R) {
        return clearTimeout(x), R;
      });
      return M.catch(function() {
        clearTimeout(x);
      }), M;
    }, Z.prototype = Object.create(B.prototype), Z.prototype.stepRegExp = /((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/, st.prototype.cloneTo = function(f) {
      f.visible = this.visible, f.borders = this.borders, f.bounds = this.bounds, f.clip = this.clip, f.backgroundClip = this.backgroundClip, f.computedStyles = this.computedStyles, f.styles = this.styles, f.backgroundImages = this.backgroundImages, f.opacity = this.opacity;
    }, st.prototype.getOpacity = function() {
      return this.opacity === null ? this.opacity = this.cssFloat("opacity") : this.opacity;
    }, st.prototype.assignStack = function(f) {
      this.stack = f, f.children.push(this);
    }, st.prototype.isElementVisible = function() {
      return this.node.nodeType === Node.TEXT_NODE ? this.parent.visible : this.css("display") !== "none" && this.css("visibility") !== "hidden" && !this.node.hasAttribute("data-html2canvas-ignore") && (this.node.nodeName !== "INPUT" || this.node.getAttribute("type") !== "hidden");
    }, st.prototype.css = function(f) {
      return this.computedStyles || (this.computedStyles = this.isPseudoElement ? this.parent.computedStyle(this.before ? ":before" : ":after") : this.computedStyle(null)), this.styles[f] || (this.styles[f] = this.computedStyles[f]);
    }, st.prototype.prefixedCss = function(f) {
      var I = ["webkit", "moz", "ms", "o"], x = this.css(f);
      return x === r && I.some(function(M) {
        return x = this.css(M + f.substr(0, 1).toUpperCase() + f.substr(1)), x !== r;
      }, this), x === r ? null : x;
    }, st.prototype.computedStyle = function(f) {
      return this.node.ownerDocument.defaultView.getComputedStyle(this.node, f);
    }, st.prototype.cssInt = function(f) {
      return f = parseInt(this.css(f), 10), isNaN(f) ? 0 : f;
    }, st.prototype.color = function(f) {
      return this.colors[f] || (this.colors[f] = new Y(this.css(f)));
    }, st.prototype.cssFloat = function(f) {
      return f = parseFloat(this.css(f)), isNaN(f) ? 0 : f;
    }, st.prototype.fontWeight = function() {
      var f = this.css("fontWeight");
      switch (parseInt(f, 10)) {
        case 401:
          f = "bold";
          break;
        case 400:
          f = "normal";
      }
      return f;
    }, st.prototype.parseClip = function() {
      var f = this.css("clip").match(this.CLIP);
      return f ? {
        top: parseInt(f[1], 10),
        right: parseInt(f[2], 10),
        bottom: parseInt(f[3], 10),
        left: parseInt(f[4], 10)
      } : null;
    }, st.prototype.parseBackgroundImages = function() {
      return this.backgroundImages || (this.backgroundImages = U(this.css("backgroundImage")));
    }, st.prototype.cssList = function(f, I) {
      var x = (this.css(f) || "").split(","), x = x[I || 0] || x[0] || "auto", x = x.trim().split(" ");
      return x.length === 1 && (x = [x[0], x[0]]), x;
    }, st.prototype.parseBackgroundSize = function(f, I, x) {
      x = this.cssList("backgroundSize", x);
      var M;
      if (gt(x[0]))
        M = f.width * parseFloat(x[0]) / 100;
      else {
        if (/contain|cover/.test(x[0]))
          return I = I.width / I.height, f.width / f.height < I ^ x[0] === "contain" ? { width: f.height * I, height: f.height } : { width: f.width, height: f.width / I };
        M = parseInt(x[0], 10);
      }
      return f = x[0] === "auto" && x[1] === "auto" ? I.height : x[1] === "auto" ? M / I.width * I.height : gt(x[1]) ? f.height * parseFloat(x[1]) / 100 : parseInt(x[1], 10), x[0] === "auto" && (M = f / I.height * I.width), { width: M, height: f };
    }, st.prototype.parseBackgroundPosition = function(f, I, x, M) {
      x = this.cssList("backgroundPosition", x);
      var R;
      return R = gt(x[0]) ? (f.width - (M || I).width) * (parseFloat(x[0]) / 100) : parseInt(x[0], 10), f = x[1] === "auto" ? R / I.width * I.height : gt(x[1]) ? (f.height - (M || I).height) * parseFloat(x[1]) / 100 : parseInt(x[1], 10), x[0] === "auto" && (R = f / I.height * I.width), { left: R, top: f };
    }, st.prototype.parseBackgroundRepeat = function(f) {
      return this.cssList("backgroundRepeat", f)[0];
    }, st.prototype.parseTextShadows = function() {
      var f = this.css("textShadow"), I = [];
      if (f && f !== "none")
        for (var f = f.match(this.TEXT_SHADOW_PROPERTY), x = 0; f && x < f.length; x++) {
          var M = f[x].match(this.TEXT_SHADOW_VALUES);
          I.push({
            color: new Y(M[0]),
            offsetX: M[1] ? parseFloat(M[1].replace("px", "")) : 0,
            offsetY: M[2] ? parseFloat(M[2].replace("px", "")) : 0,
            blur: M[3] ? M[3].replace("px", "") : 0
          });
        }
      return I;
    }, st.prototype.parseTransform = function() {
      if (!this.transformData)
        if (this.hasTransform()) {
          var f = this.parseBounds(), I = this.prefixedCss("transformOrigin").split(" ").map(ht).map(z);
          I[0] += f.left, I[1] += f.top, this.transformData = { origin: I, matrix: this.parseTransformMatrix() };
        } else
          this.transformData = { origin: [0, 0], matrix: [1, 0, 0, 1, 0, 0] };
      return this.transformData;
    }, st.prototype.parseTransformMatrix = function() {
      if (!this.transformMatrix) {
        var f = this.prefixedCss("transform");
        this.transformMatrix = (f = f ? j(f.match(this.MATRIX_PROPERTY)) : null) ? f : [1, 0, 0, 1, 0, 0];
      }
      return this.transformMatrix;
    }, st.prototype.parseBounds = function() {
      return this.bounds || (this.bounds = this.hasTransform() ? _t(this.node) : O(this.node));
    }, st.prototype.hasTransform = function() {
      return this.parseTransformMatrix().join(",") !== "1,0,0,1,0,0" || this.parent && this.parent.hasTransform();
    }, st.prototype.getValue = function() {
      var f = this.node.value || "";
      return this.node.tagName === "SELECT" ? (f = this.node, f = (f = f.options[f.selectedIndex || 0]) && f.text || "") : this.node.type === "password" && (f = Array(f.length + 1).join("•")), f.length === 0 ? this.node.placeholder || "" : f;
    }, st.prototype.MATRIX_PROPERTY = /(matrix)\((.+)\)/, st.prototype.TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g, st.prototype.TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g, st.prototype.CLIP = /^rect\((\d+)px,? (\d+)px,? (\d+)px,? (\d+)px\)$/, rt.prototype.calculateOverflowClips = function() {
      this.nodes.forEach(function(f) {
        if (lt(f)) {
          f.isPseudoElement === !0 && f.appendToDOM(), f.borders = this.parseBorders(f);
          var I = f.css("overflow") === "hidden" ? [f.borders.clip] : [], x = f.parseClip();
          x && ["absolute", "fixed"].indexOf(f.css("position")) !== -1 && I.push([
            [
              "rect",
              f.bounds.left + x.left,
              f.bounds.top + x.top,
              x.right - x.left,
              x.bottom - x.top
            ]
          ]), f.clip = f.parent && f.parent.clip.length ? f.parent.clip.concat(I) : I, f.backgroundClip = f.css("overflow") !== "hidden" ? f.clip.concat([f.borders.clip]) : f.clip, f.isPseudoElement === !0 && f.cleanDOM();
        } else
          dt(f) && (f.clip = f.parent && f.parent.clip.length ? f.parent.clip : []);
        f.isPseudoElement !== !0 && (f.bounds = null);
      }, this);
    }, rt.prototype.asyncRenderer = function(f, I, x) {
      x = x || Date.now(), this.paint(f[this.renderIndex++]), f.length === this.renderIndex ? I() : x + 20 > Date.now() ? this.asyncRenderer(f, I, x) : setTimeout(
        It(function() {
          this.asyncRenderer(f, I);
        }, this),
        0
      );
    }, rt.prototype.createPseudoHideStyles = function(f) {
      this.createStyles(
        f,
        "." + He.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ':before { content: "" !important; display: none !important; }.' + He.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER + ':after { content: "" !important; display: none !important; }'
      );
    }, rt.prototype.disableAnimations = function(f) {
      this.createStyles(
        f,
        "* { -webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; -webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}"
      );
    }, rt.prototype.createStyles = function(f, I) {
      var x = f.createElement("style");
      x.innerHTML = I, f.body.appendChild(x);
    }, rt.prototype.getPseudoElements = function(f) {
      var I = [[f]];
      if (f.node.nodeType === Node.ELEMENT_NODE) {
        var x = this.getPseudoElement(f, ":before");
        f = this.getPseudoElement(f, ":after"), x && I.push(x), f && I.push(f);
      }
      return [].concat.apply([], I);
    }, rt.prototype.getPseudoElement = function(f, I) {
      var x = f.computedStyle(I);
      if (!x || !x.content || x.content === "none" || x.content === "-moz-alt-content" || x.display === "none")
        return null;
      var M, R = x.content, F = R.substr(0, 1);
      M = F === R.substr(R.length - 1) && F.match(/'|"/) ? R.substr(1, R.length - 2) : R;
      for (var q = M.substr(0, 3) === "url", R = t.createElement(q ? "img" : "html2canvaspseudoelement"), F = new He(R, f, I), ot = x.length - 1; 0 <= ot; ot--) {
        var pt = ut(x.item(ot));
        R.style[pt] = x[pt];
      }
      return R.className = He.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + He.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER, q ? (R.src = U(M)[0].args[0], [F]) : (x = t.createTextNode(M), R.appendChild(x), [F, new yr(x, F)]);
    }, rt.prototype.getChildren = function(f) {
      return [].concat.apply(
        [],
        [].filter.call(f.node.childNodes, K).map(function(I) {
          var x = [I.nodeType === Node.TEXT_NODE ? new yr(I, f) : new st(I, f)].filter(si);
          return I.nodeType === Node.ELEMENT_NODE && x.length && I.tagName !== "TEXTAREA" ? x[0].isElementVisible() ? x.concat(this.getChildren(x[0])) : [] : x;
        }, this)
      );
    }, rt.prototype.newStackingContext = function(f, I) {
      var x = new qi(I, f.getOpacity(), f.node, f.parent);
      f.cloneTo(x), (I ? x.getParentStack(this) : x.parent.stack).contexts.push(x), f.stack = x;
    }, rt.prototype.createStackingContexts = function() {
      this.nodes.forEach(function(f) {
        var I;
        (I = lt(f)) && ((I = this.isRootElement(f) || 1 > f.getOpacity()) || (I = f.css("position"), I = (["absolute", "relative", "fixed"].indexOf(I) !== -1 ? f.css("zIndex") : "auto") !== "auto"), I = I || this.isBodyWithTransparentRoot(f) || f.hasTransform()), I ? this.newStackingContext(f, !0) : lt(f) && (tt(f) && $(f) || ["inline-block", "inline-table"].indexOf(f.css("display")) !== -1 || nt(f)) ? this.newStackingContext(f, !1) : f.assignStack(f.parent.stack);
      }, this);
    }, rt.prototype.isBodyWithTransparentRoot = function(f) {
      return f.node.nodeName === "BODY" && f.parent.color("backgroundColor").isTransparent();
    }, rt.prototype.isRootElement = function(f) {
      return f.parent === null;
    }, rt.prototype.sortStackingContexts = function(f) {
      f.contexts.sort(ct(f.contexts.slice(0))), f.contexts.forEach(this.sortStackingContexts, this);
    }, rt.prototype.parseTextBounds = function(f) {
      return function(I, x, M) {
        if (f.parent.css("textDecoration").substr(0, 4) !== "none" || I.trim().length !== 0) {
          if (this.support.rangeBounds && !f.parent.hasTransform())
            return x = M.slice(0, x).join("").length, this.getRangeBounds(f.node, x, I.length);
          if (f.node && typeof f.node.data == "string")
            return I = f.node.splitText(I.length), x = this.getWrapperBounds(f.node, f.parent.hasTransform()), f.node = I, x;
        } else
          (!this.support.rangeBounds || f.parent.hasTransform()) && (f.node = f.node.splitText(I.length));
        return {};
      };
    }, rt.prototype.getWrapperBounds = function(f, I) {
      var x = f.ownerDocument.createElement("html2canvaswrapper"), M = f.parentNode, R = f.cloneNode(!0);
      x.appendChild(f.cloneNode(!0)), M.replaceChild(x, f);
      var F = I ? _t(x) : O(x);
      return M.replaceChild(R, x), F;
    }, rt.prototype.getRangeBounds = function(f, I, x) {
      var M = this.range || (this.range = f.ownerDocument.createRange());
      return M.setStart(f, I), M.setEnd(f, I + x), M.getBoundingClientRect();
    }, rt.prototype.parse = function(f) {
      var I = f.contexts.filter(bi), M = f.children.filter(lt), F = M.filter(A(nt)), x = F.filter(A(tt)).filter(A(H)), M = M.filter(A(tt)).filter(nt), R = F.filter(A(tt)).filter(H), F = f.contexts.concat(F.filter(tt)).filter($), q = f.children.filter(dt).filter(T);
      f = f.contexts.filter(S), I.concat(x).concat(M).concat(R).concat(F).concat(q).concat(f).forEach(function(ot) {
        this.renderQueue.push(ot), ot instanceof qi && (this.parse(ot), this.renderQueue.push(new oe()));
      }, this);
    }, rt.prototype.paint = function(f) {
      try {
        f instanceof oe ? this.renderer.ctx.restore() : dt(f) ? (f.parent.isPseudoElement === !0 && f.parent.appendToDOM(), this.paintText(f), f.parent.isPseudoElement === !0 && f.parent.cleanDOM()) : this.paintNode(f);
      } catch (I) {
        if (W(I), this.options.strict)
          throw I;
      }
    }, rt.prototype.paintNode = function(f) {
      f instanceof qi && (this.renderer.setOpacity(f.opacity), this.renderer.ctx.save(), f.hasTransform() && this.renderer.setTransform(f.parseTransform())), f.node.nodeName === "INPUT" && f.node.type === "checkbox" ? this.paintCheckbox(f) : f.node.nodeName === "INPUT" && f.node.type === "radio" ? this.paintRadio(f) : this.paintElement(f);
    }, rt.prototype.paintElement = function(f) {
      var I = f.parseBounds();
      this.renderer.clip(
        f.backgroundClip,
        function() {
          this.renderer.renderBackground(f, I, f.borders.borders.map(Ft));
        },
        this
      ), this.renderer.clip(
        f.clip,
        function() {
          this.renderer.renderBorders(f.borders.borders);
        },
        this
      ), this.renderer.clip(
        f.backgroundClip,
        function() {
          switch (f.node.nodeName) {
            case "svg":
            case "IFRAME":
              var x = this.images.get(f.node);
              x ? this.renderer.renderImage(f, I, f.borders, x) : W("Error loading <" + f.node.nodeName + ">", f.node);
              break;
            case "IMG":
              (x = this.images.get(f.node.src)) ? this.renderer.renderImage(f, I, f.borders, x) : W("Error loading <img>", f.node.src);
              break;
            case "CANVAS":
              this.renderer.renderImage(f, I, f.borders, { image: f.node });
              break;
            case "SELECT":
            case "INPUT":
            case "TEXTAREA":
              this.paintFormValue(f);
          }
        },
        this
      );
    }, rt.prototype.paintCheckbox = function(f) {
      var M = f.parseBounds(), I = Math.min(M.width, M.height), x = { width: I - 1, height: I - 1, top: M.top, left: M.left }, M = [3, 3], R = [M, M, M, M], F = [1, 1, 1, 1].map(function(ot) {
        return { color: new Y("#A5A5A5"), width: ot };
      }), q = Dt(x, R, F);
      this.renderer.clip(
        f.backgroundClip,
        function() {
          this.renderer.rectangle(
            x.left + 1,
            x.top + 1,
            x.width - 2,
            x.height - 2,
            new Y("#DEDEDE")
          ), this.renderer.renderBorders(Re(F, x, q, R)), f.node.checked && (this.renderer.font(
            new Y("#424242"),
            "normal",
            "normal",
            "bold",
            I - 3 + "px",
            "arial"
          ), this.renderer.text("✔", x.left + I / 6, x.top + I - 1));
        },
        this
      );
    }, rt.prototype.paintRadio = function(f) {
      var I = f.parseBounds(), x = Math.min(I.width, I.height) - 2;
      this.renderer.clip(
        f.backgroundClip,
        function() {
          this.renderer.circleStroke(
            I.left + 1,
            I.top + 1,
            x,
            new Y("#DEDEDE"),
            1,
            new Y("#A5A5A5")
          ), f.node.checked && this.renderer.circle(
            Math.ceil(I.left + x / 4) + 1,
            Math.ceil(I.top + x / 4) + 1,
            Math.floor(x / 2),
            new Y("#424242")
          );
        },
        this
      );
    }, rt.prototype.paintFormValue = function(f) {
      var I = f.getValue();
      if (0 < I.length) {
        var x = f.node.ownerDocument, M = x.createElement("html2canvaswrapper");
        "lineHeight textAlign fontFamily fontWeight fontSize color paddingLeft paddingTop paddingRight paddingBottom width height borderLeftStyle borderTopStyle borderLeftWidth borderTopWidth boxSizing whiteSpace wordWrap".split(" ").forEach(function(F) {
          try {
            M.style[F] = f.css(F);
          } catch (q) {
            W("html2canvas: Parse: Exception caught in renderFormValue: " + q.message);
          }
        });
        var R = f.parseBounds();
        M.style.position = "fixed", M.style.left = R.left + "px", M.style.top = R.top + "px", M.textContent = I, x.body.appendChild(M), this.paintText(new yr(M.firstChild, f)), x.body.removeChild(M);
      }
    }, rt.prototype.paintText = function(f) {
      f.applyTextTransform();
      var x = n.html2canvas.punycode.ucs2.decode(f.node.data), I = this.options.letterRendering && !/^(normal|none|0px)$/.test(f.parent.css("letterSpacing")) || /[^\u0000-\u00ff]/.test(f.node.data) ? x.map(function(q) {
        return n.html2canvas.punycode.ucs2.encode([q]);
      }) : cn(x), x = f.parent.fontWeight(), M = f.parent.css("fontSize"), R = f.parent.css("fontFamily"), F = f.parent.parseTextShadows();
      this.renderer.font(
        f.parent.color("color"),
        f.parent.css("fontStyle"),
        f.parent.css("fontVariant"),
        x,
        M,
        R
      ), F.length ? this.renderer.fontShadow(F[0].color, F[0].offsetX, F[0].offsetY, F[0].blur) : this.renderer.clearShadow(), this.renderer.clip(
        f.parent.clip,
        function() {
          I.map(this.parseTextBounds(f), this).forEach(function(q, ot) {
            q && (this.renderer.text(I[ot], q.left, q.bottom), this.renderTextDecoration(f.parent, q, this.fontMetrics.getMetrics(R, M)));
          }, this);
        },
        this
      );
    }, rt.prototype.renderTextDecoration = function(f, I, x) {
      switch (f.css("textDecoration").split(" ")[0]) {
        case "underline":
          this.renderer.rectangle(
            I.left,
            Math.round(I.top + x.baseline + x.lineWidth),
            I.width,
            1,
            f.color("color")
          );
          break;
        case "overline":
          this.renderer.rectangle(I.left, Math.round(I.top), I.width, 1, f.color("color"));
          break;
        case "line-through":
          this.renderer.rectangle(
            I.left,
            Math.ceil(I.top + x.middle + x.lineWidth),
            I.width,
            1,
            f.color("color")
          );
      }
    };
    var Uh = {
      inset: [
        ["darken", 0.6],
        ["darken", 0.1],
        ["darken", 0.1],
        ["darken", 0.6]
      ]
    };
    rt.prototype.parseBorders = function(f) {
      var I = f.parseBounds(), x = G(f), M = ["Top", "Right", "Bottom", "Left"].map(function(F, q) {
        var ot = f.css("border" + F + "Style"), pt = f.color("border" + F + "Color");
        return ot === "inset" && pt.isBlack() && (pt = new Y([255, 255, 255, pt.a])), ot = Uh[ot] ? Uh[ot][q] : null, {
          width: f.cssInt("border" + F + "Width"),
          color: ot ? pt[ot[0]](ot[1]) : pt,
          args: null
        };
      }), R = Dt(I, x, M);
      return { clip: this.parseBackgroundClip(f, R, M, x, I), borders: Re(M, I, R, x) };
    }, rt.prototype.parseBackgroundClip = function(f, I, x, M, R) {
      var F = [];
      switch (f.css("backgroundClip")) {
        case "content-box":
        case "padding-box":
          Ye(
            F,
            M[0],
            M[1],
            I.topLeftInner,
            I.topRightInner,
            R.left + x[3].width,
            R.top + x[0].width
          ), Ye(
            F,
            M[1],
            M[2],
            I.topRightInner,
            I.bottomRightInner,
            R.left + R.width - x[1].width,
            R.top + x[0].width
          ), Ye(
            F,
            M[2],
            M[3],
            I.bottomRightInner,
            I.bottomLeftInner,
            R.left + R.width - x[1].width,
            R.top + R.height - x[2].width
          ), Ye(
            F,
            M[3],
            M[0],
            I.bottomLeftInner,
            I.topLeftInner,
            R.left + x[3].width,
            R.top + R.height - x[2].width
          );
          break;
        default:
          Ye(F, M[0], M[1], I.topLeftOuter, I.topRightOuter, R.left, R.top), Ye(F, M[1], M[2], I.topRightOuter, I.bottomRightOuter, R.left + R.width, R.top), Ye(
            F,
            M[2],
            M[3],
            I.bottomRightOuter,
            I.bottomLeftOuter,
            R.left + R.width,
            R.top + R.height
          ), Ye(F, M[3], M[0], I.bottomLeftOuter, I.topLeftOuter, R.left, R.top + R.height);
      }
      return F;
    };
    var Bp = 0, Qh = "withCredentials" in new XMLHttpRequest(), qh = "crossOrigin" in new Image();
    He.prototype.cloneTo = function(f) {
      He.prototype.cloneTo.call(this, f), f.isPseudoElement = !0, f.before = this.before;
    }, He.prototype = Object.create(st.prototype), He.prototype.appendToDOM = function() {
      this.before ? this.parent.node.insertBefore(this.node, this.parent.node.firstChild) : this.parent.node.appendChild(this.node), this.parent.node.className += " " + this.getHideClass();
    }, He.prototype.cleanDOM = function() {
      this.node.parentNode.removeChild(this.node), this.parent.node.className = this.parent.node.className.replace(this.getHideClass(), "");
    }, He.prototype.getHideClass = function() {
      return this["PSEUDO_HIDE_ELEMENT_CLASS_" + (this.before ? "BEFORE" : "AFTER")];
    }, He.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before", He.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after", Yi.prototype.renderImage = function(f, I, x, M) {
      var R = f.cssInt("paddingLeft"), F = f.cssInt("paddingTop"), q = f.cssInt("paddingRight");
      f = f.cssInt("paddingBottom"), x = x.borders, q = I.width - (x[1].width + x[3].width + R + q), f = I.height - (x[0].width + x[2].width + F + f), this.drawImage(
        M,
        0,
        0,
        M.image.width || q,
        M.image.height || f,
        I.left + R + x[3].width,
        I.top + F + x[0].width,
        q,
        f
      );
    }, Yi.prototype.renderBackground = function(f, I, x) {
      0 < I.height && 0 < I.width && (this.renderBackgroundColor(f, I), this.renderBackgroundImage(f, I, x));
    }, Yi.prototype.renderBackgroundColor = function(f, I) {
      var x = f.color("backgroundColor");
      x.isTransparent() || this.rectangle(I.left, I.top, I.width, I.height, x);
    }, Yi.prototype.renderBorders = function(f) {
      f.forEach(this.renderBorder, this);
    }, Yi.prototype.renderBorder = function(f) {
      f.color.isTransparent() || f.args === null || this.drawShape(f.args, f.color);
    }, Yi.prototype.renderBackgroundImage = function(f, I, x) {
      f.parseBackgroundImages().reverse().forEach(function(M, R, F) {
        switch (M.method) {
          case "url":
            var q = this.images.get(M.args[0]);
            q ? this.renderBackgroundRepeating(f, I, q, F.length - (R + 1), x) : W("Error loading background-image", M.args[0]);
            break;
          case "linear-gradient":
          case "gradient":
            (R = this.images.get(M.value)) ? this.renderBackgroundGradient(R, I, x) : W("Error loading background-image", M.args[0]);
            break;
          case "none":
            break;
          default:
            W("Unknown background-image type", M.args[0]);
        }
      }, this);
    }, Yi.prototype.renderBackgroundRepeating = function(f, I, x, M, R) {
      var F = f.parseBackgroundSize(I, x.image, M), q = f.parseBackgroundPosition(I, x.image, M, F);
      switch (f.parseBackgroundRepeat(M)) {
        case "repeat-x":
        case "repeat no-repeat":
          this.backgroundRepeatShape(
            x,
            q,
            F,
            I,
            I.left + R[3],
            I.top + q.top + R[0],
            99999,
            F.height,
            R
          );
          break;
        case "repeat-y":
        case "no-repeat repeat":
          this.backgroundRepeatShape(
            x,
            q,
            F,
            I,
            I.left + q.left + R[3],
            I.top + R[0],
            F.width,
            99999,
            R
          );
          break;
        case "no-repeat":
          this.backgroundRepeatShape(
            x,
            q,
            F,
            I,
            I.left + q.left + R[3],
            I.top + q.top + R[0],
            F.width,
            F.height,
            R
          );
          break;
        default:
          this.renderBackgroundRepeat(x, q, F, { top: I.top, left: I.left }, R[3], R[0]);
      }
    }, qi.prototype = Object.create(st.prototype), qi.prototype.getParentStack = function(f) {
      var I = this.parent ? this.parent.stack : null;
      return I ? I.ownStacking ? I : I.getParentStack(f) : f.stack;
    }, wn.prototype.testRangeBounds = function(f) {
      var I, x, M = !1;
      return f.createRange && (I = f.createRange(), I.getBoundingClientRect && (x = f.createElement("boundtest"), x.style.height = "123px", x.style.display = "block", f.body.appendChild(x), I.selectNode(x), I = I.getBoundingClientRect(), I = I.height, I === 123 && (M = !0), f.body.removeChild(x))), M;
    }, wn.prototype.testCORS = function() {
      return typeof new Image().crossOrigin < "u";
    }, wn.prototype.testSVG = function() {
      var f = new Image(), I = t.createElement("canvas"), x = I.getContext("2d");
      f.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
      try {
        x.drawImage(f, 0, 0), I.toDataURL();
      } catch {
        return !1;
      }
      return !0;
    }, Zi.prototype.hasFabric = function() {
      return html2canvas.fabric ? Promise.resolve() : Promise.reject(Error("html2canvas.svg.js is not loaded, cannot render svg"));
    }, Zi.prototype.inlineFormatting = function(f) {
      return /^data:image\/svg\+xml;base64,/.test(f) ? this.decode64(this.removeContentType(f)) : this.removeContentType(f);
    }, Zi.prototype.removeContentType = function(f) {
      return f.replace(/^data:image\/svg\+xml(;base64)?,/, "");
    }, Zi.prototype.isInline = function(f) {
      return /^data:image\/svg\+xml/i.test(f);
    }, Zi.prototype.createCanvas = function(f) {
      var I = this;
      return function(x, M) {
        var R = new html2canvas.fabric.StaticCanvas("c");
        I.image = R.lowerCanvasEl, R.setWidth(M.width).setHeight(M.height).add(html2canvas.fabric.util.groupSVGElements(x, M)).renderAll(), f(R.lowerCanvasEl);
      };
    }, Zi.prototype.decode64 = function(f) {
      return typeof n.atob == "function" ? n.atob(f) : Ge(f);
    }, Ds.prototype = Object.create(Zi.prototype), yr.prototype = Object.create(st.prototype), yr.prototype.applyTextTransform = function() {
      this.node.data = this.transform(this.parent.css("textTransform"));
    }, yr.prototype.transform = function(f) {
      var I = this.node.data;
      switch (f) {
        case "lowercase":
          return I.toLowerCase();
        case "capitalize":
          return I.replace(/(^|\s|:|-|\(|\))([a-z])/g, Lp);
        case "uppercase":
          return I.toUpperCase();
        default:
          return I;
      }
    }, jh.prototype = Object.create(B.prototype), Le.prototype = Object.create(Yi.prototype), Le.prototype.setFillStyle = function(f) {
      return this.ctx.fillStyle = typeof f == "object" && f.isColor ? f.toString() : f, this.ctx;
    }, Le.prototype.rectangle = function(f, I, x, M, R) {
      this.setFillStyle(R).fillRect(f, I, x, M);
    }, Le.prototype.circle = function(f, I, x, M) {
      this.setFillStyle(M), this.ctx.beginPath(), this.ctx.arc(f + x / 2, I + x / 2, x / 2, 0, 2 * Math.PI, !0), this.ctx.closePath(), this.ctx.fill();
    }, Le.prototype.circleStroke = function(f, I, x, M, R, F) {
      this.circle(f, I, x, M), this.ctx.strokeStyle = F.toString(), this.ctx.stroke();
    }, Le.prototype.drawShape = function(f, I) {
      this.shape(f), this.setFillStyle(I).fill();
    }, Le.prototype.taints = function(f) {
      if (f.tainted === null) {
        this.taintCtx.drawImage(f.image, 0, 0);
        try {
          this.taintCtx.getImageData(0, 0, 1, 1), f.tainted = !1;
        } catch {
          this.taintCtx = t.createElement("canvas").getContext("2d"), f.tainted = !0;
        }
      }
      return f.tainted;
    }, Le.prototype.drawImage = function(f, I, x, M, R, F, q, ot, pt) {
      this.taints(f) && !this.options.allowTaint || this.ctx.drawImage(f.image, I, x, M, R, F, q, ot, pt);
    }, Le.prototype.clip = function(f, I, x) {
      this.ctx.save(), f.filter(Xp).forEach(function(M) {
        this.shape(M).clip();
      }, this), I.call(x), this.ctx.restore();
    }, Le.prototype.shape = function(f) {
      return this.ctx.beginPath(), f.forEach(function(I, x) {
        I[0] === "rect" ? this.ctx.rect.apply(this.ctx, I.slice(1)) : this.ctx[x === 0 ? "moveTo" : I[0] + "To"].apply(this.ctx, I.slice(1));
      }, this), this.ctx.closePath(), this.ctx;
    }, Le.prototype.font = function(f, I, x, M, R, F) {
      this.setFillStyle(f).font = [I, x, M, R, F].join(" ").split(",")[0];
    }, Le.prototype.fontShadow = function(f, I, x, M) {
      this.setVariable("shadowColor", f.toString()).setVariable("shadowOffsetY", I).setVariable("shadowOffsetX", x).setVariable("shadowBlur", M);
    }, Le.prototype.clearShadow = function() {
      this.setVariable("shadowColor", "rgba(0,0,0,0)");
    }, Le.prototype.setOpacity = function(f) {
      this.ctx.globalAlpha = f;
    }, Le.prototype.setTransform = function(f) {
      this.ctx.translate(f.origin[0], f.origin[1]), this.ctx.transform.apply(this.ctx, f.matrix), this.ctx.translate(-f.origin[0], -f.origin[1]);
    }, Le.prototype.setVariable = function(f, I) {
      return this.variables[f] !== I && (this.variables[f] = this.ctx[f] = I), this;
    }, Le.prototype.text = function(f, I, x) {
      this.ctx.fillText(f, I, x);
    }, Le.prototype.backgroundRepeatShape = function(f, I, x, M, R, F, q, ot, pt) {
      this.clip(
        [
          [
            ["line", Math.round(R), Math.round(F)],
            ["line", Math.round(R + q), Math.round(F)],
            ["line", Math.round(R + q), Math.round(ot + F)],
            ["line", Math.round(R), Math.round(ot + F)]
          ]
        ],
        function() {
          this.renderBackgroundRepeat(f, I, x, M, pt[3], pt[0]);
        },
        this
      );
    }, Le.prototype.renderBackgroundRepeat = function(f, I, x, M, R, F) {
      R = Math.round(M.left + I.left + R), I = Math.round(M.top + I.top + F), this.setFillStyle(this.ctx.createPattern(this.resizeImage(f, x), "repeat")), this.ctx.translate(R, I), this.ctx.fill(), this.ctx.translate(-R, -I);
    }, Le.prototype.renderBackgroundGradient = function(f, I) {
      if (f instanceof Z) {
        var x = this.ctx.createLinearGradient(
          I.left + I.width * f.x0,
          I.top + I.height * f.y0,
          I.left + I.width * f.x1,
          I.top + I.height * f.y1
        );
        f.colorStops.forEach(function(M) {
          x.addColorStop(M.stop, M.color.toString());
        }), this.rectangle(I.left, I.top, I.width, I.height, x);
      }
    }, Le.prototype.resizeImage = function(f, I) {
      var x = f.image;
      if (x.width === I.width && x.height === I.height)
        return x;
      var M = t.createElement("canvas");
      return M.width = I.width, M.height = I.height, M.getContext("2d").drawImage(x, 0, 0, x.width, x.height, 0, 0, I.width, I.height), M;
    };
  }
}).call(
  {},
  typeof window < "u" ? window : void 0,
  typeof document < "u" ? document : void 0
);
function fc(n) {
  const t = document.createElement("canvas");
  return t.width = n.width, t.height = n.height, t.getContext("2d").drawImage(n, 0, 0), t;
}
function Np(n) {
  if (n instanceof HTMLCanvasElement) {
    const t = n;
    if (t.clientWidth > 0 && t.clientHeight > 0)
      return n;
  }
  for (let t = 0; t < n.childNodes.length; t++) {
    const e = n.childNodes.item(t), i = Np(e);
    if (i)
      return i;
  }
  return null;
}
function Z0(n) {
  const e = new DOMParser().parseFromString(n, "text/xml"), i = e.getElementsByTagName("defs"), s = [];
  for (let c = 0; c < i.length; c++) {
    const u = i.item(c).getElementsByTagName("marker");
    for (let p = 0; p < u.length; p++) {
      const m = u.item(p);
      s.push(m);
    }
  }
  const r = [], o = e.getElementsByTagName("line");
  for (let c = 0; c < o.length; c++) {
    const h = o.item(c);
    if (h.style.marker !== null && h.style.marker.length > 0) {
      const u = h.style.marker.indexOf("#") + 1, p = h.style.marker.indexOf('"', u + 1), m = h.style.marker.substring(u, p);
      let g = null, _ = null;
      for (let b = 0; b < s.length; b++)
        if (s[b].id === m) {
          g = s[b], _ = s[b + 1];
          break;
        }
      const y = { line: h, start: g, end: _ };
      r.push(y);
    }
  }
  const a = "marker: url";
  let l = n.indexOf(a);
  for (; l >= 0; ) {
    const c = n.indexOf(")", l) + 1, h = n.substring(l, c), u = h.indexOf("#") + 1, p = h.indexOf('"', u), m = h.indexOf(
      "&quot",
      u + a.length + 1
    );
    let g = p;
    (p < 0 || m < p) && (g = m);
    const _ = h.substring(u, g);
    for (const y of r) {
      const b = y.start, w = y.end;
      if (b !== null && w !== null && b.id === _) {
        let v = `marker-start: url('#${b.id}');`;
        v += `marker-end: url('#${w.id}')`, n = n.slice(0, l) + v + n.slice(c);
        break;
      }
    }
    l = n.indexOf(a, c + 1);
  }
  return n;
}
function C0(n, t) {
  const e = n.getContext("2d");
  if (e === null)
    throw new Mt("failed to create 2D canvas context");
  for (const r of t)
    e.drawImage(r, 0, 0);
  const i = ye(), s = new Image();
  return s.src = n.toDataURL(), s.onload = () => {
    i.resolve(s);
  }, i;
}
class k0 {
  constructor(t, e) {
    this._domElements = t, this._config = e;
  }
  async _extractMarkupSvgAsCanvas() {
    const t = this._domElements.getMarkupSvgElement();
    let e = new XMLSerializer().serializeToString(t);
    e = Z0(e);
    const i = document.createElement("canvas");
    document.body.appendChild(i);
    const s = i.getContext("2d");
    if (!s)
      return i;
    await (await ir.from(s, e)).render();
    const o = fc(i);
    return document.body.removeChild(i), o;
  }
  async _extractRedlineSvgAsCanvas(t, e) {
    const i = this._domElements.getRedlineSvgElement();
    i.setAttribute("width", `${t}`), i.setAttribute("height", `${e}`);
    let s = new XMLSerializer().serializeToString(i);
    s = s.replace("width: 100%;", `width: ${t};`), s = s.replace("height: 100%;", `height: ${e};`);
    const r = document.createElement("canvas");
    document.body.appendChild(r);
    const o = r.getContext("2d");
    if (!o)
      return r;
    await (await ir.from(o, s)).render();
    const l = fc(r);
    return document.body.removeChild(r), l;
  }
  async _extractRedlineAsCanvas() {
    const t = this._domElements.getRedlineElement();
    return html2canvas(t, {
      background: void 0,
      letterRendering: !0
      // Fixes word break issue
    });
  }
  async capture(t) {
    const e = Np(t);
    if (e === null)
      throw new Mt("failed to find canvas");
    const i = document.createElement("canvas");
    i.width = this._config.width || t.clientWidth, i.height = this._config.height || t.clientHeight, i.style.width = "100%", i.style.height = "100%";
    const s = [];
    return this._config.layers & Yo.Model && s.push(fc(e)), this._config.layers & Yo.Svg && (s.push(await this._extractMarkupSvgAsCanvas()), s.push(
      await this._extractRedlineSvgAsCanvas(i.width, i.height)
    )), this._config.layers & Yo.Html && s.push(await this._extractRedlineAsCanvas()), C0(i, s);
  }
}
class M0 {
  constructor(t) {
    this._timeoutDurationMinutes = 15, this._timeoutWarningMinutes = 14, this._timer = new Os(), this._enabled = !0, this._callbackManager = t, this.resetTimeout();
  }
  setTimeoutDurations(t, e) {
    return this._timeoutDurationMinutes = t, this._timeoutWarningMinutes = e, this.resetTimeout(), !0;
  }
  shutdown() {
    this._enabled = !1, this._timer.clear();
  }
  resetTimeout() {
    if (!this._enabled)
      return;
    const t = Math.round(this._timeoutWarningMinutes * 60 * 1e3);
    this._timer.set(t, () => {
      this._warn();
    });
  }
  _warn() {
    console.assert(this._timer.isIdle(mi.BeforeAction));
    const t = this._timeoutDurationMinutes - this._timeoutWarningMinutes, e = Math.round(t * 60 * 1e3);
    this._callbackManager.trigger("timeoutWarning", t), this._timer.set(e, () => {
      this._timeout();
    });
  }
  _timeout() {
    this._callbackManager.trigger("timeout"), this._callbackManager.trigger("_timeout");
  }
}
const Bh = class {
  /**
   * Creates a new Web Viewer instance. You must pass in a **containerId** key with the ID of an element or a **container** element to use for your viewer.
   * The system will create any required elements inside the supplied container.
   *
   * @param inputParams object containing key-value pairs for viewer to set
   */
  constructor(n) {
    if (this._callbackManager = new Zg(), this._interpolationManager = new eb(), this._streamingMode = Ps.Interactive, this._rendererType = Ho.Client, this._alreadyShutDown = !1, this._shutdownTimer = new Os(), this._sceneReadyPromise = ye(), this._modelLoadFailure = !1, this._seenPriorityMetaDataSent = !1, this._params = { ...n }, this._contextMenuActiveFlag = !1, this._params.containerId !== void 0) {
      const m = Gr.createFromId(this._params.containerId);
      if (m === null)
        throw new fn("'containerId' is invalid");
      this._domElements = m;
    } else if (this._params.container !== void 0)
      this._domElements = Gr.createFromElement(this._params.container);
    else
      throw new fn("must supply 'container' or 'containerId'");
    this.operatorManager = new uy(this), this._eventDispatcher = new $y(this._callbackManager, this.operatorManager), this._timeoutMonitor = new M0(this._callbackManager), this._inputMonitor = new Ul(this._eventDispatcher, this._timeoutMonitor), this._setInitialOptions(this._params), this._engine = new Hy(this._callbackManager, this._params), this._statistics = new jy(this._callbackManager, this);
    const t = new pp(this), e = new As(this);
    this.model = new Po(this._engine, this._callbackManager), this.view = new _y(
      this,
      this._engine,
      this._callbackManager,
      this._eventDispatcher,
      this._interpolationManager,
      this._statistics,
      t,
      e
    ), this.cuttingManager = new sy(this, this.model, this._callbackManager, this._engine);
    const i = {
      disableAutomaticFitWorld: vr(this._params.disableAutomaticFitWorld, !1),
      markImplicitNodesOutOfHierarchy: vr(
        this._params._markImplicitNodesOutOfHierarchy,
        !0
      ),
      streamingMode: vr(this._params.streamingMode, Ps.Default)
    };
    this._modelStructure = Kh.unsafeCreate(
      i,
      this._engine,
      this._callbackManager,
      this.cuttingManager,
      this.view,
      this.model,
      this._params._maxConcurrentAttachments || null
    ), this.model._setModelStructure(this._modelStructure), this.measureManager = new hy(this, this._callbackManager), this.lineManager = new ay(this, this._callbackManager), this.explodeManager = new ry(this.model, this._engine, this._callbackManager), this.overlayManager = new pm(this, this._engine), this.BCFManager = new qy(this), this.selectionManager = new zl(
      this._callbackManager,
      this._engine,
      this.view,
      this.model,
      this._modelStructure
    );
    const s = new ma();
    vr(
      this._params.disableAutomaticFloorplanOverlay,
      !1
    ) && (s.autoActivate = Ls.Never), this.floorplanManager = new ys(
      this,
      this.model,
      this.overlayManager,
      this._engine,
      this._modelStructure,
      s
    );
    const o = vr(
      this._params.disableAutomaticBackgroundSheets,
      !1
    );
    this.sheetManager = new dy(
      this,
      this._engine,
      this._callbackManager,
      o
    ), this.noteTextManager = new Hl(this), this.markupManager = new cy(
      this._domElements,
      this.measureManager,
      this.lineManager,
      this._callbackManager,
      this.sheetManager,
      this.noteTextManager,
      this
    ), this.view._setMarkupManager(this.markupManager), this.animationManager = new nm(this), this._initEventDispatcher();
    const a = () => {
      this.model.setPmiColor(it.black());
    }, l = (m) => {
      this.model.isDrawing() && (m = this.sheetManager.get3DNodes());
      const g = bt.PmiBody | bt.ViewFrame;
      this.model._setInstanceModifier(
        Xe.OverrideSceneVisibility,
        m,
        !0,
        g
      );
      for (const _ of m)
        this.model.setPmiColorOverride(!0, _);
    }, c = async (m) => {
      m ? await Promise.all([
        this.view.setPointSize(3e-3, Mc.ProportionOfBoundingDiagonal),
        this.view.setEyeDomeLightingEnabled(!0),
        this.view.setPointShape(Wc.Disk)
      ]) : await Promise.all([
        //reset to defaults
        this.view.setPointSize(1, Mc.ScreenPixels),
        this.view.setEyeDomeLightingEnabled(!1),
        this.view.setPointShape(Wc.Square)
      ]);
    }, h = async (m) => {
      for (const g of m) {
        const _ = this.model.getModelFileTypeFromNode(g);
        if (_ !== null && _ !== Vo.Unknown) {
          await c(!1);
          break;
        }
      }
    }, u = async (m) => {
      const g = [];
      if (this.model.getModelFileTypeFromNode(m[0]) === Vo.Ifc)
        for (const _ of m) {
          const y = this.model.registerIfcNodes(_);
          g.push(y);
        }
      await Promise.all(g);
    }, p = (m) => {
      const g = this.selectionManager.getSelectionFilter(), _ = this.model.getModelFileTypeFromNode(m[0]) === Vo.Ifc;
      if (!g && _) {
        this.selectionManager.setSelectionFilter(Xc);
        return;
      }
      g === Xc && !_ && this.selectionManager.setSelectionFilter(null);
    };
    this.setCallbacks({
      _resetAssemblyTreeBegin: async () => {
        a();
      },
      _sessionStarted: () => c(!0),
      _firstModelLoaded: async (m) => {
        a(), p(m), l([this.model.getAbsoluteRootNode()]), await Promise.all([u(m), h(m)]);
        const g = this.model.getDefaultCadView() !== null;
        this.model.getDefaultCadConfiguration() !== null && await this._modelStructure.cadConfigurationsEnabled() && await this.model.activateDefaultCadConfiguration(!g), g && await this.model.activateDefaultCadView();
      },
      _modelSwitched: async (m, g) => {
        p(g), l(g), await Promise.all([u(g), h(g)]);
      },
      _subtreeLoaded: async (m) => {
        l(m), await u(m);
      },
      modelLoadFailure: () => {
        this._modelLoadFailure = !0;
      }
    });
  }
  static get defaultEnginePath() {
    return Ro.defaultEnginePath;
  }
  static set defaultEnginePath(n) {
    Ro.defaultEnginePath = n;
  }
  /**
   * Sets a boolean with the status of the context menu
   * @param isActive
   */
  setContextMenuStatus(n) {
    this._contextMenuActiveFlag = n;
  }
  /**
   * @returns boolean true if the context menu is active, false otherwise
   */
  getContextMenuStatus() {
    return this._contextMenuActiveFlag;
  }
  /**
   * Gets the parameters that were used to initialize this instance of the WebViewer
   * @returns initial creation parameters
   */
  getCreationParameters() {
    return { ...this._params };
  }
  /**
   * @param options
   */
  _setInitialOptions(n) {
    this._inputMonitor.setOptions(n), n.streamingMode !== void 0 ? this._streamingMode = n.streamingMode : n.streamingMode = this._streamingMode, n.rendererType !== void 0 ? this._rendererType = n.rendererType : n.rendererType = this._rendererType;
  }
  /**
   * @param viewer
   */
  _initEventDispatcher() {
    const n = new Nh(this), t = new Em(this), e = new Fm(this), i = new Xm(this), s = new Tm(
      this,
      n,
      t,
      e
    ), r = new Lm(this), o = new ml(this), a = new Rm(this, r, o), l = new Nm(this), c = new dp(this, this.noteTextManager), h = new np(this), u = new up(this), p = new $m(this), m = new ip(this), g = new ep(this), _ = new tp(this), y = new Am(this, this.measureManager), b = new zm(
      this,
      this.measureManager
    ), w = new Bm(
      this,
      this.measureManager
    ), v = new jm(
      this,
      this.measureManager
    ), C = new Km(
      this,
      this.measureManager
    ), k = new Dm(
      this,
      this.measureManager
    ), Y = new Um(
      this,
      this.measureManager
    ), P = new Hm(this, this.measureManager), L = new hp(this, this.noteTextManager), N = new op(this, this.cuttingManager), D = new lp(this), B = new cp(this), V = new sp(this), X = new ap(this), Z = new mp(this);
    this.operatorManager._registerOperator(Et.Navigate, s), this.operatorManager._registerOperator(Et.Orbit, n), this.operatorManager._registerOperator(Et.Pan, t), this.operatorManager._registerOperator(Et.Zoom, e), this.operatorManager._registerOperator(Et.WindowZoom, i), this.operatorManager._registerOperator(Et.Walk, r), this.operatorManager._registerOperator(Et.KeyboardWalk, o), this.operatorManager._registerOperator(Et.WalkMode, a), this.operatorManager._registerOperator(Et.Turntable, l), this.operatorManager._registerOperator(Et.Select, c), this.operatorManager._registerOperator(Et.AreaSelect, h), this.operatorManager._registerOperator(Et.RayDrillSelect, u), this.operatorManager._registerOperator(Et.RedlineCircle, p), this.operatorManager._registerOperator(Et.RedlineText, m), this.operatorManager._registerOperator(Et.RedlineRectangle, g), this.operatorManager._registerOperator(Et.RedlinePolyline, _), this.operatorManager._registerOperator(Et.MeasureEdgeLength, y), this.operatorManager._registerOperator(
      Et.MeasureFaceFaceDistance,
      b
    ), this.operatorManager._registerOperator(
      Et.MeasureLineLineAngle,
      w
    ), this.operatorManager._registerOperator(
      Et.MeasurePointPointDistance,
      v
    ), this.operatorManager._registerOperator(
      Et.MeasureBodyBodyDistance,
      C
    ), this.operatorManager._registerOperator(
      Et.MeasureFaceFaceAngle,
      k
    ), this.operatorManager._registerOperator(
      Et.MeasurePolylineDistance,
      Y
    ), this.operatorManager._registerOperator(
      Et.MeasurePolygonArea,
      P
    ), this.operatorManager._registerOperator(Et.Note, L), this.operatorManager._registerOperator(Et.Cutting, N), this.operatorManager._registerOperator(Et.Handle, D), this.operatorManager._registerOperator(Et.NavCube, B), this.operatorManager._registerOperator(Et.AxisTriad, V), this.operatorManager._registerOperator(Et.Floorplan, X), this.operatorManager._registerOperator(Et.SpaceMouse, Z), s.setBimNavigationEnabled(!1), y.addMapping(Kt.Left), b.addMapping(Kt.Left), v.addMapping(Kt.Left), v.addMapping(Kt.Left, _e.Alt), k.addMapping(Kt.Left), i.addMapping(Kt.Left), N.addMapping(Kt.Left), h.addMapping(Kt.Left), h.addMapping(Kt.Left, _e.Control), this.operatorManager.set(Et.Navigate, 0), this.operatorManager.set(Et.Select, 1), this.operatorManager.push(Et.Cutting), this.operatorManager.push(Et.Handle), this.operatorManager.push(Et.NavCube), this.operatorManager.push(Et.AxisTriad), this.operatorManager.push(Et.Floorplan), this.operatorManager.push(Et.SpaceMouse);
  }
  /**
   * Returns the viewer version string.
   * @returns string containing version information for the viewer.
   */
  getViewerVersionString() {
    return Bh.VIEWER_VERSION_STRING;
  }
  /**
   * Returns the format version string.
   * @returns string containing version information for the format.
   */
  getFormatVersionString() {
    return this._engine.getVersionString();
  }
  /**
   * Starts the viewer and begins the loading process
   */
  start() {
    const n = this._domElements.getCanvasContainerElement();
    return this._engine.start(n, {
      enginePath: this._params.enginePath,
      engineReady: async (t) => {
        await t, await this._modelStructure.waitForReady(), await this._scEngineReady();
      },
      sceneReady: () => {
        this._sceneReady();
      },
      renderComplete: () => {
        this._renderComplete();
      },
      streamingActivated: () => {
        this._streamingActivated();
      },
      streamingDeactivated: () => {
        this._streamingDeactivated();
      },
      priorityMetaDataSent: (t, e) => {
        this._priorityMetaDataSent(t, e);
      }
    });
  }
  /**
   * Associates a custom operator object with a system generated operatorId.
   * @param operatorId the ID of the operator that is to be unregistered
   * @returns an operatorId to be used for this operator.
   */
  registerCustomOperator(n) {
    return this.operatorManager.registerCustomOperator(n);
  }
  /**
   * Removes a previously registered custom operator from the system.
   * @param operatorId the ID of the operator that is to be unregistered
   */
  unregisterCustomOperator(n) {
    this.operatorManager.unregisterCustomOperator(n);
  }
  /**
   * Sets whether keyboard input should be directed to this Web Viewer.
   * @param focus if true, the Web Viewer will be focused and accept keyboard input, otherwise it will be blurred and not accept keyboard input
   */
  focusInput(n) {
    this._inputMonitor.focusInput(n);
  }
  /**
   * Registers callbacks that will be called when their corresponding events occur.
   * @param callbacks object with property names set to corresponding functions to be called when the event occurs.
   */
  setCallbacks(n) {
    this._callbackManager.bind(n);
  }
  /**
   * Unregisters callbacks from the system. Note the actual function object passed in must be the same as the one that was registered using setCallbacks.
   * @param callbacks object with property names set to corresponding functions to be unregistered.
   */
  unsetCallbacks(n) {
    this._callbackManager.unbind(n);
  }
  /**
   * This method should be called after the container element is moved or resized.
   */
  resizeCanvas() {
    this._alreadyShutDown || (this._engine.resize(), this._inputMonitor.elementResize());
  }
  /**
   * This method should be called when the viewer is being moved to a new window. An example use case would be opening a new pop up window.
   * @param win the new document that this viewer will be associated with.
   */
  moveToWindow(n) {
    this._inputMonitor.setDocument(n.document);
  }
  /**
   * Forces the viewer to perform a full redraw.
   * @param callback A function to be called once the draw is complete.
   * This is provided instead of a `Promise` to ensure the callback is
   * called before the start of another redraw.
   */
  redraw(n) {
    if (n) {
      const t = () => {
        this._callbackManager.unbind({ _drawComplete: t }), n();
      };
      this._callbackManager.bind({ _drawComplete: t });
    }
    this._engine.redraw();
  }
  /**
   * Selects a part with the given Id.
   * @param nodeId nodeId of the part to select. Pass null to clear the selection.
   */
  selectPart(n, t = ai.Set) {
    return this.selectionManager.selectNode(n, t);
  }
  /**
   * Used to trigger Web Viewer events from operators. Refer to the overloaded method signatures for acceptable invocations of this method. Refer to [[CallbackMap]] for additional details for each event.
   * @param name
   * @param args
   */
  trigger(n, ...t) {
    this._callbackManager.unsafeTrigger(n, t);
  }
  /** @hidden */
  _getCallbackManager() {
    return this._callbackManager;
  }
  /** @hidden */
  _setStreamIdleMarker() {
    return this._engine.setStreamIdleMarker();
  }
  /**
   * Gets viewer statistics for the current rendered frame. Statistics marked with a (*) below must be calculated and will not be included in the results unless the calculateTotals parameter is true.
   * The values of these items will be cached and only updated during the next call to this method with calculateTotals set to true.
   * @param calculateTotals Forces an update of the total count elements. Please note that repeatedly calculating these items can cause a performance impact.
   * @returns an object containing informational key/value pairs
   *
   * | Statistic Name| Description                                          |
   * | ----------------------- | -----------------------------------------------------|
   * | draw_call_count  | number of draw calls made when rendering the frame             |
   * | frames_per_second  | frames per second estimation    |
   * | triangle_count  | the number of triangles rendered    |
   * | line_segment_count  | the number of line segments rendered    |
   * | point_count  | the number of points rendered    |
   * | total_element_count(*)  | the total number of elements in the scene    |
   * | total_triangle_count(*)  | the total number of triangles in the scene   |
   *
   */
  getStatistics(n = !1) {
    return this._engine.getStatistics(n);
  }
  /**
   * Sets a minimum frame rate that will be maintained by the viewer.
   * The viewer will use various culling techniques in order to maintain the value passed in.
   *
   * Passing `0` will cause the entire scene to be drawn for every frame.
   * @param value The frame rate for the viewer to maintain.
   * @returns Promise that is resolved when the operation has completed.
   */
  setMinimumFramerate(n) {
    return this._setMinimumFramerate(n), Promise.resolve();
  }
  _setMinimumFramerate(n) {
    this._engine.setMinimumFramerate(n);
  }
  /**
   * Gets the minimum framerate that will be maintained by the viewer. The viewer will use various culling techniques in order to maintain the value returned.
   * @returns Promise that is resolved when the operation has completed.
   */
  getMinimumFramerate() {
    return this._engine.getMinimumFramerate();
  }
  /**
   * Sets the image quality settings for the high quality and low quality server side render. The low quality settings will be applied during model interaction (camera changes, selection, etc)
   * @param jpegQualityLow The JPEG quality of the low quality render frame
   * @param jpegQualityHigh The JPEG quality of the high quality render frame
   * @param scaleLow The scale factor for the low quality render frame
   * @param scaleHigh The scale factor for the high quality render frame
   */
  setServerRenderQuality(n, t, e, i) {
    return this._engine.setServerRenderQuality(
      n,
      t,
      e,
      i
    );
  }
  /**
   * Gets the streaming mode this viewer was created with.
   * @returns the streaming mode.
   */
  getStreamingMode() {
    return this._streamingMode;
  }
  /**
   * Gets the RendererType this viewer was created with.
   * @returns the render mode.
   */
  getRendererType() {
    return this._engine.getRendererType();
  }
  /**
   * Gets the view element for this viewer. This element contains the canvas
   * @returns the view element
   */
  getViewElement() {
    return this._domElements.getCanvasContainerElement();
  }
  /**
   * Releases the resources used by the viewer. This method should be called when the viewer is no longer needed but the page is not being reloaded.
   */
  shutdown() {
    if (!this._alreadyShutDown) {
      if (this._shutdownTimer.clear(), !this._modelStructure.isReady() && !this._modelLoadFailure) {
        this._shutdownTimer.set(500, () => {
          this.shutdown();
        });
        return;
      }
      this._callbackManager.trigger("_shutdownBegin"), this.operatorManager._shutdown(), this._inputMonitor.shutdown(), this.markupManager._shutdown(), this._timeoutMonitor.shutdown(), this._modelStructure.shutdown(), this._domElements.shutdown(), this._engine.shutdown(), this.animationManager._shutdown(), this._alreadyShutDown = !0;
    }
  }
  /**
   * Sets the parameters for client driven timeout monitoring.
   * If no input is recorded for the the duration, the viewer will disconnect and free server resources.
   * Calling this method will reset any pending timeout duration.
   * No timeout will occur when viewing SCS Files.
   * The default value is to disconnect after 15 minutes, with a warning issued after 14 minutes of inactivity.
   * <br><br> <strong>Please note:</strong> Both parameters are required.
   * @param timeoutDuration the total time in minutes of inactivity that is allowed before a timeout event occurs
   * @param warningTime the number of minutes before issuing a timeoutWarning event
   * @returns boolean value indicating whether the timeout values were sucessfully updated
   */
  setClientTimeout(n, t) {
    return this._timeoutMonitor.setTimeoutDurations(n, t);
  }
  /**
   * Resets the client timeout to the duration set with setClientTimeout.
   */
  resetClientTimeout() {
    this._timeoutMonitor.resetTimeout();
  }
  /**
   * Pauses rendering updates for the viewer. This function is useful when
   * performing large batches of updates and you would like the result
   * to appear all at once.
   *
   * @param callback If provided, rendering will be paused, the callback
   * will be called, and then rendering will be resumed once the callback
   * returns or throws an exception.
   */
  pauseRendering(n) {
    return this._pauseRendering(n), Promise.resolve();
  }
  _pauseRendering(n) {
    this._engine.pauseRendering(n);
  }
  /**
   * Resumes rendering in the viewer.
   */
  resumeRendering() {
    return this._resumeRendering(), Promise.resolve();
  }
  _resumeRendering() {
    this._engine.resumeRendering();
  }
  /**
   * Delays capping processing by a fixed time interval.
   */
  delayCapping() {
    this.cuttingManager.delayCapping();
  }
  /**
   * Reset the camera, visibility, and transforms to their default state
   * @param duration the amount of time in milliseconds that the camera transition between the current and initial view should take.
   * @returns Promise that resolves when the operation has completed.
   */
  async reset(n = Ri) {
    await this.model.reset();
    const t = this.model.getDefaultCadView() !== null;
    this.model.getDefaultCadConfiguration() !== null && await this._modelStructure.cadConfigurationsEnabled() ? await this.model.activateDefaultCadConfiguration(!t) : !this.sheetManager.isDrawingSheetActive() && !t && await this.view.resetCamera(n), t && await this.model.activateDefaultCadView(n);
  }
  /**
   * Disconnects the network connection when in CSR mode.
   */
  closeConnection() {
    this.view.setCamera(this.view.getCamera()), this._engine.disconnectNetwork(), this._timeoutMonitor.shutdown();
  }
  /**
   * Controls rendering on high DPI displays. If true, the image will be rendered at full resolution when a high-DPI display is detected. If false, the image may be rendered at a lower resolution. The default value is false.
   * This method may be called any time during or after the sceneReady callback has triggered.
   * @param allow controls the high DPI Setting.
   */
  setAllowHighDpi(n) {
    this._engine.setAllowHighDpi(n);
  }
  /**
   * Gets the current value for high DPI rendering
   * @returns current high DPI setting
   */
  getAllowHighDpi() {
    return this._engine.getAllowHighDpi();
  }
  /**
   * Creates an Image of the current canvas
   */
  takeSnapshot(n = new my()) {
    const t = ye(), e = new k0(this._domElements, n), i = this._domElements.getCanvasContainerElement(), s = this._domElements.getRedlineElement(), r = n.width > 0 && n.height > 0;
    if (r) {
      const a = `${100 * (n.width / i.clientWidth)}%`, l = `${100 * (n.height / i.clientHeight)}%`;
      i.style.width = a, i.style.height = l, s.style.width = a, s.style.height = l;
    }
    const o = this.getAllowHighDpi();
    return this._engine.setAllowHighDpi(!1), this._engine.resize(), this.redraw(async () => {
      const a = await e.capture(i);
      r && (i.style.width = "100%", i.style.height = "100%", s.style.width = "100%", s.style.height = "100%"), this._engine.setAllowHighDpi(o), this._engine.resize(), t.resolve(a);
    }), t;
  }
  fitWorld(n = Ri) {
    return this.view.fitWorld(n);
  }
  /**
   * Sets the orientation of the current model view.
   * @param orientation a [[ViewOrientation]] object specifying back, front, top, etc.
   * @param duration the time in milliseconds for the model to transition to the new view orientation.
   */
  async setViewOrientation(n, t = Ri) {
    await this.view.setViewOrientation(n, t), this._eventDispatcher.injectViewOrientationChangeEvent();
  }
  _applyMetallicRoughnessDefaults() {
    let n = 1, t = 1, e = !1;
    this._params.defaultMetallicFactor != null && (n = this._params.defaultMetallicFactor, e = !0), this._params.defaultRoughnessFactor != null && (t = this._params.defaultRoughnessFactor, e = !0), e && this._engine.setMetallicRoughnessMaterialOverride(
      n,
      t
    );
  }
  async _scEngineReady() {
    console.assert(this._modelStructure.isReady());
    const n = this.model.getAbsoluteRootNode(), t = this._engine.getSessionType();
    try {
      this.cuttingManager._init(), await this._sceneReadyPromise, await this._callbackManager.promiseTrigger("_assemblyTreeReady", "assemblyTreeReady");
      let e = "";
      try {
        const i = new hr();
        i._allowSubtreeLoadedCallback = !1;
        let s = 0;
        if (this._applyMetallicRoughnessDefaults(), t === Ke.Network)
          e = this._engine.getNetworkModelName(), e === rr || await this.model.loadSubtreeFromModel(n, e, i);
        else if (t === Ke.Scs) {
          this._timeoutMonitor.shutdown();
          const r = this._engine.getScsInfo();
          typeof r == "string" ? await this.model.loadSubtreeFromScsFile(n, r, i) : r !== null && await this.model.loadSubtreeFromScsBuffer(n, r, i), this._params.streamCutoffScale !== void 0 && (s = this._params.streamCutoffScale);
        } else
          throw new re();
        this._modelStructure.setPrefetchScsCutoffScale(s);
      } catch (i) {
        throw this._callbackManager.trigger("modelLoadFailure", e, `${i}`, i), i;
      }
    } finally {
      return console.assert(this._modelStructure.isReady()), this._callbackManager.promiseTrigger("_modelStructureReady", "modelStructureReady");
    }
  }
  _sceneReady() {
    this._inputMonitor.bindEvents(this._domElements.getCanvasContainerElement()), this.selectionManager._init(), this._callbackManager.bind({
      _timeout: () => {
        this.shutdown();
      }
    }), this._callbackManager.trigger("sceneReady"), this._sceneReadyPromise && this._sceneReadyPromise.resolve();
  }
  _priorityMetaDataSent(n, t) {
    if (this._callbackManager.trigger("_priorityMetaDataSent", n, t), !this._seenPriorityMetaDataSent) {
      if (n !== ar.OfInitialEmptyModel || t !== 0)
        throw new re();
      this._seenPriorityMetaDataSent = !0, this._callbackManager.trigger("_attached", ar.OfInitialEmptyModel);
    }
  }
  _renderComplete() {
    this.markupManager._update();
  }
  _streamingActivated() {
    this._callbackManager.trigger("streamingActivated");
  }
  _streamingDeactivated() {
    this._callbackManager.trigger("streamingDeactivated");
  }
  /**
   * Specifies a scale factor that will be applied to the streaming size cutoff.
   * An object whose projected size is lower than the cutoff will not be streamed
   * until its projected size reaches the cutoff.
   *
   * This value may also be set for file-based sessions.  In that case, when loading
   * an SCS file based assembly via XML, projected size will be calculated on a
   * per-file basis using the bounding information provided in the XML.
   * For additional information, refer to [[Model.loadSubtreeFromXmlBuffer]].
   *
   * A value of 0 will disable the cutoff.  The value should be in the interval of [0.0, 2.0].
   */
  setStreamCutoffScale(n) {
    return this._setStreamCutoffScale(n), Promise.resolve();
  }
  _setStreamCutoffScale(n) {
    this._engine.setStreamCutoffScale(n), this._modelStructure.setPrefetchScsCutoffScale(n);
  }
  /**
   * Returns the scale factor that will be applied to the streaming size cutoff.
   * An object whose projected size is lower than the cutoff will not be streamed
   * until its projected size reaches the cutoff. A value of 0 disables the cutoff.
   */
  getStreamCutoffScale() {
    return this._engine.getStreamCutoffScale();
  }
  /** @hidden */
  _loseWebGlContext() {
    return this._engine.loseWebGlContext();
  }
  /** @hidden */
  _getScEngine() {
    return this._engine;
  }
  /** @hidden */
  _debug_log(n) {
    return this._engine.debug_log(n);
  }
  /** @hidden */
  _debug_stateFailure(n) {
    return this._engine.debug_stateFailure(n);
  }
  /** @hidden */
  _debug_sync() {
    return this._engine.debug_sync();
  }
  /**
   * Exports the current scene to a two-dimensional SVG representation.
   *
   * @param config Allows customization of the resultant SVG.
   * @return A promise that resolves to the created SVG string.
   */
  async exportToSvg(n = new yu()) {
    let t;
    this.cuttingManager._setStandinGeometryVisible(!1);
    try {
      await this.waitForIdle({ redraw: !1 }), t = await this._engine.exportToSvg(n);
    } finally {
      this.cuttingManager._setStandinGeometryVisible(!0);
    }
    return t;
  }
  /**
   * Setup the env to export the current scene to a two-dimensional SVG representation through stream.
   *
   * @param config Allows customization of the resultant SVG.
   * @return A promise that resolves to void when the env is ready.
   */
  async beginExportToSvg(n = new yu()) {
    this.cuttingManager._setStandinGeometryVisible(!1);
    try {
      await this.waitForIdle({ redraw: !1 }), await this._engine.beginExportToSvg(n);
    } catch {
      await this.endExportToSvg();
    }
  }
  /**
   * Reset the env after SVG stream export.
   *
   * @return A promise that resolves to void when the env is reset.
   */
  async endExportToSvg() {
    return this.cuttingManager._setStandinGeometryVisible(!0);
  }
  /**
   * Get the next chunk of the SVG code
   *
   * @return A promise that resolves to a string containing the next chunk or undefined on completed..
   */
  async advanceExportToSvg() {
    return this._engine.advanceExportToSvg();
  }
  /**
   * Returns a Promise that will resolve after streaming and associated
   * asynchronous operations complete and the scene is fully drawn.
   */
  async waitForIdle(n = {}) {
    if (this._alreadyShutDown)
      return;
    await this._setStreamIdleMarker();
    const t = [];
    if (this.cuttingManager.hasActiveCuttingSection() && (await this.cuttingManager.enableCappingIdleCallback(!0) || t.push(this.cuttingManager.waitForCappingIdle())), t.push(this._engine.waitForImageDecoding()), await Promise.all(t), n.redraw !== !1) {
      const e = ye();
      this.redraw(() => {
        e.resolve();
      }), await e;
    }
  }
};
let Rp = Bh;
Rp.BUILD_ID = "<BUILD_ID>";
Rp.VIEWER_VERSION_STRING = `${yd(xh)} Build ${Bh.BUILD_ID}`;
export {
  F0 as Animation,
  Hd as AntiAliasingMode,
  ur as AssemblyDataParseError,
  Bn as AttributeType,
  Ht as Axis,
  As as AxisTriad,
  le as BasicUnit,
  K0 as Bcf,
  O0 as Bim,
  ei as BimMask,
  mn as BlurIntervalUnit,
  vs as BoundingPreviewMode,
  ni as Box,
  Pt as BranchVisibility,
  Gt as BuiltinOverlayIndex,
  Kt as Button,
  Ai as Buttons,
  ci as Camera,
  it as Color,
  Mt as CommunicatorError,
  __ as CullingVectorSpace,
  sy as CuttingManager,
  _u as CuttingPlane,
  ny as CuttingSection,
  Ri as DefaultTransitionDuration,
  eh as DepthRange,
  Sn as DrawMode,
  $d as DrawStrategy,
  vt as ElementType,
  rr as EmptyModelName,
  J0 as Event,
  kt as EventType,
  ry as ExplodeManager,
  y_ as FaceFaceDistanceItem,
  Cg as FaceMeshData,
  yn as FaceWinding,
  Vo as FileType,
  L0 as FilterId,
  pu as FilteredNodes,
  D0 as Floorplan,
  Wr as FloorplanOrientation,
  ws as HandleEventType,
  Jn as HandleType,
  Oi as ImageFormat,
  Al as IncrementalPickConfig,
  p_ as InfoType,
  Xe as InstanceModifier,
  re as InternalLogicError,
  Zh as InvalidIndexError,
  jd as InvalidNodeId,
  sn as InvalidNodeIdError,
  Gi as InvalidNodeTypeError,
  Ut as KeyCode,
  kc as KeyInputType,
  _e as KeyModifiers,
  X0 as LayerId,
  oy as Light,
  ay as LineManager,
  b_ as LinePatternLengthUnit,
  Rl as LoadCancelledError,
  ts as LoadError,
  hr as LoadSubtreeConfig,
  B0 as Markup,
  cy as MarkupManager,
  jl as MarkupTypeManager,
  Q as Matrix,
  hy as MeasureManager,
  Hi as MeshData,
  xt as MeshInstanceCreationFlags,
  bn as MeshInstanceData,
  Ll as MissingModelError,
  Po as Model,
  Vn as MouseInputType,
  pp as NavCube,
  ps as NodeSource,
  At as NodeType,
  Qp as Ohm,
  Et as OperatorId,
  uy as OperatorManager,
  j0 as Operators,
  mo as OrbitFallbackMode,
  A0 as Overlay,
  Jt as OverlayAnchor,
  Bt as OverlayUnit,
  fn as ParseError,
  be as PickConfig,
  Ms as PickOutsideCanvasError,
  je as Plane,
  Qd as PmiSubType,
  Uo as PmiTopoRef,
  Ud as PmiType,
  E as Point2,
  d as Point3,
  jn as Point4,
  Mg as PointMeshData,
  Wc as PointShape,
  Mc as PointSizeUnit,
  kg as PolylineMeshData,
  te as Projection,
  Ti as Quaternion,
  Gn as Ray,
  f_ as RefOnTopoItem,
  qd as RelationshipType,
  Ho as RendererType,
  P0 as Sc,
  m_ as ScreenConfiguration,
  z0 as Selection,
  Ln as SelectionHighlightMode,
  as as SelectionInvalidatedError,
  Xt as SelectionMask,
  ai as SelectionMode,
  pi as SelectionType,
  dy as SheetManager,
  Pc as SimpleReflectionAttenuationUnit,
  my as SnapshotConfig,
  Yo as SnapshotLayer,
  Ps as StreamingMode,
  Wo as SubentityAttributes,
  Up as Subscript1,
  tu as Subscript2,
  eu as Subscript3,
  ec as SubscriptNeg,
  yu as SvgConfig,
  x_ as TextureModifier,
  v_ as TextureParameterization,
  Vc as TextureTiling,
  La as TouchInputType,
  g_ as TransparencyMode,
  w_ as TreeWalkMode,
  V0 as Util,
  gp as VerticalGradient,
  _y as View,
  mu as ViewAxes,
  et as ViewOrientation,
  I_ as VisibilityState,
  Ot as WalkDirection,
  po as WalkMode,
  Rp as WebViewer,
  Qo as XRayGroup,
  ce as XmlParseError,
  sg as closestPointFromPointToSegment,
  Hu as closestPointScalarFromPointToSegment,
  Yn as computeAngleBetweenVector,
  ro as computeOffaxisRotation,
  ss as computePointToLineDistance,
  Qi as createUuid,
  cs as degreesToRadians,
  ng as distanceLineLine,
  Go as formatWithUnit,
  _c as generateArcPoints,
  ig as generatePointsOnCircle,
  ag as getLongUnitString,
  tg as intersect3d2Planes,
  Ts as intersectionPlaneLine,
  Bu as intersectionPlaneLine2,
  cg as isIColor,
  Du as isIPoint2,
  zu as isIPoint3,
  W0 as isIPoint4,
  Uu as isPointInRect2d,
  rg as isPointOnLineSegment,
  oo as isPointOnLineSegment2d,
  ju as lineLineIntersect,
  Ju as oneVectorCross,
  _l as radiansToDegrees
};
